From 7191bbb39cece6f03d30f32d319e53f625d02ffb Mon Sep 17 00:00:00 2001
From: Yuantian Tang <andy.tang@nxp.com>
Date: Tue, 27 Sep 2022 16:48:49 +0800
Subject: [PATCH 020/274] MLK-25895-1 nvmem: imx: i.MX93 nvmem ocotp driver

This patch adds i.MX93 nvmem ocotp driver to access the fuse in i.MX93.
Sentinel have read access of OTP shadow register 0-511, and fsb have
read access of shadow 0-51/312-511.

Reviewed-by: Ye Li <ye.li@nxp.com>
Signed-off-by: Alice Guo <alice.guo@nxp.com>
---
 drivers/input/keyboard/bbnsm_pwrkey.c | 199 +++++++++++++++++++
 drivers/nvmem/imx-ocotp-fsb-s400.c    | 268 ++++++++++++++++++++++++++
 2 files changed, 467 insertions(+)
 create mode 100644 drivers/input/keyboard/bbnsm_pwrkey.c
 create mode 100644 drivers/nvmem/imx-ocotp-fsb-s400.c

diff --git a/drivers/input/keyboard/bbnsm_pwrkey.c b/drivers/input/keyboard/bbnsm_pwrkey.c
new file mode 100644
index 000000000..92fbfbcde
--- /dev/null
+++ b/drivers/input/keyboard/bbnsm_pwrkey.c
@@ -0,0 +1,199 @@
+// SPDX-License-Identifier: GPL-2.0+
+//
+// Copyright 2022 NXP.
+
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/jiffies.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/pm_wakeirq.h>
+#include <linux/mfd/syscon.h>
+#include <linux/regmap.h>
+
+#define BBNSM_CTRL		0x8
+#define BBNSM_INT_EN		0x10
+#define BBNSM_EVENTS		0x14
+#define BBNSM_PAD_CTRL		0x24
+
+#define BBNSM_BTN_PRESSED	BIT(7)
+#define BBNSM_PWR_ON		BIT(6)
+#define BBNSM_BTN_OFF		BIT(5)
+#define BBNSM_EMG_OFF		BIT(4)
+#define BBNSM_PWRKEY_EVENTS	(BBNSM_PWR_ON | BBNSM_BTN_OFF | BBNSM_EMG_OFF)
+#define BBNSM_DP_EN		BIT(24)
+
+#define DEBOUNCE_TIME		30
+#define REPEAT_INTERVAL		60
+
+struct bbnsm_pwrkey {
+	struct regmap *regmap;
+	int irq;
+	int keycode;
+	int keystate;  /* 1:pressed */
+	int wakeup;
+	struct timer_list check_timer;
+	struct input_dev *input;
+};
+
+static void bbnsm_pwrkey_check_for_events(struct timer_list *t)
+{
+	struct bbnsm_pwrkey *bbnsm = from_timer(bbnsm, t, check_timer);
+	struct input_dev *input = bbnsm->input;
+	u32 state;
+
+	regmap_read(bbnsm->regmap, BBNSM_EVENTS, &state);
+
+	state = state & BBNSM_BTN_PRESSED ? 1 : 0;
+
+	/* only report new event if status changed */
+	if (state ^ bbnsm->keystate) {
+		bbnsm->keystate = state;
+		input_event(input, EV_KEY, bbnsm->keycode, state);
+		input_sync(input);
+		pm_relax(bbnsm->input->dev.parent);
+	}
+
+	/* repeat check if pressed long */
+	if (state) {
+		mod_timer(&bbnsm->check_timer,
+			  jiffies + msecs_to_jiffies(REPEAT_INTERVAL));
+	}
+}
+
+static irqreturn_t bbnsm_pwrkey_interrupt(int irq, void *dev_id)
+{
+	struct platform_device *pdev = dev_id;
+	struct bbnsm_pwrkey *bbnsm = platform_get_drvdata(pdev);
+	struct input_dev *input = bbnsm->input;
+	u32 event;
+
+	regmap_read(bbnsm->regmap, BBNSM_EVENTS, &event);
+	if (event & BBNSM_BTN_OFF)
+		mod_timer(&bbnsm->check_timer, jiffies + msecs_to_jiffies(DEBOUNCE_TIME));
+	else
+		return IRQ_NONE;
+
+	pm_wakeup_event(input->dev.parent, 0);
+
+	/* clear PWR OFF */
+	regmap_write(bbnsm->regmap, BBNSM_EVENTS, BBNSM_BTN_OFF);
+
+	return IRQ_HANDLED;
+}
+
+static void bbnsm_pwrkey_act(void *pdata)
+{
+	struct bbnsm_pwrkey *bbnsm = pdata;
+
+	del_timer_sync(&bbnsm->check_timer);
+}
+
+static int bbnsm_pwrkey_probe(struct platform_device *pdev)
+{
+	struct bbnsm_pwrkey *bbnsm;
+	struct input_dev *input;
+	struct device_node *np = pdev->dev.of_node;
+	int error;
+
+	bbnsm = devm_kzalloc(&pdev->dev, sizeof(*bbnsm), GFP_KERNEL);
+	if (!bbnsm)
+		return -ENOMEM;
+
+	bbnsm->regmap = syscon_regmap_lookup_by_phandle(pdev->dev.of_node, "regmap");
+	if (IS_ERR(bbnsm->regmap)) {
+		dev_err(&pdev->dev, "bbnsm pwerkey get regmap failed\n");
+		return PTR_ERR(bbnsm->regmap);
+	}
+
+	if (of_property_read_u32(np, "linux,keycode", &bbnsm->keycode)) {
+		bbnsm->keycode = KEY_POWER;
+		dev_warn(&pdev->dev, "KEY_POWER without setting in dts\n");
+	}
+
+	bbnsm->wakeup = of_property_read_bool(np, "wakeup-source");
+
+	bbnsm->irq = platform_get_irq(pdev, 0);
+	if (bbnsm ->irq < 0)
+		return -EINVAL;
+
+	/* config the BBNSM power related register */
+	regmap_update_bits(bbnsm->regmap, BBNSM_CTRL, BBNSM_DP_EN, BBNSM_DP_EN);
+
+	/* clear the unexpected interrupt before driver ready */
+	regmap_write_bits(bbnsm->regmap, BBNSM_EVENTS, BBNSM_PWRKEY_EVENTS, BBNSM_PWRKEY_EVENTS);
+
+	timer_setup(&bbnsm->check_timer, bbnsm_pwrkey_check_for_events, 0);
+
+	input = devm_input_allocate_device(&pdev->dev);
+	if (!input) {
+		dev_err(&pdev->dev, "failed to allocate the input device\n");
+		error = -ENOMEM;
+		goto error_probe;
+	}
+
+	input->name = pdev->name;
+	input->phys = "bbnsm-pwrkey/input0";
+	input->id.bustype = BUS_HOST;
+
+	input_set_capability(input, EV_KEY, bbnsm->keycode);
+
+	/* input customer action to cancel release timer */
+	error = devm_add_action(&pdev->dev, bbnsm_pwrkey_act, bbnsm);
+	if (error) {
+		dev_err(&pdev->dev, "failed to register remove action\n");
+		goto error_probe;
+	}
+
+	bbnsm->input = input;
+	platform_set_drvdata(pdev, bbnsm);
+
+	error = devm_request_irq(&pdev->dev, bbnsm->irq, bbnsm_pwrkey_interrupt,
+			       IRQF_SHARED, pdev->name, pdev);
+	if (error) {
+		dev_err(&pdev->dev, "interrupt not available.\n");
+		goto error_probe;
+	}
+
+	error = input_register_device(input);
+	if (error < 0) {
+		dev_err(&pdev->dev, "failed to register input device\n");
+		goto error_probe;
+	}
+
+	device_init_wakeup(&pdev->dev, bbnsm->wakeup);
+	error = dev_pm_set_wake_irq(&pdev->dev, bbnsm->irq);
+	if (error)
+		dev_err(&pdev->dev, "irq wake enable failed.\n");
+
+	return 0;
+
+error_probe:
+	return error;
+}
+
+static const struct of_device_id bbnsm_pwrkey_ids[] = {
+	{ .compatible = "nxp,bbnsm-pwrkey" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, bbnsm_pwrkey_ids);
+
+static struct platform_driver bbnsm_pwrkey_driver = {
+	.driver = {
+		.name = "bbnsm_pwrkey",
+		.of_match_table = bbnsm_pwrkey_ids,
+	},
+	.probe = bbnsm_pwrkey_probe,
+};
+module_platform_driver(bbnsm_pwrkey_driver);
+
+MODULE_AUTHOR("Jacky Bai <ping.bai@nxp.com>");
+MODULE_DESCRIPTION("NXP bbnsm power key Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/nvmem/imx-ocotp-fsb-s400.c b/drivers/nvmem/imx-ocotp-fsb-s400.c
new file mode 100644
index 000000000..b085414c1
--- /dev/null
+++ b/drivers/nvmem/imx-ocotp-fsb-s400.c
@@ -0,0 +1,268 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2021 NXP
+ * Author: Alice Guo <alice.guo@nxp.com>
+ */
+
+#include <linux/dev_printk.h>
+#include <linux/errno.h>
+#include <linux/firmware/imx/ele_base_msg.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/nvmem-consumer.h>
+#include <linux/nvmem-provider.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+
+#define LOCK_CFG	0x01
+#define ECID		0x02
+#define UNIQ_ID		0x07
+#define OTFAD_CFG	0x17
+#define MAPPING_SIZE	0x20
+
+enum soc_type {
+	IMX8ULP,
+	IMX93,
+};
+
+struct bank_2_reg {
+	unsigned int bank;
+	unsigned int reg;
+	bool flag;
+};
+
+struct imx_fsb_s400_hw {
+	enum soc_type soc;
+	unsigned int fsb_otp_shadow;
+	const struct bank_2_reg fsb_bank_reg[MAPPING_SIZE];
+};
+
+struct imx_fsb_s400_fuse {
+	void __iomem *regs;
+	struct nvmem_config config;
+	struct mutex lock;
+	const struct imx_fsb_s400_hw *hw;
+};
+
+static int read_words_via_s400_api(u32 *buf, unsigned int fuse_base, unsigned int num)
+{
+	unsigned int i;
+	int err = 0;
+
+	for (i = 0; i < num; i++)
+		err = read_common_fuse(fuse_base + i, buf + i);
+
+	return err;
+}
+
+static int read_words_via_fsb(void *priv, unsigned int bank, u32 *buf)
+{
+	struct imx_fsb_s400_fuse *fuse = priv;
+	void __iomem *regs = fuse->regs + fuse->hw->fsb_otp_shadow;
+	unsigned int i;
+	unsigned int reg_id = UINT_MAX;
+	unsigned int size = ARRAY_SIZE(fuse->hw->fsb_bank_reg);
+
+	for (i = 0; i < size; i++) {
+		if (fuse->hw->fsb_bank_reg[i].bank == bank) {
+			reg_id = fuse->hw->fsb_bank_reg[i].reg;
+			break;
+		}
+	}
+
+	if (reg_id != UINT_MAX) {
+		size = fuse->hw->fsb_bank_reg[i].flag ? 4 : 8;
+
+		for (i = 0; i < size; i++) {
+			*buf = readl_relaxed(regs + (reg_id + i) * 4);
+			buf = buf + 1;
+		}
+	}
+
+	return 0;
+}
+
+static int read_nwords_via_fsb(void __iomem *regs, u32 *buf, u32 fuse_base, u32 num)
+{
+	unsigned int i;
+
+	for (i = 0; i < num; i++) {
+		*buf = readl_relaxed(regs + (fuse_base + i) * 4);
+		buf = buf + 1;
+	}
+
+	return 0;
+}
+
+static int fsb_s400_fuse_read(void *priv, unsigned int offset, void *val,
+			      size_t bytes)
+{
+	struct imx_fsb_s400_fuse *fuse = priv;
+	void __iomem *regs = fuse->regs + fuse->hw->fsb_otp_shadow;
+	unsigned int num_bytes, bank;
+	u32 *buf;
+	int err;
+
+	num_bytes = round_up(2048, 4);
+	buf = kzalloc(num_bytes, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	err = -EINVAL;
+
+	mutex_lock(&fuse->lock);
+	if (fuse->hw->soc == IMX8ULP) {
+		for (bank = 0; bank < 63; bank++) {
+			switch (bank) {
+			case 0:
+				break;
+			case LOCK_CFG:
+				err = read_words_via_s400_api(&buf[8], 8, 8);
+				if (err)
+					goto ret;
+				break;
+			case ECID:
+				err = read_words_via_s400_api(&buf[16], 16, 8);
+				if (err)
+					goto ret;
+				break;
+			case UNIQ_ID:
+				err = read_common_fuse(OTP_UNIQ_ID, &buf[56]);
+				if (err)
+					goto ret;
+				break;
+			case OTFAD_CFG:
+				err = read_common_fuse(OTFAD_CONFIG, &buf[184]);
+				if (err)
+					goto ret;
+				break;
+			default:
+				err = read_words_via_fsb(priv, bank, &buf[bank * 8]);
+				break;
+			}
+		}
+	} else if (fuse->hw->soc == IMX93) {
+		for (bank = 0; bank < 6; bank++)
+			read_nwords_via_fsb(regs, &buf[bank * 8], bank * 8, 8);
+
+		read_nwords_via_fsb(regs, &buf[48], 48, 4); /* OTP_UNIQ_ID */
+
+		err = read_words_via_s400_api(&buf[63], 63, 1);
+		if (err)
+			goto ret;
+
+		err = read_words_via_s400_api(&buf[128], 128, 16);
+		if (err)
+			goto ret;
+
+		err = read_words_via_s400_api(&buf[182], 182, 1);
+		if (err)
+			goto ret;
+
+		err = read_words_via_s400_api(&buf[188], 188, 1);
+		if (err)
+			goto ret;
+
+		for (bank = 39; bank < 64; bank++)
+			read_nwords_via_fsb(regs, &buf[bank * 8], bank * 8, 8);
+	}
+
+	memcpy(val, (u8 *)(buf + offset), bytes);
+
+ret:
+	kfree(buf);
+	mutex_unlock(&fuse->lock);
+
+	return err;
+}
+
+static int imx_fsb_s400_fuse_probe(struct platform_device *pdev)
+{
+	struct imx_fsb_s400_fuse *fuse;
+	struct nvmem_device *nvmem;
+
+	fuse = devm_kzalloc(&pdev->dev, sizeof(*fuse), GFP_KERNEL);
+	if (!fuse)
+		return -ENOMEM;
+
+	fuse->regs = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(fuse->regs))
+		return PTR_ERR(fuse->regs);
+
+	fuse->config.dev = &pdev->dev;
+	fuse->config.name = "fsb_s400_fuse";
+	fuse->config.id = NVMEM_DEVID_AUTO;
+	fuse->config.owner = THIS_MODULE;
+	fuse->config.size = 2048; /* 64 Banks */
+	fuse->config.reg_read = fsb_s400_fuse_read;
+	fuse->config.priv = fuse;
+
+	nvmem = devm_nvmem_register(&pdev->dev, &fuse->config);
+	if (IS_ERR(nvmem)) {
+		dev_err(&pdev->dev, "failed to register fuse nvmem device\n");
+		return PTR_ERR(nvmem);
+	}
+
+	mutex_init(&fuse->lock);
+	fuse->hw = of_device_get_match_data(&pdev->dev);
+
+	dev_dbg(&pdev->dev, "fuse nvmem device registered successfully\n");
+
+	return 0;
+}
+
+static const struct imx_fsb_s400_hw imx8ulp_fsb_s400_hw = {
+	.soc = IMX8ULP,
+	.fsb_otp_shadow = 0x800,
+	.fsb_bank_reg = {
+		[0] = { 3, 0 },
+		[1] = { 4, 8 },
+		[2] = { 5, 16 },
+		[3] = { 6, 24 },
+		[4] = { 8, 80, true },
+		[5] = { 24, 84, true },
+		[6] = { 26, 88, true },
+		[7] = { 27, 92, true },
+		[8] = { 28, 96 },
+		[9] = { 29, 104 },
+		[10] = { 30, 112 },
+		[11] = { 31, 120 },
+		[12] = { 37, 128 },
+		[13] = { 38, 136 },
+		[14] = { 39, 144 },
+		[15] = { 40, 152 },
+		[16] = { 41, 160 },
+		[17] = { 42, 168 },
+		[18] = { 43, 176 },
+		[19] = { 44, 184 },
+		[20] = { 45, 192 },
+		[21] = { 46, 200 },
+	},
+};
+
+static const struct imx_fsb_s400_hw imx93_fsb_s400_hw = {
+	.soc = IMX93,
+	.fsb_otp_shadow = 0x8000,
+};
+
+static const struct of_device_id imx_fsb_s400_fuse_match[] = {
+	{ .compatible = "fsl,imx8ulp-ocotp", .data = &imx8ulp_fsb_s400_hw, },
+	{ .compatible = "fsl,imx93-ocotp", .data = &imx93_fsb_s400_hw, },
+	{},
+};
+
+static struct platform_driver imx_fsb_s400_fuse_driver = {
+	.driver = {
+		.name = "fsl-ocotp-fsb-s400",
+		.of_match_table = imx_fsb_s400_fuse_match,
+	},
+	.probe = imx_fsb_s400_fuse_probe,
+};
+module_platform_driver(imx_fsb_s400_fuse_driver);
+
+MODULE_AUTHOR("Alice Guo <alice.guo@nxp.com>");
+MODULE_DESCRIPTION("i.MX FSB/S400-API ocotp fuse box driver");
+MODULE_LICENSE("GPL v2");
-- 
2.25.1

