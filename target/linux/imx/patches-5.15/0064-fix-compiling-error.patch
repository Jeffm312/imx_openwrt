From f17a115e554a6588768b2e2e976272e4dc2d1736 Mon Sep 17 00:00:00 2001
From: Yuantian Tang <andy.tang@nxp.com>
Date: Wed, 28 Sep 2022 11:38:18 +0800
Subject: [PATCH 064/274] fix compiling error

---
 .../boot/dts/freescale/fsl-ls1012a-2g5rdb.dts |   91 ++
 .../boot/dts/freescale/fsl-ls1012a-frdm.dts   |   44 +
 .../boot/dts/freescale/fsl-ls1012a-frwy.dts   |  122 ++
 .../boot/dts/freescale/fsl-ls1012a-qds.dts    |   43 +
 .../boot/dts/freescale/fsl-ls1012a-rdb.dts    |   44 +-
 .../arm64/boot/dts/freescale/fsl-ls1012a.dtsi |   39 +-
 .../dts/freescale/fsl-ls1028a-qds-13bb.dts    |  113 ++
 .../dts/freescale/fsl-ls1028a-qds-65bb.dts    |  108 ++
 .../dts/freescale/fsl-ls1028a-qds-7777.dts    |   82 ++
 .../dts/freescale/fsl-ls1028a-qds-85bb.dts    |  107 ++
 .../dts/freescale/fsl-ls1028a-qds-899b.dts    |   75 ++
 .../dts/freescale/fsl-ls1028a-qds-9999.dts    |   79 ++
 .../boot/dts/freescale/fsl-ls1028a-qds.dts    |   56 +-
 .../dts/freescale/fsl-ls1028a-rdb-dpdk.dts    |   47 +
 .../boot/dts/freescale/fsl-ls1028a-rdb.dts    |  107 +-
 .../arm64/boot/dts/freescale/fsl-ls1028a.dtsi |  162 ++-
 .../dts/freescale/fsl-ls1043a-qds-sdk.dts     |  263 ++++
 .../boot/dts/freescale/fsl-ls1043a-qds.dts    |  173 ++-
 .../dts/freescale/fsl-ls1043a-rdb-sdk.dts     |  262 ++++
 .../dts/freescale/fsl-ls1043a-rdb-usdpaa.dts  |  140 ++
 .../boot/dts/freescale/fsl-ls1043a-rdb.dts    |    4 +
 .../arm64/boot/dts/freescale/fsl-ls1043a.dtsi |  185 ++-
 .../dts/freescale/fsl-ls1046a-frwy-sdk.dts    |  241 ++++
 .../dts/freescale/fsl-ls1046a-frwy-usdpaa.dts |  117 ++
 .../dts/freescale/fsl-ls1046a-qds-sdk.dts     |  264 ++++
 .../boot/dts/freescale/fsl-ls1046a-qds.dts    |  158 ++-
 .../dts/freescale/fsl-ls1046a-rdb-sdk.dts     |  273 ++++
 .../fsl-ls1046a-rdb-shared-mac9-only.dts      |  108 ++
 .../fsl-ls1046a-rdb-usdpaa-shared-mac10.dts   |  142 ++
 .../fsl-ls1046a-rdb-usdpaa-shared.dts         |  189 +++
 .../dts/freescale/fsl-ls1046a-rdb-usdpaa.dts  |  133 ++
 .../boot/dts/freescale/fsl-ls1046a-rdb.dts    |    4 +-
 .../arm64/boot/dts/freescale/fsl-ls1046a.dtsi |  169 ++-
 .../boot/dts/freescale/fsl-ls1088a-qds.dts    |    3 +-
 .../boot/dts/freescale/fsl-ls1088a-rdb.dts    |    4 +-
 .../arm64/boot/dts/freescale/fsl-ls1088a.dtsi |   38 +-
 .../boot/dts/freescale/fsl-ls2080a-qds.dts    |   69 +
 .../boot/dts/freescale/fsl-ls2080a-rdb.dts    |   68 +
 .../arm64/boot/dts/freescale/fsl-ls2080a.dtsi |   12 +
 .../boot/dts/freescale/fsl-ls2081a-rdb.dts    |  131 ++
 .../boot/dts/freescale/fsl-ls2088a-qds.dts    |   68 +
 .../boot/dts/freescale/fsl-ls208xa-rdb.dtsi   |    2 +
 .../arm64/boot/dts/freescale/fsl-ls208xa.dtsi |   64 +-
 .../freescale/fsl-lx2160a-clearfog-itx.dtsi   |    4 +
 .../boot/dts/freescale/fsl-lx2160a-qds.dts    |  149 +++
 .../boot/dts/freescale/fsl-lx2160a-rdb.dts    |   21 +
 .../arm64/boot/dts/freescale/fsl-lx2160a.dtsi |  180 ++-
 .../boot/dts/freescale/fsl-lx2162a-qds.dts    |   21 +
 arch/arm64/boot/dts/freescale/imx8mm-evk.dts  |    0
 arch/arm64/boot/dts/freescale/imx8mm.dtsi     |    0
 arch/arm64/boot/dts/freescale/imx8mq-evk.dts  |    0
 arch/arm64/boot/dts/freescale/imx8mq.dtsi     |    0
 arch/arm64/boot/dts/freescale/imx8qm-mek.dts  |    0
 arch/arm64/boot/dts/freescale/imx8qm.dtsi     |    0
 .../dts/freescale/qoriq-bman-portals-sdk.dtsi |   55 +
 .../boot/dts/freescale/qoriq-dpaa-eth.dtsi    |   72 +
 .../dts/freescale/qoriq-fman3-0-10g-0.dtsi    |    9 +-
 .../dts/freescale/qoriq-fman3-0-10g-1.dtsi    |    9 +-
 .../dts/freescale/qoriq-fman3-0-1g-0.dtsi     |    5 +-
 .../dts/freescale/qoriq-fman3-0-1g-1.dtsi     |    5 +-
 .../dts/freescale/qoriq-fman3-0-1g-2.dtsi     |    5 +-
 .../dts/freescale/qoriq-fman3-0-1g-3.dtsi     |    5 +-
 .../dts/freescale/qoriq-fman3-0-1g-4.dtsi     |    5 +-
 .../dts/freescale/qoriq-fman3-0-1g-5.dtsi     |    5 +-
 .../boot/dts/freescale/qoriq-fman3-0-6oh.dtsi |   47 +
 .../boot/dts/freescale/qoriq-fman3-0.dtsi     |   52 +-
 .../dts/freescale/qoriq-qman-portals-sdk.dtsi |   38 +
 arch/arm64/boot/dts/freescale/s32v234-evb.dts |   97 +-
 arch/arm64/boot/dts/freescale/s32v234-sbc.dts |  187 +++
 arch/arm64/boot/dts/freescale/s32v234.dtsi    |  140 ++
 drivers/clk/imx/Kconfig                       |    7 +
 drivers/clk/imx/Makefile                      |    8 +-
 drivers/clk/imx/clk-blk-ctrl.c                |  342 +++++
 drivers/clk/imx/clk-blk-ctrl.h                |   81 ++
 drivers/clk/imx/clk-composite-7ulp.c          |   88 +-
 drivers/clk/imx/clk-composite-8m.c            |   21 +-
 drivers/clk/imx/clk-gate2.c                   |   38 +-
 drivers/clk/imx/clk-imx-acm-utils.c           |   78 ++
 drivers/clk/imx/clk-imx-acm-utils.h           |   19 +
 drivers/clk/imx/clk-imx6q.c                   |  103 +-
 drivers/clk/imx/clk-imx6sl.c                  |   10 +
 drivers/clk/imx/clk-imx6sll.c                 |    4 +
 drivers/clk/imx/clk-imx6sx.c                  |  166 ++-
 drivers/clk/imx/clk-imx6ul.c                  |    6 +
 drivers/clk/imx/clk-imx7d.c                   |   24 +-
 drivers/clk/imx/clk-imx7ulp.c                 |   20 +-
 drivers/clk/imx/clk-imx8dxl-acm.c             |  235 ++++
 drivers/clk/imx/clk-imx8dxl-rsrc.c            |   65 +
 drivers/clk/imx/clk-imx8mm.c                  |  168 ++-
 drivers/clk/imx/clk-imx8mn.c                  |   89 +-
 drivers/clk/imx/clk-imx8mp.c                  |  461 ++++++-
 drivers/clk/imx/clk-imx8mq.c                  |   55 +-
 drivers/clk/imx/clk-imx8qm-acm.c              |  297 +++++
 drivers/clk/imx/clk-imx8qm-rsrc.c             |    3 +-
 drivers/clk/imx/clk-imx8qxp-acm.c             |  258 ++++
 drivers/clk/imx/clk-imx8qxp-lpcg.c            |  290 +---
 drivers/clk/imx/clk-imx8qxp-lpcg.h            |    1 -
 drivers/clk/imx/clk-imx8qxp-rsrc.c            |    4 +-
 drivers/clk/imx/clk-imx8qxp.c                 |    4 +-
 drivers/clk/imx/clk-imx8ulp.c                 |  577 ++++++++
 drivers/clk/imx/clk-lpcg-scu.c                |   39 +-
 drivers/clk/imx/clk-pfd.c                     |   49 +-
 drivers/clk/imx/clk-pfdv2.c                   |   23 +-
 drivers/clk/imx/clk-pll14xx.c                 |   37 +-
 drivers/clk/imx/clk-pllv3.c                   |   84 +-
 drivers/clk/imx/clk-pllv4.c                   |   35 +-
 drivers/clk/imx/clk-scu.c                     |   39 +-
 drivers/clk/imx/clk-scu.h                     |    1 +
 drivers/clk/imx/clk.c                         |   13 +
 drivers/clk/imx/clk.h                         |   89 +-
 drivers/firmware/imx/imx-scu-irq.c            |  108 +-
 drivers/firmware/imx/scu-pd.c                 |  190 ++-
 drivers/soc/imx/soc-imx8m.c                   |   64 +
 include/drm/bridge/cdns-mhdp.h                |  921 +++++++++++++
 include/dt-bindings/clock/imx6qdl-clock.h     |    7 +-
 include/dt-bindings/clock/imx7d-clock.h       |    6 +-
 include/dt-bindings/clock/imx8-clock.h        |  203 +--
 include/dt-bindings/clock/imx8mp-clock.h      |  199 ++-
 include/dt-bindings/clock/imx8mq-clock.h      |    3 +-
 include/dt-bindings/clock/imx8ulp-clock.h     |  262 ++++
 include/dt-bindings/clock/s32v234-clock.h     |   65 +
 include/dt-bindings/firmware/imx/rsrc.h       |    8 +-
 include/dt-bindings/pinctrl/pads-imx8qxp.h    |   25 +
 include/dt-bindings/pinctrl/s32v234-pinctrl.h | 1173 +++++++++++++++++
 include/dt-bindings/power/imx8ulp-power.h     |   26 +
 include/dt-bindings/reset/imx8mm-dispmix.h    |   49 +
 include/dt-bindings/reset/imx8mn-dispmix.h    |   47 +
 include/dt-bindings/reset/imx8mp-reset.h      |   48 +-
 include/dt-bindings/reset/imx8mq-reset.h      |    4 +-
 include/dt-bindings/reset/imx8ulp-pcc-reset.h |   59 +
 include/dt-bindings/reset/imx8ulp-sim-reset.h |   16 +
 include/dt-bindings/soc/imx8_hsio.h           |   31 +
 include/linux/busfreq-imx.h                   |   77 ++
 include/linux/clk-provider.h                  |    1 +
 include/linux/imx_rpmsg.h                     |   43 +
 include/linux/imx_sema4.h                     |   83 ++
 include/linux/imx_vpu.h                       |   19 +
 include/soc/imx/gpc.h                         |    7 +
 include/soc/imx/imx-secvio-sc.h               |  178 +++
 include/soc/imx/imx_sip.h                     |   17 +
 include/soc/imx/soc.h                         |   20 +
 include/soc/imx/src.h                         |    6 +
 include/uapi/drm/drm_fourcc.h                 |   47 +
 143 files changed, 12663 insertions(+), 994 deletions(-)
 create mode 100644 arch/arm64/boot/dts/freescale/fsl-ls1012a-2g5rdb.dts
 create mode 100644 arch/arm64/boot/dts/freescale/fsl-ls1028a-qds-13bb.dts
 create mode 100644 arch/arm64/boot/dts/freescale/fsl-ls1028a-qds-65bb.dts
 create mode 100644 arch/arm64/boot/dts/freescale/fsl-ls1028a-qds-7777.dts
 create mode 100644 arch/arm64/boot/dts/freescale/fsl-ls1028a-qds-85bb.dts
 create mode 100644 arch/arm64/boot/dts/freescale/fsl-ls1028a-qds-899b.dts
 create mode 100644 arch/arm64/boot/dts/freescale/fsl-ls1028a-qds-9999.dts
 create mode 100644 arch/arm64/boot/dts/freescale/fsl-ls1028a-rdb-dpdk.dts
 create mode 100644 arch/arm64/boot/dts/freescale/fsl-ls1043a-qds-sdk.dts
 create mode 100644 arch/arm64/boot/dts/freescale/fsl-ls1043a-rdb-sdk.dts
 create mode 100644 arch/arm64/boot/dts/freescale/fsl-ls1043a-rdb-usdpaa.dts
 create mode 100644 arch/arm64/boot/dts/freescale/fsl-ls1046a-frwy-sdk.dts
 create mode 100644 arch/arm64/boot/dts/freescale/fsl-ls1046a-frwy-usdpaa.dts
 create mode 100644 arch/arm64/boot/dts/freescale/fsl-ls1046a-qds-sdk.dts
 create mode 100644 arch/arm64/boot/dts/freescale/fsl-ls1046a-rdb-sdk.dts
 create mode 100644 arch/arm64/boot/dts/freescale/fsl-ls1046a-rdb-shared-mac9-only.dts
 create mode 100644 arch/arm64/boot/dts/freescale/fsl-ls1046a-rdb-usdpaa-shared-mac10.dts
 create mode 100644 arch/arm64/boot/dts/freescale/fsl-ls1046a-rdb-usdpaa-shared.dts
 create mode 100644 arch/arm64/boot/dts/freescale/fsl-ls1046a-rdb-usdpaa.dts
 create mode 100644 arch/arm64/boot/dts/freescale/fsl-ls2081a-rdb.dts
 mode change 100644 => 100755 arch/arm64/boot/dts/freescale/imx8mm-evk.dts
 mode change 100644 => 100755 arch/arm64/boot/dts/freescale/imx8mm.dtsi
 mode change 100644 => 100755 arch/arm64/boot/dts/freescale/imx8mq-evk.dts
 mode change 100644 => 100755 arch/arm64/boot/dts/freescale/imx8mq.dtsi
 mode change 100644 => 100755 arch/arm64/boot/dts/freescale/imx8qm-mek.dts
 mode change 100644 => 100755 arch/arm64/boot/dts/freescale/imx8qm.dtsi
 create mode 100644 arch/arm64/boot/dts/freescale/qoriq-bman-portals-sdk.dtsi
 create mode 100644 arch/arm64/boot/dts/freescale/qoriq-dpaa-eth.dtsi
 create mode 100644 arch/arm64/boot/dts/freescale/qoriq-fman3-0-6oh.dtsi
 create mode 100644 arch/arm64/boot/dts/freescale/qoriq-qman-portals-sdk.dtsi
 create mode 100644 arch/arm64/boot/dts/freescale/s32v234-sbc.dts
 create mode 100644 drivers/clk/imx/clk-blk-ctrl.c
 create mode 100644 drivers/clk/imx/clk-blk-ctrl.h
 create mode 100644 drivers/clk/imx/clk-imx-acm-utils.c
 create mode 100644 drivers/clk/imx/clk-imx-acm-utils.h
 create mode 100644 drivers/clk/imx/clk-imx8dxl-acm.c
 create mode 100644 drivers/clk/imx/clk-imx8dxl-rsrc.c
 create mode 100644 drivers/clk/imx/clk-imx8qm-acm.c
 create mode 100644 drivers/clk/imx/clk-imx8qxp-acm.c
 create mode 100644 drivers/clk/imx/clk-imx8ulp.c
 create mode 100644 include/drm/bridge/cdns-mhdp.h
 create mode 100644 include/dt-bindings/clock/imx8ulp-clock.h
 create mode 100644 include/dt-bindings/clock/s32v234-clock.h
 create mode 100644 include/dt-bindings/pinctrl/s32v234-pinctrl.h
 create mode 100644 include/dt-bindings/power/imx8ulp-power.h
 create mode 100644 include/dt-bindings/reset/imx8mm-dispmix.h
 create mode 100644 include/dt-bindings/reset/imx8mn-dispmix.h
 create mode 100644 include/dt-bindings/reset/imx8ulp-pcc-reset.h
 create mode 100644 include/dt-bindings/reset/imx8ulp-sim-reset.h
 create mode 100644 include/dt-bindings/soc/imx8_hsio.h
 create mode 100644 include/linux/busfreq-imx.h
 create mode 100644 include/linux/imx_rpmsg.h
 create mode 100644 include/linux/imx_sema4.h
 create mode 100644 include/linux/imx_vpu.h
 create mode 100644 include/soc/imx/gpc.h
 create mode 100644 include/soc/imx/imx-secvio-sc.h
 create mode 100644 include/soc/imx/imx_sip.h
 create mode 100644 include/soc/imx/soc.h
 create mode 100644 include/soc/imx/src.h

diff --git a/arch/arm64/boot/dts/freescale/fsl-ls1012a-2g5rdb.dts b/arch/arm64/boot/dts/freescale/fsl-ls1012a-2g5rdb.dts
new file mode 100644
index 000000000..ce6bb86f4
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/fsl-ls1012a-2g5rdb.dts
@@ -0,0 +1,91 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Device Tree file for NXP LS1012A 2G5RDB Board.
+ *
+ * Copyright 2017 NXP
+ *
+ * Bhaskar Upadhaya <bhaskar.upadhaya@nxp.com>
+ */
+/dts-v1/;
+
+#include "fsl-ls1012a.dtsi"
+
+/ {
+	model = "LS1012A 2G5RDB Board";
+	compatible = "fsl,ls1012a-rdb", "fsl,ls1012a";
+
+	aliases {
+		ethernet0 = &pfe_mac0;
+		ethernet1 = &pfe_mac1;
+		mmc0 = &esdhc0;
+		mmc1 = &esdhc1;
+	};
+};
+
+&duart0 {
+	status = "okay";
+};
+
+&i2c0 {
+	status = "okay";
+};
+
+&qspi {
+	num-cs = <2>;
+	bus-num = <0>;
+	status = "okay";
+
+	qflash0: s25fs512s@0 {
+		compatible = "spansion,m25p80";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		spi-max-frequency = <20000000>;
+		m25p,fast-read;
+		reg = <0>;
+	};
+};
+
+&sata {
+	status = "okay";
+};
+
+&pfe {
+	status = "okay";
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	pfe_mac0: ethernet@0 {
+		compatible = "fsl,pfe-gemac-port";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg = <0x0>;	/* GEM_ID */
+		fsl,mdio-mux-val = <0x0>;
+		phy-mode = "sgmii-2500";
+		phy-handle = <&sgmii_phy1>;
+	};
+
+	pfe_mac1: ethernet@1 {
+		compatible = "fsl,pfe-gemac-port";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg = <0x1>;	/* GEM_ID */
+		fsl,mdio-mux-val = <0x0>;
+		phy-mode = "sgmii-2500";
+		phy-handle = <&sgmii_phy2>;
+	};
+
+	mdio@0 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		sgmii_phy1: ethernet-phy@1 {
+			compatible = "ethernet-phy-ieee802.3-c45";
+			reg = <0x1>;
+		};
+
+		sgmii_phy2: ethernet-phy@2 {
+			compatible = "ethernet-phy-ieee802.3-c45";
+			reg = <0x2>;
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/freescale/fsl-ls1012a-frdm.dts b/arch/arm64/boot/dts/freescale/fsl-ls1012a-frdm.dts
index 2517528f6..afac39692 100644
--- a/arch/arm64/boot/dts/freescale/fsl-ls1012a-frdm.dts
+++ b/arch/arm64/boot/dts/freescale/fsl-ls1012a-frdm.dts
@@ -14,6 +14,11 @@ / {
 	model = "LS1012A Freedom Board";
 	compatible = "fsl,ls1012a-frdm", "fsl,ls1012a";
 
+	aliases {
+		ethernet0 = &pfe_mac0;
+		ethernet1 = &pfe_mac1;
+	};
+
 	sys_mclk: clock-mclk {
 		compatible = "fixed-clock";
 		#clock-cells = <0>;
@@ -110,6 +115,45 @@ s25fs512s0: flash@0 {
 	};
 };
 
+&pfe {
+	status = "okay";
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	pfe_mac0: ethernet@0 {
+		compatible = "fsl,pfe-gemac-port";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg = <0x0>;	/* GEM_ID */
+		fsl,mdio-mux-val = <0x0>;
+		phy-mode = "sgmii";
+		phy-handle = <&sgmii_phy1>;
+	};
+
+	pfe_mac1: ethernet@1 {
+		compatible = "fsl,pfe-gemac-port";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg = <0x1>;	/* GEM_ID */
+		fsl,mdio-mux-val = <0x0>;
+		phy-mode = "sgmii";
+		phy-handle = <&sgmii_phy2>;
+	};
+
+	mdio@0 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		sgmii_phy1: ethernet-phy@2 {
+			reg = <0x2>;
+		};
+
+		sgmii_phy2: ethernet-phy@1 {
+			reg = <0x1>;
+		};
+	};
+};
+
 &sai2 {
 	status = "okay";
 };
diff --git a/arch/arm64/boot/dts/freescale/fsl-ls1012a-frwy.dts b/arch/arm64/boot/dts/freescale/fsl-ls1012a-frwy.dts
index e8562585d..18974f7c8 100644
--- a/arch/arm64/boot/dts/freescale/fsl-ls1012a-frwy.dts
+++ b/arch/arm64/boot/dts/freescale/fsl-ls1012a-frwy.dts
@@ -14,6 +14,60 @@
 / {
 	model = "LS1012A FRWY Board";
 	compatible = "fsl,ls1012a-frwy", "fsl,ls1012a";
+
+	aliases {
+		ethernet0 = &pfe_mac0;
+		ethernet1 = &pfe_mac1;
+		mmc0 = &esdhc0;
+		mmc1 = &esdhc1;
+	};
+
+	sys_mclk: clock-mclk {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <25000000>;
+	};
+
+	reg_1p8v: regulator-1p8v {
+		compatible = "regulator-fixed";
+		regulator-name = "1P8V";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		regulator-always-on;
+	};
+
+	sound {
+		compatible = "simple-audio-card";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,widgets =
+			"Microphone", "Microphone Jack",
+			"Headphone", "Headphone Jack",
+			"Speaker", "Speaker Ext",
+			"Line", "Line In Jack";
+		simple-audio-card,routing =
+			"MIC_IN", "Microphone Jack",
+			"Microphone Jack", "Mic Bias",
+			"LINE_IN", "Line In Jack",
+			"Headphone Jack", "HP_OUT",
+			"Speaker Ext", "LINE_OUT";
+
+		simple-audio-card,cpu {
+			sound-dai = <&sai2>;
+			frame-master;
+			bitclock-master;
+		};
+
+		simple-audio-card,codec {
+			sound-dai = <&codec>;
+			frame-master;
+			bitclock-master;
+			system-clock-frequency = <25000000>;
+		};
+	};
+};
+
+&pcie1 {
+	status = "okay";
 };
 
 &duart0 {
@@ -22,6 +76,74 @@ &duart0 {
 
 &i2c0 {
 	status = "okay";
+
+	codec: sgtl5000@a {
+		compatible = "fsl,sgtl5000";
+		#sound-dai-cells = <0>;
+		reg = <0xa>;
+		VDDA-supply = <&reg_1p8v>;
+		VDDIO-supply = <&reg_1p8v>;
+		clocks = <&sys_mclk>;
+	};
+};
+
+&qspi {
+	num-cs = <1>;
+	bus-num = <0>;
+	status = "okay";
+
+	qflash0: w25q16dw@0 {
+		compatible = "spansion,m25p80";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		m25p,fast-read;
+		spi-max-frequency = <20000000>;
+		reg = <0>;
+	};
+};
+
+&pfe {
+	status = "okay";
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	pfe_mac0: ethernet@0 {
+		compatible = "fsl,pfe-gemac-port";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg = <0x0>;	/* GEM_ID */
+		fsl,gemac-bus-id = <0x0>;	/* BUS_ID */
+		fsl,mdio-mux-val = <0x0>;
+		phy-mode = "sgmii";
+		phy-handle = <&sgmii_phy1>;
+	};
+
+	pfe_mac1: ethernet@1 {
+		compatible = "fsl,pfe-gemac-port";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg = <0x1>;	/* GEM_ID */
+		fsl,mdio-mux-val = <0x0>;
+		phy-mode = "sgmii";
+		phy-handle = <&sgmii_phy2>;
+	};
+
+	mdio@0 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		sgmii_phy1: ethernet-phy@2 {
+			reg = <0x2>;
+		};
+
+		sgmii_phy2: ethernet-phy@1 {
+			reg = <0x1>;
+		};
+	};
+};
+
+&sai2 {
+	status = "okay";
 };
 
 &pcie1 {
diff --git a/arch/arm64/boot/dts/freescale/fsl-ls1012a-qds.dts b/arch/arm64/boot/dts/freescale/fsl-ls1012a-qds.dts
index e22c5e77f..ee9cc5669 100644
--- a/arch/arm64/boot/dts/freescale/fsl-ls1012a-qds.dts
+++ b/arch/arm64/boot/dts/freescale/fsl-ls1012a-qds.dts
@@ -16,6 +16,8 @@ / {
 	aliases {
 		mmc0 = &esdhc0;
 		mmc1 = &esdhc1;
+		ethernet0 = &pfe_mac0;
+		ethernet1 = &pfe_mac1;
 	};
 
 	sys_mclk: clock-mclk {
@@ -148,6 +150,47 @@ s25fs512s0: flash@0 {
 	};
 };
 
+&pfe {
+	status = "okay";
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	pfe_mac0: ethernet@0 {
+		compatible = "fsl,pfe-gemac-port";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg = <0x0>;	/* GEM_ID */
+		fsl,mdio-mux-val = <0x2>;
+		phy-mode = "sgmii-2500";
+		phy-handle = <&sgmii_phy1>;
+	};
+
+	pfe_mac1: ethernet@1 {
+		compatible = "fsl,pfe-gemac-port";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg = <0x1>;	/* GEM_ID */
+		fsl,mdio-mux-val = <0x3>;
+		phy-mode = "sgmii-2500";
+		phy-handle = <&sgmii_phy2>;
+	};
+
+	mdio@0 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		sgmii_phy1: ethernet-phy@1 {
+			compatible = "ethernet-phy-ieee802.3-c45";
+			reg = <0x1>;
+		};
+
+		sgmii_phy2: ethernet-phy@2 {
+			compatible = "ethernet-phy-ieee802.3-c45";
+			reg = <0x2>;
+		};
+	};
+};
+
 &sai2 {
 	status = "okay";
 };
diff --git a/arch/arm64/boot/dts/freescale/fsl-ls1012a-rdb.dts b/arch/arm64/boot/dts/freescale/fsl-ls1012a-rdb.dts
index e662677a6..2bd1b055f 100644
--- a/arch/arm64/boot/dts/freescale/fsl-ls1012a-rdb.dts
+++ b/arch/arm64/boot/dts/freescale/fsl-ls1012a-rdb.dts
@@ -18,6 +18,8 @@ aliases {
 		serial0 = &duart0;
 		mmc0 = &esdhc0;
 		mmc1 = &esdhc1;
+		ethernet0 = &pfe_mac0;
+		ethernet1 = &pfe_mac1;
 	};
 };
 
@@ -96,11 +98,49 @@ s25fs512s0: flash@0 {
 		spi-max-frequency = <50000000>;
 		m25p,fast-read;
 		reg = <0>;
-		spi-rx-bus-width = <2>;
-		spi-tx-bus-width = <2>;
+		spi-rx-bus-width = <1>;
+		spi-tx-bus-width = <1>;
 	};
 };
 
 &sata {
 	status = "okay";
 };
+
+&pfe {
+	status = "okay";
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	pfe_mac0: ethernet@0 {
+		compatible = "fsl,pfe-gemac-port";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg = <0x0>;	/* GEM_ID */
+		fsl,mdio-mux-val = <0x0>;
+		phy-mode = "sgmii";
+		phy-handle = <&sgmii_phy>;
+	};
+
+	pfe_mac1: ethernet@1 {
+		compatible = "fsl,pfe-gemac-port";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg = <0x1>;	/* GEM_ID */
+		fsl,mdio-mux-val = <0x0>;
+		phy-mode = "rgmii-id";
+		phy-handle = <&rgmii_phy>;
+	};
+	mdio@0 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		sgmii_phy: ethernet-phy@2 {
+			reg = <0x2>;
+		};
+
+		rgmii_phy: ethernet-phy@1 {
+			reg = <0x1>;
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/freescale/fsl-ls1012a.dtsi b/arch/arm64/boot/dts/freescale/fsl-ls1012a.dtsi
index 50a72cda4..9a815fcea 100644
--- a/arch/arm64/boot/dts/freescale/fsl-ls1012a.dtsi
+++ b/arch/arm64/boot/dts/freescale/fsl-ls1012a.dtsi
@@ -282,7 +282,7 @@ sec_mon: sec_mon@1e90000 {
 		dcfg: dcfg@1ee0000 {
 			compatible = "fsl,ls1012a-dcfg",
 				     "syscon";
-			reg = <0x0 0x1ee0000 0x0 0x10000>;
+			reg = <0x0 0x1ee0000 0x0 0x1000>;
 			big-endian;
 		};
 
@@ -343,13 +343,14 @@ tmu: tmu@1f00000 {
 		};
 
 		i2c0: i2c@2180000 {
-			compatible = "fsl,vf610-i2c";
+			compatible = "fsl,vf610-i2c", "fsl,ls1012a-vf610-i2c";
 			#address-cells = <1>;
 			#size-cells = <0>;
 			reg = <0x0 0x2180000 0x0 0x10000>;
 			interrupts = <0 56 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&clockgen QORIQ_CLK_PLATFORM_PLL
 					    QORIQ_CLK_PLL_DIV(4)>;
+			scl-gpios = <&gpio0 13 0>;
 			status = "disabled";
 		};
 
@@ -484,13 +485,15 @@ QORIQ_CLK_PLL_DIV(4)>,
 		};
 
 		usb0: usb@2f00000 {
-			compatible = "snps,dwc3";
+			compatible = "fsl,ls1012a-dwc3", "snps,dwc3";
 			reg = <0x0 0x2f00000 0x0 0x10000>;
 			interrupts = <0 60 0x4>;
 			dr_mode = "host";
 			snps,quirk-frame-length-adjustment = <0x20>;
 			snps,dis_rxdet_inp3_quirk;
 			snps,incr-burst-type-adjustment = <1>, <4>, <8>, <16>;
+			snps,host-vbus-glitches;
+			dma-coherent;
 		};
 
 		sata: sata@3200000 {
@@ -542,6 +545,7 @@ pcie1: pcie@3400000 {
 					<0000 0 0 2 &gic 0 111 IRQ_TYPE_LEVEL_HIGH>,
 					<0000 0 0 3 &gic 0 112 IRQ_TYPE_LEVEL_HIGH>,
 					<0000 0 0 4 &gic 0 113 IRQ_TYPE_LEVEL_HIGH>;
+			big-endian;
 			status = "disabled";
 		};
 
@@ -560,6 +564,35 @@ ftm_alarm0: timer@29d0000 {
 		};
 	};
 
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		pfe_reserved: packetbuffer@83400000 {
+			reg = <0 0x83400000 0 0xc00000>;
+		};
+	};
+
+	pfe: pfe@4000000 {
+		compatible = "fsl,pfe";
+		reg =   <0x0 0x04000000 0x0 0xc00000>,	/* AXI 16M */
+			<0x0 0x83400000 0x0 0xc00000>;  /* PFE DDR 12M */
+		reg-names = "pfe", "pfe-ddr";
+		fsl,pfe-num-interfaces = <0x2>;
+		interrupts = <0 172 0x4>,    /* HIF interrupt */
+			     <0 173 0x4>,    /*HIF_NOCPY interrupt */
+			     <0 174 0x4>;    /* WoL interrupt */
+		interrupt-names = "pfe_hif", "pfe_hif_nocpy", "pfe_wol";
+		memory-region = <&pfe_reserved>;
+		fsl,pfe-scfg = <&scfg 0>;
+		fsl,rcpm-wakeup = <&rcpm 0xf0000020>;
+		clocks = <&clockgen 4 0>;
+		clock-names = "pfe";
+
+		status = "okay";
+	};
+
 	firmware {
 		optee {
 			compatible = "linaro,optee-tz";
diff --git a/arch/arm64/boot/dts/freescale/fsl-ls1028a-qds-13bb.dts b/arch/arm64/boot/dts/freescale/fsl-ls1028a-qds-13bb.dts
new file mode 100644
index 000000000..f748a2c12
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/fsl-ls1028a-qds-13bb.dts
@@ -0,0 +1,113 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Device Tree fragment for LS1028A QDS board, serdes 13bb
+ *
+ * Copyright 2019-2021 NXP
+ *
+ * Requires a LS1028A QDS board with lane B rework.
+ * Requires a SCH-30841 card with lane A of connector rewired to PHY lane C.
+ * Set-up is a SCH-30842 card in slot 1 and SCH-30841 in slot 2.
+ */
+
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&mdio_slot1>;
+
+		__overlay__ {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			slot1_sgmii: ethernet-phy@2 {
+				/* AQR112 */
+				reg = <0x2>;
+				compatible = "ethernet-phy-ieee802.3-c45";
+			};
+		};
+	};
+
+	fragment@1 {
+		target = <&enetc_port0>;
+
+		__overlay__ {
+			phy-handle = <&slot1_sgmii>;
+			phy-mode = "usxgmii";
+			managed = "in-band-status";
+			status = "okay";
+		};
+	};
+
+	fragment@2 {
+		target = <&mdio_slot2>;
+
+		__overlay__ {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			/* 4 ports on AQR412 */
+			slot2_qxgmii0: ethernet-phy@0 {
+				reg = <0x0>;
+				compatible = "ethernet-phy-ieee802.3-c45";
+			};
+
+			slot2_qxgmii1: ethernet-phy@1 {
+				reg = <0x1>;
+				compatible = "ethernet-phy-ieee802.3-c45";
+			};
+
+			slot2_qxgmii2: ethernet-phy@2 {
+				reg = <0x2>;
+				compatible = "ethernet-phy-ieee802.3-c45";
+			};
+
+			slot2_qxgmii3: ethernet-phy@3 {
+				reg = <0x3>;
+				compatible = "ethernet-phy-ieee802.3-c45";
+			};
+		};
+	};
+
+	fragment@3 {
+		target = <&mscc_felix_ports>;
+
+		__overlay__ {
+			port@0 {
+				status = "okay";
+				phy-handle = <&slot2_qxgmii0>;
+				phy-mode = "usxgmii";
+				managed = "in-band-status";
+			};
+
+			port@1 {
+				status = "okay";
+				phy-handle = <&slot2_qxgmii1>;
+				phy-mode = "usxgmii";
+				managed = "in-band-status";
+			};
+
+			port@2 {
+				status = "okay";
+				phy-handle = <&slot2_qxgmii2>;
+				phy-mode = "usxgmii";
+				managed = "in-band-status";
+			};
+
+			port@3 {
+				status = "okay";
+				phy-handle = <&slot2_qxgmii3>;
+				phy-mode = "usxgmii";
+				managed = "in-band-status";
+			};
+		};
+	};
+
+	fragment@4 {
+		target = <&mscc_felix>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/freescale/fsl-ls1028a-qds-65bb.dts b/arch/arm64/boot/dts/freescale/fsl-ls1028a-qds-65bb.dts
new file mode 100644
index 000000000..8ffb707a1
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/fsl-ls1028a-qds-65bb.dts
@@ -0,0 +1,108 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Device Tree fragment for LS1028A QDS board, serdes 69xx
+ *
+ * Copyright 2019-2021 NXP
+ *
+ * Requires a LS1028A QDS board with lane B rework.
+ * Requires a SCH-30842 card in slot 1 and a SCH-28021 card in slot 2.
+ */
+
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&mdio_slot1>;
+
+		__overlay__ {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			slot1_sgmii: ethernet-phy@2 {
+				/* AQR112 */
+				reg = <0x2>;
+				compatible = "ethernet-phy-ieee802.3-c45";
+			};
+		};
+	};
+
+	fragment@1 {
+		target = <&enetc_port0>;
+
+		__overlay__ {
+			phy-handle = <&slot1_sgmii>;
+			phy-mode = "2500base-x";
+			managed = "in-band-status";
+			status = "okay";
+		};
+	};
+
+	fragment@2 {
+		target = <&mdio_slot2>;
+
+		__overlay__ {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			/* 4 ports on VSC8514 */
+			slot2_qsgmii0: ethernet-phy@8 {
+				reg = <0x8>;
+			};
+
+			slot2_qsgmii1: ethernet-phy@9 {
+				reg = <0x9>;
+			};
+
+			slot2_qsgmii2: ethernet-phy@a {
+				reg = <0xa>;
+			};
+
+			slot2_qsgmii3: ethernet-phy@b {
+				reg = <0xb>;
+			};
+		};
+	};
+
+	fragment@3 {
+		target = <&mscc_felix_ports>;
+
+		__overlay__ {
+			port@0 {
+				status = "okay";
+				phy-handle = <&slot2_qsgmii0>;
+				phy-mode = "qsgmii";
+				managed = "in-band-status";
+			};
+
+			port@1 {
+				status = "okay";
+				phy-handle = <&slot2_qsgmii1>;
+				phy-mode = "qsgmii";
+				managed = "in-band-status";
+			};
+
+			port@2 {
+				status = "okay";
+				phy-handle = <&slot2_qsgmii2>;
+				phy-mode = "qsgmii";
+				managed = "in-band-status";
+			};
+
+			port@3 {
+				status = "okay";
+				phy-handle = <&slot2_qsgmii3>;
+				phy-mode = "qsgmii";
+				managed = "in-band-status";
+			};
+		};
+	};
+
+	fragment@4 {
+		target = <&mscc_felix>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/freescale/fsl-ls1028a-qds-7777.dts b/arch/arm64/boot/dts/freescale/fsl-ls1028a-qds-7777.dts
new file mode 100644
index 000000000..eb6a1e674
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/fsl-ls1028a-qds-7777.dts
@@ -0,0 +1,82 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Device Tree fragment for LS1028A QDS board, serdes 7777
+ *
+ * Copyright 2019-2021 NXP
+ *
+ * Requires a LS1028A QDS board without lane B rework.
+ * Requires a SCH-30841 card without lane A/C rewire and with a FW with muxing
+ * disabled, plugged in slot 1.
+ */
+
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&mdio_slot1>;
+
+		__overlay__ {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			/* 4 ports on AQR412 */
+			slot1_sxgmii0: ethernet-phy@0 {
+				reg = <0x0>;
+				compatible = "ethernet-phy-ieee802.3-c45";
+			};
+
+			slot1_sxgmii1: ethernet-phy@1 {
+				reg = <0x1>;
+				compatible = "ethernet-phy-ieee802.3-c45";
+			};
+
+			slot1_sxgmii2: ethernet-phy@2 {
+				reg = <0x2>;
+				compatible = "ethernet-phy-ieee802.3-c45";
+			};
+
+			slot1_sxgmii3: ethernet-phy@3 {
+				reg = <0x3>;
+				compatible = "ethernet-phy-ieee802.3-c45";
+			};
+		};
+	};
+
+	fragment@1 {
+		target = <&mscc_felix_ports>;
+
+		__overlay__ {
+			port@0 {
+				status = "okay";
+				phy-handle = <&slot1_sxgmii0>;
+				phy-mode = "2500base-x";
+			};
+
+			port@1 {
+				status = "okay";
+				phy-handle = <&slot1_sxgmii1>;
+				phy-mode = "2500base-x";
+			};
+
+			port@2 {
+				status = "okay";
+				phy-handle = <&slot1_sxgmii2>;
+				phy-mode = "2500base-x";
+			};
+
+			port@3 {
+				status = "okay";
+				phy-handle = <&slot1_sxgmii3>;
+				phy-mode = "2500base-x";
+			};
+		};
+	};
+
+	fragment@2 {
+		target = <&mscc_felix>;
+		__overlay__ {
+			status = "okay";
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/freescale/fsl-ls1028a-qds-85bb.dts b/arch/arm64/boot/dts/freescale/fsl-ls1028a-qds-85bb.dts
new file mode 100644
index 000000000..8e90c3088
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/fsl-ls1028a-qds-85bb.dts
@@ -0,0 +1,107 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Device Tree fragment for LS1028A QDS board, serdes 85bb
+ *
+ * Copyright 2019-2021 NXP
+ *
+ * Requires a LS1028A QDS board with lane B rework.
+ * Requires a SCH-24801 card in slot 1 and a SCH-28021 card in slot 2.
+ */
+
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&mdio_slot1>;
+
+		__overlay__ {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			slot1_sgmii: ethernet-phy@1c {
+				/* 1st port on VSC8234 */
+				reg = <0x1c>;
+			};
+		};
+	};
+
+	fragment@1 {
+		target = <&enetc_port0>;
+
+		__overlay__ {
+			phy-handle = <&slot1_sgmii>;
+			phy-mode = "sgmii";
+			managed = "in-band-status";
+			status = "okay";
+		};
+	};
+
+	fragment@2 {
+		target = <&mdio_slot2>;
+
+		__overlay__ {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			/* 4 ports on VSC8514 */
+			slot2_qsgmii0: ethernet-phy@8 {
+				reg = <0x8>;
+			};
+
+			slot2_qsgmii1: ethernet-phy@9 {
+				reg = <0x9>;
+			};
+
+			slot2_qsgmii2: ethernet-phy@a {
+				reg = <0xa>;
+			};
+
+			slot2_qsgmii3: ethernet-phy@b {
+				reg = <0xb>;
+			};
+		};
+	};
+
+	fragment@3 {
+		target = <&mscc_felix_ports>;
+
+		__overlay__ {
+			port@0 {
+				status = "okay";
+				phy-handle = <&slot2_qsgmii0>;
+				phy-mode = "qsgmii";
+				managed = "in-band-status";
+			};
+
+			port@1 {
+				status = "okay";
+				phy-handle = <&slot2_qsgmii1>;
+				phy-mode = "qsgmii";
+				managed = "in-band-status";
+			};
+
+			port@2 {
+				status = "okay";
+				phy-handle = <&slot2_qsgmii2>;
+				phy-mode = "qsgmii";
+				managed = "in-band-status";
+			};
+
+			port@3 {
+				status = "okay";
+				phy-handle = <&slot2_qsgmii3>;
+				phy-mode = "qsgmii";
+				managed = "in-band-status";
+			};
+		};
+	};
+
+	fragment@4 {
+		target = <&mscc_felix>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/freescale/fsl-ls1028a-qds-899b.dts b/arch/arm64/boot/dts/freescale/fsl-ls1028a-qds-899b.dts
new file mode 100644
index 000000000..5d0a094e6
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/fsl-ls1028a-qds-899b.dts
@@ -0,0 +1,75 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Device Tree fragment for LS1028A QDS board, serdes 85xx
+ *
+ * Copyright 2019-2021 NXP
+ *
+ * Requires a LS1028A QDS board without lane B rework.
+ * Requires a SCH-24801 card in slot 1.
+ */
+
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&mdio_slot1>;
+		__overlay__ {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			/* VSC8234 */
+			slot1_sgmii0: ethernet-phy@1c {
+				reg = <0x1c>;
+			};
+
+			slot1_sgmii1: ethernet-phy@1d {
+				reg = <0x1d>;
+			};
+
+			slot1_sgmii2: ethernet-phy@1e {
+				reg = <0x1e>;
+			};
+
+			slot1_sgmii3: ethernet-phy@1f {
+				reg = <0x1f>;
+			};
+		};
+	};
+
+	fragment@1 {
+		target = <&enetc_port0>;
+		__overlay__ {
+			phy-handle = <&slot1_sgmii0>;
+			phy-mode = "sgmii";
+			managed = "in-band-status";
+			status = "okay";
+		};
+	};
+
+	fragment@2 {
+		target = <&mscc_felix_ports>;
+		__overlay__ {
+			port@1 {
+				status = "okay";
+				phy-handle = <&slot1_sgmii1>;
+				phy-mode = "sgmii";
+				managed = "in-band-status";
+			};
+
+			port@2 {
+				status = "okay";
+				phy-handle = <&slot1_sgmii2>;
+				phy-mode = "sgmii";
+				managed = "in-band-status";
+			};
+		};
+	};
+
+	fragment@3 {
+		target = <&mscc_felix>;
+		__overlay__ {
+			status = "okay";
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/freescale/fsl-ls1028a-qds-9999.dts b/arch/arm64/boot/dts/freescale/fsl-ls1028a-qds-9999.dts
new file mode 100644
index 000000000..1ef743c48
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/fsl-ls1028a-qds-9999.dts
@@ -0,0 +1,79 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Device Tree fragment for LS1028A QDS board, serdes 85xx
+ *
+ * Copyright 2019-2021 NXP
+ *
+ * Requires a LS1028A QDS board without lane B rework.
+ * Requires a SCH-24801 card in slot 1.
+ */
+
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&mdio_slot1>;
+		__overlay__ {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			/* VSC8234 */
+			slot1_sgmii0: ethernet-phy@1c {
+				reg = <0x1c>;
+			};
+
+			slot1_sgmii1: ethernet-phy@1d {
+				reg = <0x1d>;
+			};
+
+			slot1_sgmii2: ethernet-phy@1e {
+				reg = <0x1e>;
+			};
+
+			slot1_sgmii3: ethernet-phy@1f {
+				reg = <0x1f>;
+			};
+		};
+	};
+
+	fragment@1 {
+		target = <&mscc_felix_ports>;
+		__overlay__ {
+			port@0 {
+				status = "okay";
+				phy-handle = <&slot1_sgmii0>;
+				phy-mode = "sgmii";
+				managed = "in-band-status";
+			};
+
+			port@1 {
+				status = "okay";
+				phy-handle = <&slot1_sgmii1>;
+				phy-mode = "sgmii";
+				managed = "in-band-status";
+			};
+
+			port@2 {
+				status = "okay";
+				phy-handle = <&slot1_sgmii2>;
+				phy-mode = "sgmii";
+				managed = "in-band-status";
+			};
+
+			port@3 {
+				status = "okay";
+				phy-handle = <&slot1_sgmii3>;
+				phy-mode = "sgmii";
+				managed = "in-band-status";
+			};
+		};
+	};
+
+	fragment@2 {
+		target = <&mscc_felix>;
+		__overlay__ {
+			status = "okay";
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/freescale/fsl-ls1028a-qds.dts b/arch/arm64/boot/dts/freescale/fsl-ls1028a-qds.dts
index 2f92e62ec..29b101a22 100644
--- a/arch/arm64/boot/dts/freescale/fsl-ls1028a-qds.dts
+++ b/arch/arm64/boot/dts/freescale/fsl-ls1028a-qds.dts
@@ -25,7 +25,7 @@ aliases {
 		serial1 = &duart1;
 		mmc0 = &esdhc;
 		mmc1 = &esdhc1;
-		rtc1 = &ftm_alarm0;
+		rtc1 = &ftm_alarm1;
 	};
 
 	chosen {
@@ -107,6 +107,30 @@ qds_phy1: ethernet-phy@5 {
 				reg = <5>;
 			};
 		};
+
+		mdio_slot1: mdio@4 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <4>;
+		};
+
+		mdio_slot2: mdio@5 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <5>;
+		};
+
+		mdio_slot3: mdio@6 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <6>;
+		};
+
+		mdio_slot4: mdio@7 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <7>;
+		};
 	};
 };
 
@@ -211,6 +235,16 @@ &duart1 {
 	status = "okay";
 };
 
+&enetc_port1 {
+	phy-handle = <&qds_phy1>;
+	phy-connection-type = "rgmii-id";
+	status = "okay";
+};
+
+&enetc_port2 {
+	status = "okay";
+};
+
 &esdhc {
 	status = "okay";
 };
@@ -234,6 +268,15 @@ mt35xu02g0: flash@0 {
 	};
 };
 
+&ftm_alarm1 {
+	status = "okay";
+};
+
+&hdptx0 {
+	lane-mapping = <0x4e>;
+	status = "okay";
+};
+
 &i2c0 {
 	status = "okay";
 
@@ -322,13 +365,16 @@ rtc@51 {
 	};
 };
 
-&enetc_port1 {
-	phy-handle = <&qds_phy1>;
-	phy-connection-type = "rgmii-id";
+&lpuart0 {
 	status = "okay";
 };
 
-&lpuart0 {
+&lpuart1 {
+	status = "okay";
+};
+
+&mscc_felix_port4 {
+	ethernet = <&enetc_port2>;
 	status = "okay";
 };
 
diff --git a/arch/arm64/boot/dts/freescale/fsl-ls1028a-rdb-dpdk.dts b/arch/arm64/boot/dts/freescale/fsl-ls1028a-rdb-dpdk.dts
new file mode 100644
index 000000000..ac9044386
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/fsl-ls1028a-rdb-dpdk.dts
@@ -0,0 +1,47 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * NXP LS1028A RDB Board device tree file for DPDK
+ *
+ * Copyright 2018-2020 NXP
+ */
+
+/dts-v1/;
+#include "fsl-ls1028a-rdb.dts"
+
+&enetc_port0 {
+	/delete-property/ phy-handle;
+	/delete-property/ phy-connection-type;
+	/delete-node/ mdio;
+
+	fixed-link {
+		speed = <1000>;
+		full-duplex;
+	};
+};
+
+/delete-node/ &enetc_mdio_pf3;
+
+/* l2switch ports */
+&mscc_felix_port0 {
+	/delete-property/ phy-handle;
+};
+
+&mscc_felix_port1 {
+	/delete-property/ phy-handle;
+};
+
+&mscc_felix_port2 {
+	/delete-property/ phy-handle;
+};
+
+&mscc_felix_port3 {
+	/delete-property/ phy-handle;
+};
+
+&mscc_felix_port5 {
+	status = "okay";
+};
+
+&enetc_port3 {
+	status = "okay";
+};
diff --git a/arch/arm64/boot/dts/freescale/fsl-ls1028a-rdb.dts b/arch/arm64/boot/dts/freescale/fsl-ls1028a-rdb.dts
index d7b527272..9fe9b6c2b 100644
--- a/arch/arm64/boot/dts/freescale/fsl-ls1028a-rdb.dts
+++ b/arch/arm64/boot/dts/freescale/fsl-ls1028a-rdb.dts
@@ -21,7 +21,7 @@ aliases {
 		serial1 = &duart1;
 		mmc0 = &esdhc;
 		mmc1 = &esdhc1;
-		rtc1 = &ftm_alarm0;
+		rtc1 = &ftm_alarm1;
 	};
 
 	chosen {
@@ -102,6 +102,52 @@ can-transceiver {
 	};
 };
 
+&duart0 {
+	status = "okay";
+};
+
+&duart1 {
+	status = "okay";
+};
+
+&enetc_mdio_pf3 {
+	/* VSC8514 QSGMII quad PHY */
+	qsgmii_phy0: ethernet-phy@10 {
+		reg = <0x10>;
+	};
+
+	qsgmii_phy1: ethernet-phy@11 {
+		reg = <0x11>;
+	};
+
+	qsgmii_phy2: ethernet-phy@12 {
+		reg = <0x12>;
+	};
+
+	qsgmii_phy3: ethernet-phy@13 {
+		reg = <0x13>;
+	};
+};
+
+&enetc_port0 {
+	phy-handle = <&sgmii_phy0>;
+	phy-connection-type = "sgmii";
+	managed = "in-band-status";
+	status = "okay";
+
+	mdio {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		sgmii_phy0: ethernet-phy@2 {
+			reg = <0x2>;
+		};
+	};
+};
+
+&enetc_port2 {
+	status = "okay";
+};
+
 &esdhc {
 	sd-uhs-sdr104;
 	sd-uhs-sdr50;
@@ -132,6 +178,15 @@ mt35xu02g0: flash@0 {
 	};
 };
 
+&ftm_alarm1 {
+	status = "okay";
+};
+
+&hdptx0 {
+	lane_mapping = <0x4e>;
+	status = "okay";
+};
+
 &i2c0 {
 	status = "okay";
 
@@ -188,52 +243,6 @@ rtc@51 {
 	};
 };
 
-&duart0 {
-	status = "okay";
-};
-
-&duart1 {
-	status = "okay";
-};
-
-&enetc_mdio_pf3 {
-	/* VSC8514 QSGMII quad PHY */
-	qsgmii_phy0: ethernet-phy@10 {
-		reg = <0x10>;
-	};
-
-	qsgmii_phy1: ethernet-phy@11 {
-		reg = <0x11>;
-	};
-
-	qsgmii_phy2: ethernet-phy@12 {
-		reg = <0x12>;
-	};
-
-	qsgmii_phy3: ethernet-phy@13 {
-		reg = <0x13>;
-	};
-};
-
-&enetc_port0 {
-	phy-handle = <&sgmii_phy0>;
-	phy-connection-type = "sgmii";
-	managed = "in-band-status";
-	status = "okay";
-
-	mdio {
-		#address-cells = <1>;
-		#size-cells = <0>;
-		sgmii_phy0: ethernet-phy@2 {
-			reg = <0x2>;
-		};
-	};
-};
-
-&enetc_port2 {
-	status = "okay";
-};
-
 &mscc_felix {
 	status = "okay";
 };
@@ -279,6 +288,10 @@ &optee {
 	status = "okay";
 };
 
+&pwm0 {
+	status = "okay";
+};
+
 &sai4 {
 	status = "okay";
 };
diff --git a/arch/arm64/boot/dts/freescale/fsl-ls1028a.dtsi b/arch/arm64/boot/dts/freescale/fsl-ls1028a.dtsi
index 06b36cc65..6a0c88767 100644
--- a/arch/arm64/boot/dts/freescale/fsl-ls1028a.dtsi
+++ b/arch/arm64/boot/dts/freescale/fsl-ls1028a.dtsi
@@ -66,6 +66,13 @@ CPU_PW20: cpu-pw20 {
 		};
 	};
 
+	rtc_clk: rtc-clk {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <32768>;
+		clock-output-names = "rtc_clk";
+	};
+
 	sysclk: sysclk {
 		compatible = "fixed-clock";
 		#clock-cells = <0>;
@@ -592,6 +599,7 @@ usb0: usb@3100000 {
 			snps,dis_rxdet_inp3_quirk;
 			snps,quirk-frame-length-adjustment = <0x20>;
 			snps,incr-burst-type-adjustment = <1>, <4>, <8>, <16>;
+			dma-coherent;
 		};
 
 		usb1: usb@3110000 {
@@ -602,6 +610,7 @@ usb1: usb@3110000 {
 			snps,dis_rxdet_inp3_quirk;
 			snps,quirk-frame-length-adjustment = <0x20>;
 			snps,incr-burst-type-adjustment = <1>, <4>, <8>, <16>;
+			dma-coherent;
 		};
 
 		sata: sata@3200000 {
@@ -642,6 +651,18 @@ pcie1: pcie@3400000 {
 			status = "disabled";
 		};
 
+		pcie_ep1: pcie_ep@3400000 {
+			compatible = "fsl,ls1028a-pcie-ep","fsl,ls-pcie-ep";
+			reg = <0x00 0x03400000 0x0 0x00100000
+			       0x80 0x00000000 0x8 0x00000000>;
+			reg-names = "regs", "addr_space";
+			interrupts = <GIC_SPI 108 IRQ_TYPE_LEVEL_HIGH>; /* PME interrupt */
+			interrupt-names = "pme";
+			num-ib-windows = <6>;
+			num-ob-windows = <8>;
+			status = "disabled";
+		};
+
 		pcie2: pcie@3500000 {
 			compatible = "fsl,ls1028a-pcie";
 			reg = <0x00 0x03500000 0x0 0x00100000>, /* controller registers */
@@ -669,6 +690,18 @@ pcie2: pcie@3500000 {
 			status = "disabled";
 		};
 
+		pcie_ep2: pcie_ep@3500000 {
+			compatible = "fsl,ls1028a-pcie-ep","fsl,ls-pcie-ep";
+			reg = <0x00 0x03500000 0x0 0x00100000
+			       0x88 0x00000000 0x8 0x00000000>;
+			reg-names = "regs", "addr_space";
+			interrupts = <GIC_SPI 113 IRQ_TYPE_LEVEL_HIGH>; /* PME interrupt */
+			interrupt-names = "pme";
+			num-ib-windows = <6>;
+			num-ob-windows = <8>;
+			status = "disabled";
+		};
+
 		smmu: iommu@5000000 {
 			compatible = "arm,mmu-500";
 			reg = <0 0x5000000 0 0x800000>;
@@ -800,6 +833,16 @@ QORIQ_CLK_PLL_DIV(16)>,
 			clock-names = "wdog_clk", "apb_pclk";
 		};
 
+		gpu@f0c0000 {
+			compatible = "fsl,ls1028a-gpu";
+			reg = <0x0 0x0f0c0000 0x0 0x10000>,
+				<0x0 0x80000000 0x0 0x80000000>,
+				<0x0 0x0 0x0 0x3000000>;
+			reg-names = "base", "phys_baseaddr",
+				"contiguous_mem";
+			interrupts = <GIC_SPI 220 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
 		sai1: audio-controller@f100000 {
 			#sound-dai-cells = <0>;
 			compatible = "fsl,vf610-sai";
@@ -1025,6 +1068,7 @@ enetc_port2: ethernet@0,2 {
 				fixed-link {
 					speed = <2500>;
 					full-duplex;
+					pause;
 				};
 			};
 
@@ -1049,7 +1093,7 @@ mscc_felix: ethernet-switch@0,5 {
 				interrupts = <GIC_SPI 95 IRQ_TYPE_LEVEL_HIGH>;
 				status = "disabled";
 
-				ports {
+				mscc_felix_ports: ports {
 					#address-cells = <1>;
 					#size-cells = <0>;
 
@@ -1083,6 +1127,7 @@ mscc_felix_port4: port@4 {
 						fixed-link {
 							speed = <2500>;
 							full-duplex;
+							pause;
 						};
 					};
 
@@ -1094,6 +1139,7 @@ mscc_felix_port5: port@5 {
 						fixed-link {
 							speed = <1000>;
 							full-duplex;
+							pause;
 						};
 					};
 				};
@@ -1108,6 +1154,7 @@ enetc_port3: ethernet@0,6 {
 				fixed-link {
 					speed = <1000>;
 					full-duplex;
+					pause;
 				};
 			};
 
@@ -1124,6 +1171,94 @@ ierb@1f0800000 {
 			reg = <0x01 0xf0800000 0x0 0x10000>;
 		};
 
+		pwm0: pwm@2800000 {
+			compatible = "fsl,vf610-ftm-pwm";
+			#pwm-cells = <3>;
+			reg = <0x0 0x2800000 0x0 0x10000>;
+			clock-names = "ftm_sys", "ftm_ext",
+				      "ftm_fix", "ftm_cnt_clk_en";
+			clocks = <&clockgen 4 1>, <&clockgen 4 1>,
+				 <&rtc_clk>, <&clockgen 4 1>;
+			status = "disabled";
+		};
+
+		pwm1: pwm@2810000 {
+			compatible = "fsl,vf610-ftm-pwm";
+			#pwm-cells = <3>;
+			reg = <0x0 0x2810000 0x0 0x10000>;
+			clock-names = "ftm_sys", "ftm_ext",
+				      "ftm_fix", "ftm_cnt_clk_en";
+			clocks = <&clockgen 4 1>, <&clockgen 4 1>,
+				 <&rtc_clk>, <&clockgen 4 1>;
+			status = "disabled";
+		};
+
+		pwm2: pwm@2820000 {
+			compatible = "fsl,vf610-ftm-pwm";
+			#pwm-cells = <3>;
+			reg = <0x0 0x2820000 0x0 0x10000>;
+			clock-names = "ftm_sys", "ftm_ext",
+				      "ftm_fix", "ftm_cnt_clk_en";
+			clocks = <&clockgen 4 1>, <&clockgen 4 1>,
+				 <&rtc_clk>, <&clockgen 4 1>;
+			status = "disabled";
+		};
+
+		pwm3: pwm@2830000 {
+			compatible = "fsl,vf610-ftm-pwm";
+			#pwm-cells = <3>;
+			reg = <0x0 0x2830000 0x0 0x10000>;
+			clock-names = "ftm_sys", "ftm_ext",
+				      "ftm_fix", "ftm_cnt_clk_en";
+			clocks = <&clockgen 4 1>, <&clockgen 4 1>,
+				 <&rtc_clk>, <&clockgen 4 1>;
+			status = "disabled";
+		};
+
+		pwm4: pwm@2840000 {
+			compatible = "fsl,vf610-ftm-pwm";
+			#pwm-cells = <3>;
+			reg = <0x0 0x2840000 0x0 0x10000>;
+			clock-names = "ftm_sys", "ftm_ext",
+				      "ftm_fix", "ftm_cnt_clk_en";
+			clocks = <&clockgen 4 1>, <&clockgen 4 1>,
+				 <&rtc_clk>, <&clockgen 4 1>;
+			status = "disabled";
+		};
+
+		pwm5: pwm@2850000 {
+			compatible = "fsl,vf610-ftm-pwm";
+			#pwm-cells = <3>;
+			reg = <0x0 0x2850000 0x0 0x10000>;
+			clock-names = "ftm_sys", "ftm_ext",
+				      "ftm_fix", "ftm_cnt_clk_en";
+			clocks = <&clockgen 4 1>, <&clockgen 4 1>,
+				 <&rtc_clk>, <&clockgen 4 1>;
+			status = "disabled";
+		};
+
+		pwm6: pwm@2860000 {
+			compatible = "fsl,vf610-ftm-pwm";
+			#pwm-cells = <3>;
+			reg = <0x0 0x2860000 0x0 0x10000>;
+			clock-names = "ftm_sys", "ftm_ext",
+				      "ftm_fix", "ftm_cnt_clk_en";
+			clocks = <&clockgen 4 1>, <&clockgen 4 1>,
+				 <&rtc_clk>, <&clockgen 4 1>;
+			status = "disabled";
+		};
+
+		pwm7: pwm@2870000 {
+			compatible = "fsl,vf610-ftm-pwm";
+			#pwm-cells = <3>;
+			reg = <0x0 0x2870000 0x0 0x10000>;
+			clock-names = "ftm_sys", "ftm_ext",
+				      "ftm_fix", "ftm_cnt_clk_en";
+			clocks = <&clockgen 4 1>, <&clockgen 4 1>,
+				 <&rtc_clk>, <&clockgen 4 1>;
+			status = "disabled";
+		};
+
 		rcpm: power-controller@1e34040 {
 			compatible = "fsl,ls1028a-rcpm", "fsl,qoriq-rcpm-2.1+";
 			reg = <0x0 0x1e34040 0x0 0x1c>;
@@ -1136,6 +1271,15 @@ ftm_alarm0: timer@2800000 {
 			reg = <0x0 0x2800000 0x0 0x10000>;
 			fsl,rcpm-wakeup = <&rcpm 0x0 0x0 0x0 0x0 0x4000 0x0 0x0>;
 			interrupts = <GIC_SPI 44 IRQ_TYPE_LEVEL_HIGH>;
+			status = "disabled";
+		};
+
+		ftm_alarm1: timer@2810000 {
+			compatible = "fsl,ls1028a-ftm-alarm";
+			reg = <0x0 0x2810000 0x0 0x10000>;
+			fsl,rcpm-wakeup = <&rcpm 0x0 0x0 0x0 0x0 0x4000 0x0 0x0>;
+			interrupts = <GIC_SPI 45 IRQ_TYPE_LEVEL_HIGH>;
+			status = "disabled";
 		};
 	};
 
@@ -1155,7 +1299,23 @@ malidp0: display@f080000 {
 
 		port {
 			dp0_out: endpoint {
+				remote-endpoint = <&dp1_out>;
+			};
+		};
+	};
+
+	hdptx0: display@f200000 {
+		compatible = "cdn,ls1028a-dp";
+		reg = <0x0 0xf200000 0x0 0xfffff>;
+		interrupts = <0 221 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&clockgen 2 2>, <&clockgen 2 2>, <&clockgen 2 2>,
+			 <&clockgen 2 2>, <&clockgen 2 2>, <&dpclk>;
+		clock-names = "clk_core", "pclk", "sclk",
+			      "cclk", "clk_vif", "clk_pxl";
 
+		port {
+			dp1_out: endpoint {
+				remote-endpoint = <&dp0_out>;
 			};
 		};
 	};
diff --git a/arch/arm64/boot/dts/freescale/fsl-ls1043a-qds-sdk.dts b/arch/arm64/boot/dts/freescale/fsl-ls1043a-qds-sdk.dts
new file mode 100644
index 000000000..43bafb515
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/fsl-ls1043a-qds-sdk.dts
@@ -0,0 +1,263 @@
+/*
+ * Device Tree Include file for Freescale Layerscape-1043A family SoC.
+ *
+ * Copyright 2014-2015 Freescale Semiconductor, Inc.
+ *
+ * Mingkai Hu <Mingkai.hu@freescale.com>
+ *
+ * This file is dual-licensed: you can use it either under the terms
+ * of the GPLv2 or the X11 license, at your option. Note that this dual
+ * licensing only applies to this file, and not this project as a
+ * whole.
+ *
+ *  a) This library is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This library is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ * Or, alternatively,
+ *
+ *  b) Permission is hereby granted, free of charge, to any person
+ *     obtaining a copy of this software and associated documentation
+ *     files (the "Software"), to deal in the Software without
+ *     restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or
+ *     sell copies of the Software, and to permit persons to whom the
+ *     Software is furnished to do so, subject to the following
+ *     conditions:
+ *
+ *     The above copyright notice and this permission notice shall be
+ *     included in all copies or substantial portions of the Software.
+ *
+ *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ *     OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include "fsl-ls1043a-qds.dts"
+#include "qoriq-qman-portals-sdk.dtsi"
+#include "qoriq-bman-portals-sdk.dtsi"
+
+&bman_fbpr {
+	compatible = "fsl,bman-fbpr";
+	alloc-ranges = <0 0 0x10000 0>;
+};
+&qman_fqd {
+	compatible = "fsl,qman-fqd";
+	alloc-ranges = <0 0 0x10000 0>;
+};
+&qman_pfdr {
+	compatible = "fsl,qman-pfdr";
+	alloc-ranges = <0 0 0x10000 0>;
+};
+
+&soc {
+/delete-property/ dma-coherent;
+
+#include "qoriq-dpaa-eth.dtsi"
+#include "qoriq-fman3-0-6oh.dtsi"
+
+pcie@3400000 {
+	/delete-property/ iommu-map;
+	dma-coherent;
+};
+
+pcie@3500000 {
+	/delete-property/ iommu-map;
+	dma-coherent;
+};
+
+pcie@3600000 {
+	/delete-property/ iommu-map;
+	dma-coherent;
+};
+
+/delete-node/ iommu@9000000;
+};
+
+&fman0 {
+	compatible = "fsl,fman", "simple-bus";
+	dma-coherent;
+};
+
+&clockgen {
+	dma-coherent;
+};
+
+&scfg {
+	dma-coherent;
+};
+
+&crypto {
+	dma-coherent;
+};
+
+&dcfg {
+	dma-coherent;
+};
+
+&ifc {
+	dma-coherent;
+};
+
+&qspi {
+	dma-coherent;
+};
+
+&esdhc {
+	dma-coherent;
+};
+
+&ddr {
+	dma-coherent;
+};
+
+&tmu {
+	dma-coherent;
+};
+
+&qman {
+	dma-coherent;
+};
+
+&bman {
+	dma-coherent;
+};
+
+&bportals {
+	dma-coherent;
+};
+
+&qportals {
+	dma-coherent;
+};
+
+&dspi0 {
+	dma-coherent;
+};
+
+&dspi1 {
+	dma-coherent;
+};
+
+&i2c0 {
+	dma-coherent;
+};
+
+&i2c1 {
+	dma-coherent;
+};
+
+&i2c2 {
+	dma-coherent;
+};
+
+&i2c3 {
+	dma-coherent;
+};
+
+&duart0 {
+	dma-coherent;
+};
+
+&duart1 {
+	dma-coherent;
+};
+
+&duart2 {
+	dma-coherent;
+};
+
+&duart3 {
+	dma-coherent;
+};
+
+&gpio1 {
+	dma-coherent;
+};
+
+&gpio2 {
+	dma-coherent;
+};
+
+&gpio3 {
+	dma-coherent;
+};
+
+&gpio4 {
+	dma-coherent;
+};
+
+&uqe {
+	dma-coherent;
+};
+
+&lpuart0 {
+	dma-coherent;
+};
+
+&lpuart1 {
+	dma-coherent;
+};
+
+&lpuart2 {
+	dma-coherent;
+};
+
+&lpuart3 {
+	dma-coherent;
+};
+
+&lpuart4 {
+	dma-coherent;
+};
+
+&lpuart5 {
+	dma-coherent;
+};
+
+&ftm_alarm0 {
+	dma-coherent;
+};
+
+&wdog0 {
+	dma-coherent;
+};
+
+&edma0 {
+	dma-coherent;
+};
+
+&qdma {
+	dma-coherent;
+};
+
+&msi1 {
+	dma-coherent;
+};
+
+&msi2 {
+	dma-coherent;
+};
+
+&msi3 {
+	dma-coherent;
+};
+
+&ptp_timer0 {
+	dma-coherent;
+};
+
+&fsldpaa {
+	dma-coherent;
+};
diff --git a/arch/arm64/boot/dts/freescale/fsl-ls1043a-qds.dts b/arch/arm64/boot/dts/freescale/fsl-ls1043a-qds.dts
index fea167d22..24898f26a 100644
--- a/arch/arm64/boot/dts/freescale/fsl-ls1043a-qds.dts
+++ b/arch/arm64/boot/dts/freescale/fsl-ls1043a-qds.dts
@@ -3,7 +3,7 @@
  * Device Tree Include file for Freescale Layerscape-1043A family SoC.
  *
  * Copyright 2014-2015 Freescale Semiconductor, Inc.
- * Copyright 2018 NXP
+ * Copyright 2018-2019 NXP
  *
  * Mingkai Hu <Mingkai.hu@freescale.com>
  */
@@ -24,6 +24,22 @@ aliases {
 		serial1 = &duart1;
 		serial2 = &duart2;
 		serial3 = &duart3;
+		sgmii-riser-s1-p1 = &sgmii_phy_s1_p1;
+		sgmii-riser-s2-p1 = &sgmii_phy_s2_p1;
+		sgmii-riser-s3-p1 = &sgmii_phy_s3_p1;
+		sgmii-riser-s4-p1 = &sgmii_phy_s4_p1;
+		qsgmii-s1-p1 = &qsgmii_phy_s1_p1;
+		qsgmii-s1-p2 = &qsgmii_phy_s1_p2;
+		qsgmii-s1-p3 = &qsgmii_phy_s1_p3;
+		qsgmii-s1-p4 = &qsgmii_phy_s1_p4;
+		qsgmii-s2-p1 = &qsgmii_phy_s2_p1;
+		qsgmii-s2-p2 = &qsgmii_phy_s2_p2;
+		qsgmii-s2-p3 = &qsgmii_phy_s2_p3;
+		qsgmii-s2-p4 = &qsgmii_phy_s2_p4;
+		emi1-slot1 = &ls1043mdio_s1;
+		emi1-slot2 = &ls1043mdio_s2;
+		emi1-slot3 = &ls1043mdio_s3;
+		emi1-slot4 = &ls1043mdio_s4;
 	};
 
 	chosen {
@@ -62,8 +78,11 @@ nand@1,0 {
 	};
 
 	fpga: board-control@2,0 {
-		compatible = "fsl,ls1043aqds-fpga", "fsl,fpga-qixis";
+		compatible = "fsl,ls1043aqds-fpga", "fsl,fpga-qixis", "simple-mfd";
 		reg = <0x2 0x0 0x0000100>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges = <0 2 0 0x100>;
 	};
 };
 
@@ -153,3 +172,153 @@ &usb0 {
 };
 
 #include "fsl-ls1043-post.dtsi"
+
+&fman0 {
+	ethernet@e0000 {
+		phy-handle = <&qsgmii_phy_s2_p1>;
+		phy-connection-type = "sgmii";
+	};
+
+	ethernet@e2000 {
+		phy-handle = <&qsgmii_phy_s2_p2>;
+		phy-connection-type = "sgmii";
+	};
+
+	ethernet@e4000 {
+		phy-handle = <&rgmii_phy1>;
+		phy-connection-type = "rgmii";
+	};
+
+	ethernet@e6000 {
+		phy-handle = <&rgmii_phy2>;
+		phy-connection-type = "rgmii";
+	};
+
+	ethernet@e8000 {
+		phy-handle = <&qsgmii_phy_s2_p3>;
+		phy-connection-type = "sgmii";
+	};
+
+	ethernet@ea000 {
+		phy-handle = <&qsgmii_phy_s2_p4>;
+		phy-connection-type = "sgmii";
+	};
+
+	ethernet@f0000 { /* DTSEC9/10GEC1 */
+		fixed-link = <1 1 10000 0 0>;
+		phy-connection-type = "xgmii";
+	};
+};
+
+&fpga {
+	mdio-mux-emi1 {
+		compatible = "mdio-mux-mmioreg", "mdio-mux";
+		mdio-parent-bus = <&mdio0>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg = <0x54 1>;    /* BRDCFG4 */
+		mux-mask = <0xe0>; /* EMI1 */
+
+		/* On-board RGMII1 PHY */
+		ls1043mdio0: mdio@0 {
+			reg = <0>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			rgmii_phy1: ethernet-phy@1 { /* MAC3 */
+				reg = <0x1>;
+			};
+		};
+
+		/* On-board RGMII2 PHY */
+		ls1043mdio1: mdio@1 {
+			reg = <0x20>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			rgmii_phy2: ethernet-phy@2 { /* MAC4 */
+				reg = <0x2>;
+			};
+		};
+
+		/* Slot 1 */
+		ls1043mdio_s1: mdio@2 {
+			reg = <0x40>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+
+			qsgmii_phy_s1_p1: ethernet-phy@4 {
+				reg = <0x4>;
+			};
+
+			qsgmii_phy_s1_p2: ethernet-phy@5 {
+				reg = <0x5>;
+			};
+
+			qsgmii_phy_s1_p3: ethernet-phy@6 {
+				reg = <0x6>;
+			};
+
+			qsgmii_phy_s1_p4: ethernet-phy@7 {
+				reg = <0x7>;
+			};
+
+			sgmii_phy_s1_p1: ethernet-phy@1c {
+				reg = <0x1c>;
+			};
+		};
+
+		/* Slot 2 */
+		ls1043mdio_s2: mdio@3 {
+			reg = <0x60>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+
+			qsgmii_phy_s2_p1: ethernet-phy@8 {
+				reg = <0x8>;
+			};
+
+			qsgmii_phy_s2_p2: ethernet-phy@9 {
+				reg = <0x9>;
+			};
+
+			qsgmii_phy_s2_p3: ethernet-phy@a {
+				reg = <0xa>;
+			};
+
+			qsgmii_phy_s2_p4: ethernet-phy@b {
+				reg = <0xb>;
+			};
+
+			sgmii_phy_s2_p1: ethernet-phy@1c {
+				reg = <0x1c>;
+			};
+		};
+
+		/* Slot 3 */
+		ls1043mdio_s3: mdio@4 {
+			reg = <0x80>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+
+			sgmii_phy_s3_p1: ethernet-phy@1c {
+				reg = <0x1c>;
+			};
+		};
+
+		/* Slot 4 */
+		ls1043mdio_s4: mdio@5 {
+			reg = <0xa0>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+
+			sgmii_phy_s4_p1: ethernet-phy@1c {
+				reg = <0x1c>;
+			};
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/freescale/fsl-ls1043a-rdb-sdk.dts b/arch/arm64/boot/dts/freescale/fsl-ls1043a-rdb-sdk.dts
new file mode 100644
index 000000000..210bc9f25
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/fsl-ls1043a-rdb-sdk.dts
@@ -0,0 +1,262 @@
+/*
+ * Device Tree Include file for Freescale Layerscape-1043A family SoC.
+ *
+ * Copyright 2014-2015 Freescale Semiconductor, Inc.
+ *
+ * Mingkai Hu <Mingkai.hu@freescale.com>
+ *
+ * This file is dual-licensed: you can use it either under the terms
+ * of the GPLv2 or the X11 license, at your option. Note that this dual
+ * licensing only applies to this file, and not this project as a
+ * whole.
+ *
+ *  a) This library is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This library is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ * Or, alternatively,
+ *
+ *  b) Permission is hereby granted, free of charge, to any person
+ *     obtaining a copy of this software and associated documentation
+ *     files (the "Software"), to deal in the Software without
+ *     restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or
+ *     sell copies of the Software, and to permit persons to whom the
+ *     Software is furnished to do so, subject to the following
+ *     conditions:
+ *
+ *     The above copyright notice and this permission notice shall be
+ *     included in all copies or substantial portions of the Software.
+ *
+ *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ *     OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include "fsl-ls1043a-rdb.dts"
+#include "qoriq-qman-portals-sdk.dtsi"
+#include "qoriq-bman-portals-sdk.dtsi"
+
+&bman_fbpr {
+	compatible = "fsl,bman-fbpr";
+	alloc-ranges = <0 0 0x10000 0>;
+};
+&qman_fqd {
+	compatible = "fsl,qman-fqd";
+	alloc-ranges = <0 0 0x10000 0>;
+};
+&qman_pfdr {
+	compatible = "fsl,qman-pfdr";
+	alloc-ranges = <0 0 0x10000 0>;
+};
+
+&soc {
+/delete-property/ dma-coherent;
+
+#include "qoriq-dpaa-eth.dtsi"
+#include "qoriq-fman3-0-6oh.dtsi"
+
+pcie@3400000 {
+	/delete-property/ iommu-map;
+	dma-coherent;
+};
+
+pcie@3500000 {
+	/delete-property/ iommu-map;
+	dma-coherent;
+};
+
+pcie@3600000 {
+	/delete-property/ iommu-map;
+	dma-coherent;
+};
+
+/delete-node/ iommu@9000000;
+};
+
+&fman0 {
+	compatible = "fsl,fman", "simple-bus";
+};
+
+&clockgen {
+	dma-coherent;
+};
+
+&scfg {
+	dma-coherent;
+};
+
+&crypto {
+	dma-coherent;
+};
+
+&dcfg {
+	dma-coherent;
+};
+
+&ifc {
+	dma-coherent;
+};
+
+&qspi {
+	dma-coherent;
+};
+
+&esdhc {
+	dma-coherent;
+};
+
+&ddr {
+	dma-coherent;
+};
+
+&tmu {
+	dma-coherent;
+};
+
+&qman {
+	dma-coherent;
+};
+
+&bman {
+	dma-coherent;
+};
+
+&bportals {
+	dma-coherent;
+};
+
+&qportals {
+	dma-coherent;
+};
+
+&dspi0 {
+	dma-coherent;
+};
+
+&dspi1 {
+	dma-coherent;
+};
+
+&i2c0 {
+	dma-coherent;
+};
+
+&i2c1 {
+	dma-coherent;
+};
+
+&i2c2 {
+	dma-coherent;
+};
+
+&i2c3 {
+	dma-coherent;
+};
+
+&duart0 {
+	dma-coherent;
+};
+
+&duart1 {
+	dma-coherent;
+};
+
+&duart2 {
+	dma-coherent;
+};
+
+&duart3 {
+	dma-coherent;
+};
+
+&gpio1 {
+	dma-coherent;
+};
+
+&gpio2 {
+	dma-coherent;
+};
+
+&gpio3 {
+	dma-coherent;
+};
+
+&gpio4 {
+	dma-coherent;
+};
+
+&lpuart0 {
+	dma-coherent;
+};
+
+&lpuart1 {
+	dma-coherent;
+};
+
+&lpuart2 {
+	dma-coherent;
+};
+
+&lpuart3 {
+	dma-coherent;
+};
+
+&lpuart4 {
+	dma-coherent;
+};
+
+&lpuart5 {
+	dma-coherent;
+};
+
+&ftm_alarm0 {
+	dma-coherent;
+};
+
+&wdog0 {
+	dma-coherent;
+};
+
+&edma0 {
+	dma-coherent;
+};
+
+&qdma {
+	dma-coherent;
+};
+
+&msi1 {
+	dma-coherent;
+};
+
+&msi2 {
+	dma-coherent;
+};
+
+&msi3 {
+	dma-coherent;
+};
+
+&fman0 {
+	dma-coherent;
+};
+
+&ptp_timer0 {
+	dma-coherent;
+};
+
+&fsldpaa {
+	dma-coherent;
+};
diff --git a/arch/arm64/boot/dts/freescale/fsl-ls1043a-rdb-usdpaa.dts b/arch/arm64/boot/dts/freescale/fsl-ls1043a-rdb-usdpaa.dts
new file mode 100644
index 000000000..7beb9985a
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/fsl-ls1043a-rdb-usdpaa.dts
@@ -0,0 +1,140 @@
+/*
+ * Device Tree Include file for Freescale Layerscape-1043A family SoC.
+ *
+ * Copyright (C) 2014-2015, Freescale Semiconductor
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include "fsl-ls1043a-rdb-sdk.dts"
+
+&soc {
+	bp7: buffer-pool@7 {
+		compatible = "fsl,p4080-bpool", "fsl,bpool";
+		fsl,bpid = <7>;
+		fsl,bpool-ethernet-cfg = <0 0 0 192 0 0xdeadbeef>;
+		fsl,bpool-thresholds = <0x400 0xc00 0x0 0x0>;
+		dma-coherent;
+	};
+
+	bp8: buffer-pool@8 {
+		compatible = "fsl,p4080-bpool", "fsl,bpool";
+		fsl,bpid = <8>;
+		fsl,bpool-ethernet-cfg = <0 0 0 576 0 0xabbaf00d>;
+		fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
+		dma-coherent;
+	};
+
+	bp9: buffer-pool@9 {
+		compatible = "fsl,p4080-bpool", "fsl,bpool";
+		fsl,bpid = <9>;
+		fsl,bpool-ethernet-cfg = <0 0 0 2048 0 0xfeedabba>;
+		fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
+		dma-coherent;
+	};
+
+	fsl,dpaa {
+		compatible = "fsl,ls1043a", "fsl,dpaa", "simple-bus";
+		dma-coherent;
+
+		ethernet@0 {
+			compatible = "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x50 1 0x51 1>;
+			fsl,qman-frame-queues-tx = <0x70 1 0x71 1>;
+		};
+
+		ethernet@1 {
+			compatible = "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x52 1 0x53 1>;
+			fsl,qman-frame-queues-tx = <0x72 1 0x73 1>;
+		};
+
+		ethernet@2 {
+			compatible = "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x54 1 0x55 1>;
+			fsl,qman-frame-queues-tx = <0x74 1 0x75 1>;
+		};
+
+		ethernet@3 {
+			compatible = "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x56 1 0x57 1>;
+			fsl,qman-frame-queues-tx = <0x76 1 0x77 1>;
+		};
+
+		ethernet@4 {
+			compatible = "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x58 1 0x59 1>;
+			fsl,qman-frame-queues-tx = <0x78 1 0x79 1>;
+		};
+
+		ethernet@5 {
+			compatible = "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x60 1 0x61 1>;
+			fsl,qman-frame-queues-tx = <0x80 1 0x81 1>;
+		};
+
+		ethernet@8 {
+			compatible = "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x5c 1 0x5d 1>;
+			fsl,qman-frame-queues-tx = <0x7c 1 0x7d 1>;
+
+		};
+		dpa-fman0-oh@2 {
+			compatible = "fsl,dpa-oh";
+			/* Define frame queues for the OH port*/
+			/* <OH Rx error, OH Rx default> */
+			fsl,qman-frame-queues-oh = <0x5a 1 0x5b 1>;
+			fsl,fman-oh-port = <&fman0_oh2>;
+		};
+	};
+
+	pcie@3400000 {
+	       /delete-property/ iommu-map;
+	};
+
+	pcie@3500000 {
+	       /delete-property/ iommu-map;
+	};
+
+	pcie@3600000 {
+	       /delete-property/ iommu-map;
+	};
+
+	/delete-node/ iommu@9000000;
+};
+/ {
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		/* For legacy usdpaa based use-cases, update the size and
+		   alignment parameters. e.g. to allocate 256 MB memory:
+		   size = <0 0x10000000>;
+		   alignment = <0 0x10000000>;
+		*/
+		usdpaa_mem: usdpaa_mem {
+			compatible = "fsl,usdpaa-mem";
+			alloc-ranges = <0 0 0x10000 0>;
+			size = <0 0x1000>;
+			alignment = <0 0x1000>;
+		};
+	};
+};
+
+&fman0 {
+	fman0_oh2: port@83000 {
+		cell-index = <1>;
+		compatible = "fsl,fman-port-oh";
+		reg = <0x83000 0x1000>;
+	};
+};
diff --git a/arch/arm64/boot/dts/freescale/fsl-ls1043a-rdb.dts b/arch/arm64/boot/dts/freescale/fsl-ls1043a-rdb.dts
index 3516af472..91917fcb2 100644
--- a/arch/arm64/boot/dts/freescale/fsl-ls1043a-rdb.dts
+++ b/arch/arm64/boot/dts/freescale/fsl-ls1043a-rdb.dts
@@ -38,6 +38,10 @@ adt7461a@4c {
 		compatible = "adi,adt7461";
 		reg = <0x4c>;
 	};
+	rtc@51 {
+		compatible = "nxp,pcf85263";
+		reg = <0x51>;
+	};
 	eeprom@52 {
 		compatible = "atmel,24c512";
 		reg = <0x52>;
diff --git a/arch/arm64/boot/dts/freescale/fsl-ls1043a.dtsi b/arch/arm64/boot/dts/freescale/fsl-ls1043a.dtsi
index 35d1939e6..8288d735b 100644
--- a/arch/arm64/boot/dts/freescale/fsl-ls1043a.dtsi
+++ b/arch/arm64/boot/dts/freescale/fsl-ls1043a.dtsi
@@ -300,6 +300,8 @@ soc: soc {
 		#address-cells = <2>;
 		#size-cells = <2>;
 		ranges;
+		dma-ranges = <0x0 0x0 0x0 0x0 0x10000 0x00000000>;
+		dma-coherent;
 
 		clockgen: clocking@1ee1000 {
 			compatible = "fsl,ls1043a-clockgen";
@@ -308,6 +310,49 @@ clockgen: clocking@1ee1000 {
 			clocks = <&sysclk>;
 		};
 
+		smmu: iommu@9000000 {
+			compatible = "arm,mmu-500";
+			reg = <0 0x9000000 0 0x400000>;
+			dma-coherent;
+			stream-match-mask = <0x7f00>;
+			#global-interrupts = <2>;
+			#iommu-cells = <1>;
+			interrupts = <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 143 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
 		scfg: scfg@1570000 {
 			compatible = "fsl,ls1043a-scfg", "syscon";
 			reg = <0x0 0x1570000 0x0 0x10000>;
@@ -385,12 +430,12 @@ sec_jr3: jr@40000 {
 
 		dcfg: dcfg@1ee0000 {
 			compatible = "fsl,ls1043a-dcfg", "syscon";
-			reg = <0x0 0x1ee0000 0x0 0x10000>;
+			reg = <0x0 0x1ee0000 0x0 0x1000>;
 			big-endian;
 		};
 
-		ifc: ifc@1530000 {
-			compatible = "fsl,ifc", "simple-bus";
+		ifc: memory-controller@1530000 {
+			compatible = "fsl,ifc";
 			reg = <0x0 0x1530000 0x0 0x10000>;
 			interrupts = <0 43 0x4>;
 		};
@@ -528,7 +573,7 @@ dspi1: spi@2110000 {
 		};
 
 		i2c0: i2c@2180000 {
-			compatible = "fsl,vf610-i2c";
+			compatible = "fsl,vf610-i2c", "fsl,ls1043a-vf610-i2c";
 			#address-cells = <1>;
 			#size-cells = <0>;
 			reg = <0x0 0x2180000 0x0 0x10000>;
@@ -536,9 +581,10 @@ i2c0: i2c@2180000 {
 			clock-names = "i2c";
 			clocks = <&clockgen QORIQ_CLK_PLATFORM_PLL
 					    QORIQ_CLK_PLL_DIV(1)>;
-			dmas = <&edma0 1 38>,
-			       <&edma0 1 39>;
-			dma-names = "rx", "tx";
+			dmas = <&edma0 1 39>,
+			       <&edma0 1 38>;
+			dma-names = "tx", "rx";
+			scl-gpios = <&gpio4 12 0>;
 			status = "disabled";
 		};
 
@@ -802,48 +848,65 @@ QORIQ_CLK_PLL_DIV(1)>,
 					    QORIQ_CLK_PLL_DIV(1)>;
 		};
 
-		usb0: usb@2f00000 {
-			compatible = "snps,dwc3";
-			reg = <0x0 0x2f00000 0x0 0x10000>;
-			interrupts = <0 60 0x4>;
-			dr_mode = "host";
-			snps,quirk-frame-length-adjustment = <0x20>;
-			snps,dis_rxdet_inp3_quirk;
-			snps,incr-burst-type-adjustment = <1>, <4>, <8>, <16>;
-			status = "disabled";
-		};
+		aux_bus: aux_bus {
+			#address-cells = <2>;
+			#size-cells = <2>;
+			compatible = "simple-bus";
+			ranges;
+			dma-ranges = <0x0 0x0 0x0 0x0 0x100 0x00000000>;
+
+			usb0: usb@2f00000 {
+				compatible = "fsl,ls1043a-dwc3", "snps,dwc3";
+				reg = <0x0 0x2f00000 0x0 0x10000>;
+				interrupts = <0 60 0x4>;
+				dr_mode = "host";
+				snps,quirk-frame-length-adjustment = <0x20>;
+				snps,dis_rxdet_inp3_quirk;
+				usb3-lpm-capable;
+				snps,incr-burst-type-adjustment = <1>, <4>, <8>, <16>;
+				snps,host-vbus-glitches;
+				dma-coherent;
+				status = "disabled";
+			};
 
-		usb1: usb@3000000 {
-			compatible = "snps,dwc3";
-			reg = <0x0 0x3000000 0x0 0x10000>;
-			interrupts = <0 61 0x4>;
-			dr_mode = "host";
-			snps,quirk-frame-length-adjustment = <0x20>;
-			snps,dis_rxdet_inp3_quirk;
-			snps,incr-burst-type-adjustment = <1>, <4>, <8>, <16>;
-			status = "disabled";
-		};
+			usb1: usb@3000000 {
+				compatible = "fsl,ls1043a-dwc3", "snps,dwc3";
+				reg = <0x0 0x3000000 0x0 0x10000>;
+				interrupts = <0 61 0x4>;
+				dr_mode = "host";
+				snps,quirk-frame-length-adjustment = <0x20>;
+				snps,dis_rxdet_inp3_quirk;
+				usb3-lpm-capable;
+				snps,incr-burst-type-adjustment = <1>, <4>, <8>, <16>;
+				snps,host-vbus-glitches;
+				dma-coherent;
+				status = "disabled";
+			};
 
-		usb2: usb@3100000 {
-			compatible = "snps,dwc3";
-			reg = <0x0 0x3100000 0x0 0x10000>;
-			interrupts = <0 63 0x4>;
-			dr_mode = "host";
-			snps,quirk-frame-length-adjustment = <0x20>;
-			snps,dis_rxdet_inp3_quirk;
-			snps,incr-burst-type-adjustment = <1>, <4>, <8>, <16>;
-			status = "disabled";
-		};
+			usb2: usb@3100000 {
+				compatible = "fsl,ls1043a-dwc3", "snps,dwc3";
+				reg = <0x0 0x3100000 0x0 0x10000>;
+				interrupts = <0 63 0x4>;
+				dr_mode = "host";
+				snps,quirk-frame-length-adjustment = <0x20>;
+				snps,dis_rxdet_inp3_quirk;
+				usb3-lpm-capable;
+				snps,incr-burst-type-adjustment = <1>, <4>, <8>, <16>;
+				snps,host-vbus-glitches;
+				dma-coherent;
+				status = "disabled";
+			};
 
-		sata: sata@3200000 {
-			compatible = "fsl,ls1043a-ahci";
-			reg = <0x0 0x3200000 0x0 0x10000>,
-				<0x0 0x20140520 0x0 0x4>;
-			reg-names = "ahci", "sata-ecc";
-			interrupts = <0 69 0x4>;
-			clocks = <&clockgen QORIQ_CLK_PLATFORM_PLL
-					    QORIQ_CLK_PLL_DIV(1)>;
-			dma-coherent;
+			sata: sata@3200000 {
+				compatible = "fsl,ls1043a-ahci";
+				reg = <0x0 0x3200000 0x0 0x10000>,
+					<0x0 0x20140520 0x0 0x4>;
+				reg-names = "ahci", "sata-ecc";
+				interrupts = <0 69 0x4>;
+				clocks = <&clockgen QORIQ_CLK_PLATFORM_PLL
+						    QORIQ_CLK_PLL_DIV(1)>;
+				dma-coherent;
+			};
 		};
 
 		msi1: msi-controller1@1571000 {
@@ -872,13 +935,13 @@ pcie1: pcie@3400000 {
 			reg = <0x00 0x03400000 0x0 0x00100000>, /* controller registers */
 			      <0x40 0x00000000 0x0 0x00002000>; /* configuration space */
 			reg-names = "regs", "config";
-			interrupts = <0 118 0x4>, /* controller interrupt */
-				     <0 117 0x4>; /* PME interrupt */
-			interrupt-names = "intr", "pme";
+			interrupts = <0 117 0x4>,
+				     <0 118 0x4>;
+			interrupt-names = "pme", "aer";
 			#address-cells = <3>;
 			#size-cells = <2>;
 			device_type = "pci";
-			dma-coherent;
+			iommu-map = <0 &smmu 0 1>;	/* update by bootloader */
 			num-viewport = <6>;
 			bus-range = <0x0 0xff>;
 			ranges = <0x81000000 0x0 0x00000000 0x40 0x00010000 0x0 0x00010000   /* downstream I/O */
@@ -890,6 +953,8 @@ pcie1: pcie@3400000 {
 					<0000 0 0 2 &gic 0 111 0x4>,
 					<0000 0 0 3 &gic 0 112 0x4>,
 					<0000 0 0 4 &gic 0 113 0x4>;
+			fsl,pcie-scfg = <&scfg 0>;
+			big-endian;
 			status = "disabled";
 		};
 
@@ -898,13 +963,13 @@ pcie2: pcie@3500000 {
 			reg = <0x00 0x03500000 0x0 0x00100000>, /* controller registers */
 			      <0x48 0x00000000 0x0 0x00002000>; /* configuration space */
 			reg-names = "regs", "config";
-			interrupts = <0 128 0x4>,
-				     <0 127 0x4>;
-			interrupt-names = "intr", "pme";
+			interrupts = <0 127 0x4>,
+				     <0 128 0x4>;
+			interrupt-names = "pme", "aer";
 			#address-cells = <3>;
 			#size-cells = <2>;
 			device_type = "pci";
-			dma-coherent;
+			iommu-map = <0 &smmu 0 1>;	/* update by bootloader */
 			num-viewport = <6>;
 			bus-range = <0x0 0xff>;
 			ranges = <0x81000000 0x0 0x00000000 0x48 0x00010000 0x0 0x00010000   /* downstream I/O */
@@ -916,6 +981,8 @@ pcie2: pcie@3500000 {
 					<0000 0 0 2 &gic 0 121 0x4>,
 					<0000 0 0 3 &gic 0 122 0x4>,
 					<0000 0 0 4 &gic 0 123 0x4>;
+			fsl,pcie-scfg = <&scfg 1>;
+			big-endian;
 			status = "disabled";
 		};
 
@@ -924,13 +991,13 @@ pcie3: pcie@3600000 {
 			reg = <0x00 0x03600000 0x0 0x00100000>, /* controller registers */
 			      <0x50 0x00000000 0x0 0x00002000>; /* configuration space */
 			reg-names = "regs", "config";
-			interrupts = <0 162 0x4>,
-				     <0 161 0x4>;
-			interrupt-names = "intr", "pme";
+			interrupts = <0 161 0x4>,
+				     <0 162 0x4>;
+			interrupt-names = "pme", "aer";
 			#address-cells = <3>;
 			#size-cells = <2>;
 			device_type = "pci";
-			dma-coherent;
+			iommu-map = <0 &smmu 0 1>;	/* update by bootloader */
 			num-viewport = <6>;
 			bus-range = <0x0 0xff>;
 			ranges = <0x81000000 0x0 0x00000000 0x50 0x00010000 0x0 0x00010000   /* downstream I/O */
@@ -942,6 +1009,8 @@ pcie3: pcie@3600000 {
 					<0000 0 0 2 &gic 0 155 0x4>,
 					<0000 0 0 3 &gic 0 156 0x4>,
 					<0000 0 0 4 &gic 0 157 0x4>;
+			fsl,pcie-scfg = <&scfg 2>;
+			big-endian;
 			status = "disabled";
 		};
 
diff --git a/arch/arm64/boot/dts/freescale/fsl-ls1046a-frwy-sdk.dts b/arch/arm64/boot/dts/freescale/fsl-ls1046a-frwy-sdk.dts
new file mode 100644
index 000000000..8c0e8aadd
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/fsl-ls1046a-frwy-sdk.dts
@@ -0,0 +1,241 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Device Tree Include file for Freescale Layerscape-1046A family SoC.
+ *
+ * Copyright 2019 NXP.
+ *
+ */
+
+#include "fsl-ls1046a-frwy.dts"
+#include "qoriq-qman-portals-sdk.dtsi"
+#include "qoriq-bman-portals-sdk.dtsi"
+
+&bman_fbpr {
+	compatible = "fsl,bman-fbpr";
+	alloc-ranges = <0 0 0x10000 0>;
+};
+&qman_fqd {
+	compatible = "fsl,qman-fqd";
+	alloc-ranges = <0 0 0x10000 0>;
+};
+&qman_pfdr {
+	compatible = "fsl,qman-pfdr";
+	alloc-ranges = <0 0 0x10000 0>;
+};
+
+&soc {
+/delete-property/ dma-coherent;
+
+#include "qoriq-dpaa-eth.dtsi"
+#include "qoriq-fman3-0-6oh.dtsi"
+
+	pcie@3400000 {
+		/delete-property/ iommu-map;
+	};
+
+	pcie@3500000 {
+		/delete-property/ iommu-map;
+	};
+
+	pcie@3600000 {
+		/delete-property/ iommu-map;
+	};
+
+	/delete-node/ iommu@9000000;
+};
+
+&fsldpaa {
+	ethernet@1 {
+		status = "disabled";
+	};
+	ethernet@2 {
+		status = "disabled";
+	};
+	ethernet@3 {
+		status = "disabled";
+	};
+	ethernet@6 {
+		status = "disabled";
+	};
+	ethernet@9 {
+		compatible = "fsl,dpa-ethernet";
+		fsl,fman-mac = <&enet7>;
+		dma-coherent;
+	};
+};
+
+&fman0 {
+	compatible = "fsl,fman", "simple-bus";
+};
+
+&clockgen {
+	dma-coherent;
+};
+
+&scfg {
+	dma-coherent;
+};
+
+&crypto {
+	dma-coherent;
+};
+
+&dcfg {
+	dma-coherent;
+};
+
+&ifc {
+	dma-coherent;
+};
+
+&qspi {
+	dma-coherent;
+};
+
+&esdhc {
+	dma-coherent;
+};
+
+&ddr {
+	dma-coherent;
+};
+
+&tmu {
+	dma-coherent;
+};
+
+&qman {
+	dma-coherent;
+};
+
+&bman {
+	dma-coherent;
+};
+
+&bportals {
+	dma-coherent;
+};
+
+&qportals {
+	dma-coherent;
+};
+
+&dspi {
+	dma-coherent;
+};
+
+&i2c0 {
+	dma-coherent;
+};
+
+&i2c1 {
+	dma-coherent;
+};
+
+&i2c2 {
+	dma-coherent;
+};
+
+&i2c3 {
+	dma-coherent;
+};
+
+&duart0 {
+	dma-coherent;
+};
+
+&duart1 {
+	dma-coherent;
+};
+
+&duart2 {
+	dma-coherent;
+};
+
+&duart3 {
+	dma-coherent;
+};
+
+&gpio0 {
+	dma-coherent;
+};
+
+&gpio1 {
+	dma-coherent;
+};
+
+&gpio2 {
+	dma-coherent;
+};
+
+&gpio3 {
+	dma-coherent;
+};
+
+&lpuart0 {
+	dma-coherent;
+};
+
+&lpuart1 {
+	dma-coherent;
+};
+
+&lpuart2 {
+	dma-coherent;
+};
+
+&lpuart3 {
+	dma-coherent;
+};
+
+&lpuart4 {
+	dma-coherent;
+};
+
+&lpuart5 {
+	dma-coherent;
+};
+
+&ftm_alarm0 {
+	dma-coherent;
+};
+
+&wdog0 {
+	dma-coherent;
+};
+
+&edma0 {
+	dma-coherent;
+};
+
+&sata {
+	dma-coherent;
+};
+
+&qdma {
+	dma-coherent;
+};
+
+&msi1 {
+	dma-coherent;
+};
+
+&msi2 {
+	dma-coherent;
+};
+
+&msi3 {
+	dma-coherent;
+};
+
+&fman0 {
+	dma-coherent;
+};
+
+&ptp_timer0 {
+	dma-coherent;
+};
+
+&fsldpaa {
+	dma-coherent;
+};
diff --git a/arch/arm64/boot/dts/freescale/fsl-ls1046a-frwy-usdpaa.dts b/arch/arm64/boot/dts/freescale/fsl-ls1046a-frwy-usdpaa.dts
new file mode 100644
index 000000000..bd4f884eb
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/fsl-ls1046a-frwy-usdpaa.dts
@@ -0,0 +1,117 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Device Tree Include file for Freescale Layerscape-1046A family SoC.
+ *
+ * Copyright 2019 NXP.
+ *
+ */
+
+#include "fsl-ls1046a-frwy-sdk.dts"
+
+&soc {
+	bp7: buffer-pool@7 {
+		compatible = "fsl,ls1046a-bpool", "fsl,bpool";
+		fsl,bpid = <7>;
+		fsl,bpool-ethernet-cfg = <0 0 0 192 0 0xdeadbeef>;
+		fsl,bpool-thresholds = <0x400 0xc00 0x0 0x0>;
+		dma-coherent;
+	};
+
+	bp8: buffer-pool@8 {
+		compatible = "fsl,ls1046a-bpool", "fsl,bpool";
+		fsl,bpid = <8>;
+		fsl,bpool-ethernet-cfg = <0 0 0 576 0 0xabbaf00d>;
+		fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
+		dma-coherent;
+	};
+
+	bp9: buffer-pool@9 {
+		compatible = "fsl,ls1046a-bpool", "fsl,bpool";
+		fsl,bpid = <9>;
+		fsl,bpool-ethernet-cfg = <0 0 0 2048 0 0xfeedabba>;
+		fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
+		dma-coherent;
+	};
+
+	fsl,dpaa {
+		compatible = "fsl,ls1046a", "fsl,dpaa", "simple-bus";
+		dma-coherent;
+
+		ethernet@0 {
+			compatible = "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x50 1 0x51 1>;
+			fsl,qman-frame-queues-tx = <0x70 1 0x71 1>;
+		};
+
+		ethernet@4 {
+			compatible = "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x52 1 0x53 1>;
+			fsl,qman-frame-queues-tx = <0x72 1 0x73 1>;
+		};
+
+		ethernet@5 {
+			compatible = "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x54 1 0x55 1>;
+			fsl,qman-frame-queues-tx = <0x74 1 0x75 1>;
+		};
+
+		ethernet@9 {
+			compatible = "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x56 1 0x57 1>;
+			fsl,qman-frame-queues-tx = <0x76 1 0x77 1>;
+		};
+
+		dpa-fman0-oh@2 {
+			compatible = "fsl,dpa-oh";
+			/* Define frame queues for the OH port*/
+			/* <OH Rx error, OH Rx default> */
+			fsl,qman-frame-queues-oh = <0x60 1 0x61 1>;
+			fsl,fman-oh-port = <&fman0_oh2>;
+		};
+	};
+
+	pcie@3400000 {
+		/delete-property/ iommu-map;
+	};
+
+	pcie@3500000 {
+		/delete-property/ iommu-map;
+	};
+
+	pcie@3600000 {
+		/delete-property/ iommu-map;
+	};
+
+	/delete-node/ iommu@9000000;
+};
+/ {
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+		/* For legacy usdpaa based use-cases, update the size and
+		   alignment parameters. e.g. to allocate 256 MB memory:
+		   size = <0 0x10000000>;
+		   alignment = <0 0x10000000>;
+		*/
+
+		usdpaa_mem: usdpaa_mem {
+			compatible = "fsl,usdpaa-mem";
+			alloc-ranges = <0 0 0x10000 0>;
+			size = <0 0x1000>;
+			alignment = <0 0x1000>;
+		};
+	};
+};
+
+&fman0 {
+	fman0_oh2: port@83000 {
+		cell-index = <1>;
+		compatible = "fsl,fman-port-oh";
+		reg = <0x83000 0x1000>;
+	};
+};
diff --git a/arch/arm64/boot/dts/freescale/fsl-ls1046a-qds-sdk.dts b/arch/arm64/boot/dts/freescale/fsl-ls1046a-qds-sdk.dts
new file mode 100644
index 000000000..d5de7ea92
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/fsl-ls1046a-qds-sdk.dts
@@ -0,0 +1,264 @@
+/*
+ * Device Tree Include file for Freescale Layerscape-1046A family SoC.
+ *
+ * Copyright 2014-2015 Freescale Semiconductor, Inc.
+ *
+ * Mingkai Hu <Mingkai.hu@freescale.com>
+ *
+ * This file is dual-licensed: you can use it either under the terms
+ * of the GPLv2 or the X11 license, at your option. Note that this dual
+ * licensing only applies to this file, and not this project as a
+ * whole.
+ *
+ *  a) This library is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This library is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ * Or, alternatively,
+ *
+ *  b) Permission is hereby granted, free of charge, to any person
+ *     obtaining a copy of this software and associated documentation
+ *     files (the "Software"), to deal in the Software without
+ *     restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or
+ *     sell copies of the Software, and to permit persons to whom the
+ *     Software is furnished to do so, subject to the following
+ *     conditions:
+ *
+ *     The above copyright notice and this permission notice shall be
+ *     included in all copies or substantial portions of the Software.
+ *
+ *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ *     OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include "fsl-ls1046a-qds.dts"
+#include "qoriq-qman-portals-sdk.dtsi"
+#include "qoriq-bman-portals-sdk.dtsi"
+
+&bman_fbpr {
+	compatible = "fsl,bman-fbpr";
+	alloc-ranges = <0 0 0x10000 0>;
+};
+&qman_fqd {
+	compatible = "fsl,qman-fqd";
+	alloc-ranges = <0 0 0x10000 0>;
+};
+&qman_pfdr {
+	compatible = "fsl,qman-pfdr";
+	alloc-ranges = <0 0 0x10000 0>;
+};
+
+&soc {
+/delete-property/ dma-coherent;
+
+#include "qoriq-dpaa-eth.dtsi"
+#include "qoriq-fman3-0-6oh.dtsi"
+
+pcie@3400000 {
+       /delete-property/ iommu-map;
+};
+
+pcie@3500000 {
+       /delete-property/ iommu-map;
+};
+
+pcie@3600000 {
+       /delete-property/ iommu-map;
+};
+
+/delete-node/ iommu@9000000;
+};
+
+&fsldpaa {
+	ethernet@9 {
+		compatible = "fsl,dpa-ethernet";
+		fsl,fman-mac = <&enet7>;
+		dma-coherent;
+	};
+};
+
+&fman0 {
+	compatible = "fsl,fman", "simple-bus";
+	dma-coherent;
+};
+
+&clockgen {
+	dma-coherent;
+};
+
+&scfg {
+	dma-coherent;
+};
+
+&crypto {
+	dma-coherent;
+};
+
+&dcfg {
+	dma-coherent;
+};
+
+&ifc {
+	dma-coherent;
+};
+
+&qspi {
+	dma-coherent;
+};
+
+&esdhc {
+	dma-coherent;
+};
+
+&ddr {
+	dma-coherent;
+};
+
+&tmu {
+	dma-coherent;
+};
+
+&qman {
+	dma-coherent;
+};
+
+&bman {
+	dma-coherent;
+};
+
+&bportals {
+	dma-coherent;
+};
+
+&qportals {
+	dma-coherent;
+};
+
+&dspi {
+	dma-coherent;
+};
+
+&i2c0 {
+	dma-coherent;
+};
+
+&i2c1 {
+	dma-coherent;
+};
+
+&i2c2 {
+	dma-coherent;
+};
+
+&i2c3 {
+	dma-coherent;
+};
+
+&duart0 {
+	dma-coherent;
+};
+
+&duart1 {
+	dma-coherent;
+};
+
+&duart2 {
+	dma-coherent;
+};
+
+&duart3 {
+	dma-coherent;
+};
+
+&gpio0 {
+	dma-coherent;
+};
+
+&gpio1 {
+	dma-coherent;
+};
+
+&gpio2 {
+	dma-coherent;
+};
+
+&gpio3 {
+	dma-coherent;
+};
+
+&lpuart0 {
+	dma-coherent;
+};
+
+&lpuart1 {
+	dma-coherent;
+};
+
+&lpuart2 {
+	dma-coherent;
+};
+
+&lpuart3 {
+	dma-coherent;
+};
+
+&lpuart4 {
+	dma-coherent;
+};
+
+&lpuart5 {
+	dma-coherent;
+};
+
+&ftm_alarm0 {
+	dma-coherent;
+};
+
+&wdog0 {
+	dma-coherent;
+};
+
+&edma0 {
+	dma-coherent;
+};
+
+&sata {
+	dma-coherent;
+};
+
+&qdma {
+	dma-coherent;
+};
+
+&msi1 {
+	dma-coherent;
+};
+
+&msi2 {
+	dma-coherent;
+};
+
+&msi3 {
+	dma-coherent;
+};
+
+&ptp_timer0 {
+	dma-coherent;
+};
+
+&fsldpaa {
+	dma-coherent;
+};
diff --git a/arch/arm64/boot/dts/freescale/fsl-ls1046a-qds.dts b/arch/arm64/boot/dts/freescale/fsl-ls1046a-qds.dts
index eec62c63d..a9089966a 100644
--- a/arch/arm64/boot/dts/freescale/fsl-ls1046a-qds.dts
+++ b/arch/arm64/boot/dts/freescale/fsl-ls1046a-qds.dts
@@ -3,7 +3,7 @@
  * Device Tree Include file for Freescale Layerscape-1046A family SoC.
  *
  * Copyright 2016 Freescale Semiconductor, Inc.
- * Copyright 2018 NXP
+ * Copyright 2018-2019 NXP
  *
  * Shaohui Xie <Shaohui.Xie@nxp.com>
  */
@@ -25,6 +25,20 @@ aliases {
 		serial1 = &duart1;
 		serial2 = &duart2;
 		serial3 = &duart3;
+
+		emi1-slot1 = &ls1046mdio_s1;
+		emi1-slot2 = &ls1046mdio_s2;
+		emi1-slot4 = &ls1046mdio_s4;
+
+		sgmii-s1-p1 = &sgmii_phy_s1_p1;
+		sgmii-s1-p2 = &sgmii_phy_s1_p2;
+		sgmii-s1-p3 = &sgmii_phy_s1_p3;
+		sgmii-s1-p4 = &sgmii_phy_s1_p4;
+		sgmii-s4-p1 = &sgmii_phy_s4_p1;
+		qsgmii-s2-p1 = &qsgmii_phy_s2_p1;
+		qsgmii-s2-p2 = &qsgmii_phy_s2_p2;
+		qsgmii-s2-p3 = &qsgmii_phy_s2_p3;
+		qsgmii-s2-p4 = &qsgmii_phy_s2_p4;
 	};
 
 	chosen {
@@ -153,8 +167,9 @@ nand@1,0 {
 	};
 
 	fpga: board-control@2,0 {
-		compatible = "fsl,ls1046aqds-fpga", "fsl,fpga-qixis";
+		compatible = "fsl,ls1046aqds-fpga", "fsl,fpga-qixis", "simple-mfd";
 		reg = <0x2 0x0 0x0000100>;
+		ranges = <0 2 0 0x100>;
 	};
 };
 
@@ -169,7 +184,7 @@ qflash0: flash@0 {
 		compatible = "spansion,m25p80";
 		#address-cells = <1>;
 		#size-cells = <1>;
-		spi-max-frequency = <20000000>;
+		spi-max-frequency = <50000000>;
 		spi-rx-bus-width = <4>;
 		spi-tx-bus-width = <4>;
 		reg = <0>;
@@ -177,3 +192,140 @@ qflash0: flash@0 {
 };
 
 #include "fsl-ls1046-post.dtsi"
+
+&fman0 {
+	ethernet@e0000 {
+		phy-handle = <&qsgmii_phy_s2_p1>;
+		phy-connection-type = "sgmii";
+	};
+
+	ethernet@e2000 {
+		phy-handle = <&sgmii_phy_s4_p1>;
+		phy-connection-type = "sgmii";
+	};
+
+	ethernet@e4000 {
+		phy-handle = <&rgmii_phy1>;
+		phy-connection-type = "rgmii";
+	};
+
+	ethernet@e6000 {
+		phy-handle = <&rgmii_phy2>;
+		phy-connection-type = "rgmii";
+	};
+
+	ethernet@e8000 {
+		phy-handle = <&sgmii_phy_s1_p3>;
+		phy-connection-type = "sgmii";
+	};
+
+	ethernet@ea000 {
+		phy-handle = <&sgmii_phy_s1_p4>;
+		phy-connection-type = "sgmii";
+	};
+
+	ethernet@f0000 { /* DTSEC9/10GEC1 */
+		phy-handle = <&sgmii_phy_s1_p1>;
+		phy-connection-type = "xgmii";
+	};
+
+	ethernet@f2000 { /* DTSEC10/10GEC2 */
+		phy-handle = <&sgmii_phy_s1_p2>;
+		phy-connection-type = "xgmii";
+	};
+};
+
+&fpga {
+	#address-cells = <1>;
+	#size-cells = <1>;
+	mdio-mux-emi1 {
+		compatible = "mdio-mux-mmioreg", "mdio-mux";
+		mdio-parent-bus = <&mdio0>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg = <0x54 1>;    /* BRDCFG4 */
+		mux-mask = <0xe0>; /* EMI1 */
+
+		/* On-board RGMII1 PHY */
+		ls1046mdio0: mdio@0 {
+			reg = <0>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			rgmii_phy1: ethernet-phy@1 { /* MAC3 */
+				reg = <0x1>;
+			};
+		};
+
+		/* On-board RGMII2 PHY */
+		ls1046mdio1: mdio@1 {
+			reg = <0x20>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			rgmii_phy2: ethernet-phy@2 { /* MAC4 */
+				reg = <0x2>;
+			};
+		};
+
+		/* Slot 1 */
+		ls1046mdio_s1: mdio@2 {
+			reg = <0x40>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+
+			sgmii_phy_s1_p1: ethernet-phy@1c {
+				reg = <0x1c>;
+			};
+
+			sgmii_phy_s1_p2: ethernet-phy@1d {
+				reg = <0x1d>;
+			};
+
+			sgmii_phy_s1_p3: ethernet-phy@1e {
+				reg = <0x1e>;
+			};
+
+			sgmii_phy_s1_p4: ethernet-phy@1f {
+				reg = <0x1f>;
+			};
+		};
+
+		/* Slot 2 */
+		ls1046mdio_s2: mdio@3 {
+			reg = <0x60>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+
+			qsgmii_phy_s2_p1: ethernet-phy@8 {
+				reg = <0x8>;
+			};
+
+			qsgmii_phy_s2_p2: ethernet-phy@9 {
+				reg = <0x9>;
+			};
+
+			qsgmii_phy_s2_p3: ethernet-phy@a {
+				reg = <0xa>;
+			};
+
+			qsgmii_phy_s2_p4: ethernet-phy@b {
+				reg = <0xb>;
+			};
+		};
+
+		/* Slot 4 */
+		ls1046mdio_s4: mdio@5 {
+			reg = <0x80>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+
+			sgmii_phy_s4_p1: ethernet-phy@1c {
+				reg = <0x1c>;
+			};
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/freescale/fsl-ls1046a-rdb-sdk.dts b/arch/arm64/boot/dts/freescale/fsl-ls1046a-rdb-sdk.dts
new file mode 100644
index 000000000..d9ae081b4
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/fsl-ls1046a-rdb-sdk.dts
@@ -0,0 +1,273 @@
+/*
+ * Device Tree Include file for Freescale Layerscape-1046A family SoC.
+ *
+ * Copyright 2014-2015 Freescale Semiconductor, Inc.
+ *
+ * Mingkai Hu <Mingkai.hu@freescale.com>
+ *
+ * This file is dual-licensed: you can use it either under the terms
+ * of the GPLv2 or the X11 license, at your option. Note that this dual
+ * licensing only applies to this file, and not this project as a
+ * whole.
+ *
+ *  a) This library is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This library is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ * Or, alternatively,
+ *
+ *  b) Permission is hereby granted, free of charge, to any person
+ *     obtaining a copy of this software and associated documentation
+ *     files (the "Software"), to deal in the Software without
+ *     restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or
+ *     sell copies of the Software, and to permit persons to whom the
+ *     Software is furnished to do so, subject to the following
+ *     conditions:
+ *
+ *     The above copyright notice and this permission notice shall be
+ *     included in all copies or substantial portions of the Software.
+ *
+ *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ *     OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include "fsl-ls1046a-rdb.dts"
+#include "qoriq-qman-portals-sdk.dtsi"
+#include "qoriq-bman-portals-sdk.dtsi"
+
+&bman_fbpr {
+	compatible = "fsl,bman-fbpr";
+	alloc-ranges = <0 0 0x10000 0>;
+};
+&qman_fqd {
+	compatible = "fsl,qman-fqd";
+	alloc-ranges = <0 0 0x10000 0>;
+};
+&qman_pfdr {
+	compatible = "fsl,qman-pfdr";
+	alloc-ranges = <0 0 0x10000 0>;
+};
+
+&soc {
+/delete-property/ dma-coherent;
+
+#include "qoriq-dpaa-eth.dtsi"
+#include "qoriq-fman3-0-6oh.dtsi"
+
+pcie@3400000 {
+	/delete-property/ iommu-map;
+};
+
+pcie@3500000 {
+	/delete-property/ iommu-map;
+};
+
+pcie@3600000 {
+	/delete-property/ iommu-map;
+};
+
+/delete-node/ iommu@9000000;
+};
+
+&fsldpaa {
+	ethernet@0 {
+		status = "disabled";
+	};
+	ethernet@1 {
+		status = "disabled";
+	};
+	ethernet@9 {
+		compatible = "fsl,dpa-ethernet";
+		fsl,fman-mac = <&enet7>;
+		dma-coherent;
+	};
+};
+
+&fman0 {
+	compatible = "fsl,fman", "simple-bus";
+};
+
+&clockgen {
+	dma-coherent;
+};
+
+&scfg {
+	dma-coherent;
+};
+
+&crypto {
+	dma-coherent;
+};
+
+&dcfg {
+	dma-coherent;
+};
+
+&ifc {
+	dma-coherent;
+};
+
+&qspi {
+	dma-coherent;
+};
+
+&esdhc {
+	dma-coherent;
+};
+
+&ddr {
+	dma-coherent;
+};
+
+&tmu {
+	dma-coherent;
+};
+
+&qman {
+	dma-coherent;
+};
+
+&bman {
+	dma-coherent;
+};
+
+&bportals {
+	dma-coherent;
+};
+
+&qportals {
+	dma-coherent;
+};
+
+&dspi {
+	dma-coherent;
+};
+
+&i2c0 {
+	dma-coherent;
+};
+
+&i2c1 {
+	dma-coherent;
+};
+
+&i2c2 {
+	dma-coherent;
+};
+
+&i2c3 {
+	dma-coherent;
+};
+
+&duart0 {
+	dma-coherent;
+};
+
+&duart1 {
+	dma-coherent;
+};
+
+&duart2 {
+	dma-coherent;
+};
+
+&duart3 {
+	dma-coherent;
+};
+
+&gpio0 {
+	dma-coherent;
+};
+
+&gpio1 {
+	dma-coherent;
+};
+
+&gpio2 {
+	dma-coherent;
+};
+
+&gpio3 {
+	dma-coherent;
+};
+
+&lpuart0 {
+	dma-coherent;
+};
+
+&lpuart1 {
+	dma-coherent;
+};
+
+&lpuart2 {
+	dma-coherent;
+};
+
+&lpuart3 {
+	dma-coherent;
+};
+
+&lpuart4 {
+	dma-coherent;
+};
+
+&lpuart5 {
+	dma-coherent;
+};
+
+&ftm_alarm0 {
+	dma-coherent;
+};
+
+&wdog0 {
+	dma-coherent;
+};
+
+&edma0 {
+	dma-coherent;
+};
+
+&sata {
+	dma-coherent;
+};
+
+&qdma {
+	dma-coherent;
+};
+
+&msi1 {
+	dma-coherent;
+};
+
+&msi2 {
+	dma-coherent;
+};
+
+&msi3 {
+	dma-coherent;
+};
+
+&fman0 {
+	dma-coherent;
+};
+
+&ptp_timer0 {
+	dma-coherent;
+};
+
+&fsldpaa {
+	dma-coherent;
+};
diff --git a/arch/arm64/boot/dts/freescale/fsl-ls1046a-rdb-shared-mac9-only.dts b/arch/arm64/boot/dts/freescale/fsl-ls1046a-rdb-shared-mac9-only.dts
new file mode 100644
index 000000000..7f29a2b84
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/fsl-ls1046a-rdb-shared-mac9-only.dts
@@ -0,0 +1,108 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright 2019-2021 NXP
+ * Device Tree file to support Shared Mac interface for 1046A family SoC.
+ * This file is for MAC9 as shared and rest of the interfaces are assigned to Linux Kernel only
+ */
+
+#include "fsl-ls1046a-rdb-sdk.dts"
+
+&bportals {
+	bman-bpids@0 {
+		compatible = "fsl,bpid-range";
+		fsl,bpid-range = <16 48>;
+	};
+};
+
+&soc {
+	chosen {
+		name = "chosen";
+		dpaa-extended-args {
+			fman0-extd-args {
+
+				cell-index = <0>;
+				compatible = "fsl,fman-extended-args";
+				dma-aid-mode = "port";
+
+				fman0_rxt0-extd-args {
+					cell-index = <0>;
+					compatible = "fsl,fman-port-10g-rx-extended-args";
+					/* Define Virtual storage profile */
+					/* <number of profiles, default profile id> */
+					vsp-window = <2 0>;
+				};
+			};
+		};
+	};
+
+	bp7: buffer-pool@7 {
+		compatible = "fsl,ls1046a-bpool", "fsl,bpool";
+		fsl,bpid = <7>;
+		fsl,bpool-ethernet-cfg = <0 16 0 1728 0 0xdeadbeef>;
+		fsl,bpool-thresholds = <0x400 0xc00 0x0 0x0>;
+		dma-coherent;
+	};
+
+	bp8: buffer-pool@8 {
+		compatible = "fsl,ls1046a-bpool", "fsl,bpool";
+		fsl,bpid = <8>;
+		fsl,bpool-ethernet-cfg = <0 16 0 1728 0 0xabbaf00d>;
+		fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
+		dma-coherent;
+	};
+
+	bp9: buffer-pool@9 {
+		compatible = "fsl,ls1046a-bpool", "fsl,bpool";
+		fsl,bpid = <9>;
+		fsl,bpool-ethernet-cfg = <0 16 0 1728 0 0xfeedabba>;
+		fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
+		dma-coherent;
+	};
+
+	fsl,dpaa {
+		compatible = "fsl,ls1046a", "fsl,dpaa", "simple-bus";
+		dma-coherent;
+
+		ethernet@8 {
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x5c 1 0x5d 1 0x8a 1>;
+			fsl,qman-frame-queues-tx = <0x7c 1 0x7d 1 0x84 1>;
+		};
+
+
+		dpa-fman0-oh@2 {
+			compatible = "fsl,dpa-oh";
+			/* Define frame queues for the OH port*/
+			/* <OH Rx error, OH Rx default> */
+			fsl,qman-frame-queues-oh = <0x60 1 0x61 1>;
+			fsl,fman-oh-port = <&fman0_oh2>;
+		};
+	};
+};
+/ {
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		/* For legacy usdpaa based use-cases, update the size and
+		   alignment parameters. e.g. to allocate 256 MB memory:
+		   size = <0 0x10000000>;
+		   alignment = <0 0x10000000>;
+		*/
+		usdpaa_mem: usdpaa_mem {
+			compatible = "fsl,usdpaa-mem";
+			alloc-ranges = <0 0 0x10000 0>;
+			size = <0 0x1000>;
+			alignment = <0 0x1000>;
+		};
+	};
+};
+
+&fman0 {
+	fman0_oh2: port@83000 {
+		cell-index = <1>;
+		compatible = "fsl,fman-port-oh";
+		reg = <0x83000 0x1000>;
+	};
+};
diff --git a/arch/arm64/boot/dts/freescale/fsl-ls1046a-rdb-usdpaa-shared-mac10.dts b/arch/arm64/boot/dts/freescale/fsl-ls1046a-rdb-usdpaa-shared-mac10.dts
new file mode 100644
index 000000000..bfb48d038
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/fsl-ls1046a-rdb-usdpaa-shared-mac10.dts
@@ -0,0 +1,142 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright 2019-2021 NXP
+ * Device Tree file to support Shared Mac interface for 1046A family SoC.
+ * This file is for MAC10 as shared and rest of the interfaces are for Userspace-DPDK
+ */
+
+#include "fsl-ls1046a-rdb-sdk.dts"
+
+&bportals {
+	bman-bpids@0 {
+		compatible = "fsl,bpid-range";
+		fsl,bpid-range = <16 48>;
+	};
+};
+
+&soc {
+	chosen {
+		name = "chosen";
+		dpaa-extended-args {
+			fman0-extd-args {
+
+				cell-index = <0>;
+				compatible = "fsl,fman-extended-args";
+				dma-aid-mode = "port";
+
+				fman0_rxt1-extd-args {
+					cell-index = <1>;
+					compatible = "fsl,fman-port-10g-rx-extended-args";
+					/* Define Virtual storage profile */
+					/* <number of profiles, default profile id> */
+					vsp-window = <2 0>;
+				};
+			};
+		};
+	};
+
+	bp7: buffer-pool@7 {
+		compatible = "fsl,ls1046a-bpool", "fsl,bpool";
+		fsl,bpid = <7>;
+		fsl,bpool-ethernet-cfg = <0 16 0 1728 0 0xdeadbeef>;
+		fsl,bpool-thresholds = <0x400 0xc00 0x0 0x0>;
+		dma-coherent;
+	};
+
+	bp8: buffer-pool@8 {
+		compatible = "fsl,ls1046a-bpool", "fsl,bpool";
+		fsl,bpid = <8>;
+		fsl,bpool-ethernet-cfg = <0 16 0 1728 0 0xabbaf00d>;
+		fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
+		dma-coherent;
+	};
+
+	bp9: buffer-pool@9 {
+		compatible = "fsl,ls1046a-bpool", "fsl,bpool";
+		fsl,bpid = <9>;
+		fsl,bpool-ethernet-cfg = <0 16 0 1728 0 0xfeedabba>;
+		fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
+		dma-coherent;
+	};
+
+	fsl,dpaa {
+		compatible = "fsl,ls1046a", "fsl,dpaa", "simple-bus";
+		dma-coherent;
+
+		ethernet@2 {
+			compatible = "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x54 1 0x55 1>;
+			fsl,qman-frame-queues-tx = <0x74 1 0x75 1>;
+		};
+
+		ethernet@3 {
+			compatible = "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x56 1 0x57 1>;
+			fsl,qman-frame-queues-tx = <0x76 1 0x77 1>;
+		};
+
+		ethernet@4 {
+			compatible = "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x58 1 0x59 1>;
+			fsl,qman-frame-queues-tx = <0x78 1 0x79 1>;
+		};
+
+		ethernet@5 {
+			compatible = "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x5a 1 0x5b 1>;
+			fsl,qman-frame-queues-tx = <0x7a 1 0x7b 1>;
+		};
+
+		ethernet@8 {
+			compatible = "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x5c 1 0x5d 1>;
+			fsl,qman-frame-queues-tx = <0x7c 1 0x7d 1>;
+		};
+
+		ethernet@9 {
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x5e 1 0x5f 1 0x8b 1>;
+			fsl,qman-frame-queues-tx = <0x7e 1 0x7f 1 0x85 1>;
+		};
+
+		dpa-fman0-oh@2 {
+			compatible = "fsl,dpa-oh";
+			/* Define frame queues for the OH port*/
+			/* <OH Rx error, OH Rx default> */
+			fsl,qman-frame-queues-oh = <0x60 1 0x61 1>;
+			fsl,fman-oh-port = <&fman0_oh2>;
+		};
+	};
+};
+/ {
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		/* For legacy usdpaa based use-cases, update the size and
+		   alignment parameters. e.g. to allocate 256 MB memory:
+		   size = <0 0x10000000>;
+		   alignment = <0 0x10000000>;
+		*/
+		usdpaa_mem: usdpaa_mem {
+			compatible = "fsl,usdpaa-mem";
+			alloc-ranges = <0 0 0x10000 0>;
+			size = <0 0x1000>;
+			alignment = <0 0x1000>;
+		};
+	};
+};
+
+&fman0 {
+	fman0_oh2: port@83000 {
+		cell-index = <1>;
+		compatible = "fsl,fman-port-oh";
+		reg = <0x83000 0x1000>;
+	};
+};
diff --git a/arch/arm64/boot/dts/freescale/fsl-ls1046a-rdb-usdpaa-shared.dts b/arch/arm64/boot/dts/freescale/fsl-ls1046a-rdb-usdpaa-shared.dts
new file mode 100644
index 000000000..be9662553
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/fsl-ls1046a-rdb-usdpaa-shared.dts
@@ -0,0 +1,189 @@
+/*
+ * Device Tree file to support Shared Mac interface for 1046A family SoC.
+ *
+ * Copyright 2019-2021 NXP
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include "fsl-ls1046a-rdb-sdk.dts"
+
+&bportals {
+	bman-bpids@0 {
+		compatible = "fsl,bpid-range";
+		fsl,bpid-range = <16 48>;
+	};
+};
+
+&soc {
+	bp7: buffer-pool@7 {
+		compatible = "fsl,ls1046a-bpool", "fsl,bpool";
+		fsl,bpid = <7>;
+		fsl,bpool-ethernet-cfg = <0 16 0 1728 0 0xdeadbeef>;
+		fsl,bpool-thresholds = <0x400 0xc00 0x0 0x0>;
+		dma-coherent;
+	};
+
+	bp8: buffer-pool@8 {
+		compatible = "fsl,ls1046a-bpool", "fsl,bpool";
+		fsl,bpid = <8>;
+		fsl,bpool-ethernet-cfg = <0 16 0 1728 0 0xabbaf00d>;
+		fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
+		dma-coherent;
+	};
+
+	bp9: buffer-pool@9 {
+		compatible = "fsl,ls1046a-bpool", "fsl,bpool";
+		fsl,bpid = <9>;
+		fsl,bpool-ethernet-cfg = <0 16 0 1728 0 0xfeedabba>;
+		fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
+		dma-coherent;
+	};
+
+	fsl,dpaa {
+		compatible = "fsl,ls1046a", "fsl,dpaa", "simple-bus";
+		dma-coherent;
+
+		ethernet@2 {
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x54 1 0x55 1 0x86 1>;
+			fsl,qman-frame-queues-tx = <0x74 1 0x75 1 0x80 1>;
+		};
+
+		ethernet@3 {
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x56 1 0x57 1 0x87 1>;
+			fsl,qman-frame-queues-tx = <0x76 1 0x77 1 0x81 1>;
+		};
+
+		ethernet@4 {
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x58 1 0x59 1 0x88 1>;
+			fsl,qman-frame-queues-tx = <0x78 1 0x79 1 0x82 1>;
+		};
+
+		ethernet@5 {
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x5a 1 0x5b 1 0x89 1>;
+			fsl,qman-frame-queues-tx = <0x7a 1 0x7b 1 0x83 1>;
+		};
+
+		ethernet@8 {
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x5c 1 0x5d 1 0x8a 1>;
+			fsl,qman-frame-queues-tx = <0x7c 1 0x7d 1 0x84 1>;
+		};
+
+		ethernet@9 {
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x5e 1 0x5f 1 0x8b 1>;
+			fsl,qman-frame-queues-tx = <0x7e 1 0x7f 1 0x85 1>;
+		};
+
+		dpa-fman0-oh@2 {
+			compatible = "fsl,dpa-oh";
+			/* Define frame queues for the OH port*/
+			/* <OH Rx error, OH Rx default> */
+			fsl,qman-frame-queues-oh = <0x60 1 0x61 1>;
+			fsl,fman-oh-port = <&fman0_oh2>;
+		};
+	};
+};
+/ {
+	chosen {
+		name = "chosen";
+		dpaa-extended-args {
+			fman0-extd-args {
+
+				cell-index = <0>;
+				compatible = "fsl,fman-extended-args";
+				dma-aid-mode = "port";
+
+				fman0_rx2-extd-args {
+					cell-index = <2>;
+					compatible = "fsl,fman-port-1g-rx-extended-args";
+					/* Define Virtual storage profile */
+					/* <number of profiles, default profile id> */
+					vsp-window = <2 0>;
+				};
+				fman0_rx3-extd-args {
+					cell-index = <3>;
+					compatible = "fsl,fman-port-1g-rx-extended-args";
+					/* Define Virtual storage profile */
+					/* <number of profiles, default profile id> */
+					vsp-window = <2 0>;
+				};
+				fman0_rx4-extd-args {
+					cell-index = <4>;
+					compatible = "fsl,fman-port-1g-rx-extended-args";
+					/* Define Virtual storage profile */
+					/* <number of profiles, default profile id> */
+					vsp-window = <2 0>;
+				};
+				fman0_rx5-extd-args {
+					cell-index = <5>;
+					compatible = "fsl,fman-port-1g-rx-extended-args";
+					/* Define Virtual storage profile */
+					/* <number of profiles, default profile id> */
+					vsp-window = <2 0>;
+				};
+				fman0_rx6-extd-args {
+					cell-index = <6>;
+					compatible = "fsl,fman-port-1g-rx-extended-args";
+					/* Define Virtual storage profile */
+					/* <number of profiles, default profile id> */
+					vsp-window = <2 0>;
+				};
+				fman0_rx7-extd-args {
+					cell-index = <7>;
+					compatible = "fsl,fman-port-1g-rx-extended-args";
+					/* Define Virtual storage profile */
+					/* <number of profiles, default profile id> */
+					vsp-window = <2 0>;
+				};
+				fman0_rxt0-extd-args {
+					cell-index = <0>;
+					compatible = "fsl,fman-port-10g-rx-extended-args";
+					/* Define Virtual storage profile */
+					/* <number of profiles, default profile id> */
+					vsp-window = <2 0>;
+				};
+				fman0_rxt1-extd-args {
+					cell-index = <1>;
+					compatible = "fsl,fman-port-10g-rx-extended-args";
+					/* Define Virtual storage profile */
+					/* <number of profiles, default profile id> */
+					vsp-window = <2 0>;
+				};
+			};
+		};
+	};
+
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		/* For legacy usdpaa based use-cases, update the size and
+		   alignment parameters. e.g. to allocate 256 MB memory:
+		   size = <0 0x10000000>;
+		   alignment = <0 0x10000000>;
+		*/
+		usdpaa_mem: usdpaa_mem {
+			compatible = "fsl,usdpaa-mem";
+			alloc-ranges = <0 0 0x10000 0>;
+			size = <0 0x1000>;
+			alignment = <0 0x1000>;
+		};
+	};
+};
+
+&fman0 {
+	fman0_oh2: port@83000 {
+		cell-index = <1>;
+		compatible = "fsl,fman-port-oh";
+		reg = <0x83000 0x1000>;
+	};
+};
diff --git a/arch/arm64/boot/dts/freescale/fsl-ls1046a-rdb-usdpaa.dts b/arch/arm64/boot/dts/freescale/fsl-ls1046a-rdb-usdpaa.dts
new file mode 100644
index 000000000..343c9d81a
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/fsl-ls1046a-rdb-usdpaa.dts
@@ -0,0 +1,133 @@
+/*
+ * Device Tree Include file for Freescale Layerscape-1046A family SoC.
+ *
+ * Copyright (C) 2016, Freescale Semiconductor
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include "fsl-ls1046a-rdb-sdk.dts"
+
+&soc {
+	bp7: buffer-pool@7 {
+		compatible = "fsl,ls1046a-bpool", "fsl,bpool";
+		fsl,bpid = <7>;
+		fsl,bpool-ethernet-cfg = <0 0 0 192 0 0xdeadbeef>;
+		fsl,bpool-thresholds = <0x400 0xc00 0x0 0x0>;
+		dma-coherent;
+	};
+
+	bp8: buffer-pool@8 {
+		compatible = "fsl,ls1046a-bpool", "fsl,bpool";
+		fsl,bpid = <8>;
+		fsl,bpool-ethernet-cfg = <0 0 0 576 0 0xabbaf00d>;
+		fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
+		dma-coherent;
+	};
+
+	bp9: buffer-pool@9 {
+		compatible = "fsl,ls1046a-bpool", "fsl,bpool";
+		fsl,bpid = <9>;
+		fsl,bpool-ethernet-cfg = <0 0 0 2048 0 0xfeedabba>;
+		fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
+		dma-coherent;
+	};
+
+	fsl,dpaa {
+		compatible = "fsl,ls1046a", "fsl,dpaa", "simple-bus";
+		dma-coherent;
+
+		ethernet@2 {
+			compatible = "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x54 1 0x55 1>;
+			fsl,qman-frame-queues-tx = <0x74 1 0x75 1>;
+		};
+
+		ethernet@3 {
+			compatible = "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x56 1 0x57 1>;
+			fsl,qman-frame-queues-tx = <0x76 1 0x77 1>;
+		};
+
+		ethernet@4 {
+			compatible = "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x58 1 0x59 1>;
+			fsl,qman-frame-queues-tx = <0x78 1 0x79 1>;
+		};
+
+		ethernet@5 {
+			compatible = "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x5a 1 0x5b 1>;
+			fsl,qman-frame-queues-tx = <0x7a 1 0x7b 1>;
+		};
+
+		ethernet@8 {
+			compatible = "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x5c 1 0x5d 1>;
+			fsl,qman-frame-queues-tx = <0x7c 1 0x7d 1>;
+		};
+
+		ethernet@9 {
+			compatible = "fsl,dpa-ethernet-init";
+			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
+			fsl,qman-frame-queues-rx = <0x5e 1 0x5f 1>;
+			fsl,qman-frame-queues-tx = <0x7e 1 0x7f 1>;
+		};
+
+		dpa-fman0-oh@2 {
+			compatible = "fsl,dpa-oh";
+			/* Define frame queues for the OH port*/
+			/* <OH Rx error, OH Rx default> */
+			fsl,qman-frame-queues-oh = <0x60 1 0x61 1>;
+			fsl,fman-oh-port = <&fman0_oh2>;
+		};
+	};
+
+	pcie@3400000 {
+	       /delete-property/ iommu-map;
+	};
+
+	pcie@3500000 {
+	       /delete-property/ iommu-map;
+	};
+
+	pcie@3600000 {
+	       /delete-property/ iommu-map;
+	};
+
+	/delete-node/ iommu@9000000;
+};
+/ {
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		/* For legacy usdpaa based use-cases, update the size and
+		   alignment parameters. e.g. to allocate 256 MB memory:
+		   size = <0 0x10000000>;
+		   alignment = <0 0x10000000>;
+		*/
+		usdpaa_mem: usdpaa_mem {
+			compatible = "fsl,usdpaa-mem";
+			alloc-ranges = <0 0 0x10000 0>;
+			size = <0 0x1000>;
+			alignment = <0 0x1000>;
+		};
+	};
+};
+
+&fman0 {
+	fman0_oh2: port@83000 {
+		cell-index = <1>;
+		compatible = "fsl,fman-port-oh";
+		reg = <0x83000 0x1000>;
+	};
+};
diff --git a/arch/arm64/boot/dts/freescale/fsl-ls1046a-rdb.dts b/arch/arm64/boot/dts/freescale/fsl-ls1046a-rdb.dts
index 7025aad8a..4361f296f 100644
--- a/arch/arm64/boot/dts/freescale/fsl-ls1046a-rdb.dts
+++ b/arch/arm64/boot/dts/freescale/fsl-ls1046a-rdb.dts
@@ -104,7 +104,7 @@ s25fs512s0: flash@0 {
 		#address-cells = <1>;
 		#size-cells = <1>;
 		spi-max-frequency = <50000000>;
-		spi-rx-bus-width = <4>;
+		spi-rx-bus-width = <1>;
 		spi-tx-bus-width = <1>;
 		reg = <0>;
 	};
@@ -114,7 +114,7 @@ s25fs512s1: flash@1 {
 		#address-cells = <1>;
 		#size-cells = <1>;
 		spi-max-frequency = <50000000>;
-		spi-rx-bus-width = <4>;
+		spi-rx-bus-width = <1>;
 		spi-tx-bus-width = <1>;
 		reg = <1>;
 	};
diff --git a/arch/arm64/boot/dts/freescale/fsl-ls1046a.dtsi b/arch/arm64/boot/dts/freescale/fsl-ls1046a.dtsi
index 4e7bd04d9..b29ff0069 100644
--- a/arch/arm64/boot/dts/freescale/fsl-ls1046a.dtsi
+++ b/arch/arm64/boot/dts/freescale/fsl-ls1046a.dtsi
@@ -272,6 +272,8 @@ soc: soc {
 		#address-cells = <2>;
 		#size-cells = <2>;
 		ranges;
+		dma-ranges = <0x0 0x0 0x0 0x0 0x10000 0x00000000>;
+		dma-coherent;
 
 		ddr: memory-controller@1080000 {
 			compatible = "fsl,qoriq-memory-controller";
@@ -280,8 +282,8 @@ ddr: memory-controller@1080000 {
 			big-endian;
 		};
 
-		ifc: ifc@1530000 {
-			compatible = "fsl,ifc", "simple-bus";
+		ifc: memory-controller@1530000 {
+			compatible = "fsl,ifc";
 			reg = <0x0 0x1530000 0x0 0x10000>;
 			interrupts = <GIC_SPI 43 IRQ_TYPE_LEVEL_HIGH>;
 			status = "disabled";
@@ -314,6 +316,49 @@ esdhc: esdhc@1560000 {
 			bus-width = <4>;
 		};
 
+		smmu: iommu@9000000 {
+			compatible = "arm,mmu-500";
+			reg = <0 0x9000000 0 0x400000>;
+			dma-coherent;
+			stream-match-mask = <0x7f00>;
+			#global-interrupts = <2>;
+			#iommu-cells = <1>;
+			interrupts = <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 143 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
 		scfg: scfg@1570000 {
 			compatible = "fsl,ls1046a-scfg", "syscon";
 			reg = <0x0 0x1570000 0x0 0x10000>;
@@ -492,16 +537,17 @@ dspi: spi@2100000 {
 		};
 
 		i2c0: i2c@2180000 {
-			compatible = "fsl,vf610-i2c";
+			compatible = "fsl,vf610-i2c", "fsl,ls1046a-vf610-i2c";
 			#address-cells = <1>;
 			#size-cells = <0>;
 			reg = <0x0 0x2180000 0x0 0x10000>;
 			interrupts = <GIC_SPI 56 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&clockgen QORIQ_CLK_PLATFORM_PLL
 					    QORIQ_CLK_PLL_DIV(2)>;
-			dmas = <&edma0 1 38>,
-			       <&edma0 1 39>;
-			dma-names = "rx", "tx";
+			dmas = <&edma0 1 39>,
+			       <&edma0 1 38>;
+			dma-names = "tx", "rx";
+			scl-gpios = <&gpio3 12 0>;
 			status = "disabled";
 		};
 
@@ -528,13 +574,14 @@ i2c2: i2c@21a0000 {
 		};
 
 		i2c3: i2c@21b0000 {
-			compatible = "fsl,vf610-i2c";
+			compatible = "fsl,vf610-i2c", "fsl,ls1046a-vf610-i2c";
 			#address-cells = <1>;
 			#size-cells = <0>;
 			reg = <0x0 0x21b0000 0x0 0x10000>;
 			interrupts = <GIC_SPI 59 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&clockgen QORIQ_CLK_PLATFORM_PLL
 					    QORIQ_CLK_PLL_DIV(2)>;
+			scl-gpios = <&gpio3 12 0>;
 			status = "disabled";
 		};
 
@@ -701,44 +748,61 @@ QORIQ_CLK_PLL_DIV(2)>,
 					    QORIQ_CLK_PLL_DIV(2)>;
 		};
 
-		usb0: usb@2f00000 {
-			compatible = "snps,dwc3";
-			reg = <0x0 0x2f00000 0x0 0x10000>;
-			interrupts = <GIC_SPI 60 IRQ_TYPE_LEVEL_HIGH>;
-			dr_mode = "host";
-			snps,quirk-frame-length-adjustment = <0x20>;
-			snps,dis_rxdet_inp3_quirk;
-			snps,incr-burst-type-adjustment = <1>, <4>, <8>, <16>;
-		};
-
-		usb1: usb@3000000 {
-			compatible = "snps,dwc3";
-			reg = <0x0 0x3000000 0x0 0x10000>;
-			interrupts = <GIC_SPI 61 IRQ_TYPE_LEVEL_HIGH>;
-			dr_mode = "host";
-			snps,quirk-frame-length-adjustment = <0x20>;
-			snps,dis_rxdet_inp3_quirk;
-			snps,incr-burst-type-adjustment = <1>, <4>, <8>, <16>;
-		};
-
-		usb2: usb@3100000 {
-			compatible = "snps,dwc3";
-			reg = <0x0 0x3100000 0x0 0x10000>;
-			interrupts = <GIC_SPI 63 IRQ_TYPE_LEVEL_HIGH>;
-			dr_mode = "host";
-			snps,quirk-frame-length-adjustment = <0x20>;
-			snps,dis_rxdet_inp3_quirk;
-			snps,incr-burst-type-adjustment = <1>, <4>, <8>, <16>;
-		};
-
-		sata: sata@3200000 {
-			compatible = "fsl,ls1046a-ahci";
-			reg = <0x0 0x3200000 0x0 0x10000>,
-				<0x0 0x20140520 0x0 0x4>;
-			reg-names = "ahci", "sata-ecc";
-			interrupts = <GIC_SPI 69 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&clockgen QORIQ_CLK_PLATFORM_PLL
-					    QORIQ_CLK_PLL_DIV(2)>;
+		aux_bus: aux_bus {
+			#address-cells = <2>;
+			#size-cells = <2>;
+			compatible = "simple-bus";
+			ranges;
+			dma-ranges = <0x0 0x0 0x0 0x0 0x100 0x00000000>;
+
+			usb0: usb@2f00000 {
+				compatible = "fsl,ls1046a-dwc3", "snps,dwc3";
+				reg = <0x0 0x2f00000 0x0 0x10000>;
+				interrupts = <GIC_SPI 60 IRQ_TYPE_LEVEL_HIGH>;
+				dr_mode = "host";
+				snps,quirk-frame-length-adjustment = <0x20>;
+				snps,dis_rxdet_inp3_quirk;
+				snps,incr-burst-type-adjustment = <1>, <4>, <8>, <16>;
+				usb3-lpm-capable;
+				snps,host-vbus-glitches;
+				dma-coherent;
+			};
+
+			usb1: usb@3000000 {
+				compatible = "fsl,ls1046a-dwc3", "snps,dwc3";
+				reg = <0x0 0x3000000 0x0 0x10000>;
+				interrupts = <GIC_SPI 61 IRQ_TYPE_LEVEL_HIGH>;
+				dr_mode = "host";
+				snps,quirk-frame-length-adjustment = <0x20>;
+				snps,dis_rxdet_inp3_quirk;
+				snps,incr-burst-type-adjustment = <1>, <4>, <8>, <16>;
+				usb3-lpm-capable;
+				snps,host-vbus-glitches;
+				dma-coherent;
+			};
+
+			usb2: usb@3100000 {
+				compatible = "fsl,ls1046a-dwc3", "snps,dwc3";
+				reg = <0x0 0x3100000 0x0 0x10000>;
+				interrupts = <GIC_SPI 63 IRQ_TYPE_LEVEL_HIGH>;
+				dr_mode = "host";
+				snps,quirk-frame-length-adjustment = <0x20>;
+				snps,dis_rxdet_inp3_quirk;
+				snps,incr-burst-type-adjustment = <1>, <4>, <8>, <16>;
+				usb3-lpm-capable;
+				snps,host-vbus-glitches;
+				dma-coherent;
+			};
+
+			sata: sata@3200000 {
+				compatible = "fsl,ls1046a-ahci";
+				reg = <0x0 0x3200000 0x0 0x10000>,
+					<0x0 0x20140520 0x0 0x4>;
+				reg-names = "ahci", "sata-ecc";
+				interrupts = <GIC_SPI 69 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&clockgen QORIQ_CLK_PLATFORM_PLL
+						    QORIQ_CLK_PLL_DIV(2)>;
+			};
 		};
 
 		msi1: msi-controller@1580000 {
@@ -783,6 +847,7 @@ pcie1: pcie@3400000 {
 			#size-cells = <2>;
 			device_type = "pci";
 			dma-coherent;
+			iommu-map = <0 &smmu 0 1>;	/* update by bootloader */
 			num-viewport = <8>;
 			bus-range = <0x0 0xff>;
 			ranges = <0x81000000 0x0 0x00000000 0x40 0x00010000 0x0 0x00010000   /* downstream I/O */
@@ -794,6 +859,7 @@ pcie1: pcie@3400000 {
 					<0000 0 0 2 &gic GIC_SPI 110 IRQ_TYPE_LEVEL_HIGH>,
 					<0000 0 0 3 &gic GIC_SPI 110 IRQ_TYPE_LEVEL_HIGH>,
 					<0000 0 0 4 &gic GIC_SPI 110 IRQ_TYPE_LEVEL_HIGH>;
+			big-endian;
 			status = "disabled";
 		};
 
@@ -802,8 +868,11 @@ pcie_ep1: pcie_ep@3400000 {
 			reg = <0x00 0x03400000 0x0 0x00100000>,
 			      <0x40 0x00000000 0x8 0x00000000>;
 			reg-names = "regs", "addr_space";
+			interrupts = <GIC_SPI 117 IRQ_TYPE_LEVEL_HIGH>; /* PME interrupt */
+			interrupt-names = "pme";
 			num-ib-windows = <6>;
 			num-ob-windows = <8>;
+			big-endian;
 			status = "disabled";
 		};
 
@@ -819,6 +888,7 @@ pcie2: pcie@3500000 {
 			#size-cells = <2>;
 			device_type = "pci";
 			dma-coherent;
+			iommu-map = <0 &smmu 0 1>;	/* update by bootloader */
 			num-viewport = <8>;
 			bus-range = <0x0 0xff>;
 			ranges = <0x81000000 0x0 0x00000000 0x48 0x00010000 0x0 0x00010000   /* downstream I/O */
@@ -830,6 +900,7 @@ pcie2: pcie@3500000 {
 					<0000 0 0 2 &gic GIC_SPI 120 IRQ_TYPE_LEVEL_HIGH>,
 					<0000 0 0 3 &gic GIC_SPI 120 IRQ_TYPE_LEVEL_HIGH>,
 					<0000 0 0 4 &gic GIC_SPI 120 IRQ_TYPE_LEVEL_HIGH>;
+			big-endian;
 			status = "disabled";
 		};
 
@@ -838,8 +909,11 @@ pcie_ep2: pcie_ep@3500000 {
 			reg = <0x00 0x03500000 0x0 0x00100000>,
 			      <0x48 0x00000000 0x8 0x00000000>;
 			reg-names = "regs", "addr_space";
+			interrupts = <GIC_SPI 127 IRQ_TYPE_LEVEL_HIGH>; /* PME interrupt */
+			interrupt-names = "pme";
 			num-ib-windows = <6>;
 			num-ob-windows = <8>;
+			big-endian;
 			status = "disabled";
 		};
 
@@ -855,6 +929,7 @@ pcie3: pcie@3600000 {
 			#size-cells = <2>;
 			device_type = "pci";
 			dma-coherent;
+			iommu-map = <0 &smmu 0 1>;	/* update by bootloader */
 			num-viewport = <8>;
 			bus-range = <0x0 0xff>;
 			ranges = <0x81000000 0x0 0x00000000 0x50 0x00010000 0x0 0x00010000   /* downstream I/O */
@@ -866,6 +941,7 @@ pcie3: pcie@3600000 {
 					<0000 0 0 2 &gic GIC_SPI 154 IRQ_TYPE_LEVEL_HIGH>,
 					<0000 0 0 3 &gic GIC_SPI 154 IRQ_TYPE_LEVEL_HIGH>,
 					<0000 0 0 4 &gic GIC_SPI 154 IRQ_TYPE_LEVEL_HIGH>;
+			big-endian;
 			status = "disabled";
 		};
 
@@ -874,8 +950,11 @@ pcie_ep3: pcie_ep@3600000 {
 			reg = <0x00 0x03600000 0x0 0x00100000>,
 			      <0x50 0x00000000 0x8 0x00000000>;
 			reg-names = "regs", "addr_space";
+			interrupts = <GIC_SPI 161 IRQ_TYPE_LEVEL_HIGH>; /* PME interrupt */
+			interrupt-names = "pme";
 			num-ib-windows = <6>;
 			num-ob-windows = <8>;
+			big-endian;
 			status = "disabled";
 		};
 
diff --git a/arch/arm64/boot/dts/freescale/fsl-ls1088a-qds.dts b/arch/arm64/boot/dts/freescale/fsl-ls1088a-qds.dts
index 41d8b15f2..881f1eed8 100644
--- a/arch/arm64/boot/dts/freescale/fsl-ls1088a-qds.dts
+++ b/arch/arm64/boot/dts/freescale/fsl-ls1088a-qds.dts
@@ -113,12 +113,13 @@ &ifc {
 		  3 0 0x5 0x20000000 0x00010000>;
 	status = "okay";
 
+	/* not working, disabled to workaround boot issue
 	nor@0,0 {
 		compatible = "cfi-flash";
 		reg = <0x0 0x0 0x8000000>;
 		bank-width = <2>;
 		device-width = <1>;
-	};
+	};*/
 
 	nand@2,0 {
 		compatible = "fsl,ifc-nand";
diff --git a/arch/arm64/boot/dts/freescale/fsl-ls1088a-rdb.dts b/arch/arm64/boot/dts/freescale/fsl-ls1088a-rdb.dts
index 1bfbce69c..8070ac262 100644
--- a/arch/arm64/boot/dts/freescale/fsl-ls1088a-rdb.dts
+++ b/arch/arm64/boot/dts/freescale/fsl-ls1088a-rdb.dts
@@ -223,7 +223,7 @@ s25fs512s0: flash@0 {
 		#address-cells = <1>;
 		#size-cells = <1>;
 		spi-max-frequency = <50000000>;
-		spi-rx-bus-width = <4>;
+		spi-rx-bus-width = <1>;
 		spi-tx-bus-width = <1>;
 		reg = <0>;
 	};
@@ -233,7 +233,7 @@ s25fs512s1: flash@1 {
 		#address-cells = <1>;
 		#size-cells = <1>;
 		spi-max-frequency = <50000000>;
-		spi-rx-bus-width = <4>;
+		spi-rx-bus-width = <1>;
 		spi-tx-bus-width = <1>;
 		reg = <1>;
 	};
diff --git a/arch/arm64/boot/dts/freescale/fsl-ls1088a.dtsi b/arch/arm64/boot/dts/freescale/fsl-ls1088a.dtsi
index 605072317..2bc0613d0 100644
--- a/arch/arm64/boot/dts/freescale/fsl-ls1088a.dtsi
+++ b/arch/arm64/boot/dts/freescale/fsl-ls1088a.dtsi
@@ -206,6 +206,19 @@ sysclk: sysclk {
 		clock-output-names = "sysclk";
 	};
 
+	rstcr: syscon@1e60000 {
+		compatible = "fsl,ls1088a-rstcr", "syscon";
+		reg = <0x0 0x1e60000 0x0 0x4>;
+	};
+
+	reboot {
+		compatible = "syscon-reboot";
+		regmap = <&rstcr>;
+		offset = <0x0>;
+		mask = <0x02>;
+	};
+
+
 	soc {
 		compatible = "simple-bus";
 		#address-cells = <2>;
@@ -384,8 +397,8 @@ gpio3: gpio@2330000 {
 			#interrupt-cells = <2>;
 		};
 
-		ifc: ifc@2240000 {
-			compatible = "fsl,ifc", "simple-bus";
+		ifc: memory-controller@2240000 {
+			compatible = "fsl,ifc";
 			reg = <0x0 0x2240000 0x0 0x20000>;
 			interrupts = <0 21 IRQ_TYPE_LEVEL_HIGH>;
 			little-endian;
@@ -395,13 +408,14 @@ ifc: ifc@2240000 {
 		};
 
 		i2c0: i2c@2000000 {
-			compatible = "fsl,vf610-i2c";
+			compatible = "fsl,vf610-i2c", "fsl,ls1088a-vf610-i2c";
 			#address-cells = <1>;
 			#size-cells = <0>;
 			reg = <0x0 0x2000000 0x0 0x10000>;
 			interrupts = <0 34 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&clockgen QORIQ_CLK_PLATFORM_PLL
 					    QORIQ_CLK_PLL_DIV(8)>;
+			scl-gpios = <&gpio3 30 0>;
 			status = "disabled";
 		};
 
@@ -468,23 +482,28 @@ esdhc: esdhc@2140000 {
 		};
 
 		usb0: usb@3100000 {
-			compatible = "snps,dwc3";
+			compatible = "fsl,ls1088a-dwc3", "snps,dwc3";
 			reg = <0x0 0x3100000 0x0 0x10000>;
 			interrupts = <0 80 IRQ_TYPE_LEVEL_HIGH>;
 			dr_mode = "host";
 			snps,quirk-frame-length-adjustment = <0x20>;
 			snps,dis_rxdet_inp3_quirk;
 			snps,incr-burst-type-adjustment = <1>, <4>, <8>, <16>;
+			snps,host-vbus-glitches;
+			dma-coherent;
 			status = "disabled";
 		};
 
 		usb1: usb@3110000 {
-			compatible = "snps,dwc3";
+			compatible = "fsl,ls1088a-dwc3", "snps,dwc3";
 			reg = <0x0 0x3110000 0x0 0x10000>;
 			interrupts = <0 81 IRQ_TYPE_LEVEL_HIGH>;
 			dr_mode = "host";
 			snps,quirk-frame-length-adjustment = <0x20>;
 			snps,dis_rxdet_inp3_quirk;
+			snps,incr-burst-type-adjustment = <1>, <4>, <8>, <16>;
+			snps,host-vbus-glitches;
+			dma-coherent;
 			status = "disabled";
 		};
 
@@ -570,9 +589,12 @@ pcie_ep1: pcie-ep@3400000 {
 			reg = <0x00 0x03400000 0x0 0x00100000>,
 			      <0x20 0x00000000 0x8 0x00000000>;
 			reg-names = "regs", "addr_space";
+			interrupts = <GIC_SPI 108 IRQ_TYPE_LEVEL_HIGH>; /* PME interrupt */
+			interrupt-names = "pme";
 			num-ib-windows = <24>;
 			num-ob-windows = <256>;
 			max-functions = /bits/ 8 <2>;
+			big-endian;
 			status = "disabled";
 		};
 
@@ -607,8 +629,11 @@ pcie_ep2: pcie-ep@3500000 {
 			reg = <0x00 0x03500000 0x0 0x00100000>,
 			      <0x28 0x00000000 0x8 0x00000000>;
 			reg-names = "regs", "addr_space";
+			interrupts = <GIC_SPI 113 IRQ_TYPE_LEVEL_HIGH>; /* PME interrupt */
+			interrupt-names = "pme";
 			num-ib-windows = <6>;
 			num-ob-windows = <6>;
+			big-endian;
 			status = "disabled";
 		};
 
@@ -643,8 +668,11 @@ pcie_ep3: pcie-ep@3600000 {
 			reg = <0x00 0x03600000 0x0 0x00100000>,
 			      <0x30 0x00000000 0x8 0x00000000>;
 			reg-names = "regs", "addr_space";
+			interrupts = <GIC_SPI 118 IRQ_TYPE_LEVEL_HIGH>; /* PME interrupt */
+			interrupt-names = "pme";
 			num-ib-windows = <6>;
 			num-ob-windows = <6>;
+			big-endian;
 			status = "disabled";
 		};
 
diff --git a/arch/arm64/boot/dts/freescale/fsl-ls2080a-qds.dts b/arch/arm64/boot/dts/freescale/fsl-ls2080a-qds.dts
index f6c3ee78a..30d3398af 100644
--- a/arch/arm64/boot/dts/freescale/fsl-ls2080a-qds.dts
+++ b/arch/arm64/boot/dts/freescale/fsl-ls2080a-qds.dts
@@ -23,3 +23,72 @@ chosen {
 		stdout-path = "serial0:115200n8";
 	};
 };
+
+/* Update DPMAC connections to external PHYs, under SerDes 0x2a_0x49. */
+&dpmac9 {
+	phy-handle = <&mdio0_phy12>;
+	phy-connection-type = "sgmii";
+};
+
+&dpmac10 {
+	phy-handle = <&mdio0_phy13>;
+	phy-connection-type = "sgmii";
+};
+
+&dpmac11 {
+	phy-handle = <&mdio0_phy14>;
+	phy-connection-type = "sgmii";
+};
+
+&dpmac12 {
+	phy-handle = <&mdio0_phy15>;
+	phy-connection-type = "sgmii";
+};
+
+&ifc {
+	boardctrl: board-control@3,0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "fsl,tetra-fpga", "fsl,fpga-qixis", "simple-mfd";
+		reg = <3 0 0x300>;		/* TODO check address */
+		ranges = <0 3 0 0x300>;
+
+		mdio_mux_emi1 {
+			compatible = "mdio-mux-mmioreg", "mdio-mux";
+			mdio-parent-bus = <&emdio1>;
+			reg = <0x54 1>;		/* BRDCFG4 */
+			mux-mask = <0xe0>;	/* EMI1_MDIO */
+
+			#address-cells=<1>;
+			#size-cells = <0>;
+
+			/* Child MDIO buses, one for each riser card:
+			 * reg = 0x0, 0x20, 0x40, 0x60, 0x80, 0xa0.
+			 * VSC8234 PHYs on the riser cards.
+			 */
+
+			mdio_mux3: mdio@60 {
+				reg = <0x60>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				mdio0_phy12: mdio_phy0@1c {
+					reg = <0x1c>;
+				};
+
+				mdio0_phy13: mdio_phy1@1d {
+					reg = <0x1d>;
+				};
+
+				mdio0_phy14: mdio_phy2@1e {
+					reg = <0x1e>;
+				};
+
+				mdio0_phy15: mdio_phy3@1f {
+					reg = <0x1f>;
+				};
+			};
+		};
+	};
+};
+
diff --git a/arch/arm64/boot/dts/freescale/fsl-ls2080a-rdb.dts b/arch/arm64/boot/dts/freescale/fsl-ls2080a-rdb.dts
index 448943560..1c8c99a74 100644
--- a/arch/arm64/boot/dts/freescale/fsl-ls2080a-rdb.dts
+++ b/arch/arm64/boot/dts/freescale/fsl-ls2080a-rdb.dts
@@ -23,3 +23,71 @@ chosen {
 		stdout-path = "serial1:115200n8";
 	};
 };
+
+&dpmac5 {
+	phy-handle = <&mdio2_phy1>;
+	phy-connection-type = "10gbase-r";
+};
+
+&dpmac6 {
+	phy-handle = <&mdio2_phy2>;
+	phy-connection-type = "10gbase-r";
+};
+
+&dpmac7 {
+	phy-handle = <&mdio2_phy3>;
+	phy-connection-type = "10gbase-r";
+};
+
+&dpmac8 {
+	phy-handle = <&mdio2_phy4>;
+	phy-connection-type = "10gbase-r";
+};
+
+&emdio1 {
+	status = "disabled";
+
+	/* CS4340 PHYs */
+	mdio1_phy1: emdio1_phy@1 {
+		reg = <0x10>;
+	};
+
+	mdio1_phy2: emdio1_phy@2 {
+		reg = <0x11>;
+	};
+
+	mdio1_phy3: emdio1_phy@3 {
+		reg = <0x12>;
+	};
+
+	mdio1_phy4: emdio1_phy@4 {
+		reg = <0x13>;
+	};
+};
+
+&emdio2 {
+	/* AQR405 PHYs */
+	mdio2_phy1: emdio2_phy@1 {
+		compatible = "ethernet-phy-ieee802.3-c45";
+		interrupts = <0 1 0x4>; /* Level high type */
+		reg = <0x0>;
+	};
+
+	mdio2_phy2: emdio2_phy@2 {
+		compatible = "ethernet-phy-ieee802.3-c45";
+		interrupts = <0 2 0x4>; /* Level high type */
+		reg = <0x1>;
+	};
+
+	mdio2_phy3: emdio2_phy@3 {
+		compatible = "ethernet-phy-ieee802.3-c45";
+		interrupts = <0 4 0x4>; /* Level high type */
+		reg = <0x2>;
+	};
+
+	mdio2_phy4: emdio2_phy@4 {
+		compatible = "ethernet-phy-ieee802.3-c45";
+		interrupts = <0 5 0x4>; /* Level high type */
+		reg = <0x3>;
+	};
+};
diff --git a/arch/arm64/boot/dts/freescale/fsl-ls2080a.dtsi b/arch/arm64/boot/dts/freescale/fsl-ls2080a.dtsi
index 6f6667b70..a7c65a026 100644
--- a/arch/arm64/boot/dts/freescale/fsl-ls2080a.dtsi
+++ b/arch/arm64/boot/dts/freescale/fsl-ls2080a.dtsi
@@ -150,3 +150,15 @@ &pcie4 {
 	ranges = <0x81000000 0x0 0x00000000 0x16 0x00010000 0x0 0x00010000   /* downstream I/O */
 		  0x82000000 0x0 0x40000000 0x16 0x40000000 0x0 0x40000000>; /* non-prefetchable memory */
 };
+
+&timer {
+	fsl,erratum-a008585;
+};
+
+&usb0 {
+	snps,incr-burst-type-adjustment = <1>, <4>, <8>, <16>;
+};
+
+&usb1 {
+	snps,incr-burst-type-adjustment = <1>, <4>, <8>, <16>;
+};
diff --git a/arch/arm64/boot/dts/freescale/fsl-ls2081a-rdb.dts b/arch/arm64/boot/dts/freescale/fsl-ls2081a-rdb.dts
new file mode 100644
index 000000000..908b9aff0
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/fsl-ls2081a-rdb.dts
@@ -0,0 +1,131 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Device Tree file for NXP LS2081A RDB Board.
+ *
+ * Copyright 2017 NXP
+ *
+ * Priyanka Jain <priyanka.jain@nxp.com>
+ *
+ */
+
+/dts-v1/;
+
+#include "fsl-ls2088a.dtsi"
+
+/ {
+	model = "NXP Layerscape 2081A RDB Board";
+	compatible = "fsl,ls2081a-rdb", "fsl,ls2081a";
+
+	aliases {
+		serial0 = &serial0;
+		serial1 = &serial1;
+	};
+
+	chosen {
+		stdout-path = "serial1:115200n8";
+	};
+};
+
+&dspi {
+	status = "okay";
+
+	n25q512a: flash@0 {
+		compatible = "jedec,spi-nor";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		spi-max-frequency = <3000000>;
+		reg = <0>;
+	};
+};
+
+&esdhc {
+	status = "okay";
+};
+
+&ifc {
+	status = "disabled";
+};
+
+&i2c0 {
+	status = "okay";
+
+	pca9547: mux@75 {
+		compatible = "nxp,pca9547";
+		reg = <0x75>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		i2c@1 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0x01>;
+			rtc@51 {
+				compatible = "nxp,pcf2129";
+				reg = <0x51>;
+			};
+		};
+
+		i2c@2 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0x02>;
+
+			ina220@40 {
+				compatible = "ti,ina220";
+				reg = <0x40>;
+				shunt-resistor = <500>;
+			};
+		};
+
+		i2c@3 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0x3>;
+
+			adt7481@4c {
+				compatible = "adi,adt7461";
+				reg = <0x4c>;
+			};
+		};
+	};
+};
+
+&qspi {
+	status = "okay";
+
+	s25fs512s0: flash@0 {
+		compatible = "jedec,spi-nor";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		spi-rx-bus-width = <4>;
+		spi-tx-bus-width = <4>;
+		spi-max-frequency = <20000000>;
+		reg = <0>;
+	};
+
+	s25fs512s1: flash@1 {
+		compatible = "jedec,spi-nor";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		spi-rx-bus-width = <4>;
+		spi-tx-bus-width = <4>;
+		spi-max-frequency = <20000000>;
+		reg = <1>;
+	};
+};
+
+&sata0 {
+	status = "okay";
+};
+
+&sata1 {
+	status = "okay";
+};
+
+&usb0 {
+	status = "okay";
+};
+
+&usb1 {
+	status = "okay";
+};
diff --git a/arch/arm64/boot/dts/freescale/fsl-ls2088a-qds.dts b/arch/arm64/boot/dts/freescale/fsl-ls2088a-qds.dts
index 7c17b1bd4..2f48a7b4c 100644
--- a/arch/arm64/boot/dts/freescale/fsl-ls2088a-qds.dts
+++ b/arch/arm64/boot/dts/freescale/fsl-ls2088a-qds.dts
@@ -22,3 +22,71 @@ chosen {
 		stdout-path = "serial0:115200n8";
 	};
 };
+
+/* Update DPMAC connections to external PHYs, under SerDes 0x2a_0x49. */
+&dpmac9 {
+	phy-handle = <&mdio0_phy12>;
+	phy-connection-type = "sgmii";
+};
+
+&dpmac10 {
+	phy-handle = <&mdio0_phy13>;
+	phy-connection-type = "sgmii";
+};
+
+&dpmac11 {
+	phy-handle = <&mdio0_phy14>;
+	phy-connection-type = "sgmii";
+};
+
+&dpmac12 {
+	phy-handle = <&mdio0_phy15>;
+	phy-connection-type = "sgmii";
+};
+
+&ifc {
+	boardctrl: board-control@3,0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "fsl,tetra-fpga", "fsl,fpga-qixis", "simple-mfd";
+		reg = <3 0 0x300>;		/* TODO check address */
+		ranges = <0 3 0 0x300>;
+
+		mdio_mux_emi1 {
+			compatible = "mdio-mux-mmioreg", "mdio-mux";
+			mdio-parent-bus = <&emdio1>;
+			reg = <0x54 1>;		/* BRDCFG4 */
+			mux-mask = <0xe0>;	/* EMI1_MDIO */
+
+			#address-cells=<1>;
+			#size-cells = <0>;
+
+			/* Child MDIO buses, one for each riser card:
+			 * reg = 0x0, 0x20, 0x40, 0x60, 0x80, 0xa0.
+			 * VSC8234 PHYs on the riser cards.
+			 */
+
+			mdio_mux3: mdio@60 {
+				reg = <0x60>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				mdio0_phy12: mdio_phy0@1c {
+					reg = <0x1c>;
+				};
+
+				mdio0_phy13: mdio_phy1@1d {
+					reg = <0x1d>;
+				};
+
+				mdio0_phy14: mdio_phy2@1e {
+					reg = <0x1e>;
+				};
+
+				mdio0_phy15: mdio_phy3@1f {
+					reg = <0x1f>;
+				};
+			};
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/freescale/fsl-ls208xa-rdb.dtsi b/arch/arm64/boot/dts/freescale/fsl-ls208xa-rdb.dtsi
index 4b71c4fcb..a752f06a2 100644
--- a/arch/arm64/boot/dts/freescale/fsl-ls208xa-rdb.dtsi
+++ b/arch/arm64/boot/dts/freescale/fsl-ls208xa-rdb.dtsi
@@ -49,6 +49,8 @@ pca9547@75 {
 		reg = <0x75>;
 		#address-cells = <1>;
 		#size-cells = <0>;
+		idle-state = <0>;
+
 		i2c@1 {
 			#address-cells = <1>;
 			#size-cells = <0>;
diff --git a/arch/arm64/boot/dts/freescale/fsl-ls208xa.dtsi b/arch/arm64/boot/dts/freescale/fsl-ls208xa.dtsi
index 1282b61da..388fdd3b7 100644
--- a/arch/arm64/boot/dts/freescale/fsl-ls208xa.dtsi
+++ b/arch/arm64/boot/dts/freescale/fsl-ls208xa.dtsi
@@ -239,13 +239,12 @@ map0 {
 		};
 	};
 
-	timer {
+	timer: timer {
 		compatible = "arm,armv8-timer";
 		interrupts = <1 13 4>, /* Physical Secure PPI, active-low */
 			     <1 14 4>, /* Physical Non-Secure PPI, active-low */
 			     <1 11 4>, /* Virtual PPI, active-low */
 			     <1 10 4>; /* Hypervisor PPI, active-low */
-		fsl,erratum-a008585;
 	};
 
 	pmu {
@@ -390,9 +389,9 @@ cluster1_core0_watchdog: wdt@c000000 {
 			compatible = "arm,sp805", "arm,primecell";
 			reg = <0x0 0xc000000 0x0 0x1000>;
 			clocks = <&clockgen QORIQ_CLK_PLATFORM_PLL
-					    QORIQ_CLK_PLL_DIV(4)>,
+					    QORIQ_CLK_PLL_DIV(32)>,
 				 <&clockgen QORIQ_CLK_PLATFORM_PLL
-					    QORIQ_CLK_PLL_DIV(4)>;
+					    QORIQ_CLK_PLL_DIV(32)>;
 			clock-names = "wdog_clk", "apb_pclk";
 		};
 
@@ -400,9 +399,9 @@ cluster1_core1_watchdog: wdt@c010000 {
 			compatible = "arm,sp805", "arm,primecell";
 			reg = <0x0 0xc010000 0x0 0x1000>;
 			clocks = <&clockgen QORIQ_CLK_PLATFORM_PLL
-					    QORIQ_CLK_PLL_DIV(4)>,
+					    QORIQ_CLK_PLL_DIV(32)>,
 				 <&clockgen QORIQ_CLK_PLATFORM_PLL
-					    QORIQ_CLK_PLL_DIV(4)>;
+					    QORIQ_CLK_PLL_DIV(32)>;
 			clock-names = "wdog_clk", "apb_pclk";
 		};
 
@@ -410,9 +409,9 @@ cluster2_core0_watchdog: wdt@c100000 {
 			compatible = "arm,sp805", "arm,primecell";
 			reg = <0x0 0xc100000 0x0 0x1000>;
 			clocks = <&clockgen QORIQ_CLK_PLATFORM_PLL
-					    QORIQ_CLK_PLL_DIV(4)>,
+					    QORIQ_CLK_PLL_DIV(32)>,
 				 <&clockgen QORIQ_CLK_PLATFORM_PLL
-					    QORIQ_CLK_PLL_DIV(4)>;
+					    QORIQ_CLK_PLL_DIV(32)>;
 			clock-names = "wdog_clk", "apb_pclk";
 		};
 
@@ -420,9 +419,9 @@ cluster2_core1_watchdog: wdt@c110000 {
 			compatible = "arm,sp805", "arm,primecell";
 			reg = <0x0 0xc110000 0x0 0x1000>;
 			clocks = <&clockgen QORIQ_CLK_PLATFORM_PLL
-					    QORIQ_CLK_PLL_DIV(4)>,
+					    QORIQ_CLK_PLL_DIV(32)>,
 				 <&clockgen QORIQ_CLK_PLATFORM_PLL
-					    QORIQ_CLK_PLL_DIV(4)>;
+					    QORIQ_CLK_PLL_DIV(32)>;
 			clock-names = "wdog_clk", "apb_pclk";
 		};
 
@@ -430,9 +429,9 @@ cluster3_core0_watchdog: wdt@c200000 {
 			compatible = "arm,sp805", "arm,primecell";
 			reg = <0x0 0xc200000 0x0 0x1000>;
 			clocks = <&clockgen QORIQ_CLK_PLATFORM_PLL
-					    QORIQ_CLK_PLL_DIV(4)>,
+					    QORIQ_CLK_PLL_DIV(32)>,
 				 <&clockgen QORIQ_CLK_PLATFORM_PLL
-					    QORIQ_CLK_PLL_DIV(4)>;
+					    QORIQ_CLK_PLL_DIV(32)>;
 			clock-names = "wdog_clk", "apb_pclk";
 		};
 
@@ -440,9 +439,9 @@ cluster3_core1_watchdog: wdt@c210000 {
 			compatible = "arm,sp805", "arm,primecell";
 			reg = <0x0 0xc210000 0x0 0x1000>;
 			clocks = <&clockgen QORIQ_CLK_PLATFORM_PLL
-					    QORIQ_CLK_PLL_DIV(4)>,
+					    QORIQ_CLK_PLL_DIV(32)>,
 				 <&clockgen QORIQ_CLK_PLATFORM_PLL
-					    QORIQ_CLK_PLL_DIV(4)>;
+					    QORIQ_CLK_PLL_DIV(32)>;
 			clock-names = "wdog_clk", "apb_pclk";
 		};
 
@@ -450,9 +449,9 @@ cluster4_core0_watchdog: wdt@c300000 {
 			compatible = "arm,sp805", "arm,primecell";
 			reg = <0x0 0xc300000 0x0 0x1000>;
 			clocks = <&clockgen QORIQ_CLK_PLATFORM_PLL
-					    QORIQ_CLK_PLL_DIV(4)>,
+					    QORIQ_CLK_PLL_DIV(32)>,
 				 <&clockgen QORIQ_CLK_PLATFORM_PLL
-					    QORIQ_CLK_PLL_DIV(4)>;
+					    QORIQ_CLK_PLL_DIV(32)>;
 			clock-names = "wdog_clk", "apb_pclk";
 		};
 
@@ -460,9 +459,9 @@ cluster4_core1_watchdog: wdt@c310000 {
 			compatible = "arm,sp805", "arm,primecell";
 			reg = <0x0 0xc310000 0x0 0x1000>;
 			clocks = <&clockgen QORIQ_CLK_PLATFORM_PLL
-					    QORIQ_CLK_PLL_DIV(4)>,
+					    QORIQ_CLK_PLL_DIV(32)>,
 				 <&clockgen QORIQ_CLK_PLATFORM_PLL
-					    QORIQ_CLK_PLL_DIV(4)>;
+					    QORIQ_CLK_PLL_DIV(32)>;
 			clock-names = "wdog_clk", "apb_pclk";
 		};
 
@@ -990,7 +989,7 @@ gpio3: gpio@2330000 {
 
 		i2c0: i2c@2000000 {
 			status = "disabled";
-			compatible = "fsl,vf610-i2c";
+			compatible = "fsl,vf610-i2c", "fsl,ls208xa-vf610-i2c";
 			#address-cells = <1>;
 			#size-cells = <0>;
 			reg = <0x0 0x2000000 0x0 0x10000>;
@@ -998,6 +997,7 @@ i2c0: i2c@2000000 {
 			clock-names = "i2c";
 			clocks = <&clockgen QORIQ_CLK_PLATFORM_PLL
 					    QORIQ_CLK_PLL_DIV(4)>;
+			scl-gpios = <&gpio3 10 0>;
 		};
 
 		i2c1: i2c@2010000 {
@@ -1036,8 +1036,8 @@ i2c3: i2c@2030000 {
 					    QORIQ_CLK_PLL_DIV(4)>;
 		};
 
-		ifc: ifc@2240000 {
-			compatible = "fsl,ifc", "simple-bus";
+		ifc: memory-controller@2240000 {
+			compatible = "fsl,ifc";
 			reg = <0x0 0x2240000 0x0 0x20000>;
 			interrupts = <0 21 0x4>; /* Level high type */
 			little-endian;
@@ -1068,8 +1068,8 @@ QORIQ_CLK_PLL_DIV(4)>,
 		pcie1: pcie@3400000 {
 			compatible = "fsl,ls2080a-pcie", "fsl,ls2085a-pcie";
 			reg-names = "regs", "config";
-			interrupts = <0 108 0x4>; /* Level high type */
-			interrupt-names = "intr";
+			interrupts = <0 108 0x4>; /* aer interrupt */
+			interrupt-names = "aer";
 			#address-cells = <3>;
 			#size-cells = <2>;
 			device_type = "pci";
@@ -1090,8 +1090,8 @@ pcie1: pcie@3400000 {
 		pcie2: pcie@3500000 {
 			compatible = "fsl,ls2080a-pcie", "fsl,ls2085a-pcie";
 			reg-names = "regs", "config";
-			interrupts = <0 113 0x4>; /* Level high type */
-			interrupt-names = "intr";
+			interrupts = <0 113 0x4>; /* aer interrupt */
+			interrupt-names = "aer";
 			#address-cells = <3>;
 			#size-cells = <2>;
 			device_type = "pci";
@@ -1112,8 +1112,8 @@ pcie2: pcie@3500000 {
 		pcie3: pcie@3600000 {
 			compatible = "fsl,ls2080a-pcie", "fsl,ls2085a-pcie";
 			reg-names = "regs", "config";
-			interrupts = <0 118 0x4>; /* Level high type */
-			interrupt-names = "intr";
+			interrupts = <0 118 0x4>; /* aer interrupt */
+			interrupt-names = "aer";
 			#address-cells = <3>;
 			#size-cells = <2>;
 			device_type = "pci";
@@ -1134,8 +1134,8 @@ pcie3: pcie@3600000 {
 		pcie4: pcie@3700000 {
 			compatible = "fsl,ls2080a-pcie", "fsl,ls2085a-pcie";
 			reg-names = "regs", "config";
-			interrupts = <0 123 0x4>; /* Level high type */
-			interrupt-names = "intr";
+			interrupts = <0 123 0x4>; /* aer interrupt */
+			interrupt-names = "aer";
 			#address-cells = <3>;
 			#size-cells = <2>;
 			device_type = "pci";
@@ -1175,24 +1175,26 @@ sata1: sata@3210000 {
 
 		usb0: usb@3100000 {
 			status = "disabled";
-			compatible = "snps,dwc3";
+			compatible = "fsl,ls2088a-dwc3", "snps,dwc3";
 			reg = <0x0 0x3100000 0x0 0x10000>;
 			interrupts = <0 80 0x4>; /* Level high type */
 			dr_mode = "host";
 			snps,quirk-frame-length-adjustment = <0x20>;
 			snps,dis_rxdet_inp3_quirk;
 			snps,incr-burst-type-adjustment = <1>, <4>, <8>, <16>;
+			snps,host-vbus-glitches;
 		};
 
 		usb1: usb@3110000 {
 			status = "disabled";
-			compatible = "snps,dwc3";
+			compatible = "fsl,ls2088a-dwc3", "snps,dwc3";
 			reg = <0x0 0x3110000 0x0 0x10000>;
 			interrupts = <0 81 0x4>; /* Level high type */
 			dr_mode = "host";
 			snps,quirk-frame-length-adjustment = <0x20>;
 			snps,dis_rxdet_inp3_quirk;
 			snps,incr-burst-type-adjustment = <1>, <4>, <8>, <16>;
+			snps,host-vbus-glitches;
 		};
 
 		ccn@4000000 {
diff --git a/arch/arm64/boot/dts/freescale/fsl-lx2160a-clearfog-itx.dtsi b/arch/arm64/boot/dts/freescale/fsl-lx2160a-clearfog-itx.dtsi
index 17f8e7339..41702e738 100644
--- a/arch/arm64/boot/dts/freescale/fsl-lx2160a-clearfog-itx.dtsi
+++ b/arch/arm64/boot/dts/freescale/fsl-lx2160a-clearfog-itx.dtsi
@@ -63,21 +63,25 @@ sfp3: sfp-3 {
 &dpmac7 {
 	sfp = <&sfp0>;
 	managed = "in-band-status";
+	phys = <&serdes_1 3>;
 };
 
 &dpmac8 {
 	sfp = <&sfp1>;
 	managed = "in-band-status";
+	phys = <&serdes_1 2>;
 };
 
 &dpmac9 {
 	sfp = <&sfp2>;
 	managed = "in-band-status";
+	phys = <&serdes_1 1>;
 };
 
 &dpmac10 {
 	sfp = <&sfp3>;
 	managed = "in-band-status";
+	phys = <&serdes_1 0>;
 };
 
 &emdio2 {
diff --git a/arch/arm64/boot/dts/freescale/fsl-lx2160a-qds.dts b/arch/arm64/boot/dts/freescale/fsl-lx2160a-qds.dts
index d858d9c8b..2ecfa90f5 100644
--- a/arch/arm64/boot/dts/freescale/fsl-lx2160a-qds.dts
+++ b/arch/arm64/boot/dts/freescale/fsl-lx2160a-qds.dts
@@ -31,6 +31,130 @@ sb_3v3: regulator-sb3v3 {
 		regulator-boot-on;
 		regulator-always-on;
 	};
+
+	mdio-mux-1 {
+		compatible = "mdio-mux-multiplexer";
+		mux-controls = <&mux 0>;
+		mdio-parent-bus = <&emdio1>;
+		#address-cells=<1>;
+		#size-cells = <0>;
+
+		mdio@0 { /* On-board PHY #1 RGMI1*/
+			reg = <0x00>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		mdio@8 { /* On-board PHY #2 RGMI2*/
+			reg = <0x8>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		mdio@18 { /* Slot #1 */
+			reg = <0x18>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		mdio@19 { /* Slot #2 */
+			reg = <0x19>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		mdio@1a { /* Slot #3 */
+			reg = <0x1a>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		mdio@1b { /* Slot #4 */
+			reg = <0x1b>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		mdio@1c { /* Slot #5 */
+			reg = <0x1c>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		mdio@1d { /* Slot #6 */
+			reg = <0x1d>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		mdio@1e { /* Slot #7 */
+			reg = <0x1e>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		mdio@1f { /* Slot #8 */
+			reg = <0x1f>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+	};
+
+	mdio-mux-2 {
+		compatible = "mdio-mux-multiplexer";
+		mux-controls = <&mux 1>;
+		mdio-parent-bus = <&emdio2>;
+		#address-cells=<1>;
+		#size-cells = <0>;
+
+		mdio@0 { /* Slot #1 (secondary EMI) */
+			reg = <0x00>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		mdio@1 { /* Slot #2 (secondary EMI) */
+			reg = <0x01>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		mdio@2 { /* Slot #3 (secondary EMI) */
+			reg = <0x02>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		mdio@3 { /* Slot #4 (secondary EMI) */
+			reg = <0x03>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		mdio@4 { /* Slot #5 (secondary EMI) */
+			reg = <0x04>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		mdio@5 { /* Slot #6 (secondary EMI) */
+			reg = <0x05>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		mdio@6 { /* Slot #7 (secondary EMI) */
+			reg = <0x06>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		mdio@7 { /* Slot #8 (secondary EMI) */
+			reg = <0x07>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+	};
 };
 
 &can0 {
@@ -81,6 +205,14 @@ dflash2: flash@0 {
 	};
 };
 
+&emdio1 {
+	status = "okay";
+};
+
+&emdio2 {
+	status = "okay";
+};
+
 &esdhc0 {
 	status = "okay";
 };
@@ -107,6 +239,19 @@ mt35xu512aba0: flash@0 {
 &i2c0 {
 	status = "okay";
 
+	fpga@66 {
+		compatible = "fsl,lx2160aqds-fpga", "fsl,fpga-qixis-i2c",
+			     "simple-mfd";
+		reg = <0x66>;
+
+		mux: mux-controller {
+			compatible = "reg-mux";
+			#mux-control-cells = <1>;
+			mux-reg-masks = <0x54 0xf8>, /* 0: reg 0x54, bits 7:3 */
+					<0x54 0x07>; /* 1: reg 0x54, bit 2:0 */
+		};
+	};
+
 	i2c-mux@77 {
 		compatible = "nxp,pca9547";
 		reg = <0x77>;
@@ -156,6 +301,10 @@ rtc@51 {
 	};
 };
 
+&optee {
+	status = "okay";
+};
+
 &sata0 {
 	status = "okay";
 };
diff --git a/arch/arm64/boot/dts/freescale/fsl-lx2160a-rdb.dts b/arch/arm64/boot/dts/freescale/fsl-lx2160a-rdb.dts
index 028ff8074..0c44b3cbe 100644
--- a/arch/arm64/boot/dts/freescale/fsl-lx2160a-rdb.dts
+++ b/arch/arm64/boot/dts/freescale/fsl-lx2160a-rdb.dts
@@ -49,6 +49,14 @@ &dpmac4 {
 	managed = "in-band-status";
 };
 
+&dpmac5 {
+	phy-handle = <&inphi_phy>;
+};
+
+&dpmac6 {
+	phy-handle = <&inphi_phy>;
+};
+
 &dpmac17 {
 	phy-handle = <&rgmii_phy1>;
 	phy-connection-type = "rgmii-id";
@@ -109,6 +117,15 @@ can-transceiver {
 	};
 };
 
+&emdio2 {
+	status = "okay";
+
+	inphi_phy: ethernet-phy@0 {
+		compatible = "ethernet-phy-id0210.7440";
+		reg = <0x0>;
+	};
+};
+
 &esdhc0 {
 	sd-uhs-sdr104;
 	sd-uhs-sdr50;
@@ -202,6 +219,10 @@ rtc@51 {
 	};
 };
 
+&optee {
+	status = "okay";
+};
+
 &pcs_mdio3 {
 	status = "okay";
 };
diff --git a/arch/arm64/boot/dts/freescale/fsl-lx2160a.dtsi b/arch/arm64/boot/dts/freescale/fsl-lx2160a.dtsi
index 51c4f6100..a1675afe1 100644
--- a/arch/arm64/boot/dts/freescale/fsl-lx2160a.dtsi
+++ b/arch/arm64/boot/dts/freescale/fsl-lx2160a.dtsi
@@ -612,6 +612,12 @@ soc {
 		ranges;
 		dma-ranges = <0x0 0x0 0x0 0x0 0x10000 0x00000000>;
 
+		serdes_1: phy@1ea0000 {
+			compatible = "fsl,lynx-28g";
+			reg = <0x0 0x1ea0000 0x0 0x1e30>;
+			#phy-cells = <1>;
+		};
+
 		crypto: crypto@8000000 {
 			compatible = "fsl,sec-v5.0", "fsl,sec-v4.0";
 			fsl,sec-era = <10>;
@@ -1018,24 +1024,30 @@ ftm_alarm0: timer@2800000 {
 		};
 
 		usb0: usb@3100000 {
-			compatible = "snps,dwc3";
+			compatible = "fsl,lx2160a-dwc3", "snps,dwc3";
 			reg = <0x0 0x3100000 0x0 0x10000>;
 			interrupts = <GIC_SPI 80 IRQ_TYPE_LEVEL_HIGH>;
 			dr_mode = "host";
 			snps,quirk-frame-length-adjustment = <0x20>;
+			usb3-lpm-capable;
 			snps,dis_rxdet_inp3_quirk;
 			snps,incr-burst-type-adjustment = <1>, <4>, <8>, <16>;
+			snps,host-vbus-glitches;
+			dma-coherent;
 			status = "disabled";
 		};
 
 		usb1: usb@3110000 {
-			compatible = "snps,dwc3";
+			compatible = "fsl,lx2160a-dwc3", "snps,dwc3";
 			reg = <0x0 0x3110000 0x0 0x10000>;
 			interrupts = <GIC_SPI 81 IRQ_TYPE_LEVEL_HIGH>;
 			dr_mode = "host";
 			snps,quirk-frame-length-adjustment = <0x20>;
+			usb3-lpm-capable;
 			snps,dis_rxdet_inp3_quirk;
 			snps,incr-burst-type-adjustment = <1>, <4>, <8>, <16>;
+			snps,host-vbus-glitches;
+			dma-coherent;
 			status = "disabled";
 		};
 
@@ -1088,10 +1100,10 @@ sata3: sata@3230000 {
 		};
 
 		pcie1: pcie@3400000 {
-			compatible = "fsl,lx2160a-pcie";
-			reg = <0x00 0x03400000 0x0 0x00100000>, /* controller registers */
-			      <0x80 0x00000000 0x0 0x00002000>; /* configuration space */
-			reg-names = "csr_axi_slave", "config_axi_slave";
+			compatible = "fsl,ls2088a-pcie";
+			reg = <0x00 0x03400000 0x0 0x00100000   /* controller registers */
+			       0x80 0x00000000 0x0 0x00002000>; /* configuration space */
+			reg-names = "regs", "config";
 			interrupts = <GIC_SPI 108 IRQ_TYPE_LEVEL_HIGH>, /* AER interrupt */
 				     <GIC_SPI 108 IRQ_TYPE_LEVEL_HIGH>, /* PME interrupt */
 				     <GIC_SPI 108 IRQ_TYPE_LEVEL_HIGH>; /* controller interrupt */
@@ -1100,26 +1112,36 @@ pcie1: pcie@3400000 {
 			#size-cells = <2>;
 			device_type = "pci";
 			dma-coherent;
-			apio-wins = <8>;
-			ppio-wins = <8>;
+			num-viewport = <8>;
 			bus-range = <0x0 0xff>;
-			ranges = <0x82000000 0x0 0x40000000 0x80 0x40000000 0x0 0x40000000>; /* non-prefetchable memory */
+			ranges = <0x81000000 0x0 0x00000000 0x80 0x00010000 0x0 0x00010000
+				  0x82000000 0x0 0x40000000 0x80 0x40000000 0x0 0x40000000>; /* non-prefetchable memory */
 			msi-parent = <&its>;
+			iommu-map = <0 &smmu 0 1>; /* This is fixed-up by u-boot */
 			#interrupt-cells = <1>;
 			interrupt-map-mask = <0 0 0 7>;
 			interrupt-map = <0000 0 0 1 &gic 0 0 GIC_SPI 109 IRQ_TYPE_LEVEL_HIGH>,
 					<0000 0 0 2 &gic 0 0 GIC_SPI 110 IRQ_TYPE_LEVEL_HIGH>,
 					<0000 0 0 3 &gic 0 0 GIC_SPI 111 IRQ_TYPE_LEVEL_HIGH>,
 					<0000 0 0 4 &gic 0 0 GIC_SPI 112 IRQ_TYPE_LEVEL_HIGH>;
-			iommu-map = <0 &smmu 0 1>; /* Fixed-up by bootloader */
+			status = "disabled";
+		};
+
+		pcie_ep1: pcie_ep@3400000 {
+			compatible = "fsl,lx2160ar2-pcie-ep", "fsl,ls-pcie-ep";
+			reg = <0x00 0x03400000 0x0 0x00100000
+			       0x80 0x00000000 0x8 0x00000000>;
+			reg-names = "regs", "addr_space";
+			num-ob-windows = <8>;
+			num-ib-windows = <8>;
 			status = "disabled";
 		};
 
 		pcie2: pcie@3500000 {
-			compatible = "fsl,lx2160a-pcie";
-			reg = <0x00 0x03500000 0x0 0x00100000>, /* controller registers */
-			      <0x88 0x00000000 0x0 0x00002000>; /* configuration space */
-			reg-names = "csr_axi_slave", "config_axi_slave";
+			compatible = "fsl,ls2088a-pcie";
+			reg = <0x00 0x03500000 0x0 0x00100000   /* controller registers */
+			       0x88 0x00000000 0x0 0x00002000>; /* configuration space */
+			reg-names = "regs", "config";
 			interrupts = <GIC_SPI 113 IRQ_TYPE_LEVEL_HIGH>, /* AER interrupt */
 				     <GIC_SPI 113 IRQ_TYPE_LEVEL_HIGH>, /* PME interrupt */
 				     <GIC_SPI 113 IRQ_TYPE_LEVEL_HIGH>; /* controller interrupt */
@@ -1128,26 +1150,36 @@ pcie2: pcie@3500000 {
 			#size-cells = <2>;
 			device_type = "pci";
 			dma-coherent;
-			apio-wins = <8>;
-			ppio-wins = <8>;
+			num-viewport = <8>;
 			bus-range = <0x0 0xff>;
-			ranges = <0x82000000 0x0 0x40000000 0x88 0x40000000 0x0 0x40000000>; /* non-prefetchable memory */
+			ranges = <0x81000000 0x0 0x00000000 0x88 0x00010000 0x0 0x00010000
+				  0x82000000 0x0 0x40000000 0x88 0x40000000 0x0 0x40000000>; /* non-prefetchable memory */
 			msi-parent = <&its>;
+			iommu-map = <0 &smmu 0 1>; /* This is fixed-up by u-boot */
 			#interrupt-cells = <1>;
 			interrupt-map-mask = <0 0 0 7>;
 			interrupt-map = <0000 0 0 1 &gic 0 0 GIC_SPI 114 IRQ_TYPE_LEVEL_HIGH>,
 					<0000 0 0 2 &gic 0 0 GIC_SPI 115 IRQ_TYPE_LEVEL_HIGH>,
 					<0000 0 0 3 &gic 0 0 GIC_SPI 116 IRQ_TYPE_LEVEL_HIGH>,
 					<0000 0 0 4 &gic 0 0 GIC_SPI 117 IRQ_TYPE_LEVEL_HIGH>;
-			iommu-map = <0 &smmu 0 1>; /* Fixed-up by bootloader */
+			status = "disabled";
+		};
+
+		pcie_ep2: pcie_ep@3500000 {
+			compatible = "fsl,lx2160ar2-pcie-ep", "fsl,ls-pcie-ep";
+			reg = <0x00 0x03500000 0x0 0x00100000
+			       0x88 0x00000000 0x8 0x00000000>;
+			reg-names = "regs", "addr_space";
+			num-ob-windows = <8>;
+			num-ib-windows = <8>;
 			status = "disabled";
 		};
 
 		pcie3: pcie@3600000 {
-			compatible = "fsl,lx2160a-pcie";
-			reg = <0x00 0x03600000 0x0 0x00100000>, /* controller registers */
-			      <0x90 0x00000000 0x0 0x00002000>; /* configuration space */
-			reg-names = "csr_axi_slave", "config_axi_slave";
+			compatible = "fsl,ls2088a-pcie";
+			reg = <0x00 0x03600000 0x0 0x00100000   /* controller registers */
+			       0x90 0x00000000 0x0 0x00002000>; /* configuration space */
+			reg-names = "regs", "config";
 			interrupts = <GIC_SPI 118 IRQ_TYPE_LEVEL_HIGH>, /* AER interrupt */
 				     <GIC_SPI 118 IRQ_TYPE_LEVEL_HIGH>, /* PME interrupt */
 				     <GIC_SPI 118 IRQ_TYPE_LEVEL_HIGH>; /* controller interrupt */
@@ -1156,26 +1188,36 @@ pcie3: pcie@3600000 {
 			#size-cells = <2>;
 			device_type = "pci";
 			dma-coherent;
-			apio-wins = <256>;
-			ppio-wins = <24>;
+			num-viewport = <256>;
 			bus-range = <0x0 0xff>;
-			ranges = <0x82000000 0x0 0x40000000 0x90 0x40000000 0x0 0x40000000>; /* non-prefetchable memory */
+			ranges = <0x81000000 0x0 0x00000000 0x90 0x00010000 0x0 0x00010000
+				  0x82000000 0x0 0x40000000 0x90 0x40000000 0x0 0x40000000>; /* non-prefetchable memory */
 			msi-parent = <&its>;
+			iommu-map = <0 &smmu 0 1>; /* This is fixed-up by u-boot */
 			#interrupt-cells = <1>;
 			interrupt-map-mask = <0 0 0 7>;
 			interrupt-map = <0000 0 0 1 &gic 0 0 GIC_SPI 119 IRQ_TYPE_LEVEL_HIGH>,
 					<0000 0 0 2 &gic 0 0 GIC_SPI 120 IRQ_TYPE_LEVEL_HIGH>,
 					<0000 0 0 3 &gic 0 0 GIC_SPI 121 IRQ_TYPE_LEVEL_HIGH>,
 					<0000 0 0 4 &gic 0 0 GIC_SPI 122 IRQ_TYPE_LEVEL_HIGH>;
-			iommu-map = <0 &smmu 0 1>; /* Fixed-up by bootloader */
+			status = "disabled";
+		};
+
+		pcie_ep3: pcie_ep@3600000 {
+			compatible = "fsl,lx2160ar2-pcie-ep", "fsl,ls-pcie-ep";
+			reg = <0x00 0x03600000 0x0 0x00100000
+			       0x90 0x00000000 0x8 0x00000000>;
+			reg-names = "regs", "addr_space";
+			num-ob-windows = <256>;
+			num-ib-windows = <24>;
 			status = "disabled";
 		};
 
 		pcie4: pcie@3700000 {
-			compatible = "fsl,lx2160a-pcie";
-			reg = <0x00 0x03700000 0x0 0x00100000>, /* controller registers */
-			      <0x98 0x00000000 0x0 0x00002000>; /* configuration space */
-			reg-names = "csr_axi_slave", "config_axi_slave";
+			compatible = "fsl,ls2088a-pcie";
+			reg = <0x00 0x03700000 0x0 0x00100000   /* controller registers */
+			       0x98 0x00000000 0x0 0x00002000>; /* configuration space */
+			reg-names = "regs", "config";
 			interrupts = <GIC_SPI 123 IRQ_TYPE_LEVEL_HIGH>, /* AER interrupt */
 				     <GIC_SPI 123 IRQ_TYPE_LEVEL_HIGH>, /* PME interrupt */
 				     <GIC_SPI 123 IRQ_TYPE_LEVEL_HIGH>; /* controller interrupt */
@@ -1184,26 +1226,36 @@ pcie4: pcie@3700000 {
 			#size-cells = <2>;
 			device_type = "pci";
 			dma-coherent;
-			apio-wins = <8>;
-			ppio-wins = <8>;
+			num-viewport = <8>;
 			bus-range = <0x0 0xff>;
-			ranges = <0x82000000 0x0 0x40000000 0x98 0x40000000 0x0 0x40000000>; /* non-prefetchable memory */
+			ranges = <0x81000000 0x0 0x00000000 0x98 0x00010000 0x0 0x00010000
+				  0x82000000 0x0 0x40000000 0x98 0x40000000 0x0 0x40000000>; /* non-prefetchable memory */
 			msi-parent = <&its>;
+			iommu-map = <0 &smmu 0 1>; /* This is fixed-up by u-boot */
 			#interrupt-cells = <1>;
 			interrupt-map-mask = <0 0 0 7>;
 			interrupt-map = <0000 0 0 1 &gic 0 0 GIC_SPI 124 IRQ_TYPE_LEVEL_HIGH>,
 					<0000 0 0 2 &gic 0 0 GIC_SPI 125 IRQ_TYPE_LEVEL_HIGH>,
 					<0000 0 0 3 &gic 0 0 GIC_SPI 126 IRQ_TYPE_LEVEL_HIGH>,
 					<0000 0 0 4 &gic 0 0 GIC_SPI 127 IRQ_TYPE_LEVEL_HIGH>;
-			iommu-map = <0 &smmu 0 1>; /* Fixed-up by bootloader */
+			status = "disabled";
+		};
+
+		pcie_ep4: pcie_ep@3700000 {
+			compatible = "fsl,lx2160ar2-pcie-ep", "fsl,ls-pcie-ep";
+			reg = <0x00 0x03700000 0x0 0x00100000
+			       0x98 0x00000000 0x8 0x00000000>;
+			reg-names = "regs", "addr_space";
+			num-ob-windows = <8>;
+			num-ib-windows = <8>;
 			status = "disabled";
 		};
 
 		pcie5: pcie@3800000 {
-			compatible = "fsl,lx2160a-pcie";
-			reg = <0x00 0x03800000 0x0 0x00100000>, /* controller registers */
-			      <0xa0 0x00000000 0x0 0x00002000>; /* configuration space */
-			reg-names = "csr_axi_slave", "config_axi_slave";
+			compatible = "fsl,ls2088a-pcie";
+			reg = <0x00 0x03800000 0x0 0x00100000   /* controller registers */
+			       0xa0 0x00000000 0x0 0x00002000>; /* configuration space */
+			reg-names = "regs", "config";
 			interrupts = <GIC_SPI 128 IRQ_TYPE_LEVEL_HIGH>, /* AER interrupt */
 				     <GIC_SPI 128 IRQ_TYPE_LEVEL_HIGH>, /* PME interrupt */
 				     <GIC_SPI 128 IRQ_TYPE_LEVEL_HIGH>; /* controller interrupt */
@@ -1212,26 +1264,36 @@ pcie5: pcie@3800000 {
 			#size-cells = <2>;
 			device_type = "pci";
 			dma-coherent;
-			apio-wins = <256>;
-			ppio-wins = <24>;
+			num-viewport = <256>;
 			bus-range = <0x0 0xff>;
-			ranges = <0x82000000 0x0 0x40000000 0xa0 0x40000000 0x0 0x40000000>; /* non-prefetchable memory */
+			ranges = <0x81000000 0x0 0x00000000 0xa0 0x00010000 0x0 0x00010000
+				  0x82000000 0x0 0x40000000 0xa0 0x40000000 0x0 0x40000000>; /* non-prefetchable memory */
 			msi-parent = <&its>;
+			iommu-map = <0 &smmu 0 1>; /* This is fixed-up by u-boot */
 			#interrupt-cells = <1>;
 			interrupt-map-mask = <0 0 0 7>;
 			interrupt-map = <0000 0 0 1 &gic 0 0 GIC_SPI 129 IRQ_TYPE_LEVEL_HIGH>,
 					<0000 0 0 2 &gic 0 0 GIC_SPI 130 IRQ_TYPE_LEVEL_HIGH>,
 					<0000 0 0 3 &gic 0 0 GIC_SPI 131 IRQ_TYPE_LEVEL_HIGH>,
 					<0000 0 0 4 &gic 0 0 GIC_SPI 132 IRQ_TYPE_LEVEL_HIGH>;
-			iommu-map = <0 &smmu 0 1>; /* Fixed-up by bootloader */
+			status = "disabled";
+		};
+
+		pcie_ep5: pcie_ep@3800000 {
+			compatible = "fsl,lx2160ar2-pcie-ep", "fsl,ls-pcie-ep";
+			reg = <0x00 0x03800000 0x0 0x00100000
+			       0xa0 0x00000000 0x8 0x00000000>;
+			reg-names = "regs", "addr_space";
+			num-ob-windows = <256>;
+			num-ib-windows = <24>;
 			status = "disabled";
 		};
 
 		pcie6: pcie@3900000 {
-			compatible = "fsl,lx2160a-pcie";
-			reg = <0x00 0x03900000 0x0 0x00100000>, /* controller registers */
-			      <0xa8 0x00000000 0x0 0x00002000>; /* configuration space */
-			reg-names = "csr_axi_slave", "config_axi_slave";
+			compatible = "fsl,ls2088a-pcie";
+			reg = <0x00 0x03900000 0x0 0x00100000   /* controller registers */
+			       0xa8 0x00000000 0x0 0x00002000>; /* configuration space */
+			reg-names = "regs", "config";
 			interrupts = <GIC_SPI 103 IRQ_TYPE_LEVEL_HIGH>, /* AER interrupt */
 				     <GIC_SPI 103 IRQ_TYPE_LEVEL_HIGH>, /* PME interrupt */
 				     <GIC_SPI 103 IRQ_TYPE_LEVEL_HIGH>; /* controller interrupt */
@@ -1240,18 +1302,28 @@ pcie6: pcie@3900000 {
 			#size-cells = <2>;
 			device_type = "pci";
 			dma-coherent;
-			apio-wins = <8>;
-			ppio-wins = <8>;
+			num-viewport = <8>;
 			bus-range = <0x0 0xff>;
-			ranges = <0x82000000 0x0 0x40000000 0xa8 0x40000000 0x0 0x40000000>; /* non-prefetchable memory */
+			ranges = <0x81000000 0x0 0x00000000 0xa8 0x00010000 0x0 0x00010000
+				  0x82000000 0x0 0x40000000 0xa8 0x40000000 0x0 0x40000000>; /* non-prefetchable memory */
 			msi-parent = <&its>;
+			iommu-map = <0 &smmu 0 1>; /* This is fixed-up by u-boot */
 			#interrupt-cells = <1>;
 			interrupt-map-mask = <0 0 0 7>;
 			interrupt-map = <0000 0 0 1 &gic 0 0 GIC_SPI 104 IRQ_TYPE_LEVEL_HIGH>,
 					<0000 0 0 2 &gic 0 0 GIC_SPI 105 IRQ_TYPE_LEVEL_HIGH>,
 					<0000 0 0 3 &gic 0 0 GIC_SPI 106 IRQ_TYPE_LEVEL_HIGH>,
 					<0000 0 0 4 &gic 0 0 GIC_SPI 107 IRQ_TYPE_LEVEL_HIGH>;
-			iommu-map = <0 &smmu 0 1>; /* Fixed-up by bootloader */
+			status = "disabled";
+		};
+
+		pcie_ep6: pcie_ep@3900000 {
+			compatible = "fsl,lx2160ar2-pcie-ep", "fsl,ls-pcie-ep";
+			reg = <0x00 0x03900000 0x0 0x00100000
+			       0xa8 0x00000000 0x8 0x00000000>;
+			reg-names = "regs", "addr_space";
+			num-ob-windows = <8>;
+			num-ib-windows = <8>;
 			status = "disabled";
 		};
 
@@ -1751,4 +1823,12 @@ dpmac18: ethernet@12 {
 			};
 		};
 	};
+
+	firmware {
+		optee: optee {
+			compatible = "linaro,optee-tz";
+			method = "smc";
+			status = "disabled";
+		};
+	};
 };
diff --git a/arch/arm64/boot/dts/freescale/fsl-lx2162a-qds.dts b/arch/arm64/boot/dts/freescale/fsl-lx2162a-qds.dts
index e1defee1a..a1644ceed 100644
--- a/arch/arm64/boot/dts/freescale/fsl-lx2162a-qds.dts
+++ b/arch/arm64/boot/dts/freescale/fsl-lx2162a-qds.dts
@@ -167,6 +167,14 @@ mdio@7 { /* Slot #8 (secondary EMI) */
 	};
 };
 
+&can0 {
+	status = "okay";
+};
+
+&can1 {
+	status = "okay";
+};
+
 &crypto {
 	status = "okay";
 };
@@ -226,10 +234,17 @@ &emdio2 {
 };
 
 &esdhc0 {
+	sd-uhs-sdr104;
+	sd-uhs-sdr50;
+	sd-uhs-sdr25;
+	sd-uhs-sdr12;
 	status = "okay";
 };
 
 &esdhc1 {
+	mmc-hs200-1_8v;
+	mmc-hs400-1_8v;
+	bus-width = <8>;
 	status = "okay";
 };
 
@@ -302,11 +317,17 @@ temperature-sensor@4c {
 			rtc@51 {
 				compatible = "nxp,pcf2129";
 				reg = <0x51>;
+				/* IRQ_RTC_B -> IRQ11_B(CPLD) -> IRQ11(CPU), active low */
+				interrupts-extended = <&extirq 11 IRQ_TYPE_LEVEL_LOW>;
 			};
 		};
 	};
 };
 
+&optee {
+	status = "okay";
+};
+
 &sata0 {
 	status = "okay";
 };
diff --git a/arch/arm64/boot/dts/freescale/imx8mm-evk.dts b/arch/arm64/boot/dts/freescale/imx8mm-evk.dts
old mode 100644
new mode 100755
diff --git a/arch/arm64/boot/dts/freescale/imx8mm.dtsi b/arch/arm64/boot/dts/freescale/imx8mm.dtsi
old mode 100644
new mode 100755
diff --git a/arch/arm64/boot/dts/freescale/imx8mq-evk.dts b/arch/arm64/boot/dts/freescale/imx8mq-evk.dts
old mode 100644
new mode 100755
diff --git a/arch/arm64/boot/dts/freescale/imx8mq.dtsi b/arch/arm64/boot/dts/freescale/imx8mq.dtsi
old mode 100644
new mode 100755
diff --git a/arch/arm64/boot/dts/freescale/imx8qm-mek.dts b/arch/arm64/boot/dts/freescale/imx8qm-mek.dts
old mode 100644
new mode 100755
diff --git a/arch/arm64/boot/dts/freescale/imx8qm.dtsi b/arch/arm64/boot/dts/freescale/imx8qm.dtsi
old mode 100644
new mode 100755
diff --git a/arch/arm64/boot/dts/freescale/qoriq-bman-portals-sdk.dtsi b/arch/arm64/boot/dts/freescale/qoriq-bman-portals-sdk.dtsi
new file mode 100644
index 000000000..0a68ec4c0
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/qoriq-bman-portals-sdk.dtsi
@@ -0,0 +1,55 @@
+/*
+ * QorIQ BMan SDK Portals device tree nodes
+ *
+ * Copyright 2011-2016 Freescale Semiconductor Inc.
+ * Copyright 2017 NXP
+ *
+ * SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+ */
+
+&bportals {
+	bman-portal@0 {
+		cell-index = <0>;
+	};
+
+	bman-portal@10000 {
+		cell-index = <1>;
+	};
+
+	bman-portal@20000 {
+		cell-index = <2>;
+	};
+
+	bman-portal@30000 {
+		cell-index = <3>;
+	};
+
+	bman-portal@40000 {
+		cell-index = <4>;
+	};
+
+	bman-portal@50000 {
+		cell-index = <5>;
+	};
+
+	bman-portal@60000 {
+		cell-index = <6>;
+	};
+
+	bman-portal@70000 {
+		cell-index = <7>;
+	};
+
+	bman-portal@80000 {
+		cell-index = <8>;
+	};
+
+	bman-portal@90000 {
+		cell-index = <9>;
+	};
+
+	 bman-bpids@0 {
+		compatible = "fsl,bpid-range";
+		fsl,bpid-range = <32 32>;
+	};
+};
diff --git a/arch/arm64/boot/dts/freescale/qoriq-dpaa-eth.dtsi b/arch/arm64/boot/dts/freescale/qoriq-dpaa-eth.dtsi
new file mode 100644
index 000000000..d3ae39944
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/qoriq-dpaa-eth.dtsi
@@ -0,0 +1,72 @@
+/*
+ * QorIQ FMan v3 10g port #1 device tree stub [ controller @ offset 0x400000 ]
+ *
+ * Copyright 2012 - 2015 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+fsldpaa: fsl,dpaa {
+	compatible = "fsl,ls1043a-dpaa", "simple-bus", "fsl,dpaa";
+	ethernet@0 {
+		compatible = "fsl,dpa-ethernet";
+		fsl,fman-mac = <&enet0>;
+		dma-coherent;
+	};
+	ethernet@1 {
+		compatible = "fsl,dpa-ethernet";
+		fsl,fman-mac = <&enet1>;
+		dma-coherent;
+	};
+	ethernet@2 {
+		compatible = "fsl,dpa-ethernet";
+		fsl,fman-mac = <&enet2>;
+		dma-coherent;
+	};
+	ethernet@3 {
+		compatible = "fsl,dpa-ethernet";
+		fsl,fman-mac = <&enet3>;
+		dma-coherent;
+	};
+	ethernet@4 {
+		compatible = "fsl,dpa-ethernet";
+		fsl,fman-mac = <&enet4>;
+		dma-coherent;
+	};
+	ethernet@5 {
+		compatible = "fsl,dpa-ethernet";
+		fsl,fman-mac = <&enet5>;
+		dma-coherent;
+	};
+	ethernet@8 {
+		compatible = "fsl,dpa-ethernet";
+		fsl,fman-mac = <&enet6>;
+		dma-coherent;
+	};
+};
diff --git a/arch/arm64/boot/dts/freescale/qoriq-fman3-0-10g-0.dtsi b/arch/arm64/boot/dts/freescale/qoriq-fman3-0-10g-0.dtsi
index dbd2fc3ba..7886b94cc 100644
--- a/arch/arm64/boot/dts/freescale/qoriq-fman3-0-10g-0.dtsi
+++ b/arch/arm64/boot/dts/freescale/qoriq-fman3-0-10g-0.dtsi
@@ -9,19 +9,20 @@
 fman@1a00000 {
 	fman0_rx_0x10: port@90000 {
 		cell-index = <0x10>;
-		compatible = "fsl,fman-v3-port-rx";
+		compatible = "fsl,fman-v3-port-rx", "fsl,fman-port-10g-rx";
 		reg = <0x90000 0x1000>;
 		fsl,fman-10g-port;
 	};
 
 	fman0_tx_0x30: port@b0000 {
 		cell-index = <0x30>;
-		compatible = "fsl,fman-v3-port-tx";
+		compatible = "fsl,fman-v3-port-tx", "fsl,fman-port-10g-tx";
 		reg = <0xb0000 0x1000>;
 		fsl,fman-10g-port;
+		fsl,qman-channel-id = <0x800>;
 	};
 
-	ethernet@f0000 {
+	mac9: ethernet@f0000 {
 		cell-index = <0x8>;
 		compatible = "fsl,fman-memac";
 		reg = <0xf0000 0x1000>;
@@ -29,7 +30,7 @@ ethernet@f0000 {
 		pcsphy-handle = <&pcsphy6>;
 	};
 
-	mdio@f1000 {
+	mdio9: mdio@f1000 {
 		#address-cells = <1>;
 		#size-cells = <0>;
 		compatible = "fsl,fman-memac-mdio", "fsl,fman-xmdio";
diff --git a/arch/arm64/boot/dts/freescale/qoriq-fman3-0-10g-1.dtsi b/arch/arm64/boot/dts/freescale/qoriq-fman3-0-10g-1.dtsi
index 6fc5d2560..89b9d14b8 100644
--- a/arch/arm64/boot/dts/freescale/qoriq-fman3-0-10g-1.dtsi
+++ b/arch/arm64/boot/dts/freescale/qoriq-fman3-0-10g-1.dtsi
@@ -9,19 +9,20 @@
 fman@1a00000 {
 	fman0_rx_0x11: port@91000 {
 		cell-index = <0x11>;
-		compatible = "fsl,fman-v3-port-rx";
+		compatible = "fsl,fman-v3-port-rx", "fsl,fman-port-10g-rx";
 		reg = <0x91000 0x1000>;
 		fsl,fman-10g-port;
 	};
 
 	fman0_tx_0x31: port@b1000 {
 		cell-index = <0x31>;
-		compatible = "fsl,fman-v3-port-tx";
+		compatible = "fsl,fman-v3-port-tx", "fsl,fman-port-10g-tx";
 		reg = <0xb1000 0x1000>;
 		fsl,fman-10g-port;
+		fsl,qman-channel-id = <0x801>;
 	};
 
-	ethernet@f2000 {
+	mac10: ethernet@f2000 {
 		cell-index = <0x9>;
 		compatible = "fsl,fman-memac";
 		reg = <0xf2000 0x1000>;
@@ -29,7 +30,7 @@ ethernet@f2000 {
 		pcsphy-handle = <&pcsphy7>;
 	};
 
-	mdio@f3000 {
+	mdio10: mdio@f3000 {
 		#address-cells = <1>;
 		#size-cells = <0>;
 		compatible = "fsl,fman-memac-mdio", "fsl,fman-xmdio";
diff --git a/arch/arm64/boot/dts/freescale/qoriq-fman3-0-1g-0.dtsi b/arch/arm64/boot/dts/freescale/qoriq-fman3-0-1g-0.dtsi
index 4e02276fc..60ed4473e 100644
--- a/arch/arm64/boot/dts/freescale/qoriq-fman3-0-1g-0.dtsi
+++ b/arch/arm64/boot/dts/freescale/qoriq-fman3-0-1g-0.dtsi
@@ -9,14 +9,15 @@
 fman@1a00000 {
 	fman0_rx_0x08: port@88000 {
 		cell-index = <0x8>;
-		compatible = "fsl,fman-v3-port-rx";
+		compatible = "fsl,fman-v3-port-rx", "fsl,fman-port-1g-rx";
 		reg = <0x88000 0x1000>;
 	};
 
 	fman0_tx_0x28: port@a8000 {
 		cell-index = <0x28>;
-		compatible = "fsl,fman-v3-port-tx";
+		compatible = "fsl,fman-v3-port-tx", "fsl,fman-port-1g-tx";
 		reg = <0xa8000 0x1000>;
+		fsl,qman-channel-id = <0x802>;
 	};
 
 	ethernet@e0000 {
diff --git a/arch/arm64/boot/dts/freescale/qoriq-fman3-0-1g-1.dtsi b/arch/arm64/boot/dts/freescale/qoriq-fman3-0-1g-1.dtsi
index 0312fa43f..69de2c1ff 100644
--- a/arch/arm64/boot/dts/freescale/qoriq-fman3-0-1g-1.dtsi
+++ b/arch/arm64/boot/dts/freescale/qoriq-fman3-0-1g-1.dtsi
@@ -9,14 +9,15 @@
 fman@1a00000 {
 	fman0_rx_0x09: port@89000 {
 		cell-index = <0x9>;
-		compatible = "fsl,fman-v3-port-rx";
+		compatible = "fsl,fman-v3-port-rx", "fsl,fman-port-1g-rx";
 		reg = <0x89000 0x1000>;
 	};
 
 	fman0_tx_0x29: port@a9000 {
 		cell-index = <0x29>;
-		compatible = "fsl,fman-v3-port-tx";
+		compatible = "fsl,fman-v3-port-tx", "fsl,fman-port-1g-tx";
 		reg = <0xa9000 0x1000>;
+		fsl,qman-channel-id = <0x803>;
 	};
 
 	ethernet@e2000 {
diff --git a/arch/arm64/boot/dts/freescale/qoriq-fman3-0-1g-2.dtsi b/arch/arm64/boot/dts/freescale/qoriq-fman3-0-1g-2.dtsi
index af2df0797..981bbfcaa 100644
--- a/arch/arm64/boot/dts/freescale/qoriq-fman3-0-1g-2.dtsi
+++ b/arch/arm64/boot/dts/freescale/qoriq-fman3-0-1g-2.dtsi
@@ -9,14 +9,15 @@
 fman@1a00000 {
 	fman0_rx_0x0a: port@8a000 {
 		cell-index = <0xa>;
-		compatible = "fsl,fman-v3-port-rx";
+		compatible = "fsl,fman-v3-port-rx", "fsl,fman-port-1g-rx";
 		reg = <0x8a000 0x1000>;
 	};
 
 	fman0_tx_0x2a: port@aa000 {
 		cell-index = <0x2a>;
-		compatible = "fsl,fman-v3-port-tx";
+		compatible = "fsl,fman-v3-port-tx", "fsl,fman-port-1g-tx";
 		reg = <0xaa000 0x1000>;
+		fsl,qman-channel-id = <0x804>;
 	};
 
 	ethernet@e4000 {
diff --git a/arch/arm64/boot/dts/freescale/qoriq-fman3-0-1g-3.dtsi b/arch/arm64/boot/dts/freescale/qoriq-fman3-0-1g-3.dtsi
index 4ac98dc8b..956b1b9df 100644
--- a/arch/arm64/boot/dts/freescale/qoriq-fman3-0-1g-3.dtsi
+++ b/arch/arm64/boot/dts/freescale/qoriq-fman3-0-1g-3.dtsi
@@ -9,14 +9,15 @@
 fman@1a00000 {
 	fman0_rx_0x0b: port@8b000 {
 		cell-index = <0xb>;
-		compatible = "fsl,fman-v3-port-rx";
+		compatible = "fsl,fman-v3-port-rx", "fsl,fman-port-1g-rx";
 		reg = <0x8b000 0x1000>;
 	};
 
 	fman0_tx_0x2b: port@ab000 {
 		cell-index = <0x2b>;
-		compatible = "fsl,fman-v3-port-tx";
+		compatible = "fsl,fman-v3-port-tx", "fsl,fman-port-1g-tx";
 		reg = <0xab000 0x1000>;
+		fsl,qman-channel-id = <0x805>;
 	};
 
 	ethernet@e6000 {
diff --git a/arch/arm64/boot/dts/freescale/qoriq-fman3-0-1g-4.dtsi b/arch/arm64/boot/dts/freescale/qoriq-fman3-0-1g-4.dtsi
index bd932d8b0..52899ce69 100644
--- a/arch/arm64/boot/dts/freescale/qoriq-fman3-0-1g-4.dtsi
+++ b/arch/arm64/boot/dts/freescale/qoriq-fman3-0-1g-4.dtsi
@@ -9,14 +9,15 @@
 fman@1a00000 {
 	fman0_rx_0x0c: port@8c000 {
 		cell-index = <0xc>;
-		compatible = "fsl,fman-v3-port-rx";
+		compatible = "fsl,fman-v3-port-rx", "fsl,fman-port-1g-rx";
 		reg = <0x8c000 0x1000>;
 	};
 
 	fman0_tx_0x2c: port@ac000 {
 		cell-index = <0x2c>;
-		compatible = "fsl,fman-v3-port-tx";
+		compatible = "fsl,fman-v3-port-tx", "fsl,fman-port-1g-tx";
 		reg = <0xac000 0x1000>;
+		fsl,qman-channel-id = <0x806>;
 	};
 
 	ethernet@e8000 {
diff --git a/arch/arm64/boot/dts/freescale/qoriq-fman3-0-1g-5.dtsi b/arch/arm64/boot/dts/freescale/qoriq-fman3-0-1g-5.dtsi
index 7de1c5203..fe8c4c29b 100644
--- a/arch/arm64/boot/dts/freescale/qoriq-fman3-0-1g-5.dtsi
+++ b/arch/arm64/boot/dts/freescale/qoriq-fman3-0-1g-5.dtsi
@@ -9,14 +9,15 @@
 fman@1a00000 {
 	fman0_rx_0x0d: port@8d000 {
 		cell-index = <0xd>;
-		compatible = "fsl,fman-v3-port-rx";
+		compatible = "fsl,fman-v3-port-rx", "fsl,fman-port-1g-rx";
 		reg = <0x8d000 0x1000>;
 	};
 
 	fman0_tx_0x2d: port@ad000 {
 		cell-index = <0x2d>;
-		compatible = "fsl,fman-v3-port-tx";
+		compatible = "fsl,fman-v3-port-tx", "fsl,fman-port-1g-tx";
 		reg = <0xad000 0x1000>;
+		fsl,qman-channel-id = <0x807>;
 	};
 
 	ethernet@ea000 {
diff --git a/arch/arm64/boot/dts/freescale/qoriq-fman3-0-6oh.dtsi b/arch/arm64/boot/dts/freescale/qoriq-fman3-0-6oh.dtsi
new file mode 100644
index 000000000..2d0df20db
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/qoriq-fman3-0-6oh.dtsi
@@ -0,0 +1,47 @@
+/*
+ * QorIQ FMan v3 OH ports device tree
+ *
+ * Copyright 2012-2015 Freescale Semiconductor Inc.
+ *
+ * SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+ */
+
+fman@1a00000 {
+
+	fman0_oh1: port@82000 {
+		cell-index = <0>;
+		compatible = "fsl,fman-port-oh";
+		reg = <0x82000 0x1000>;
+	};
+
+	fman0_oh2: port@83000 {
+		cell-index = <1>;
+		compatible = "fsl,fman-port-oh";
+		reg = <0x83000 0x1000>;
+	};
+
+	fman0_oh3: port@84000 {
+		cell-index = <2>;
+		compatible = "fsl,fman-port-oh";
+		reg = <0x84000 0x1000>;
+	};
+
+	fman0_oh4: port@85000 {
+		cell-index = <3>;
+		compatible = "fsl,fman-port-oh";
+		reg = <0x85000 0x1000>;
+	};
+
+	fman0_oh5: port@86000 {
+		cell-index = <4>;
+		compatible = "fsl,fman-port-oh";
+		reg = <0x86000 0x1000>;
+	};
+
+	fman0_oh6: port@87000 {
+		cell-index = <5>;
+		compatible = "fsl,fman-port-oh";
+		reg = <0x87000 0x1000>;
+	};
+
+};
diff --git a/arch/arm64/boot/dts/freescale/qoriq-fman3-0.dtsi b/arch/arm64/boot/dts/freescale/qoriq-fman3-0.dtsi
index ae1c2abaa..99cd3c75a 100644
--- a/arch/arm64/boot/dts/freescale/qoriq-fman3-0.dtsi
+++ b/arch/arm64/boot/dts/freescale/qoriq-fman3-0.dtsi
@@ -23,45 +23,95 @@ fman0: fman@1a00000 {
 	ptimer-handle = <&ptp_timer0>;
 	dma-coherent;
 
+	cc {
+		compatible = "fsl,fman-cc";
+	};
+
 	muram@0 {
 		compatible = "fsl,fman-muram";
 		reg = <0x0 0x60000>;
 	};
 
+	bmi@80000 {
+		compatible = "fsl,fman-bmi";
+		reg = <0x80000 0x400>;
+	};
+
+	qmi@80400 {
+		compatible = "fsl,fman-qmi";
+		reg = <0x80400 0x400>;
+	};
+
 	fman0_oh_0x2: port@82000 {
 		cell-index = <0x2>;
 		compatible = "fsl,fman-v3-port-oh";
 		reg = <0x82000 0x1000>;
+		fsl,qman-channel-id = <0x809>;
 	};
 
 	fman0_oh_0x3: port@83000 {
 		cell-index = <0x3>;
 		compatible = "fsl,fman-v3-port-oh";
 		reg = <0x83000 0x1000>;
+		fsl,qman-channel-id = <0x80a>;
 	};
 
 	fman0_oh_0x4: port@84000 {
 		cell-index = <0x4>;
 		compatible = "fsl,fman-v3-port-oh";
 		reg = <0x84000 0x1000>;
+		fsl,qman-channel-id = <0x80b>;
 	};
 
 	fman0_oh_0x5: port@85000 {
 		cell-index = <0x5>;
 		compatible = "fsl,fman-v3-port-oh";
 		reg = <0x85000 0x1000>;
+		fsl,qman-channel-id = <0x80c>;
 	};
 
 	fman0_oh_0x6: port@86000 {
 		cell-index = <0x6>;
 		compatible = "fsl,fman-v3-port-oh";
 		reg = <0x86000 0x1000>;
+		fsl,qman-channel-id = <0x80d>;
 	};
 
 	fman0_oh_0x7: port@87000 {
 		cell-index = <0x7>;
 		compatible = "fsl,fman-v3-port-oh";
 		reg = <0x87000 0x1000>;
+		fsl,qman-channel-id = <0x80e>;
+	};
+
+	policer@c0000 {
+		compatible = "fsl,fman-policer";
+		reg = <0xc0000 0x1000>;
+	};
+
+	keygen@c1000 {
+		compatible = "fsl,fman-keygen";
+		reg = <0xc1000 0x1000>;
+	};
+
+	dma@c2000 {
+		compatible = "fsl,fman-dma";
+		reg = <0xc2000 0x1000>;
+	};
+
+	fpm@c3000 {
+		compatible = "fsl,fman-fpm";
+		reg = <0xc3000 0x1000>;
+	};
+
+	parser@c7000 {
+		compatible = "fsl,fman-parser";
+		reg = <0xc7000 0x1000>;
+	};
+
+	vsps@dc000 {
+		compatible = "fsl,fman-vsps";
+		reg = <0xdc000 0x1000>;
 	};
 
 	mdio0: mdio@fc000 {
@@ -80,7 +130,7 @@ xmdio0: mdio@fd000 {
 };
 
 ptp_timer0: ptp-timer@1afe000 {
-	compatible = "fsl,fman-ptp-timer";
+	compatible = "fsl,fman-ptp-timer", "fsl,fman-rtc";
 	reg = <0x0 0x1afe000 0x0 0x1000>;
 	interrupts = <GIC_SPI 44 IRQ_TYPE_LEVEL_HIGH>;
 	clocks = <&clockgen QORIQ_CLK_FMAN 0>;
diff --git a/arch/arm64/boot/dts/freescale/qoriq-qman-portals-sdk.dtsi b/arch/arm64/boot/dts/freescale/qoriq-qman-portals-sdk.dtsi
new file mode 100644
index 000000000..d3abfaf6e
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/qoriq-qman-portals-sdk.dtsi
@@ -0,0 +1,38 @@
+/*
+ * QorIQ QMan SDK Portals device tree nodes
+ *
+ * Copyright 2011-2016 Freescale Semiconductor Inc.
+ * Copyright 2017 NXP
+ *
+ * SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+ */
+
+&qportals {
+	qman-fqids@0 {
+		compatible = "fsl,fqid-range";
+		fsl,fqid-range = <256 256>;
+	};
+
+	qman-fqids@1 {
+		compatible = "fsl,fqid-range";
+		fsl,fqid-range = <32768 32768>;
+	};
+
+	qman-pools@0 {
+		compatible = "fsl,pool-channel-range";
+		fsl,pool-channel-range = <0x401 0xf>;
+	};
+
+	qman-cgrids@0 {
+		compatible = "fsl,cgrid-range";
+		fsl,cgrid-range = <0 256>;
+	};
+
+	qman-ceetm@0 {
+		compatible = "fsl,qman-ceetm";
+		fsl,ceetm-lfqid-range = <0xf00000 0x1000>;
+		fsl,ceetm-sp-range = <0 16>;
+		fsl,ceetm-lni-range = <0 8>;
+		fsl,ceetm-channel-range = <0 32>;
+	};
+};
diff --git a/arch/arm64/boot/dts/freescale/s32v234-evb.dts b/arch/arm64/boot/dts/freescale/s32v234-evb.dts
index 4b802518c..70dfa31d9 100644
--- a/arch/arm64/boot/dts/freescale/s32v234-evb.dts
+++ b/arch/arm64/boot/dts/freescale/s32v234-evb.dts
@@ -1,7 +1,7 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright 2015-2016 Freescale Semiconductor, Inc.
- * Copyright 2016-2017 NXP
+ * Copyright 2016-2017,2019 NXP
  */
 
 /dts-v1/;
@@ -16,10 +16,105 @@ chosen {
 	};
 };
 
+&can0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_can0>;
+	status = "okay";
+};
+
+&can1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_can1>;
+	status = "okay";
+};
+
+&edma {
+	status = "okay";
+};
+
+&siul2 {
+	status = "okay";
+	s32v234-evb {
+
+		/* Format of pins: MSCR_IDX PAD_CONFIGURATION If you know the
+		 * IMCR_IDX instead of MSCR_IDX, add 512 to it as the Reference
+		 * Manual states.
+		 */
+
+		pinctrl_can0: can0grp {
+			fsl,pins = <
+				S32V234_PAD_PA2__CAN_FD0_TXD
+				S32V234_PAD_PA3__CAN_FD0_RXD_OUT
+				S32V234_PAD_PA3__CAN_FD0_RXD_IN
+			>;
+		};
+
+		pinctrl_can1: can1grp {
+			fsl,pins = <
+				S32V234_PAD_PA4__CAN_FD1_TXD
+				S32V234_PAD_PA5__CAN_FD1_RXD_OUT
+				S32V234_PAD_PA5__CAN_FD1_RXD_IN
+			>;
+		};
+
+		pinctrl_uart0: uart0grp {
+			fsl,pins = <
+				S32V234_PAD_PA12__UART0_TXD
+				S32V234_PAD_PA11__UART0_RXD_OUT
+				S32V234_PAD_PA11__UART0_RXD_IN
+			>;
+		};
+
+		pinctrl_uart1: uart1grp {
+			fsl,pins = <
+				S32V234_PAD_PA14__UART1_TXD
+				S32V234_PAD_PA13__UART1_RXD_OUT
+				S32V234_PAD_PA13__UART1_RXD_IN
+			>;
+		};
+
+		pinctrl_usdhc0: usdhc0grp {
+			fsl,pins = <
+				S32V234_PAD_PK6__USDHC_CLK_OUT
+				S32V234_PAD_PK6__USDHC_CLK_IN
+				S32V234_PAD_PK7__USDHC_CMD_OUT
+				S32V234_PAD_PK7__USDHC_CMD_IN
+				S32V234_PAD_PK8__USDHC_DAT0_OUT
+				S32V234_PAD_PK8__USDHC_DAT0_IN
+				S32V234_PAD_PK9__USDHC_DAT1_OUT
+				S32V234_PAD_PK9__USDHC_DAT1_IN
+				S32V234_PAD_PK10__USDHC_DAT2_OUT
+				S32V234_PAD_PK10__USDHC_DAT2_IN
+				S32V234_PAD_PK11__USDHC_DAT3_OUT
+				S32V234_PAD_PK11__USDHC_DAT3_IN
+				S32V234_PAD_PK15__USDHC_DAT4_OUT
+				S32V234_PAD_PK15__USDHC_DAT4_IN
+				S32V234_PAD_PL0__USDHC_DAT5_OUT
+				S32V234_PAD_PL0__USDHC_DAT5_IN
+				S32V234_PAD_PL1__USDHC_DAT6_OUT
+				S32V234_PAD_PL1__USDHC_DAT6_IN
+				S32V234_PAD_PL2__USDHC_DAT7_OUT
+				S32V234_PAD_PL2__USDHC_DAT7_IN
+			>;
+		};
+	};
+};
+
 &uart0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart0>;
 	status = "okay";
 };
 
 &uart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart1>;
+	status = "okay";
+};
+
+&usdhc0 {
+	no-1-8-v;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc0>;
 	status = "okay";
 };
diff --git a/arch/arm64/boot/dts/freescale/s32v234-sbc.dts b/arch/arm64/boot/dts/freescale/s32v234-sbc.dts
new file mode 100644
index 000000000..2b5b1e305
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/s32v234-sbc.dts
@@ -0,0 +1,187 @@
+/*
+ * Copyright 2015-2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 MicroSys Electronics GmbH
+ * Copyright 2018-2019 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+/dts-v1/;
+
+#include "s32v234.dtsi"
+
+/ {
+	model = "Freescale S32V234";
+	compatible = "fsl,s32v234-sbc", "fsl,s32v234";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+};
+
+&can0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_can0>;
+	status = "okay";
+};
+
+&can1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_can1>;
+	status = "okay";
+};
+
+&edma {
+	status = "okay";
+};
+
+&fec {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_enet>;
+	phy-mode = "rgmii-id";
+	phy-handle = <&phy0>;
+	status = "okay";
+
+	mdio {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		phy0: ethernet-phy@1 {
+			reg = <1>;
+		};
+	};
+};
+
+&siul2 {
+	status = "okay";
+
+	s32v234-sbc {
+		/* Format of pins: MSCR_IDX PAD_CONFIGURATION If you know the
+		 * IMCR_IDX instead of MSCR_IDX, add 512 to it as the Reference
+		 * Manual states.
+		 */
+
+		pinctrl_can0: can0grp {
+			fsl,pins = <
+				S32V234_PAD_PA2__CAN_FD0_TXD
+				S32V234_PAD_PA3__CAN_FD0_RXD_OUT
+				S32V234_PAD_PA3__CAN_FD0_RXD_IN
+				/*
+				 * Configure pin C12 as GPIO[6] in MSCR#6.
+				 * Effect: the S-pin at CAN is not longer
+				 * flowting at ~0.75V, but driven to low ~0.0V.
+				 */
+				S32V234_MSCR_PA6 (PAD_CTL_MUX_MODE_ALT0 \
+							| PAD_CTL_OBE \
+							| PAD_CTL_DSE_34 \
+							| PAD_CTL_PUS_33K_UP)
+			>;
+		};
+
+		pinctrl_can1: can1grp {
+			fsl,pins = <
+				S32V234_PAD_PA4__CAN_FD1_TXD
+				S32V234_PAD_PA5__CAN_FD1_RXD_OUT
+				S32V234_PAD_PA5__CAN_FD1_RXD_IN
+				/*
+				 * Configure pin C11 as GPIO[7] in MSCR#7.
+				 * Effect: the S-pin at CAN is not longer
+				 * flowting at ~0.39V, but driven to low ~0.0V.
+				 */
+				S32V234_MSCR_PA7 (PAD_CTL_MUX_MODE_ALT0 \
+							| PAD_CTL_OBE \
+							| PAD_CTL_DSE_34 \
+							| PAD_CTL_PUS_33K_UP)
+			>;
+		};
+
+		pinctrl_enet: enetgrp {
+			fsl,pins = <
+				S32V234_PAD_PC13__MDC
+				S32V234_PAD_PC14__MDIO_OUT
+				S32v234_PAD_PC14__MDIO_IN
+				S32V234_PAD_PC15__TXCLK_OUT
+				S32V234_PAD_PC15__TXCLK_IN
+				S32V234_PAD_PD0__RXCLK_OUT
+				S32V234_PAD_PD0__RXCLK_IN
+				S32V234_PAD_PD1__RX_D0_OUT
+				S32V234_PAD_PD1__RX_D0_IN
+				S32V234_PAD_PD2__RX_D1_OUT
+				S32V234_PAD_PD2__RX_D1_IN
+				S32V234_PAD_PD3__RX_D2_OUT
+				S32V234_PAD_PD3__RX_D2_IN
+				S32V234_PAD_PD4__RX_D3_OUT
+				S32V234_PAD_PD4__RX_D3_IN
+				S32V234_PAD_PD4__RX_DV_OUT
+				S32V234_PAD_PD4__RX_DV_IN
+				S32V234_PAD_PD7__TX_D0_OUT
+				S32V234_PAD_PD8__TX_D1_OUT
+				S32V234_PAD_PD9__TX_D2_OUT
+				S32V234_PAD_PD10__TX_D3_OUT
+				S32V234_PAD_PD11__TX_EN_OUT
+			>;
+		};
+
+		pinctrl_uart0: uart0grp {
+			fsl,pins = <
+				S32V234_PAD_PA12__UART0_TXD
+				S32V234_PAD_PA11__UART0_RXD_OUT
+				S32V234_PAD_PA11__UART0_RXD_IN
+			>;
+		};
+
+		pinctrl_uart1: uart1grp {
+			fsl,pins = <
+				S32V234_PAD_PA14__UART1_TXD
+				S32V234_PAD_PA13__UART1_RXD_OUT
+				S32V234_PAD_PA13__UART1_RXD_IN
+			>;
+		};
+
+		pinctrl_usdhc0: usdhc0grp {
+			fsl,pins = <
+				S32V234_PAD_PK6__USDHC_CLK_OUT
+				S32V234_PAD_PK6__USDHC_CLK_IN
+				S32V234_PAD_PK7__USDHC_CMD_OUT
+				S32V234_PAD_PK7__USDHC_CMD_IN
+				S32V234_PAD_PK8__USDHC_DAT0_OUT
+				S32V234_PAD_PK8__USDHC_DAT0_IN
+				S32V234_PAD_PK9__USDHC_DAT1_OUT
+				S32V234_PAD_PK9__USDHC_DAT1_IN
+				S32V234_PAD_PK10__USDHC_DAT2_OUT
+				S32V234_PAD_PK10__USDHC_DAT2_IN
+				S32V234_PAD_PK11__USDHC_DAT3_OUT
+				S32V234_PAD_PK11__USDHC_DAT3_IN
+				S32V234_PAD_PK15__USDHC_DAT4_OUT
+				S32V234_PAD_PK15__USDHC_DAT4_IN
+				S32V234_PAD_PL0__USDHC_DAT5_OUT
+				S32V234_PAD_PL0__USDHC_DAT5_IN
+				S32V234_PAD_PL1__USDHC_DAT6_OUT
+				S32V234_PAD_PL1__USDHC_DAT6_IN
+				S32V234_PAD_PL2__USDHC_DAT7_OUT
+				S32V234_PAD_PL2__USDHC_DAT7_IN
+			>;
+		};
+	};
+};
+
+&uart0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart0>;
+	status = "okay";
+};
+
+&uart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart1>;
+	status = "okay";
+};
+
+&usdhc0 {
+	no-1-8-v;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc0>;
+	status = "okay";
+};
diff --git a/arch/arm64/boot/dts/freescale/s32v234.dtsi b/arch/arm64/boot/dts/freescale/s32v234.dtsi
index ba0b5305d..c162b3049 100644
--- a/arch/arm64/boot/dts/freescale/s32v234.dtsi
+++ b/arch/arm64/boot/dts/freescale/s32v234.dtsi
@@ -5,6 +5,8 @@
  */
 
 #include <dt-bindings/interrupt-controller/arm-gic.h>
+#include <dt-bindings/clock/s32v234-clock.h>
+#include <dt-bindings/pinctrl/s32v234-pinctrl.h>
 
 /memreserve/ 0x80000000 0x00010000;
 
@@ -15,10 +17,28 @@ / {
 	#size-cells = <2>;
 
 	aliases {
+		can0 = &can0;
+		can1 = &can1;
 		serial0 = &uart0;
 		serial1 = &uart1;
 	};
 
+	clocks {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		firc {
+			compatible = "fixed-clock";
+			clock-frequency = <48000000>;
+			#clock-cells = <0>;
+		};
+		fxosc {
+			compatible = "fixed-clock";
+			clock-frequency = <40000000>;
+			#clock-cells = <0>;
+		};
+	};
+
 	cpus {
 		#address-cells = <2>;
 		#size-cells = <0>;
@@ -112,12 +132,117 @@ aips0: bus@40000000 {
 			reg = <0x0 0x40000000 0x0 0x7d000>;
 			ranges;
 
+			edma: dma-controller@40002000 {
+				#dma-cells = <2>;
+				compatible = "fsl,s32v234-edma";
+				reg = <0x0 0x40002000 0x0 0x2000>,
+				      <0x0 0x40031000 0x0 0x1000>,
+				      <0x0 0x400A1000 0x0 0x1000>;
+				dma-channels = <32>;
+				interrupts = <GIC_SPI 8 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 9 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 10 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "edma-tx_0-15",
+						  "edma-tx_16-31",
+						  "edma-err";
+				clock-names = "dmamux0", "dmamux1";
+				clocks = <&clks S32V234_CLK_SYS6>,
+					 <&clks S32V234_CLK_SYS6>;
+				status = "disabled";
+			};
+
+			fec: ethernet@40032000 {
+				compatible = "fsl,s32v234-fec";
+				reg = <0x0 0x40032000 0x0 0x1000>;
+				interrupt-names = "int0", "int1", "int2", "pps";
+				interrupts = <GIC_SPI 38 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 37 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 36 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 35 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&clks S32V234_CLK_SYS6>,
+					 <&clks S32V234_CLK_SYS3>,
+					 <&clks S32V234_CLK_ENET_TIME>,
+					 <&clks S32V234_CLK_ENET>,
+					 <&clks S32V234_CLK_ENET_TIME>;
+				clock-names = "ipg", "ahb", "ptp",
+					      "enet_clk_ref",
+					      "enet_out";
+				fsl,num-tx-queues = <3>;
+				fsl,num-rx-queues = <3>;
+				status = "disabled";
+			};
+
+			clks: mc_cgm0@4003c000 {
+				compatible = "fsl,s32v234-mc_cgm0";
+				reg = <0x0 0x4003C000 0x0 0x1000>;
+				#clock-cells = <1>;
+			};
+
+			mc_cgm1: mc_cgm1@4003F000 {
+				compatible = "fsl,s32v234-mc_cgm1";
+				reg = <0x0 0x4003F000 0x0 0x1000>;
+			};
+
+			mc_cgm2: mc_cgm2@40042000 {
+				compatible = "fsl,s32v234-mc_cgm2";
+				reg = <0x0 0x40042000 0x0 0x1000>;
+			};
+
+			mc_cgm3: mc_cgm3@40045000 {
+				compatible = "fsl,s32v234-mc_cgm3";
+				reg = <0x0 0x40045000 0x0 0x1000>;
+			};
+
+			mc_me: mc_me@4004a000 {
+				compatible = "fsl,s32v234-mc_me";
+				reg = <0x0 0x4004A000 0x0 0x1000>;
+			};
+
 			uart0: serial@40053000 {
 				compatible = "fsl,s32v234-linflexuart";
 				reg = <0x0 0x40053000 0x0 0x1000>;
 				interrupts = <GIC_SPI 59 IRQ_TYPE_EDGE_RISING>;
+				clocks = <&clks S32V234_CLK_LIN>;
+				clock-names = "lin";
+				dmas = <&edma 0 20>,
+				       <&edma 0 19>;
+				dma-names = "rx", "tx";
+				status = "disabled";
+			};
+
+			can0: flexcan@40055000 {
+				compatible = "fsl,s32v234-flexcan";
+				reg = <0x0 0x40055000 0x0 0x1000>;
+				interrupts = <GIC_SPI 42 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&clks S32V234_CLK_CAN>,
+					 <&clks S32V234_CLK_CAN>;
+				clock-names = "ipg", "per";
+				status = "disabled";
+			};
+
+			usdhc0: usdhc@4005d000 {
+				compatible = "fsl,s32v234-usdhc";
+				reg = <0x0 0x4005D000 0x0 0x1000>;
+				interrupts = <0 28 4>;
+				clocks = <&clks S32V234_CLK_SDHC>,
+					 <&clks S32V234_CLK_SDHC>,
+					 <&clks S32V234_CLK_SDHC>;
+				clock-names = "ipg", "ahb", "per";
+				bus-width = <8>;
 				status = "disabled";
 			};
+
+			siul2: siul@4006c000 {
+				compatible = "fsl,s32v234-siul2";
+				reg = <0x0 0x4006C000 0x0 0x1794>;
+				status = "disabled";
+			};
+
+			src: src@4007c000 {
+				compatible = "fsl,s32v234-src";
+				reg = <0x0 0x4007C000 0x0 0x1000>;
+				#reset-cells = <1>;
+			};
 		};
 
 		aips1: bus@40080000 {
@@ -132,6 +257,21 @@ uart1: serial@400bc000 {
 				compatible = "fsl,s32v234-linflexuart";
 				reg = <0x0 0x400bc000 0x0 0x1000>;
 				interrupts = <GIC_SPI 60 IRQ_TYPE_EDGE_RISING>;
+				clocks = <&clks S32V234_CLK_LIN>;
+				clock-names = "lin";
+				dmas = <&edma 1 13>,
+				       <&edma 1 12>;
+				dma-names = "rx", "tx";
+				status = "disabled";
+			};
+
+			can1: flexcan@400be000 {
+				compatible = "fsl,s32v234-flexcan";
+				reg = <0x0 0x400be000 0x0 0x1000>;
+				interrupts = <GIC_SPI 44 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&clks S32V234_CLK_CAN>,
+					 <&clks S32V234_CLK_CAN>;
+				clock-names = "ipg", "per";
 				status = "disabled";
 			};
 		};
diff --git a/drivers/clk/imx/Kconfig b/drivers/clk/imx/Kconfig
index 935792e3c..cd55c302e 100644
--- a/drivers/clk/imx/Kconfig
+++ b/drivers/clk/imx/Kconfig
@@ -99,6 +99,13 @@ config CLK_IMX8QXP
 	help
 	  Build the driver for IMX8QXP SCU based clocks.
 
+config CLK_IMX8ULP
+	tristate "IMX8ULP CCM Clock Driver"
+	depends on ARCH_MXC || COMPILE_TEST
+	select RESET_CONTROLLER
+	help
+	    Build the driver for i.MX8ULP CCM Clock Driver
+
 config CLK_IMX93
 	tristate "IMX93 CCM Clock Driver"
 	depends on ARCH_MXC || COMPILE_TEST
diff --git a/drivers/clk/imx/Makefile b/drivers/clk/imx/Makefile
index bac65a896..983c149c4 100644
--- a/drivers/clk/imx/Makefile
+++ b/drivers/clk/imx/Makefile
@@ -25,15 +25,19 @@ obj-$(CONFIG_MXC_CLK) += mxc-clk.o
 
 obj-$(CONFIG_CLK_IMX8MM) += clk-imx8mm.o
 obj-$(CONFIG_CLK_IMX8MN) += clk-imx8mn.o
-obj-$(CONFIG_CLK_IMX8MP) += clk-imx8mp.o
+obj-$(CONFIG_CLK_IMX8MP) += clk-imx8mp.o clk-blk-ctrl.o
 obj-$(CONFIG_CLK_IMX8MQ) += clk-imx8mq.o
 
 obj-$(CONFIG_CLK_IMX93) += clk-imx93.o
 
 obj-$(CONFIG_MXC_CLK_SCU) += clk-imx-scu.o clk-imx-lpcg-scu.o
 clk-imx-scu-$(CONFIG_CLK_IMX8QXP) += clk-scu.o clk-imx8qxp.o \
-				     clk-imx8qxp-rsrc.o clk-imx8qm-rsrc.o
+				     clk-imx8qxp-rsrc.o clk-imx8qm-rsrc.o \
+				     clk-imx8dxl-rsrc.o
 clk-imx-lpcg-scu-$(CONFIG_CLK_IMX8QXP) += clk-lpcg-scu.o clk-imx8qxp-lpcg.o
+obj-$(CONFIG_CLK_IMX8QXP) += clk-imx8qxp-acm.o clk-imx8qm-acm.o clk-imx8dxl-acm.o clk-imx-acm-utils.o
+
+obj-$(CONFIG_CLK_IMX8ULP) += clk-imx8ulp.o
 
 obj-$(CONFIG_CLK_IMX1)   += clk-imx1.o
 obj-$(CONFIG_CLK_IMX25)  += clk-imx25.o
diff --git a/drivers/clk/imx/clk-blk-ctrl.c b/drivers/clk/imx/clk-blk-ctrl.c
new file mode 100644
index 000000000..e36035b3e
--- /dev/null
+++ b/drivers/clk/imx/clk-blk-ctrl.c
@@ -0,0 +1,342 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright 2020 NXP.
+ */
+
+#include <linux/clk.h>
+#include <linux/reset-controller.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/types.h>
+
+#include "clk.h"
+#include "clk-blk-ctrl.h"
+
+struct reset_hw {
+	u32 offset;
+	u32 shift;
+	u32 mask;
+	unsigned long asserted;
+};
+
+struct pm_safekeep_info {
+	uint32_t *regs_values;
+	uint32_t *regs_offsets;
+	uint32_t regs_num;
+};
+
+struct imx_blk_ctrl_drvdata {
+	void __iomem *base;
+	struct reset_controller_dev rcdev;
+	struct reset_hw *rst_hws;
+	struct pm_safekeep_info pm_info;
+
+	spinlock_t *lock;
+};
+
+static int imx_blk_ctrl_reset_set(struct reset_controller_dev *rcdev,
+				  unsigned long id, bool assert)
+{
+	struct imx_blk_ctrl_drvdata *drvdata = container_of(rcdev,
+			struct imx_blk_ctrl_drvdata, rcdev);
+	unsigned int offset = drvdata->rst_hws[id].offset;
+	unsigned int shift = drvdata->rst_hws[id].shift;
+	unsigned int mask = drvdata->rst_hws[id].mask;
+	void __iomem *reg_addr = drvdata->base + offset;
+	unsigned long flags;
+	u32 reg;
+
+	if (!assert && !test_bit(1, &drvdata->rst_hws[id].asserted))
+		return -ENODEV;
+
+	if (assert && !test_and_set_bit(1, &drvdata->rst_hws[id].asserted))
+		pm_runtime_get_sync(rcdev->dev);
+
+	spin_lock_irqsave(drvdata->lock, flags);
+
+	reg = readl(reg_addr);
+	if (assert)
+		writel(reg & ~(mask << shift), reg_addr);
+	else
+		writel(reg | (mask << shift), reg_addr);
+
+	spin_unlock_irqrestore(drvdata->lock, flags);
+
+	if (!assert && test_and_clear_bit(1, &drvdata->rst_hws[id].asserted))
+		pm_runtime_put_sync(rcdev->dev);
+
+	return 0;
+}
+
+static int imx_blk_ctrl_reset_reset(struct reset_controller_dev *rcdev,
+					   unsigned long id)
+{
+	imx_blk_ctrl_reset_set(rcdev, id, true);
+	return imx_blk_ctrl_reset_set(rcdev, id, false);
+}
+
+static int imx_blk_ctrl_reset_assert(struct reset_controller_dev *rcdev,
+					   unsigned long id)
+{
+	return imx_blk_ctrl_reset_set(rcdev, id, true);
+}
+
+static int imx_blk_ctrl_reset_deassert(struct reset_controller_dev *rcdev,
+					     unsigned long id)
+{
+	return imx_blk_ctrl_reset_set(rcdev, id, false);
+}
+
+static const struct reset_control_ops imx_blk_ctrl_reset_ops = {
+	.reset		= imx_blk_ctrl_reset_reset,
+	.assert		= imx_blk_ctrl_reset_assert,
+	.deassert	= imx_blk_ctrl_reset_deassert,
+};
+
+static int imx_blk_ctrl_register_reset_controller(struct device *dev)
+{
+	struct imx_blk_ctrl_drvdata *drvdata = dev_get_drvdata(dev);
+	const struct imx_blk_ctrl_dev_data *dev_data = of_device_get_match_data(dev);
+	struct reset_hw *hws;
+	int max = dev_data->resets_max;
+	int i;
+
+	drvdata->lock = &imx_ccm_lock;
+
+	drvdata->rcdev.owner     = THIS_MODULE;
+	drvdata->rcdev.nr_resets = max;
+	drvdata->rcdev.ops       = &imx_blk_ctrl_reset_ops;
+	drvdata->rcdev.of_node   = dev->of_node;
+	drvdata->rcdev.dev	 = dev;
+
+	drvdata->rst_hws = devm_kzalloc(dev, sizeof(struct reset_hw) * max,
+					GFP_KERNEL);
+	hws = drvdata->rst_hws;
+
+	for (i = 0; i < dev_data->hws_num; i++) {
+		struct imx_blk_ctrl_hw *hw = &dev_data->hws[i];
+
+		if (hw->type != BLK_CTRL_RESET)
+			continue;
+
+		hws[hw->id].offset = hw->offset;
+		hws[hw->id].shift = hw->shift;
+		hws[hw->id].mask = hw->mask;
+	}
+
+	return devm_reset_controller_register(dev, &drvdata->rcdev);
+}
+static struct clk_hw *imx_blk_ctrl_register_one_clock(struct device *dev,
+						struct imx_blk_ctrl_hw *hw)
+{
+	struct imx_blk_ctrl_drvdata *drvdata = dev_get_drvdata(dev);
+	void __iomem *base = drvdata->base;
+	struct clk_hw *clk_hw;
+
+	switch (hw->type) {
+	case BLK_CTRL_CLK_MUX:
+		clk_hw = imx_dev_clk_hw_mux_flags(dev, hw->name,
+						  base + hw->offset,
+						  hw->shift, hw->width,
+						  hw->parents,
+						  hw->parents_count,
+						  hw->flags);
+		break;
+	case BLK_CTRL_CLK_GATE:
+		clk_hw = imx_dev_clk_hw_gate(dev, hw->name, hw->parents,
+					     base + hw->offset, hw->shift);
+		break;
+	case BLK_CTRL_CLK_SHARED_GATE:
+		clk_hw = imx_dev_clk_hw_gate_shared(dev, hw->name,
+						    hw->parents,
+						    base + hw->offset,
+						    hw->shift,
+						    hw->shared_count);
+		break;
+	case BLK_CTRL_CLK_PLL14XX:
+		clk_hw = imx_dev_clk_hw_pll14xx(dev, hw->name, hw->parents,
+						base + hw->offset, hw->pll_tbl);
+		break;
+	default:
+		clk_hw = NULL;
+	};
+
+	return clk_hw;
+}
+
+static int imx_blk_ctrl_register_clock_controller(struct device *dev)
+{
+	const struct imx_blk_ctrl_dev_data *dev_data = of_device_get_match_data(dev);
+	struct clk_hw_onecell_data *clk_hw_data;
+	struct clk_hw **hws;
+	int i;
+
+	clk_hw_data = devm_kzalloc(dev, struct_size(clk_hw_data, hws,
+				dev_data->hws_num), GFP_KERNEL);
+	if (WARN_ON(!clk_hw_data))
+		return -ENOMEM;
+
+	clk_hw_data->num = dev_data->clocks_max;
+	hws = clk_hw_data->hws;
+
+	for (i = 0; i < dev_data->hws_num; i++) {
+		struct imx_blk_ctrl_hw *hw = &dev_data->hws[i];
+		struct clk_hw *tmp = imx_blk_ctrl_register_one_clock(dev, hw);
+
+		if (!tmp)
+			continue;
+		hws[hw->id] = tmp;
+	}
+
+	imx_check_clk_hws(hws, dev_data->clocks_max);
+
+	return of_clk_add_hw_provider(dev->of_node, of_clk_hw_onecell_get,
+					clk_hw_data);
+}
+
+static int imx_blk_ctrl_init_runtime_pm_safekeeping(struct device *dev)
+{
+	const struct imx_blk_ctrl_dev_data *dev_data = of_device_get_match_data(dev);
+	struct imx_blk_ctrl_drvdata *drvdata = dev_get_drvdata(dev);
+	struct pm_safekeep_info *pm_info = &drvdata->pm_info;
+	u32 regs_num = dev_data->pm_runtime_saved_regs_num;
+	const u32 *regs_offsets = dev_data->pm_runtime_saved_regs;
+
+	if (!dev_data->pm_runtime_saved_regs_num)
+		return 0;
+
+	pm_info->regs_values = devm_kzalloc(dev,
+					    sizeof(u32) * regs_num,
+					    GFP_KERNEL);
+	if (WARN_ON(IS_ERR(pm_info->regs_values)))
+		return PTR_ERR(pm_info->regs_values);
+
+	pm_info->regs_offsets = kmemdup(regs_offsets,
+					regs_num * sizeof(u32), GFP_KERNEL);
+	if (WARN_ON(IS_ERR(pm_info->regs_offsets)))
+		return PTR_ERR(pm_info->regs_offsets);
+
+	pm_info->regs_num = regs_num;
+
+	return 0;
+}
+
+static int imx_blk_ctrl_probe(struct platform_device *pdev)
+{
+	struct imx_blk_ctrl_drvdata *drvdata;
+	struct device *dev = &pdev->dev;
+	int ret;
+
+	drvdata = devm_kzalloc(dev, sizeof(*drvdata), GFP_KERNEL);
+	if (WARN_ON(!drvdata))
+		return -ENOMEM;
+
+	drvdata->base = devm_platform_ioremap_resource(pdev, 0);
+	if (WARN_ON(IS_ERR(drvdata->base)))
+		return PTR_ERR(drvdata->base);
+
+	dev_set_drvdata(dev, drvdata);
+
+	ret = imx_blk_ctrl_init_runtime_pm_safekeeping(dev);
+	if (ret)
+		return ret;
+
+	pm_runtime_get_noresume(dev);
+	pm_runtime_set_active(dev);
+	pm_runtime_enable(dev);
+
+	ret = imx_blk_ctrl_register_clock_controller(dev);
+	if (ret) {
+		pm_runtime_put(dev);
+		return ret;
+	}
+
+	ret = imx_blk_ctrl_register_reset_controller(dev);
+
+	pm_runtime_put(dev);
+
+	return ret;
+}
+
+static void imx_blk_ctrl_read_write(struct device *dev, bool write)
+{
+	struct imx_blk_ctrl_drvdata *drvdata = dev_get_drvdata(dev);
+	struct pm_safekeep_info *pm_info = &drvdata->pm_info;
+	void __iomem *base = drvdata->base;
+	unsigned long flags;
+	int i;
+
+	if (!pm_info->regs_num)
+		return;
+
+	spin_lock_irqsave(drvdata->lock, flags);
+
+	for (i = 0; i < pm_info->regs_num; i++) {
+		u32 offset = pm_info->regs_offsets[i];
+
+		if (write)
+			writel(pm_info->regs_values[i], base + offset);
+		else
+			pm_info->regs_values[i] = readl(base + offset);
+	}
+
+	spin_unlock_irqrestore(drvdata->lock, flags);
+
+}
+
+static int imx_blk_ctrl_runtime_suspend(struct device *dev)
+{
+	imx_blk_ctrl_read_write(dev, false);
+
+	return 0;
+}
+
+static int imx_blk_ctrl_runtime_resume(struct device *dev)
+{
+	imx_blk_ctrl_read_write(dev, true);
+
+	return 0;
+}
+
+static const struct dev_pm_ops imx_blk_ctrl_pm_ops = {
+	SET_RUNTIME_PM_OPS(imx_blk_ctrl_runtime_suspend,
+			   imx_blk_ctrl_runtime_resume, NULL)
+	SET_NOIRQ_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,
+			   pm_runtime_force_resume)
+};
+
+static const struct of_device_id imx_blk_ctrl_of_match[] = {
+	{
+		.compatible = "fsl,imx8mp-audio-blk-ctrl",
+		.data = &imx8mp_audio_blk_ctrl_dev_data
+	},
+	{
+		.compatible = "fsl,imx8mp-media-blk-ctrl",
+		.data = &imx8mp_media_blk_ctrl_dev_data
+	},
+	{
+		.compatible = "fsl,imx8mp-hdmi-blk-ctrl",
+		.data = &imx8mp_hdmi_blk_ctrl_dev_data
+	},
+	{ /* Sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, imx_blk_ctrl_of_match);
+
+static struct platform_driver imx_blk_ctrl_driver = {
+	.probe = imx_blk_ctrl_probe,
+	.driver = {
+		.name = "imx-blk-ctrl",
+		.of_match_table = of_match_ptr(imx_blk_ctrl_of_match),
+		.pm = &imx_blk_ctrl_pm_ops,
+	},
+};
+module_platform_driver(imx_blk_ctrl_driver);
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/clk/imx/clk-blk-ctrl.h b/drivers/clk/imx/clk-blk-ctrl.h
new file mode 100644
index 000000000..e0574b20b
--- /dev/null
+++ b/drivers/clk/imx/clk-blk-ctrl.h
@@ -0,0 +1,81 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __MACH_IMX_CLK_BLK_CTRL_H
+#define __MACH_IMX_CLK_BLK_CTRL_H
+
+enum imx_blk_ctrl_hw_type {
+	BLK_CTRL_CLK_MUX,
+	BLK_CTRL_CLK_GATE,
+	BLK_CTRL_CLK_SHARED_GATE,
+	BLK_CTRL_CLK_PLL14XX,
+	BLK_CTRL_RESET,
+};
+
+struct imx_blk_ctrl_hw {
+	int type;
+	char *name;
+	u32 offset;
+	u32 shift;
+	u32 mask;
+	u32 width;
+	u32 flags;
+	u32 id;
+	void *parents;
+	u32 parents_count;
+	int *shared_count;
+	const struct imx_pll14xx_clk *pll_tbl;
+};
+
+struct imx_blk_ctrl_dev_data {
+	struct imx_blk_ctrl_hw *hws;
+	u32 hws_num;
+
+	u32 clocks_max;
+	u32 resets_max;
+
+	u32 pm_runtime_saved_regs_num;
+	u32 pm_runtime_saved_regs[];
+};
+
+#define IMX_BLK_CTRL(_type, _name, _id, _offset, _shift, _width, _mask, _parents, _parents_count, _flags, sh_count, _pll_tbl) \
+	{						\
+		.type = _type,				\
+		.name = _name,				\
+		.id = _id,				\
+		.offset = _offset,			\
+		.shift = _shift,			\
+		.width = _width,			\
+		.mask = _mask,				\
+		.parents = _parents,			\
+		.parents_count = _parents_count,	\
+		.flags = _flags,			\
+		.shared_count = sh_count,		\
+		.pll_tbl = _pll_tbl,			\
+	}
+
+#define IMX_BLK_CTRL_CLK_MUX(_name, _id, _offset, _shift, _width, _parents) \
+	IMX_BLK_CTRL(BLK_CTRL_CLK_MUX, _name, _id, _offset, _shift, _width, 0, _parents, ARRAY_SIZE(_parents), 0, NULL, NULL)
+
+#define IMX_BLK_CTRL_CLK_MUX_FLAGS(_name, _id, _offset, _shift, _width, _parents, _flags) \
+	IMX_BLK_CTRL(BLK_CTRL_CLK_MUX, _name, _id, _offset, _shift, _width, 0, _parents, ARRAY_SIZE(_parents), _flags, NULL, NULL)
+
+#define IMX_BLK_CTRL_CLK_GATE(_name, _id, _offset, _shift, _parents) \
+	IMX_BLK_CTRL(BLK_CTRL_CLK_GATE, _name, _id, _offset, _shift, 1, 0, _parents, 1, 0, NULL, NULL)
+
+#define IMX_BLK_CTRL_CLK_SHARED_GATE(_name, _id, _offset, _shift, _parents, sh_count) \
+	IMX_BLK_CTRL(BLK_CTRL_CLK_SHARED_GATE, _name, _id, _offset, _shift, 1, 0, _parents, 1, 0, sh_count, NULL)
+
+#define IMX_BLK_CTRL_CLK_PLL14XX(_name, _id, _offset, _parents, _pll_tbl) \
+	IMX_BLK_CTRL(BLK_CTRL_CLK_PLL14XX, _name, _id, _offset, 0, 0, 0, _parents, 1, 0, NULL, _pll_tbl)
+
+#define IMX_BLK_CTRL_RESET(_id, _offset, _shift) \
+	IMX_BLK_CTRL(BLK_CTRL_RESET, NULL, _id, _offset, _shift, 0, 1, NULL, 0, 0, NULL, NULL)
+
+#define IMX_BLK_CTRL_RESET_MASK(_id, _offset, _shift, mask) \
+	IMX_BLK_CTRL(BLK_CTRL_RESET, NULL, _id, _offset, _shift, 0, mask, NULL, 0, 0, NULL, NULL)
+
+extern const struct imx_blk_ctrl_dev_data imx8mp_audio_blk_ctrl_dev_data;
+extern const struct imx_blk_ctrl_dev_data imx8mp_media_blk_ctrl_dev_data;
+extern const struct imx_blk_ctrl_dev_data imx8mp_hdmi_blk_ctrl_dev_data;
+
+#endif
+
diff --git a/drivers/clk/imx/clk-composite-7ulp.c b/drivers/clk/imx/clk-composite-7ulp.c
index d85ba78ab..4eedd45db 100644
--- a/drivers/clk/imx/clk-composite-7ulp.c
+++ b/drivers/clk/imx/clk-composite-7ulp.c
@@ -8,6 +8,7 @@
 #include <linux/bits.h>
 #include <linux/clk-provider.h>
 #include <linux/err.h>
+#include <linux/io.h>
 #include <linux/slab.h>
 
 #include "../clk-fractional-divider.h"
@@ -23,17 +24,61 @@
 #define PCG_PCD_WIDTH	3
 #define PCG_PCD_MASK	0x7
 
-struct clk_hw *imx7ulp_clk_hw_composite(const char *name,
+#define SW_RST		BIT(28)
+
+static int pcc_gate_enable(struct clk_hw *hw)
+{
+	struct clk_gate *gate = to_clk_gate(hw);
+	unsigned long flags;
+	u32 val;
+	int ret;
+
+	ret = clk_gate_ops.enable(hw);
+	if (ret)
+		return ret;
+
+	spin_lock_irqsave(gate->lock, flags);
+	/*
+	 * release the sw reset for peripherals associated with
+	 * with this pcc clock.
+	 */
+	val = readl(gate->reg);
+	val |= SW_RST;
+	writel(val, gate->reg);
+
+	spin_unlock_irqrestore(gate->lock, flags);
+
+	return 0;
+}
+
+static void pcc_gate_disable(struct clk_hw *hw)
+{
+	clk_gate_ops.disable(hw);
+}
+
+static int pcc_gate_is_enabled(struct clk_hw *hw)
+{
+	return clk_gate_ops.is_enabled(hw);
+}
+
+static const struct clk_ops pcc_gate_ops = {
+	.enable = pcc_gate_enable,
+	.disable = pcc_gate_disable,
+	.is_enabled = pcc_gate_is_enabled,
+};
+
+static struct clk_hw *imx_ulp_clk_hw_composite(const char *name,
 				     const char * const *parent_names,
 				     int num_parents, bool mux_present,
 				     bool rate_present, bool gate_present,
-				     void __iomem *reg)
+				     void __iomem *reg, bool has_swrst)
 {
 	struct clk_hw *mux_hw = NULL, *fd_hw = NULL, *gate_hw = NULL;
 	struct clk_fractional_divider *fd = NULL;
 	struct clk_gate *gate = NULL;
 	struct clk_mux *mux = NULL;
 	struct clk_hw *hw;
+	u32 val;
 
 	if (mux_present) {
 		mux = kzalloc(sizeof(*mux), GFP_KERNEL);
@@ -43,6 +88,8 @@ struct clk_hw *imx7ulp_clk_hw_composite(const char *name,
 		mux->reg = reg;
 		mux->shift = PCG_PCS_SHIFT;
 		mux->mask = PCG_PCS_MASK;
+		if (has_swrst)
+			mux->lock = &imx_ccm_lock;
 	}
 
 	if (rate_present) {
@@ -60,6 +107,8 @@ struct clk_hw *imx7ulp_clk_hw_composite(const char *name,
 		fd->nwidth = PCG_PCD_WIDTH;
 		fd->nmask = PCG_PCD_MASK;
 		fd->flags = CLK_FRAC_DIVIDER_ZERO_BASED;
+		if (has_swrst)
+			fd->lock = &imx_ccm_lock;
 	}
 
 	if (gate_present) {
@@ -72,13 +121,27 @@ struct clk_hw *imx7ulp_clk_hw_composite(const char *name,
 		gate_hw = &gate->hw;
 		gate->reg = reg;
 		gate->bit_idx = PCG_CGC_SHIFT;
+		if (has_swrst)
+			gate->lock = &imx_ccm_lock;
+		/*
+		 * make sure clock is gated during clock tree initialization,
+		 * the HW ONLY allow clock parent/rate changed with clock gated,
+		 * during clock tree initialization, clocks could be enabled
+		 * by bootloader, so the HW status will mismatch with clock tree
+		 * prepare count, then clock core driver will allow parent/rate
+		 * change since the prepare count is zero, but HW actually
+		 * prevent the parent/rate change due to the clock is enabled.
+		 */
+		val = readl_relaxed(reg);
+		val &= ~(1 << PCG_CGC_SHIFT);
+		writel_relaxed(val, reg);
 	}
 
 	hw = clk_hw_register_composite(NULL, name, parent_names, num_parents,
 				       mux_hw, &clk_mux_ops, fd_hw,
 				       &clk_fractional_divider_ops, gate_hw,
-				       &clk_gate_ops, CLK_SET_RATE_GATE |
-				       CLK_SET_PARENT_GATE);
+				       has_swrst ? &pcc_gate_ops : &clk_gate_ops, CLK_SET_RATE_GATE |
+				       CLK_SET_PARENT_GATE | CLK_SET_RATE_NO_REPARENT);
 	if (IS_ERR(hw)) {
 		kfree(mux);
 		kfree(fd);
@@ -87,3 +150,20 @@ struct clk_hw *imx7ulp_clk_hw_composite(const char *name,
 
 	return hw;
 }
+
+struct clk_hw *imx7ulp_clk_hw_composite(const char *name, const char * const *parent_names,
+				int num_parents, bool mux_present, bool rate_present,
+				bool gate_present, void __iomem *reg)
+{
+	return imx_ulp_clk_hw_composite(name, parent_names, num_parents, mux_present, rate_present,
+					gate_present, reg, false);
+}
+
+struct clk_hw *imx8ulp_clk_hw_composite(const char *name, const char * const *parent_names,
+				int num_parents, bool mux_present, bool rate_present,
+				bool gate_present, void __iomem *reg, bool has_swrst)
+{
+	return imx_ulp_clk_hw_composite(name, parent_names, num_parents, mux_present, rate_present,
+					gate_present, reg, has_swrst);
+}
+EXPORT_SYMBOL_GPL(imx8ulp_clk_hw_composite);
diff --git a/drivers/clk/imx/clk-composite-8m.c b/drivers/clk/imx/clk-composite-8m.c
index 04e728538..fec34169a 100644
--- a/drivers/clk/imx/clk-composite-8m.c
+++ b/drivers/clk/imx/clk-composite-8m.c
@@ -223,14 +223,19 @@ struct clk_hw *imx8m_clk_hw_composite_flags(const char *name,
 	div->lock = &imx_ccm_lock;
 	div->flags = CLK_DIVIDER_ROUND_CLOSEST;
 
-	gate = kzalloc(sizeof(*gate), GFP_KERNEL);
-	if (!gate)
-		goto fail;
-
-	gate_hw = &gate->hw;
-	gate->reg = reg;
-	gate->bit_idx = PCG_CGC_SHIFT;
-	gate->lock = &imx_ccm_lock;
+	/* skip registering the gate ops if M4 is enabled */
+	if (imx_src_is_m4_enabled()) {
+		gate_hw = NULL;
+	} else {
+		gate = kzalloc(sizeof(*gate), GFP_KERNEL);
+		if (!gate)
+			goto fail;
+
+		gate_hw = &gate->hw;
+		gate->reg = reg;
+		gate->bit_idx = PCG_CGC_SHIFT;
+		gate->lock = &imx_ccm_lock;
+	}
 
 	hw = clk_hw_register_composite(NULL, name, parent_names, num_parents,
 			mux_hw, mux_ops, div_hw,
diff --git a/drivers/clk/imx/clk-gate2.c b/drivers/clk/imx/clk-gate2.c
index f16c4019f..52baf8126 100644
--- a/drivers/clk/imx/clk-gate2.c
+++ b/drivers/clk/imx/clk-gate2.c
@@ -8,11 +8,13 @@
 
 #include <linux/clk-provider.h>
 #include <linux/export.h>
+#include <linux/imx_sema4.h>
 #include <linux/module.h>
 #include <linux/slab.h>
 #include <linux/io.h>
 #include <linux/err.h>
 #include <linux/string.h>
+#include <soc/imx/src.h>
 #include "clk.h"
 
 /**
@@ -38,9 +40,8 @@ struct clk_gate2 {
 
 #define to_clk_gate2(_hw) container_of(_hw, struct clk_gate2, hw)
 
-static void clk_gate2_do_shared_clks(struct clk_hw *hw, bool enable)
+static void clk_gate2_do_hardware(struct clk_gate2 *gate, bool enable)
 {
-	struct clk_gate2 *gate = to_clk_gate2(hw);
 	u32 reg;
 
 	reg = readl(gate->reg);
@@ -50,6 +51,39 @@ static void clk_gate2_do_shared_clks(struct clk_hw *hw, bool enable)
 	writel(reg, gate->reg);
 }
 
+static void clk_gate2_do_shared_clks(struct clk_hw *hw, bool enable)
+{
+	struct clk_gate2 *gate = to_clk_gate2(hw);
+
+	if (imx_src_is_m4_enabled() && clk_on_imx6sx()) {
+#ifdef CONFIG_SOC_IMX6SX
+		if (!amp_power_mutex || !shared_mem) {
+			if (enable)
+				clk_gate2_do_hardware(gate, enable);
+			return;
+		}
+
+		imx_sema4_mutex_lock(amp_power_mutex);
+		if (shared_mem->ca9_valid != SHARED_MEM_MAGIC_NUMBER ||
+			shared_mem->cm4_valid != SHARED_MEM_MAGIC_NUMBER) {
+			imx_sema4_mutex_unlock(amp_power_mutex);
+			return;
+		}
+
+		if (!imx_update_shared_mem(hw, enable)) {
+			imx_sema4_mutex_unlock(amp_power_mutex);
+			return;
+		}
+
+		clk_gate2_do_hardware(gate, enable);
+
+		imx_sema4_mutex_unlock(amp_power_mutex);
+#endif
+	} else {
+		clk_gate2_do_hardware(gate, enable);
+	}
+}
+
 static int clk_gate2_enable(struct clk_hw *hw)
 {
 	struct clk_gate2 *gate = to_clk_gate2(hw);
diff --git a/drivers/clk/imx/clk-imx-acm-utils.c b/drivers/clk/imx/clk-imx-acm-utils.c
new file mode 100644
index 000000000..b923e117d
--- /dev/null
+++ b/drivers/clk/imx/clk-imx-acm-utils.c
@@ -0,0 +1,78 @@
+// SPDX-License-Identifier: GPL-2.0+
+// Copyright 2020 NXP
+
+#include <linux/pm_runtime.h>
+#include <linux/pm_domain.h>
+#include "clk-imx-acm-utils.h"
+
+/**
+ * clk_imx_acm_attach_pm_domains
+ */
+int clk_imx_acm_attach_pm_domains(struct device *dev,
+				  struct clk_imx_acm_pm_domains *dev_pm)
+{
+	int ret;
+	int i;
+
+	dev_pm->num_domains = of_count_phandle_with_args(dev->of_node, "power-domains",
+							 "#power-domain-cells");
+	if (dev_pm->num_domains <= 1)
+		return 0;
+
+	dev_pm->pd_dev = devm_kmalloc_array(dev, dev_pm->num_domains,
+					    sizeof(*dev_pm->pd_dev),
+					    GFP_KERNEL);
+	if (!dev_pm->pd_dev)
+		return -ENOMEM;
+
+	dev_pm->pd_dev_link = devm_kmalloc_array(dev,
+						 dev_pm->num_domains,
+						 sizeof(*dev_pm->pd_dev_link),
+						 GFP_KERNEL);
+	if (!dev_pm->pd_dev_link)
+		return -ENOMEM;
+
+	for (i = 0; i < dev_pm->num_domains; i++) {
+		dev_pm->pd_dev[i] = dev_pm_domain_attach_by_id(dev, i);
+		if (IS_ERR(dev_pm->pd_dev[i]))
+			return PTR_ERR(dev_pm->pd_dev[i]);
+
+		dev_pm->pd_dev_link[i] = device_link_add(dev,
+							 dev_pm->pd_dev[i],
+							 DL_FLAG_STATELESS |
+							 DL_FLAG_PM_RUNTIME |
+							 DL_FLAG_RPM_ACTIVE);
+		if (IS_ERR(dev_pm->pd_dev_link[i])) {
+			dev_pm_domain_detach(dev_pm->pd_dev[i], false);
+			ret = PTR_ERR(dev_pm->pd_dev_link[i]);
+			goto detach_pm;
+		}
+	}
+	return 0;
+
+detach_pm:
+	while (--i >= 0) {
+		device_link_del(dev_pm->pd_dev_link[i]);
+		dev_pm_domain_detach(dev_pm->pd_dev[i], false);
+	}
+	return ret;
+}
+
+/**
+ * fsl_dev_detach_pm_domains
+ */
+int clk_imx_acm_detach_pm_domains(struct device *dev,
+				  struct clk_imx_acm_pm_domains *dev_pm)
+{
+	int i;
+
+	if (dev_pm->num_domains <= 1)
+		return 0;
+
+	for (i = 0; i < dev_pm->num_domains; i++) {
+		device_link_del(dev_pm->pd_dev_link[i]);
+		dev_pm_domain_detach(dev_pm->pd_dev[i], false);
+	}
+
+	return 0;
+}
diff --git a/drivers/clk/imx/clk-imx-acm-utils.h b/drivers/clk/imx/clk-imx-acm-utils.h
new file mode 100644
index 000000000..662e0d123
--- /dev/null
+++ b/drivers/clk/imx/clk-imx-acm-utils.h
@@ -0,0 +1,19 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright 2020 NXP */
+
+#ifndef _CLK_IMX_ACM_UTILS_H
+#define _CLK_IMX_ACM_UTILS_H
+
+#include <linux/device.h>
+
+struct clk_imx_acm_pm_domains {
+	struct device **pd_dev;
+	struct device_link **pd_dev_link;
+	int    num_domains;
+};
+
+int clk_imx_acm_attach_pm_domains(struct device *dev,
+				  struct clk_imx_acm_pm_domains *dev_pm);
+int clk_imx_acm_detach_pm_domains(struct device *dev,
+				  struct clk_imx_acm_pm_domains *dev_pm);
+#endif /* _CLK_IMX_ACM_UTILS_H */
diff --git a/drivers/clk/imx/clk-imx6q.c b/drivers/clk/imx/clk-imx6q.c
index de36f58d5..c598f65d7 100644
--- a/drivers/clk/imx/clk-imx6q.c
+++ b/drivers/clk/imx/clk-imx6q.c
@@ -27,7 +27,8 @@ static const char *periph_clk2_sels[]	= { "pll3_usb_otg", "osc", "osc", "dummy",
 static const char *periph2_clk2_sels[]	= { "pll3_usb_otg", "pll2_bus", };
 static const char *periph_sels[]	= { "periph_pre", "periph_clk2", };
 static const char *periph2_sels[]	= { "periph2_pre", "periph2_clk2", };
-static const char *axi_sels[]		= { "periph", "pll2_pfd2_396m", "periph", "pll3_pfd1_540m", };
+static const char *axi_alt_sels[]	= { "pll2_pfd2_396m", "pll3_pfd1_540m", };
+static const char *axi_sels[]		= { "periph", "axi_alt_sel", };
 static const char *audio_sels[]	= { "pll4_audio_div", "pll3_pfd2_508m", "pll3_pfd3_454m", "pll3_usb_otg", };
 static const char *gpu_axi_sels[]	= { "axi", "ahb", };
 static const char *pre_axi_sels[]	= { "axi", "ahb", };
@@ -37,15 +38,17 @@ static const char *gpu3d_core_sels[]	= { "mmdc_ch0_axi", "pll3_usb_otg", "pll2_p
 static const char *gpu3d_shader_sels[] = { "mmdc_ch0_axi", "pll3_usb_otg", "pll2_pfd1_594m", "pll3_pfd0_720m", };
 static const char *ipu_sels[]		= { "mmdc_ch0_axi", "pll2_pfd2_396m", "pll3_120m", "pll3_pfd1_540m", };
 static const char *ldb_di_sels[]	= { "pll5_video_div", "pll2_pfd0_352m", "pll2_pfd2_396m", "mmdc_ch1_axi", "pll3_usb_otg", };
+static const char *ldb_di0_div_sels[]	= { "ldb_di0_div_3_5", "ldb_di0_div_7", };
+static const char *ldb_di1_div_sels[]	= { "ldb_di1_div_3_5", "ldb_di1_div_7", };
 static const char *ipu_di_pre_sels[]	= { "mmdc_ch0_axi", "pll3_usb_otg", "pll5_video_div", "pll2_pfd0_352m", "pll2_pfd2_396m", "pll3_pfd1_540m", };
 static const char *ipu1_di0_sels[]	= { "ipu1_di0_pre", "dummy", "dummy", "ldb_di0", "ldb_di1", };
 static const char *ipu1_di1_sels[]	= { "ipu1_di1_pre", "dummy", "dummy", "ldb_di0", "ldb_di1", };
 static const char *ipu2_di0_sels[]	= { "ipu2_di0_pre", "dummy", "dummy", "ldb_di0", "ldb_di1", };
 static const char *ipu2_di1_sels[]	= { "ipu2_di1_pre", "dummy", "dummy", "ldb_di0", "ldb_di1", };
-static const char *ipu1_di0_sels_2[]	= { "ipu1_di0_pre", "dummy", "dummy", "ldb_di0_podf", "ldb_di1_podf", };
-static const char *ipu1_di1_sels_2[]	= { "ipu1_di1_pre", "dummy", "dummy", "ldb_di0_podf", "ldb_di1_podf", };
-static const char *ipu2_di0_sels_2[]	= { "ipu2_di0_pre", "dummy", "dummy", "ldb_di0_podf", "ldb_di1_podf", };
-static const char *ipu2_di1_sels_2[]	= { "ipu2_di1_pre", "dummy", "dummy", "ldb_di0_podf", "ldb_di1_podf", };
+static const char *ipu1_di0_sels_2[]	= { "ipu1_di0_pre", "dummy", "dummy", "ldb_di0_div_sel", "ldb_di1_div_sel", };
+static const char *ipu1_di1_sels_2[]	= { "ipu1_di1_pre", "dummy", "dummy", "ldb_di0_div_sel", "ldb_di1_div_sel", };
+static const char *ipu2_di0_sels_2[]	= { "ipu2_di0_pre", "dummy", "dummy", "ldb_di0_div_sel", "ldb_di1_div_sel", };
+static const char *ipu2_di1_sels_2[]	= { "ipu2_di1_pre", "dummy", "dummy", "ldb_di0_div_sel", "ldb_di1_div_sel", };
 static const char *hsi_tx_sels[]	= { "pll3_120m", "pll2_pfd2_396m", };
 static const char *pcie_axi_sels[]	= { "axi", "ahb", };
 static const char *ssi_sels[]		= { "pll3_pfd2_508m", "pll3_pfd3_454m", "pll4_audio_div", };
@@ -91,6 +94,7 @@ static const char *pll7_bypass_sels[] = { "pll7", "pll7_bypass_src", };
 
 static struct clk_hw **hws;
 static struct clk_hw_onecell_data *clk_hw_data;
+static void __iomem *ccm_base;
 
 static struct clk_div_table clk_enet_ref_table[] = {
 	{ .val = 0, .div = 20, },
@@ -252,6 +256,11 @@ static bool pll6_bypassed(struct device_node *node)
 
 #define CCM_CCSR		0x0c
 #define CCM_CS2CDR		0x2c
+#define CCM_CSCDR3		0x3c
+#define CCM_CCGR0		0x68
+#define CCM_CCGR3		0x74
+
+#define ANATOP_PLL3_PFD		0xf0
 
 #define CCSR_PLL3_SW_CLK_SEL		BIT(0)
 
@@ -388,6 +397,62 @@ static void init_ldb_clks(struct device_node *np, void __iomem *ccm_base)
 #define PFD2_CLKGATE		BIT(23)
 #define PFD3_CLKGATE		BIT(31)
 
+/*
+ * workaround for ERR010579, when switching the clock source of IPU clock
+ * root in CCM. even setting CCGR3[CG0]=0x0 to gate off clock before
+ * switching, IPU may hang due to no IPU clock from CCM.
+ */
+static void __init init_ipu_clk(void __iomem *anatop_base)
+{
+	u32 val, origin_podf;
+
+	/* gate off the IPU1_IPU clock */
+	val = readl_relaxed(ccm_base + CCM_CCGR3);
+	val &= ~0x3;
+	writel_relaxed(val, ccm_base + CCM_CCGR3);
+
+	/* gate off IPU DCIC1/2 clocks */
+	val = readl_relaxed(ccm_base + CCM_CCGR0);
+	val &= ~(0xf << 24);
+	writel_relaxed(val, ccm_base + CCM_CCGR0);
+
+	/* set IPU_PODF to 3'b000 */
+	val = readl_relaxed(ccm_base + CCM_CSCDR3);
+	origin_podf = val & (0x7 << 11);
+	val &= ~(0x7 << 11);
+	writel_relaxed(val, ccm_base + CCM_CSCDR3);
+
+	/* disable PLL3_PFD1 */
+	val = readl_relaxed(anatop_base + ANATOP_PLL3_PFD);
+	val &= ~(0x1 << 15);
+	writel_relaxed(val, anatop_base + ANATOP_PLL3_PFD);
+
+	/* switch IPU_SEL clock to PLL3_PFD1 */
+	val = readl_relaxed(ccm_base + CCM_CSCDR3);
+	val |= (0x3 << 9);
+	writel_relaxed(val, ccm_base + CCM_CSCDR3);
+
+	 /* restore the IPU PODF*/
+	val = readl_relaxed(ccm_base + CCM_CSCDR3);
+	val |= origin_podf;
+	writel_relaxed(val, ccm_base + CCM_CSCDR3);
+
+	/* enable PLL3_PFD1 */
+	val = readl_relaxed(anatop_base + ANATOP_PLL3_PFD);
+	val |= (0x1 << 15);
+	writel_relaxed(val, anatop_base + ANATOP_PLL3_PFD);
+
+	/* enable IPU1_IPU clock */
+	val = readl_relaxed(ccm_base + CCM_CCGR3);
+	val |= 0x3;
+	writel_relaxed(val, ccm_base + CCM_CCGR3);
+
+	/* enable IPU DCIC1/2 clock */
+	val = readl_relaxed(ccm_base + CCM_CCGR0);
+	val |= (0xf << 24);
+	writel_relaxed(val, ccm_base + CCM_CCGR0);
+}
+
 static void disable_anatop_clocks(void __iomem *anatop_base)
 {
 	unsigned int reg;
@@ -600,6 +665,7 @@ static void __init imx6q_clocks_init(struct device_node *ccm_node)
 
 	np = ccm_node;
 	base = of_iomap(np, 0);
+	ccm_base = base;
 	WARN_ON(!base);
 
 	/*                                              name                reg       shift width parent_names     num_parents */
@@ -609,7 +675,8 @@ static void __init imx6q_clocks_init(struct device_node *ccm_node)
 	hws[IMX6QDL_CLK_PERIPH2_PRE]      = imx_clk_hw_mux("periph2_pre",      base + 0x18, 21, 2, periph_pre_sels,   ARRAY_SIZE(periph_pre_sels));
 	hws[IMX6QDL_CLK_PERIPH_CLK2_SEL]  = imx_clk_hw_mux("periph_clk2_sel",  base + 0x18, 12, 2, periph_clk2_sels,  ARRAY_SIZE(periph_clk2_sels));
 	hws[IMX6QDL_CLK_PERIPH2_CLK2_SEL] = imx_clk_hw_mux("periph2_clk2_sel", base + 0x18, 20, 1, periph2_clk2_sels, ARRAY_SIZE(periph2_clk2_sels));
-	hws[IMX6QDL_CLK_AXI_SEL]          = imx_clk_hw_mux("axi_sel",          base + 0x14, 6,  2, axi_sels,          ARRAY_SIZE(axi_sels));
+	hws[IMX6QDL_CLK_AXI_ALT_SEL]      = imx_clk_hw_mux("axi_alt_sel",      base + 0x14, 7,  1, axi_alt_sels,      ARRAY_SIZE(axi_alt_sels));
+	hws[IMX6QDL_CLK_AXI_SEL]          = imx_clk_hw_mux("axi_sel",          base + 0x14, 6,  1, axi_sels,          ARRAY_SIZE(axi_sels));
 	hws[IMX6QDL_CLK_ESAI_SEL]         = imx_clk_hw_mux("esai_sel",         base + 0x20, 19, 2, audio_sels,        ARRAY_SIZE(audio_sels));
 	hws[IMX6QDL_CLK_ASRC_SEL]         = imx_clk_hw_mux("asrc_sel",         base + 0x30, 7,  2, audio_sels,        ARRAY_SIZE(audio_sels));
 	hws[IMX6QDL_CLK_SPDIF_SEL]        = imx_clk_hw_mux("spdif_sel",        base + 0x30, 20, 2, audio_sels,        ARRAY_SIZE(audio_sels));
@@ -655,6 +722,8 @@ static void __init imx6q_clocks_init(struct device_node *ccm_node)
 		hws[IMX6QDL_CLK_LDB_DI1_SEL]      = imx_clk_hw_mux_ldb("ldb_di1_sel", base + 0x2c, 12, 3, ldb_di_sels,      ARRAY_SIZE(ldb_di_sels));
 	}
 
+	hws[IMX6QDL_CLK_LDB_DI0_DIV_SEL]  = imx_clk_hw_mux_flags("ldb_di0_div_sel",  base + 0x20, 10, 1, ldb_di0_div_sels, ARRAY_SIZE(ldb_di0_div_sels), CLK_SET_RATE_PARENT);
+	hws[IMX6QDL_CLK_LDB_DI1_DIV_SEL]  = imx_clk_hw_mux_flags("ldb_di1_div_sel",  base + 0x20, 11, 1, ldb_di1_div_sels, ARRAY_SIZE(ldb_di1_div_sels), CLK_SET_RATE_PARENT);
 	hws[IMX6QDL_CLK_IPU1_DI0_PRE_SEL] = imx_clk_hw_mux_flags("ipu1_di0_pre_sel", base + 0x34, 6,  3, ipu_di_pre_sels,   ARRAY_SIZE(ipu_di_pre_sels), CLK_SET_RATE_PARENT);
 	hws[IMX6QDL_CLK_IPU1_DI1_PRE_SEL] = imx_clk_hw_mux_flags("ipu1_di1_pre_sel", base + 0x34, 15, 3, ipu_di_pre_sels,   ARRAY_SIZE(ipu_di_pre_sels), CLK_SET_RATE_PARENT);
 	hws[IMX6QDL_CLK_IPU2_DI0_PRE_SEL] = imx_clk_hw_mux_flags("ipu2_di0_pre_sel", base + 0x38, 6,  3, ipu_di_pre_sels,   ARRAY_SIZE(ipu_di_pre_sels), CLK_SET_RATE_PARENT);
@@ -723,6 +792,8 @@ static void __init imx6q_clocks_init(struct device_node *ccm_node)
 		hws[IMX6QDL_CLK_UART_SERIAL_PODF] = imx_clk_hw_divider("uart_serial_podf", "uart_sel", base + 0x24, 0, 6);
 		hws[IMX6QDL_CLK_LDB_DI0_DIV_3_5] = imx_clk_hw_fixed_factor("ldb_di0_div_3_5", "ldb_di0", 2, 7);
 		hws[IMX6QDL_CLK_LDB_DI1_DIV_3_5] = imx_clk_hw_fixed_factor("ldb_di1_div_3_5", "ldb_di1", 2, 7);
+		hws[IMX6QDL_CLK_LDB_DI0_DIV_7] = imx_clk_hw_fixed_factor("ldb_di0_div_7",   "ldb_di0", 1, 7);
+		hws[IMX6QDL_CLK_LDB_DI1_DIV_7] = imx_clk_hw_fixed_factor("ldb_di1_div_7",   "ldb_di1", 1, 7);
 	} else {
 		hws[IMX6QDL_CLK_ECSPI_ROOT] = imx_clk_hw_divider("ecspi_root", "pll3_60m", base + 0x38, 19, 6);
 		hws[IMX6QDL_CLK_CAN_ROOT] = imx_clk_hw_divider("can_root", "pll3_60m", base + 0x20, 2, 6);
@@ -730,6 +801,8 @@ static void __init imx6q_clocks_init(struct device_node *ccm_node)
 		hws[IMX6QDL_CLK_UART_SERIAL_PODF] = imx_clk_hw_divider("uart_serial_podf", "pll3_80m",          base + 0x24, 0,  6);
 		hws[IMX6QDL_CLK_LDB_DI0_DIV_3_5] = imx_clk_hw_fixed_factor("ldb_di0_div_3_5", "ldb_di0_sel", 2, 7);
 		hws[IMX6QDL_CLK_LDB_DI1_DIV_3_5] = imx_clk_hw_fixed_factor("ldb_di1_div_3_5", "ldb_di1_sel", 2, 7);
+		hws[IMX6QDL_CLK_LDB_DI0_DIV_7] = imx_clk_hw_fixed_factor("ldb_di0_div_7",   "ldb_di0_sel", 1, 7);
+		hws[IMX6QDL_CLK_LDB_DI1_DIV_7] = imx_clk_hw_fixed_factor("ldb_di1_div_7",   "ldb_di1_sel", 1, 7);
 	}
 
 	if (clk_on_imx6dl())
@@ -915,8 +988,24 @@ static void __init imx6q_clocks_init(struct device_node *ccm_node)
 	clk_hw_register_clkdev(hws[IMX6QDL_CLK_ENET_REF], "enet_ref", NULL);
 
 	clk_set_rate(hws[IMX6QDL_CLK_PLL3_PFD1_540M]->clk, 540000000);
-	if (clk_on_imx6dl())
+	if (clk_on_imx6dl()) {
+		init_ipu_clk(anatop_base);
 		clk_set_parent(hws[IMX6QDL_CLK_IPU1_SEL]->clk, hws[IMX6QDL_CLK_PLL3_PFD1_540M]->clk);
+		clk_set_parent(hws[IMX6QDL_CLK_AXI_ALT_SEL]->clk, hws[IMX6QDL_CLK_PLL3_PFD1_540M]->clk);
+		clk_set_parent(hws[IMX6QDL_CLK_AXI_SEL]->clk, hws[IMX6QDL_CLK_AXI_ALT_SEL]->clk);
+		/* set eim_slow to 135Mhz */
+		clk_set_rate(hws[IMX6QDL_CLK_EIM_SLOW]->clk, 135000000);
+
+		/* set epdc/pxp axi clock to 200Mhz */
+		clk_set_parent(hws[IMX6QDL_CLK_IPU2_SEL]->clk, hws[IMX6QDL_CLK_PLL2_PFD2_396M]->clk);
+		clk_set_rate(hws[IMX6QDL_CLK_IPU2]->clk, 200000000);
+	} else {
+		/* set eim_slow to 132Mhz */
+		clk_set_rate(hws[IMX6QDL_CLK_EIM_SLOW]->clk, 132000000);
+		clk_set_parent(hws[IMX6QDL_CLK_IPU1_SEL]->clk, hws[IMX6QDL_CLK_MMDC_CH0_AXI]->clk);
+
+		clk_set_parent(hws[IMX6QDL_CLK_IPU2_SEL]->clk, hws[IMX6QDL_CLK_MMDC_CH0_AXI]->clk);
+	}
 
 	clk_set_parent(hws[IMX6QDL_CLK_IPU1_DI0_PRE_SEL]->clk, hws[IMX6QDL_CLK_PLL5_VIDEO_DIV]->clk);
 	clk_set_parent(hws[IMX6QDL_CLK_IPU1_DI1_PRE_SEL]->clk, hws[IMX6QDL_CLK_PLL5_VIDEO_DIV]->clk);
diff --git a/drivers/clk/imx/clk-imx6sl.c b/drivers/clk/imx/clk-imx6sl.c
index 277365970..92edc24cc 100644
--- a/drivers/clk/imx/clk-imx6sl.c
+++ b/drivers/clk/imx/clk-imx6sl.c
@@ -433,10 +433,20 @@ static void __init imx6sl_clocks_init(struct device_node *ccm_node)
 	/* Audio-related clocks configuration */
 	clk_set_parent(hws[IMX6SL_CLK_SPDIF0_SEL]->clk, hws[IMX6SL_CLK_PLL3_PFD3]->clk);
 
+	/* Initialize Video PLLs to valid frequency (650MHz). */
+	clk_set_rate(hws[IMX6SL_CLK_PLL5_VIDEO_DIV]->clk, 650000000);
+
 	/* set PLL5 video as lcdif pix parent clock */
 	clk_set_parent(hws[IMX6SL_CLK_LCDIF_PIX_SEL]->clk,
 			hws[IMX6SL_CLK_PLL5_VIDEO_DIV]->clk);
 
+	/* Configure EPDC clocks */
+	clk_set_parent(hws[IMX6SL_CLK_EPDC_PIX_SEL]->clk,
+		hws[IMX6SL_CLK_PLL5_VIDEO_DIV]->clk);
+	clk_set_parent(hws[IMX6SL_CLK_EPDC_AXI_SEL]->clk,
+		hws[IMX6SL_CLK_PLL2_PFD2]->clk);
+	clk_set_rate(hws[IMX6SL_CLK_EPDC_AXI]->clk, 200000000);
+
 	clk_set_parent(hws[IMX6SL_CLK_LCDIF_AXI_SEL]->clk,
 		       hws[IMX6SL_CLK_PLL2_PFD2]->clk);
 
diff --git a/drivers/clk/imx/clk-imx6sll.c b/drivers/clk/imx/clk-imx6sll.c
index 31d777f30..d1e6428da 100644
--- a/drivers/clk/imx/clk-imx6sll.c
+++ b/drivers/clk/imx/clk-imx6sll.c
@@ -350,6 +350,10 @@ static void __init imx6sll_clocks_init(struct device_node *ccm_node)
 	clk_set_parent(hws[IMX6SLL_CLK_PERIPH]->clk, hws[IMX6SLL_CLK_PERIPH_CLK2]->clk);
 	clk_set_parent(hws[IMX6SLL_CLK_PERIPH_PRE]->clk, hws[IMX6SLL_CLK_PLL2_BUS]->clk);
 	clk_set_parent(hws[IMX6SLL_CLK_PERIPH]->clk, hws[IMX6SLL_CLK_PERIPH_PRE]->clk);
+	/* Configure EPDC clocks */
+	clk_set_rate(hws[IMX6SLL_CLK_PLL3_PFD2]->clk, 320000000);
+	clk_set_parent(hws[IMX6SLL_CLK_EPDC_PRE_SEL]->clk,
+		hws[IMX6SLL_CLK_PLL3_PFD2]->clk);
 
 	clk_set_rate(hws[IMX6SLL_CLK_AHB]->clk, 132000000);
 }
diff --git a/drivers/clk/imx/clk-imx6sx.c b/drivers/clk/imx/clk-imx6sx.c
index fc1bd23d4..2301d8fb8 100644
--- a/drivers/clk/imx/clk-imx6sx.c
+++ b/drivers/clk/imx/clk-imx6sx.c
@@ -11,13 +11,18 @@
 #include <linux/err.h>
 #include <linux/init.h>
 #include <linux/io.h>
+#include <linux/imx_sema4.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
 #include <linux/of_irq.h>
 #include <linux/types.h>
+#include <soc/imx/gpc.h>
+#include <soc/imx/src.h>
 
 #include "clk.h"
 
+#define CCM_CCGR_OFFSET(index)		(index * 2)
+
 static const char *step_sels[]		= { "osc", "pll2_pfd2_396m", };
 static const char *pll1_sw_sels[]	= { "pll1_sys", "step", };
 static const char *periph_pre_sels[]	= { "pll2_bus", "pll2_pfd2_396m", "pll2_pfd0_352m", "pll2_198m", };
@@ -84,6 +89,12 @@ static const char *pll7_bypass_sels[] = { "pll7", "pll7_bypass_src", };
 
 static struct clk_hw **hws;
 static struct clk_hw_onecell_data *clk_hw_data;
+struct imx_sema4_mutex *amp_power_mutex;
+
+static int clks_shared[MAX_SHARED_CLK_NUMBER];
+
+struct imx_shared_mem *shared_mem;
+static unsigned int shared_mem_paddr, shared_mem_size;
 
 static const struct clk_div_table clk_enet_ref_table[] = {
 	{ .val = 0, .div = 20, },
@@ -117,6 +128,39 @@ static u32 share_count_ssi3;
 static u32 share_count_sai1;
 static u32 share_count_sai2;
 
+/*
+ * As IMX6SX_CLK_M4_PRE_SEL is NOT a glitchless MUX, so when
+ * M4 is trying to change its clk parent, need to ask A9 to
+ * help do it, and M4 must be hold in wfi. To avoid glitch
+ * occur, need to gate M4 clk first before switching its parent.
+ */
+void imx6sx_set_m4_highfreq(bool high_freq)
+{
+	static struct clk *m4_high_freq_sel;
+
+	imx_gpc_hold_m4_in_sleep();
+
+	clk_disable_unprepare(hws[IMX6SX_CLK_M4]->clk);
+	clk_set_parent(hws[IMX6SX_CLK_M4_SEL]->clk,
+		hws[IMX6SX_CLK_LDB_DI0]->clk);
+
+	if (high_freq) {
+		/* FIXME: m4_high_freq_sel possible used without intialization? */ 
+		clk_set_parent(hws[IMX6SX_CLK_M4_PRE_SEL]->clk,
+			m4_high_freq_sel);
+	} else {
+		m4_high_freq_sel = clk_get_parent(hws[IMX6SX_CLK_M4_PRE_SEL]->clk);
+		clk_set_parent(hws[IMX6SX_CLK_M4_PRE_SEL]->clk,
+			hws[IMX6SX_CLK_OSC]->clk);
+	}
+
+	clk_set_parent(hws[IMX6SX_CLK_M4_SEL]->clk,
+		       hws[IMX6SX_CLK_M4_PRE_SEL]->clk);
+	clk_prepare_enable(hws[IMX6SX_CLK_M4]->clk);
+
+	imx_gpc_release_m4_in_sleep();
+}
+
 static void __init imx6sx_clocks_init(struct device_node *ccm_node)
 {
 	struct device_node *np;
@@ -182,7 +226,7 @@ static void __init imx6sx_clocks_init(struct device_node *ccm_node)
 	clk_set_parent(hws[IMX6SX_PLL6_BYPASS]->clk, hws[IMX6SX_CLK_PLL6]->clk);
 	clk_set_parent(hws[IMX6SX_PLL7_BYPASS]->clk, hws[IMX6SX_CLK_PLL7]->clk);
 
-	hws[IMX6SX_CLK_PLL1_SYS]      = imx_clk_hw_gate("pll1_sys",      "pll1_bypass", base + 0x00, 13);
+	hws[IMX6SX_CLK_PLL1_SYS]      = imx_clk_hw_fixed_factor("pll1_sys", "pll1_bypass", 1, 1);
 	hws[IMX6SX_CLK_PLL2_BUS]      = imx_clk_hw_gate("pll2_bus",      "pll2_bypass", base + 0x30, 13);
 	hws[IMX6SX_CLK_PLL3_USB_OTG]  = imx_clk_hw_gate("pll3_usb_otg",  "pll3_bypass", base + 0x10, 13);
 	hws[IMX6SX_CLK_PLL4_AUDIO]    = imx_clk_hw_gate("pll4_audio",    "pll4_bypass", base + 0x70, 13);
@@ -398,7 +442,7 @@ static void __init imx6sx_clocks_init(struct device_node *ccm_node)
 	hws[IMX6SX_CLK_GPT_BUS]      = imx_clk_hw_gate2("gpt_bus",       "perclk",            base + 0x6c, 20);
 	hws[IMX6SX_CLK_GPT_SERIAL]   = imx_clk_hw_gate2("gpt_serial",    "perclk",            base + 0x6c, 22);
 	hws[IMX6SX_CLK_GPU]          = imx_clk_hw_gate2("gpu",           "gpu_core_podf",     base + 0x6c, 26);
-	hws[IMX6SX_CLK_OCRAM_S]      = imx_clk_hw_gate2("ocram_s",       "ahb",               base + 0x6c, 28);
+	hws[IMX6SX_CLK_OCRAM_S]      = imx_clk_hw_gate2_flags("ocram_s",       "ahb",               base + 0x6c, 28, CLK_IS_CRITICAL);
 	hws[IMX6SX_CLK_CANFD]        = imx_clk_hw_gate2("canfd",         "can_podf",          base + 0x6c, 30);
 
 	/* CCGR2 */
@@ -482,13 +526,59 @@ static void __init imx6sx_clocks_init(struct device_node *ccm_node)
 	hws[IMX6SX_CLK_CKO1]         = imx_clk_hw_gate("cko1",           "cko1_podf",         base + 0x60, 7);
 	hws[IMX6SX_CLK_CKO2]         = imx_clk_hw_gate("cko2",           "cko2_podf",         base + 0x60, 24);
 
+	/* get those shared clk nodes if M4 is active */
+	if (imx_src_is_m4_enabled()) {
+		u32 num;
+
+		of_property_read_u32(np, "fsl,shared-clks-number", &num);
+		if (num > MAX_SHARED_CLK_NUMBER)
+			pr_err("clk: shared clk nodes exceed the max number!\n");
+		of_property_read_u32_array(np, "fsl,shared-clks-index",
+			clks_shared, num);
+		if (of_property_read_u32(np, "fsl,shared-mem-addr",
+			&shared_mem_paddr))
+			pr_err("clk: fsl,shared-mem-addr NOT found!\n");
+		if (of_property_read_u32(np, "fsl,shared-mem-size",
+			&shared_mem_size))
+			pr_err("clk: fsl,shared-mem-size NOT found!\n");
+	}
+
 	/* mask handshake of mmdc */
 	imx_mmdc_mask_handshake(base, 0);
 
 	imx_check_clk_hws(hws, IMX6SX_CLK_CLK_END);
 
+	/*
+	 * QSPI2/GPMI_IO share the same clock source but with the
+	 * different gate, need explicitely gate the QSPI2 & GPMI_IO
+	 * during the clock init phase according to the SOC design.
+	 */
+	if (!imx_src_is_m4_enabled()) {
+		writel_relaxed(readl_relaxed(base + 0x78) &
+			~(3 << CCM_CCGR_OFFSET(5)), base + 0x78);
+		writel_relaxed(readl_relaxed(base + 0x78) &
+			~(3 << CCM_CCGR_OFFSET(14)), base + 0x78);
+	}
+
+
 	of_clk_add_hw_provider(np, of_clk_hw_onecell_get, clk_hw_data);
 
+	/*
+	 * As some of the modules need to access ocotp in MSL,
+	 * need to make sure ocotp clk(CCM_CCGR2_CG6) is enabled
+	 * during MSL, as on i.MX6SX, accessing OCOTP registers
+	 * needs its clk on, it will be disabled by clk late
+	 * init and managed by ocotp driver.
+	 */
+	writel_relaxed(readl_relaxed(base + 0x70) | 1 << 12, base + 0x70);
+
+	/* maintain M4 usecount */
+	if (imx_src_is_m4_enabled())
+		clk_prepare_enable(hws[IMX6SX_CLK_M4]->clk);
+
+	/* set perclk to from OSC */
+	clk_set_parent(hws[IMX6SX_CLK_PERCLK_SEL]->clk, hws[IMX6SX_CLK_OSC]->clk);
+
 	if (IS_ENABLED(CONFIG_USB_MXS_PHY)) {
 		clk_prepare_enable(hws[IMX6SX_CLK_USBPHY1_GATE]->clk);
 		clk_prepare_enable(hws[IMX6SX_CLK_USBPHY2_GATE]->clk);
@@ -520,7 +610,7 @@ static void __init imx6sx_clocks_init(struct device_node *ccm_node)
 	clk_set_rate(hws[IMX6SX_CLK_PLL4_AUDIO_DIV]->clk, 393216000);
 
 	clk_set_parent(hws[IMX6SX_CLK_SPDIF_SEL]->clk, hws[IMX6SX_CLK_PLL4_AUDIO_DIV]->clk);
-	clk_set_rate(hws[IMX6SX_CLK_SPDIF_PODF]->clk, 98304000);
+	clk_set_rate(hws[IMX6SX_CLK_SPDIF_PODF]->clk, 24576000);
 
 	clk_set_parent(hws[IMX6SX_CLK_AUDIO_SEL]->clk, hws[IMX6SX_CLK_PLL3_USB_OTG]->clk);
 	clk_set_rate(hws[IMX6SX_CLK_AUDIO_PODF]->clk, 24000000);
@@ -535,6 +625,12 @@ static void __init imx6sx_clocks_init(struct device_node *ccm_node)
 	clk_set_parent(hws[IMX6SX_CLK_ESAI_SEL]->clk, hws[IMX6SX_CLK_PLL4_AUDIO_DIV]->clk);
 	clk_set_rate(hws[IMX6SX_CLK_ESAI_PODF]->clk, 24576000);
 
+        /* Set the UART parent if needed. */
+        if (uart_from_osc)
+		clk_set_parent(hws[IMX6SX_CLK_UART_SEL]->clk, hws[IMX6SX_CLK_OSC]->clk);
+        else
+		clk_set_parent(hws[IMX6SX_CLK_UART_SEL]->clk, hws[IMX6SX_CLK_PLL3_80M]->clk);
+
 	/* Set parent clock for vadc */
 	clk_set_parent(hws[IMX6SX_CLK_VID_SEL]->clk, hws[IMX6SX_CLK_PLL3_USB_OTG]->clk);
 
@@ -544,6 +640,9 @@ static void __init imx6sx_clocks_init(struct device_node *ccm_node)
 	/* Update gpu clock from default 528M to 720M */
 	clk_set_parent(hws[IMX6SX_CLK_GPU_CORE_SEL]->clk, hws[IMX6SX_CLK_PLL3_PFD0]->clk);
 	clk_set_parent(hws[IMX6SX_CLK_GPU_AXI_SEL]->clk, hws[IMX6SX_CLK_PLL3_PFD0]->clk);
+	if (!imx_src_is_m4_enabled())
+		/* default parent of can_sel clock is invalid, manually set it here */
+		clk_set_parent(hws[IMX6SX_CLK_CAN_SEL]->clk, hws[IMX6SX_CLK_PLL3_60M]->clk);
 
 	clk_set_parent(hws[IMX6SX_CLK_QSPI1_SEL]->clk, hws[IMX6SX_CLK_PLL2_BUS]->clk);
 	clk_set_parent(hws[IMX6SX_CLK_QSPI2_SEL]->clk, hws[IMX6SX_CLK_PLL2_BUS]->clk);
@@ -551,3 +650,64 @@ static void __init imx6sx_clocks_init(struct device_node *ccm_node)
 	imx_register_uart_clocks(2);
 }
 CLK_OF_DECLARE(imx6sx, "fsl,imx6sx-ccm", imx6sx_clocks_init);
+
+int imx_update_shared_mem(struct clk_hw *hw, bool enable)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(clks_shared); i++) {
+		if (shared_mem->imx_clk[i].self == hw->clk)
+			break;
+	}
+
+	if (i >= ARRAY_SIZE(clks_shared))
+		return 1;
+
+	/* update ca9 clk status in shared memory */
+	if (enable)
+		shared_mem->imx_clk[i].ca9_enabled = 1;
+	else
+		shared_mem->imx_clk[i].ca9_enabled = 0;
+
+	if (shared_mem->imx_clk[i].cm4_enabled == 0)
+		return 1;
+
+	return 0;
+}
+
+static int __init imx_amp_power_init(void)
+{
+	int i;
+	void __iomem *shared_mem_base;
+
+	if (!(imx_src_is_m4_enabled() && clk_on_imx6sx()))
+		return 0;
+
+	amp_power_mutex = imx_sema4_mutex_create(0, MCC_POWER_SHMEM_NUMBER);
+
+	shared_mem_base = ioremap(shared_mem_paddr, shared_mem_size);
+
+	if (!amp_power_mutex) {
+		pr_err("Failed to create sema4 mutex!\n");
+		return 0;
+	}
+
+	shared_mem = (struct imx_shared_mem *)shared_mem_base;
+
+	for (i = 0; i < ARRAY_SIZE(clks_shared); i++) {
+		shared_mem->imx_clk[i].self = hws[clks_shared[i]]->clk;
+		shared_mem->imx_clk[i].ca9_enabled = 1;
+		pr_debug("%d: name %s, addr 0x%x\n", i,
+			__clk_get_name(shared_mem->imx_clk[i].self),
+			(u32)&(shared_mem->imx_clk[i]));
+	}
+	/* enable amp power management */
+	shared_mem->ca9_valid = SHARED_MEM_MAGIC_NUMBER;
+
+	pr_info("A9-M4 sema4 num %d, A9-M4 magic number 0x%x - 0x%x.\n",
+		amp_power_mutex->gate_num, shared_mem->ca9_valid,
+		shared_mem->cm4_valid);
+
+	return 0;
+}
+late_initcall(imx_amp_power_init);
diff --git a/drivers/clk/imx/clk-imx6ul.c b/drivers/clk/imx/clk-imx6ul.c
index 206e4c43f..427f1310a 100644
--- a/drivers/clk/imx/clk-imx6ul.c
+++ b/drivers/clk/imx/clk-imx6ul.c
@@ -495,6 +495,12 @@ static void __init imx6ul_clocks_init(struct device_node *ccm_node)
 	clk_set_rate(hws[IMX6UL_CLK_ENET2_REF]->clk, 50000000);
 	clk_set_rate(hws[IMX6UL_CLK_CSI]->clk, 24000000);
 
+        /* Set the UART parent if needed */
+        if (uart_from_osc)
+		clk_set_parent(hws[IMX6UL_CLK_UART_SEL]->clk, hws[IMX6UL_CLK_OSC]->clk);
+        else
+		clk_set_parent(hws[IMX6UL_CLK_UART_SEL]->clk, hws[IMX6UL_CLK_PLL3_80M]->clk);
+
 	if (clk_on_imx6ull())
 		clk_prepare_enable(hws[IMX6UL_CLK_AIPSTZ3]->clk);
 
diff --git a/drivers/clk/imx/clk-imx7d.c b/drivers/clk/imx/clk-imx7d.c
index 3f6fd7ef2..f9046d06e 100644
--- a/drivers/clk/imx/clk-imx7d.c
+++ b/drivers/clk/imx/clk-imx7d.c
@@ -15,6 +15,7 @@
 #include <linux/of_address.h>
 #include <linux/of_irq.h>
 #include <linux/types.h>
+#include <soc/imx/src.h>
 
 #include "clk.h"
 
@@ -24,6 +25,7 @@ static u32 share_count_sai3;
 static u32 share_count_nand;
 static u32 share_count_enet1;
 static u32 share_count_enet2;
+static u32 share_count_pxp;
 
 static const struct clk_div_table test_div_table[] = {
 	{ .val = 3, .div = 1, },
@@ -498,14 +500,14 @@ static void __init imx7d_clocks_init(struct device_node *ccm_node)
 	hws[IMX7D_ENET_AXI_ROOT_SRC] = imx_clk_hw_mux2_flags("enet_axi_src", base + 0x8900, 24, 3, enet_axi_sel, ARRAY_SIZE(enet_axi_sel), CLK_SET_PARENT_GATE);
 	hws[IMX7D_NAND_USDHC_BUS_ROOT_SRC] = imx_clk_hw_mux2_flags("nand_usdhc_src", base + 0x8980, 24, 3, nand_usdhc_bus_sel, ARRAY_SIZE(nand_usdhc_bus_sel), CLK_SET_PARENT_GATE);
 	hws[IMX7D_DRAM_PHYM_ROOT_SRC] = imx_clk_hw_mux2_flags("dram_phym_src", base + 0x9800, 24, 1, dram_phym_sel, ARRAY_SIZE(dram_phym_sel), CLK_SET_PARENT_GATE);
-	hws[IMX7D_DRAM_ROOT_SRC] = imx_clk_hw_mux2_flags("dram_src", base + 0x9880, 24, 1, dram_sel, ARRAY_SIZE(dram_sel), CLK_SET_PARENT_GATE);
+	hws[IMX7D_DRAM_ROOT_SRC] = imx_clk_hw_mux2("dram_src", base + 0x9880, 24, 1, dram_sel, ARRAY_SIZE(dram_sel));
 	hws[IMX7D_DRAM_PHYM_ALT_ROOT_SRC] = imx_clk_hw_mux2_flags("dram_phym_alt_src", base + 0xa000, 24, 3, dram_phym_alt_sel, ARRAY_SIZE(dram_phym_alt_sel), CLK_SET_PARENT_GATE);
-	hws[IMX7D_DRAM_ALT_ROOT_SRC]  = imx_clk_hw_mux2_flags("dram_alt_src", base + 0xa080, 24, 3, dram_alt_sel, ARRAY_SIZE(dram_alt_sel), CLK_SET_PARENT_GATE);
+	hws[IMX7D_DRAM_ALT_ROOT_SRC]  = imx_clk_hw_mux2("dram_alt_src", base + 0xa080, 24, 3, dram_alt_sel, ARRAY_SIZE(dram_alt_sel));
 	hws[IMX7D_USB_HSIC_ROOT_SRC] = imx_clk_hw_mux2_flags("usb_hsic_src", base + 0xa100, 24, 3, usb_hsic_sel, ARRAY_SIZE(usb_hsic_sel), CLK_SET_PARENT_GATE);
 	hws[IMX7D_PCIE_CTRL_ROOT_SRC] = imx_clk_hw_mux2_flags("pcie_ctrl_src", base + 0xa180, 24, 3, pcie_ctrl_sel, ARRAY_SIZE(pcie_ctrl_sel), CLK_SET_PARENT_GATE);
 	hws[IMX7D_PCIE_PHY_ROOT_SRC] = imx_clk_hw_mux2_flags("pcie_phy_src", base + 0xa200, 24, 3, pcie_phy_sel, ARRAY_SIZE(pcie_phy_sel), CLK_SET_PARENT_GATE);
 	hws[IMX7D_EPDC_PIXEL_ROOT_SRC] = imx_clk_hw_mux2_flags("epdc_pixel_src", base + 0xa280, 24, 3, epdc_pixel_sel, ARRAY_SIZE(epdc_pixel_sel), CLK_SET_PARENT_GATE);
-	hws[IMX7D_LCDIF_PIXEL_ROOT_SRC] = imx_clk_hw_mux2_flags("lcdif_pixel_src", base + 0xa300, 24, 3, lcdif_pixel_sel, ARRAY_SIZE(lcdif_pixel_sel), CLK_SET_PARENT_GATE);
+	hws[IMX7D_LCDIF_PIXEL_ROOT_SRC] = imx_clk_hw_mux2_flags("lcdif_pixel_src", base + 0xa300, 24, 3, lcdif_pixel_sel, ARRAY_SIZE(lcdif_pixel_sel), CLK_SET_PARENT_GATE | CLK_SET_RATE_PARENT);
 	hws[IMX7D_MIPI_DSI_ROOT_SRC] = imx_clk_hw_mux2_flags("mipi_dsi_src", base + 0xa380, 24, 3,  mipi_dsi_sel, ARRAY_SIZE(mipi_dsi_sel), CLK_SET_PARENT_GATE);
 	hws[IMX7D_MIPI_CSI_ROOT_SRC] = imx_clk_hw_mux2_flags("mipi_csi_src", base + 0xa400, 24, 3, mipi_csi_sel, ARRAY_SIZE(mipi_csi_sel), CLK_SET_PARENT_GATE);
 	hws[IMX7D_MIPI_DPHY_ROOT_SRC] = imx_clk_hw_mux2_flags("mipi_dphy_src", base + 0xa480, 24, 3, mipi_dphy_sel, ARRAY_SIZE(mipi_dphy_sel), CLK_SET_PARENT_GATE);
@@ -782,7 +784,7 @@ static void __init imx7d_clocks_init(struct device_node *ccm_node)
 	hws[IMX7D_DRAM_PHYM_ALT_ROOT_CLK] = imx_clk_hw_gate2_flags("dram_phym_alt_root_clk", "dram_phym_alt_post_div", base + 0x4130, 0, CLK_IS_CRITICAL | CLK_OPS_PARENT_ENABLE);
 	hws[IMX7D_DRAM_ALT_ROOT_CLK] = imx_clk_hw_gate2_flags("dram_alt_root_clk", "dram_alt_post_div", base + 0x4130, 0, CLK_IS_CRITICAL | CLK_OPS_PARENT_ENABLE);
 	hws[IMX7D_OCOTP_CLK] = imx_clk_hw_gate4("ocotp_clk", "ipg_root_clk", base + 0x4230, 0);
-	hws[IMX7D_SNVS_CLK] = imx_clk_hw_gate4("snvs_clk", "ipg_root_clk", base + 0x4250, 0);
+	hws[IMX7D_SNVS_CLK] = imx_clk_hw_gate2_flags("snvs_clk", "ipg_root_clk", base + 0x4250, 0, CLK_IS_CRITICAL);
 	hws[IMX7D_MU_ROOT_CLK] = imx_clk_hw_gate4("mu_root_clk", "ipg_root_clk", base + 0x4270, 0);
 	hws[IMX7D_CAAM_CLK] = imx_clk_hw_gate4("caam_clk", "ipg_root_clk", base + 0x4240, 0);
 	hws[IMX7D_USB_HSIC_ROOT_CLK] = imx_clk_hw_gate4("usb_hsic_root_clk", "usb_hsic_post_div", base + 0x4690, 0);
@@ -791,7 +793,6 @@ static void __init imx7d_clocks_init(struct device_node *ccm_node)
 	hws[IMX7D_PCIE_PHY_ROOT_CLK] = imx_clk_hw_gate4("pcie_phy_root_clk", "pcie_phy_post_div", base + 0x4600, 0);
 	hws[IMX7D_EPDC_PIXEL_ROOT_CLK] = imx_clk_hw_gate4("epdc_pixel_root_clk", "epdc_pixel_post_div", base + 0x44a0, 0);
 	hws[IMX7D_LCDIF_PIXEL_ROOT_CLK] = imx_clk_hw_gate4("lcdif_pixel_root_clk", "lcdif_pixel_post_div", base + 0x44b0, 0);
-	hws[IMX7D_PXP_CLK] = imx_clk_hw_gate4("pxp_clk", "main_axi_root_clk", base + 0x44c0, 0);
 	hws[IMX7D_MIPI_DSI_ROOT_CLK] = imx_clk_hw_gate4("mipi_dsi_root_clk", "mipi_dsi_post_div", base + 0x4650, 0);
 	hws[IMX7D_MIPI_CSI_ROOT_CLK] = imx_clk_hw_gate4("mipi_csi_root_clk", "mipi_csi_post_div", base + 0x4640, 0);
 	hws[IMX7D_MIPI_DPHY_ROOT_CLK] = imx_clk_hw_gate4("mipi_dphy_root_clk", "mipi_dphy_post_div", base + 0x4660, 0);
@@ -849,11 +850,14 @@ static void __init imx7d_clocks_init(struct device_node *ccm_node)
 	hws[IMX7D_WDOG4_ROOT_CLK] = imx_clk_hw_gate4("wdog4_root_clk", "wdog_post_div", base + 0x49f0, 0);
 	hws[IMX7D_KPP_ROOT_CLK] = imx_clk_hw_gate4("kpp_root_clk", "ipg_root_clk", base + 0x4aa0, 0);
 	hws[IMX7D_CSI_MCLK_ROOT_CLK] = imx_clk_hw_gate4("csi_mclk_root_clk", "csi_mclk_post_div", base + 0x4490, 0);
+	hws[IMX7D_AUDIO_MCLK_ROOT_CLK] = imx_clk_hw_gate4("audio_mclk_root_clk", "audio_mclk_post_div", base + 0x4790, 0);
 	hws[IMX7D_WRCLK_ROOT_CLK] = imx_clk_hw_gate4("wrclk_root_clk", "wrclk_post_div", base + 0x47a0, 0);
 	hws[IMX7D_USB_CTRL_CLK] = imx_clk_hw_gate4("usb_ctrl_clk", "ahb_root_clk", base + 0x4680, 0);
 	hws[IMX7D_USB_PHY1_CLK] = imx_clk_hw_gate4("usb_phy1_clk", "pll_usb1_main_clk", base + 0x46a0, 0);
 	hws[IMX7D_USB_PHY2_CLK] = imx_clk_hw_gate4("usb_phy2_clk", "pll_usb_main_clk", base + 0x46b0, 0);
 	hws[IMX7D_ADC_ROOT_CLK] = imx_clk_hw_gate4("adc_root_clk", "ipg_root_clk", base + 0x4200, 0);
+	hws[IMX7D_PXP_IPG_CLK] = imx_clk_hw_gate2_shared2("pxp_ipg_clk", "ipg_root_clk", base + 0x44c0, 0, &share_count_pxp);
+	hws[IMX7D_PXP_AXI_CLK] = imx_clk_hw_gate2_shared2("pxp_axi_clk", "main_axi_root_clk", base + 0x44c0, 0, &share_count_pxp);
 
 	hws[IMX7D_GPT_3M_CLK] = imx_clk_hw_fixed_factor("gpt_3m", "osc", 1, 8);
 
@@ -876,6 +880,12 @@ static void __init imx7d_clocks_init(struct device_node *ccm_node)
 
 	clk_set_parent(hws[IMX7D_MIPI_CSI_ROOT_SRC]->clk, hws[IMX7D_PLL_SYS_PFD3_CLK]->clk);
 
+	if (imx_src_is_m4_enabled()) {
+		clk_set_parent(hws[IMX7D_ARM_M4_ROOT_SRC]->clk, hws[IMX7D_PLL_SYS_MAIN_240M_CLK]->clk);
+		clk_prepare_enable(hws[IMX7D_ARM_M4_ROOT_CLK]->clk);
+		clk_prepare_enable(hws[IMX7D_UART2_ROOT_CLK]->clk);
+	}
+
 	/* use old gpt clk setting, gpt1 root clk must be twice as gpt counter freq */
 	clk_set_parent(hws[IMX7D_GPT1_ROOT_SRC]->clk, hws[IMX7D_OSC_24M_CLK]->clk);
 
@@ -883,7 +893,9 @@ static void __init imx7d_clocks_init(struct device_node *ccm_node)
 	hws[IMX7D_USB1_MAIN_480M_CLK] = imx_clk_hw_fixed_factor("pll_usb1_main_clk", "osc", 20, 1);
 	hws[IMX7D_USB_MAIN_480M_CLK] = imx_clk_hw_fixed_factor("pll_usb_main_clk", "osc", 20, 1);
 
-	imx_register_uart_clocks(7);
+	/* set parent of EPDC pixel clock */
+	clk_set_parent(hws[IMX7D_EPDC_PIXEL_ROOT_SRC]->clk, hws[IMX7D_PLL_SYS_MAIN_CLK]->clk);
 
+	imx_register_uart_clocks(7);
 }
 CLK_OF_DECLARE(imx7d, "fsl,imx7d-ccm", imx7d_clocks_init);
diff --git a/drivers/clk/imx/clk-imx7ulp.c b/drivers/clk/imx/clk-imx7ulp.c
index 779e09105..b6e45e77e 100644
--- a/drivers/clk/imx/clk-imx7ulp.c
+++ b/drivers/clk/imx/clk-imx7ulp.c
@@ -78,20 +78,20 @@ static void __init imx7ulp_clk_scg1_init(struct device_node *np)
 	hws[IMX7ULP_CLK_SPLL_PRE_DIV]	= imx_clk_hw_divider_flags("spll_pre_div", "spll_pre_sel", base + 0x608,	8,	3,	CLK_SET_RATE_GATE);
 
 	/*						name	 parent_name	 base */
-	hws[IMX7ULP_CLK_APLL]		= imx_clk_hw_pllv4("apll",  "apll_pre_div", base + 0x500);
-	hws[IMX7ULP_CLK_SPLL]		= imx_clk_hw_pllv4("spll",  "spll_pre_div", base + 0x600);
+	hws[IMX7ULP_CLK_APLL]		= imx_clk_hw_pllv4(IMX_PLLV4_IMX7ULP, "apll",  "apll_pre_div", base + 0x500);
+	hws[IMX7ULP_CLK_SPLL]		= imx_clk_hw_pllv4(IMX_PLLV4_IMX7ULP, "spll",  "spll_pre_div", base + 0x600);
 
 	/* APLL PFDs */
-	hws[IMX7ULP_CLK_APLL_PFD0]	= imx_clk_hw_pfdv2("apll_pfd0", "apll", base + 0x50c, 0);
-	hws[IMX7ULP_CLK_APLL_PFD1]	= imx_clk_hw_pfdv2("apll_pfd1", "apll", base + 0x50c, 1);
-	hws[IMX7ULP_CLK_APLL_PFD2]	= imx_clk_hw_pfdv2("apll_pfd2", "apll", base + 0x50c, 2);
-	hws[IMX7ULP_CLK_APLL_PFD3]	= imx_clk_hw_pfdv2("apll_pfd3", "apll", base + 0x50c, 3);
+	hws[IMX7ULP_CLK_APLL_PFD0]	= imx_clk_hw_pfdv2(IMX_PFDV2_IMX7ULP, "apll_pfd0", "apll", base + 0x50c, 0);
+	hws[IMX7ULP_CLK_APLL_PFD1]	= imx_clk_hw_pfdv2(IMX_PFDV2_IMX7ULP, "apll_pfd1", "apll", base + 0x50c, 1);
+	hws[IMX7ULP_CLK_APLL_PFD2]	= imx_clk_hw_pfdv2(IMX_PFDV2_IMX7ULP, "apll_pfd2", "apll", base + 0x50c, 2);
+	hws[IMX7ULP_CLK_APLL_PFD3]	= imx_clk_hw_pfdv2(IMX_PFDV2_IMX7ULP, "apll_pfd3", "apll", base + 0x50c, 3);
 
 	/* SPLL PFDs */
-	hws[IMX7ULP_CLK_SPLL_PFD0]	= imx_clk_hw_pfdv2("spll_pfd0", "spll", base + 0x60C, 0);
-	hws[IMX7ULP_CLK_SPLL_PFD1]	= imx_clk_hw_pfdv2("spll_pfd1", "spll", base + 0x60C, 1);
-	hws[IMX7ULP_CLK_SPLL_PFD2]	= imx_clk_hw_pfdv2("spll_pfd2", "spll", base + 0x60C, 2);
-	hws[IMX7ULP_CLK_SPLL_PFD3]	= imx_clk_hw_pfdv2("spll_pfd3", "spll", base + 0x60C, 3);
+	hws[IMX7ULP_CLK_SPLL_PFD0]	= imx_clk_hw_pfdv2(IMX_PFDV2_IMX7ULP, "spll_pfd0", "spll", base + 0x60C, 0);
+	hws[IMX7ULP_CLK_SPLL_PFD1]	= imx_clk_hw_pfdv2(IMX_PFDV2_IMX7ULP, "spll_pfd1", "spll", base + 0x60C, 1);
+	hws[IMX7ULP_CLK_SPLL_PFD2]	= imx_clk_hw_pfdv2(IMX_PFDV2_IMX7ULP, "spll_pfd2", "spll", base + 0x60C, 2);
+	hws[IMX7ULP_CLK_SPLL_PFD3]	= imx_clk_hw_pfdv2(IMX_PFDV2_IMX7ULP, "spll_pfd3", "spll", base + 0x60C, 3);
 
 	/* PLL Mux */
 	hws[IMX7ULP_CLK_APLL_PFD_SEL]	= imx_clk_hw_mux_flags("apll_pfd_sel", base + 0x508, 14, 2, apll_pfd_sels, ARRAY_SIZE(apll_pfd_sels), CLK_SET_RATE_PARENT | CLK_SET_PARENT_GATE);
diff --git a/drivers/clk/imx/clk-imx8dxl-acm.c b/drivers/clk/imx/clk-imx8dxl-acm.c
new file mode 100644
index 000000000..b11254522
--- /dev/null
+++ b/drivers/clk/imx/clk-imx8dxl-acm.c
@@ -0,0 +1,235 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2019~2020 NXP
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/pm_domain.h>
+#include <linux/pm_runtime.h>
+
+#include "clk.h"
+#include "clk-scu.h"
+#include "clk-imx-acm-utils.h"
+
+#include <dt-bindings/clock/imx8-clock.h>
+
+struct imx8dxl_acm_priv {
+	struct clk_imx_acm_pm_domains dev_pm;
+	void __iomem *reg;
+	u32 regs[0x20];
+};
+
+static const char *aud_clk_sels[] = {
+	"aud_rec_clk0_lpcg_clk",
+	"aud_rec_clk1_lpcg_clk",
+	"ext_aud_mclk0",
+	"ext_aud_mclk1",
+	"dummy",
+	"dummy",
+	"dummy",
+	"dummy",
+	"spdif0_rx",
+	"sai0_rx_bclk",
+	"sai0_tx_bclk",
+	"sai1_rx_bclk",
+	"sai1_tx_bclk",
+	"sai2_rx_bclk",
+	"sai3_rx_bclk",
+};
+
+static const char *mclk_out_sels[] = {
+	"aud_rec_clk0_lpcg_clk",
+	"aud_rec_clk1_lpcg_clk",
+	"dummy",
+	"dummy",
+	"spdif0_rx",
+	"dummy",
+	"dummy",
+	"dummy",
+};
+
+static const char *sai_mclk_sels[] = {
+	"aud_pll_div_clk0_lpcg_clk",
+	"aud_pll_div_clk1_lpcg_clk",
+	"acm_aud_clk0_sel",
+	"acm_aud_clk1_sel",
+};
+
+static const char *spdif_mclk_sels[] = {
+	"aud_pll_div_clk0_lpcg_clk",
+	"aud_pll_div_clk1_lpcg_clk",
+	"acm_aud_clk0_sel",
+	"acm_aud_clk1_sel",
+};
+
+static const char *mqs_mclk_sels[] = {
+	"aud_pll_div_clk0_lpcg_clk",
+	"aud_pll_div_clk1_lpcg_clk",
+	"acm_aud_clk0_sel",
+	"acm_aud_clk1_sel",
+};
+
+static int imx8dxl_acm_clk_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	struct clk_onecell_data *clk_data;
+	struct imx8dxl_acm_priv *priv;
+	struct resource *res;
+	struct clk **clks;
+	void __iomem *base;
+	int ret;
+	int i;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	base = devm_ioremap(dev, res->start, resource_size(res));
+	if (!base)
+		return -ENOMEM;
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->reg = base;
+
+	platform_set_drvdata(pdev, priv);
+
+	clk_data = devm_kzalloc(&pdev->dev, sizeof(*clk_data), GFP_KERNEL);
+	if (!clk_data)
+		return -ENOMEM;
+
+	clk_data->clks = devm_kcalloc(&pdev->dev, IMX_ADMA_ACM_CLK_END,
+					sizeof(*clk_data->clks), GFP_KERNEL);
+	if (!clk_data->clks)
+		return -ENOMEM;
+
+	clk_data->clk_num = IMX_ADMA_ACM_CLK_END;
+
+	clks = clk_data->clks;
+
+	ret = clk_imx_acm_attach_pm_domains(&pdev->dev, &priv->dev_pm);
+	if (ret)
+		return ret;
+
+	pm_runtime_enable(&pdev->dev);
+	pm_runtime_get_sync(&pdev->dev);
+
+	clks[IMX_ADMA_EXT_AUD_MCLK0]     = imx_clk_fixed("ext_aud_mclk0", 0);
+	clks[IMX_ADMA_EXT_AUD_MCLK1]     = imx_clk_fixed("ext_aud_mclk1", 0);
+	clks[IMX_ADMA_SPDIF0_RX]         = imx_clk_fixed("spdif0_rx", 0);
+	clks[IMX_ADMA_SAI0_RX_BCLK]      = imx_clk_fixed("sai0_rx_bclk", 0);
+	clks[IMX_ADMA_SAI0_TX_BCLK]      = imx_clk_fixed("sai0_tx_bclk", 0);
+	clks[IMX_ADMA_SAI1_RX_BCLK]      = imx_clk_fixed("sai1_rx_bclk", 0);
+	clks[IMX_ADMA_SAI1_TX_BCLK]      = imx_clk_fixed("sai1_tx_bclk", 0);
+	clks[IMX_ADMA_SAI2_RX_BCLK]      = imx_clk_fixed("sai2_rx_bclk", 0);
+	clks[IMX_ADMA_SAI3_RX_BCLK]      = imx_clk_fixed("sai3_rx_bclk", 0);
+
+	clks[IMX_ADMA_ACM_AUD_CLK0_SEL] = imx_dev_clk_mux(dev, "acm_aud_clk0_sel", base+0x000000, 0, 5, aud_clk_sels, ARRAY_SIZE(aud_clk_sels));
+	clks[IMX_ADMA_ACM_AUD_CLK1_SEL]	= imx_dev_clk_mux(dev, "acm_aud_clk1_sel", base+0x010000, 0, 5, aud_clk_sels, ARRAY_SIZE(aud_clk_sels));
+
+	clks[IMX_ADMA_ACM_MCLKOUT0_SEL]	= imx_dev_clk_mux(dev, "acm_mclkout0_sel", base+0x020000, 0, 3, mclk_out_sels, ARRAY_SIZE(mclk_out_sels));
+	clks[IMX_ADMA_ACM_MCLKOUT1_SEL]	= imx_dev_clk_mux(dev, "acm_mclkout1_sel", base+0x030000, 0, 3, mclk_out_sels, ARRAY_SIZE(mclk_out_sels));
+
+	clks[IMX_ADMA_ACM_SAI0_MCLK_SEL] = imx_dev_clk_mux(dev, "acm_sai0_mclk_sel", base+0x0E0000, 0, 2, sai_mclk_sels, ARRAY_SIZE(sai_mclk_sels));
+	clks[IMX_ADMA_ACM_SAI1_MCLK_SEL] = imx_dev_clk_mux(dev, "acm_sai1_mclk_sel", base+0x0F0000, 0, 2, sai_mclk_sels, ARRAY_SIZE(sai_mclk_sels));
+	clks[IMX_ADMA_ACM_SAI2_MCLK_SEL] = imx_dev_clk_mux(dev, "acm_sai2_mclk_sel", base+0x100000, 0, 2, sai_mclk_sels, ARRAY_SIZE(sai_mclk_sels));
+	clks[IMX_ADMA_ACM_SAI3_MCLK_SEL] = imx_dev_clk_mux(dev, "acm_sai3_mclk_sel", base+0x110000, 0, 2, sai_mclk_sels, ARRAY_SIZE(sai_mclk_sels));
+
+	clks[IMX_ADMA_ACM_SPDIF0_TX_CLK_SEL] = imx_dev_clk_mux(dev, "acm_spdif0_mclk_sel", base+0x1A0000, 0, 2, spdif_mclk_sels, ARRAY_SIZE(spdif_mclk_sels));
+	clks[IMX_ADMA_ACM_MQS_TX_CLK_SEL] = imx_dev_clk_mux(dev, "acm_mqs_mclk_sel", base+0x1C0000, 0, 2, mqs_mclk_sels, ARRAY_SIZE(mqs_mclk_sels));
+
+	for (i = 0; i < clk_data->clk_num; i++) {
+		if (IS_ERR(clks[i]))
+			pr_warn("i.MX clk %u: register failed with %ld\n",
+				i, PTR_ERR(clks[i]));
+	}
+
+	ret = of_clk_add_provider(np, of_clk_src_onecell_get, clk_data);
+
+	pm_runtime_put_sync(&pdev->dev);
+
+	return ret;
+}
+
+static int imx8dxl_acm_clk_remove(struct platform_device *pdev)
+{
+	struct imx8dxl_acm_priv *priv = dev_get_drvdata(&pdev->dev);
+
+	pm_runtime_disable(&pdev->dev);
+
+	clk_imx_acm_detach_pm_domains(&pdev->dev, &priv->dev_pm);
+
+	return 0;
+}
+
+static const struct of_device_id imx8dxl_acm_match[] = {
+	{ .compatible = "nxp,imx8dxl-acm", },
+	{ /* sentinel */ }
+};
+
+static int __maybe_unused imx8dxl_acm_runtime_suspend(struct device *dev)
+{
+	struct imx8dxl_acm_priv *priv = dev_get_drvdata(dev);
+
+	priv->regs[0]  = readl_relaxed(priv->reg + 0x000000);
+	priv->regs[1]  = readl_relaxed(priv->reg + 0x010000);
+	priv->regs[2]  = readl_relaxed(priv->reg + 0x020000);
+	priv->regs[3]  = readl_relaxed(priv->reg + 0x030000);
+	priv->regs[14] = readl_relaxed(priv->reg + 0x0E0000);
+	priv->regs[15] = readl_relaxed(priv->reg + 0x0F0000);
+	priv->regs[16] = readl_relaxed(priv->reg + 0x100000);
+	priv->regs[17] = readl_relaxed(priv->reg + 0x110000);
+	priv->regs[26] = readl_relaxed(priv->reg + 0x1A0000);
+	priv->regs[28] = readl_relaxed(priv->reg + 0x1C0000);
+
+	return 0;
+}
+
+static int __maybe_unused imx8dxl_acm_runtime_resume(struct device *dev)
+{
+	struct imx8dxl_acm_priv *priv = dev_get_drvdata(dev);
+
+	writel_relaxed(priv->regs[0],  priv->reg + 0x000000);
+	writel_relaxed(priv->regs[1],  priv->reg + 0x010000);
+	writel_relaxed(priv->regs[2],  priv->reg + 0x020000);
+	writel_relaxed(priv->regs[3],  priv->reg + 0x030000);
+	writel_relaxed(priv->regs[14], priv->reg + 0x0E0000);
+	writel_relaxed(priv->regs[15], priv->reg + 0x0F0000);
+	writel_relaxed(priv->regs[16], priv->reg + 0x100000);
+	writel_relaxed(priv->regs[17], priv->reg + 0x110000);
+	writel_relaxed(priv->regs[26], priv->reg + 0x1A0000);
+	writel_relaxed(priv->regs[28], priv->reg + 0x1C0000);
+
+	return 0;
+}
+
+const struct dev_pm_ops imx8dxl_acm_pm_ops = {
+	SET_RUNTIME_PM_OPS(imx8dxl_acm_runtime_suspend,
+			   imx8dxl_acm_runtime_resume, NULL)
+	SET_NOIRQ_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,
+				      pm_runtime_force_resume)
+};
+
+static struct platform_driver imx8dxl_acm_clk_driver = {
+	.driver = {
+		.name = "imx8dxl-acm",
+		.of_match_table = imx8dxl_acm_match,
+		.pm = &imx8dxl_acm_pm_ops,
+		.suppress_bind_attrs = true,
+	},
+	.probe = imx8dxl_acm_clk_probe,
+	.remove = imx8dxl_acm_clk_remove,
+};
+
+static int __init imx8dxl_acm_init(void)
+{
+	return platform_driver_register(&imx8dxl_acm_clk_driver);
+}
+fs_initcall(imx8dxl_acm_init);
diff --git a/drivers/clk/imx/clk-imx8dxl-rsrc.c b/drivers/clk/imx/clk-imx8dxl-rsrc.c
new file mode 100644
index 000000000..084bad519
--- /dev/null
+++ b/drivers/clk/imx/clk-imx8dxl-rsrc.c
@@ -0,0 +1,65 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2019~2020 NXP
+ */
+
+#include <dt-bindings/firmware/imx/rsrc.h>
+
+#include "clk-scu.h"
+
+/* Keep sorted in the ascending order */
+static u32 imx8dxl_clk_scu_rsrc_table[] = {
+	IMX_SC_R_SPI_0,
+	IMX_SC_R_SPI_1,
+	IMX_SC_R_SPI_2,
+	IMX_SC_R_SPI_3,
+	IMX_SC_R_UART_0,
+	IMX_SC_R_UART_1,
+	IMX_SC_R_UART_2,
+	IMX_SC_R_UART_3,
+	IMX_SC_R_I2C_0,
+	IMX_SC_R_I2C_1,
+	IMX_SC_R_I2C_2,
+	IMX_SC_R_I2C_3,
+	IMX_SC_R_ADC_0,
+	IMX_SC_R_FTM_0,
+	IMX_SC_R_FTM_1,
+	IMX_SC_R_CAN_0,
+	IMX_SC_R_LCD_0,
+	IMX_SC_R_LCD_0_PWM_0,
+	IMX_SC_R_PWM_0,
+	IMX_SC_R_PWM_1,
+	IMX_SC_R_PWM_2,
+	IMX_SC_R_PWM_3,
+	IMX_SC_R_PWM_4,
+	IMX_SC_R_PWM_5,
+	IMX_SC_R_PWM_6,
+	IMX_SC_R_PWM_7,
+	IMX_SC_R_GPT_0,
+	IMX_SC_R_GPT_1,
+	IMX_SC_R_GPT_2,
+	IMX_SC_R_GPT_3,
+	IMX_SC_R_GPT_4,
+	IMX_SC_R_FSPI_0,
+	IMX_SC_R_FSPI_1,
+	IMX_SC_R_SDHC_0,
+	IMX_SC_R_SDHC_1,
+	IMX_SC_R_SDHC_2,
+	IMX_SC_R_ENET_0,
+	IMX_SC_R_ENET_1,
+	IMX_SC_R_USB_1,
+	IMX_SC_R_NAND,
+	IMX_SC_R_M4_0_I2C,
+	IMX_SC_R_M4_0_UART,
+	IMX_SC_R_ELCDIF_PLL,
+	IMX_SC_R_AUDIO_PLL_0,
+	IMX_SC_R_AUDIO_PLL_1,
+	IMX_SC_R_AUDIO_CLK_0,
+	IMX_SC_R_AUDIO_CLK_1,
+	IMX_SC_R_A35
+};
+
+const struct imx_clk_scu_rsrc_table imx_clk_scu_rsrc_imx8dxl = {
+	.rsrc = imx8dxl_clk_scu_rsrc_table,
+	.num = ARRAY_SIZE(imx8dxl_clk_scu_rsrc_table),
+};
diff --git a/drivers/clk/imx/clk-imx8mm.c b/drivers/clk/imx/clk-imx8mm.c
index e92621fa8..5a9f84ae2 100644
--- a/drivers/clk/imx/clk-imx8mm.c
+++ b/drivers/clk/imx/clk-imx8mm.c
@@ -4,7 +4,9 @@
  */
 
 #include <dt-bindings/clock/imx8mm-clock.h>
+#include <linux/clk.h>
 #include <linux/clk-provider.h>
+#include <linux/debugfs.h>
 #include <linux/err.h>
 #include <linux/io.h>
 #include <linux/module.h>
@@ -12,6 +14,7 @@
 #include <linux/platform_device.h>
 #include <linux/slab.h>
 #include <linux/types.h>
+#include <soc/imx/soc.h>
 
 #include "clk.h"
 
@@ -296,6 +299,34 @@ static const char * const clkout_sels[] = {"audio_pll1_out", "audio_pll2_out", "
 static struct clk_hw_onecell_data *clk_hw_data;
 static struct clk_hw **hws;
 
+static int imx_clk_init_on(struct device_node *np,
+				  struct clk_hw * const clks[])
+{
+	u32 *array;
+	int i, ret, elems;
+
+	elems = of_property_count_u32_elems(np, "init-on-array");
+	if (elems < 0)
+		return elems;
+	array = kcalloc(elems, sizeof(elems), GFP_KERNEL);
+	if (!array)
+		return -ENOMEM;
+
+	ret = of_property_read_u32_array(np, "init-on-array", array, elems);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < elems; i++) {
+		ret = clk_prepare_enable(clks[array[i]]->clk);
+		if (ret)
+			pr_err("clk_prepare_enable failed %d\n", array[i]);
+	}
+
+	kfree(array);
+
+	return 0;
+}
+
 static int imx8mm_clocks_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -303,6 +334,8 @@ static int imx8mm_clocks_probe(struct platform_device *pdev)
 	void __iomem *base;
 	int ret;
 
+	check_m4_enabled();
+
 	clk_hw_data = kzalloc(struct_size(clk_hw_data, hws,
 					  IMX8MM_CLK_END), GFP_KERNEL);
 	if (WARN_ON(!clk_hw_data))
@@ -366,45 +399,29 @@ static int imx8mm_clocks_probe(struct platform_device *pdev)
 	hws[IMX8MM_SYS_PLL3_OUT] = imx_clk_hw_gate("sys_pll3_out", "sys_pll3_bypass", base + 0x114, 11);
 
 	/* SYS PLL1 fixed output */
-	hws[IMX8MM_SYS_PLL1_40M_CG] = imx_clk_hw_gate("sys_pll1_40m_cg", "sys_pll1", base + 0x94, 27);
-	hws[IMX8MM_SYS_PLL1_80M_CG] = imx_clk_hw_gate("sys_pll1_80m_cg", "sys_pll1", base + 0x94, 25);
-	hws[IMX8MM_SYS_PLL1_100M_CG] = imx_clk_hw_gate("sys_pll1_100m_cg", "sys_pll1", base + 0x94, 23);
-	hws[IMX8MM_SYS_PLL1_133M_CG] = imx_clk_hw_gate("sys_pll1_133m_cg", "sys_pll1", base + 0x94, 21);
-	hws[IMX8MM_SYS_PLL1_160M_CG] = imx_clk_hw_gate("sys_pll1_160m_cg", "sys_pll1", base + 0x94, 19);
-	hws[IMX8MM_SYS_PLL1_200M_CG] = imx_clk_hw_gate("sys_pll1_200m_cg", "sys_pll1", base + 0x94, 17);
-	hws[IMX8MM_SYS_PLL1_266M_CG] = imx_clk_hw_gate("sys_pll1_266m_cg", "sys_pll1", base + 0x94, 15);
-	hws[IMX8MM_SYS_PLL1_400M_CG] = imx_clk_hw_gate("sys_pll1_400m_cg", "sys_pll1", base + 0x94, 13);
 	hws[IMX8MM_SYS_PLL1_OUT] = imx_clk_hw_gate("sys_pll1_out", "sys_pll1", base + 0x94, 11);
 
-	hws[IMX8MM_SYS_PLL1_40M] = imx_clk_hw_fixed_factor("sys_pll1_40m", "sys_pll1_40m_cg", 1, 20);
-	hws[IMX8MM_SYS_PLL1_80M] = imx_clk_hw_fixed_factor("sys_pll1_80m", "sys_pll1_80m_cg", 1, 10);
-	hws[IMX8MM_SYS_PLL1_100M] = imx_clk_hw_fixed_factor("sys_pll1_100m", "sys_pll1_100m_cg", 1, 8);
-	hws[IMX8MM_SYS_PLL1_133M] = imx_clk_hw_fixed_factor("sys_pll1_133m", "sys_pll1_133m_cg", 1, 6);
-	hws[IMX8MM_SYS_PLL1_160M] = imx_clk_hw_fixed_factor("sys_pll1_160m", "sys_pll1_160m_cg", 1, 5);
-	hws[IMX8MM_SYS_PLL1_200M] = imx_clk_hw_fixed_factor("sys_pll1_200m", "sys_pll1_200m_cg", 1, 4);
-	hws[IMX8MM_SYS_PLL1_266M] = imx_clk_hw_fixed_factor("sys_pll1_266m", "sys_pll1_266m_cg", 1, 3);
-	hws[IMX8MM_SYS_PLL1_400M] = imx_clk_hw_fixed_factor("sys_pll1_400m", "sys_pll1_400m_cg", 1, 2);
+	hws[IMX8MM_SYS_PLL1_40M] = imx_clk_hw_fixed_factor("sys_pll1_40m", "sys_pll1_out", 1, 20);
+	hws[IMX8MM_SYS_PLL1_80M] = imx_clk_hw_fixed_factor("sys_pll1_80m", "sys_pll1_out", 1, 10);
+	hws[IMX8MM_SYS_PLL1_100M] = imx_clk_hw_fixed_factor("sys_pll1_100m", "sys_pll1_out", 1, 8);
+	hws[IMX8MM_SYS_PLL1_133M] = imx_clk_hw_fixed_factor("sys_pll1_133m", "sys_pll1_out", 1, 6);
+	hws[IMX8MM_SYS_PLL1_160M] = imx_clk_hw_fixed_factor("sys_pll1_160m", "sys_pll1_out", 1, 5);
+	hws[IMX8MM_SYS_PLL1_200M] = imx_clk_hw_fixed_factor("sys_pll1_200m", "sys_pll1_out", 1, 4);
+	hws[IMX8MM_SYS_PLL1_266M] = imx_clk_hw_fixed_factor("sys_pll1_266m", "sys_pll1_out", 1, 3);
+	hws[IMX8MM_SYS_PLL1_400M] = imx_clk_hw_fixed_factor("sys_pll1_400m", "sys_pll1_out", 1, 2);
 	hws[IMX8MM_SYS_PLL1_800M] = imx_clk_hw_fixed_factor("sys_pll1_800m", "sys_pll1_out", 1, 1);
 
 	/* SYS PLL2 fixed output */
-	hws[IMX8MM_SYS_PLL2_50M_CG] = imx_clk_hw_gate("sys_pll2_50m_cg", "sys_pll2", base + 0x104, 27);
-	hws[IMX8MM_SYS_PLL2_100M_CG] = imx_clk_hw_gate("sys_pll2_100m_cg", "sys_pll2", base + 0x104, 25);
-	hws[IMX8MM_SYS_PLL2_125M_CG] = imx_clk_hw_gate("sys_pll2_125m_cg", "sys_pll2", base + 0x104, 23);
-	hws[IMX8MM_SYS_PLL2_166M_CG] = imx_clk_hw_gate("sys_pll2_166m_cg", "sys_pll2", base + 0x104, 21);
-	hws[IMX8MM_SYS_PLL2_200M_CG] = imx_clk_hw_gate("sys_pll2_200m_cg", "sys_pll2", base + 0x104, 19);
-	hws[IMX8MM_SYS_PLL2_250M_CG] = imx_clk_hw_gate("sys_pll2_250m_cg", "sys_pll2", base + 0x104, 17);
-	hws[IMX8MM_SYS_PLL2_333M_CG] = imx_clk_hw_gate("sys_pll2_333m_cg", "sys_pll2", base + 0x104, 15);
-	hws[IMX8MM_SYS_PLL2_500M_CG] = imx_clk_hw_gate("sys_pll2_500m_cg", "sys_pll2", base + 0x104, 13);
 	hws[IMX8MM_SYS_PLL2_OUT] = imx_clk_hw_gate("sys_pll2_out", "sys_pll2", base + 0x104, 11);
 
-	hws[IMX8MM_SYS_PLL2_50M] = imx_clk_hw_fixed_factor("sys_pll2_50m", "sys_pll2_50m_cg", 1, 20);
-	hws[IMX8MM_SYS_PLL2_100M] = imx_clk_hw_fixed_factor("sys_pll2_100m", "sys_pll2_100m_cg", 1, 10);
-	hws[IMX8MM_SYS_PLL2_125M] = imx_clk_hw_fixed_factor("sys_pll2_125m", "sys_pll2_125m_cg", 1, 8);
-	hws[IMX8MM_SYS_PLL2_166M] = imx_clk_hw_fixed_factor("sys_pll2_166m", "sys_pll2_166m_cg", 1, 6);
-	hws[IMX8MM_SYS_PLL2_200M] = imx_clk_hw_fixed_factor("sys_pll2_200m", "sys_pll2_200m_cg", 1, 5);
-	hws[IMX8MM_SYS_PLL2_250M] = imx_clk_hw_fixed_factor("sys_pll2_250m", "sys_pll2_250m_cg", 1, 4);
-	hws[IMX8MM_SYS_PLL2_333M] = imx_clk_hw_fixed_factor("sys_pll2_333m", "sys_pll2_333m_cg", 1, 3);
-	hws[IMX8MM_SYS_PLL2_500M] = imx_clk_hw_fixed_factor("sys_pll2_500m", "sys_pll2_500m_cg", 1, 2);
+	hws[IMX8MM_SYS_PLL2_50M] = imx_clk_hw_fixed_factor("sys_pll2_50m", "sys_pll2_out", 1, 20);
+	hws[IMX8MM_SYS_PLL2_100M] = imx_clk_hw_fixed_factor("sys_pll2_100m", "sys_pll2_out", 1, 10);
+	hws[IMX8MM_SYS_PLL2_125M] = imx_clk_hw_fixed_factor("sys_pll2_125m", "sys_pll2_out", 1, 8);
+	hws[IMX8MM_SYS_PLL2_166M] = imx_clk_hw_fixed_factor("sys_pll2_166m", "sys_pll2_out", 1, 6);
+	hws[IMX8MM_SYS_PLL2_200M] = imx_clk_hw_fixed_factor("sys_pll2_200m", "sys_pll2_out", 1, 5);
+	hws[IMX8MM_SYS_PLL2_250M] = imx_clk_hw_fixed_factor("sys_pll2_250m", "sys_pll2_out", 1, 4);
+	hws[IMX8MM_SYS_PLL2_333M] = imx_clk_hw_fixed_factor("sys_pll2_333m", "sys_pll2_out", 1, 3);
+	hws[IMX8MM_SYS_PLL2_500M] = imx_clk_hw_fixed_factor("sys_pll2_500m", "sys_pll2_out", 1, 2);
 	hws[IMX8MM_SYS_PLL2_1000M] = imx_clk_hw_fixed_factor("sys_pll2_1000m", "sys_pll2_out", 1, 1);
 
 	hws[IMX8MM_CLK_CLKOUT1_SEL] = imx_clk_hw_mux2("clkout1_sel", base + 0x128, 4, 4, clkout_sels, ARRAY_SIZE(clkout_sels));
@@ -449,7 +466,7 @@ static int imx8mm_clocks_probe(struct platform_device *pdev)
 	/* BUS */
 	hws[IMX8MM_CLK_MAIN_AXI] = imx8m_clk_hw_composite_bus_critical("main_axi",  imx8mm_main_axi_sels, base + 0x8800);
 	hws[IMX8MM_CLK_ENET_AXI] = imx8m_clk_hw_composite_bus("enet_axi", imx8mm_enet_axi_sels, base + 0x8880);
-	hws[IMX8MM_CLK_NAND_USDHC_BUS] = imx8m_clk_hw_composite_bus_critical("nand_usdhc_bus", imx8mm_nand_usdhc_sels, base + 0x8900);
+	hws[IMX8MM_CLK_NAND_USDHC_BUS] = imx8m_clk_hw_composite("nand_usdhc_bus", imx8mm_nand_usdhc_sels, base + 0x8900);
 	hws[IMX8MM_CLK_VPU_BUS] = imx8m_clk_hw_composite_bus("vpu_bus", imx8mm_vpu_bus_sels, base + 0x8980);
 	hws[IMX8MM_CLK_DISP_AXI] = imx8m_clk_hw_composite_bus("disp_axi", imx8mm_disp_axi_sels, base + 0x8a00);
 	hws[IMX8MM_CLK_DISP_APB] = imx8m_clk_hw_composite_bus("disp_apb", imx8mm_disp_apb_sels, base + 0x8a80);
@@ -577,7 +594,7 @@ static int imx8mm_clocks_probe(struct platform_device *pdev)
 	hws[IMX8MM_CLK_SAI5_IPG] = imx_clk_hw_gate2_shared2("sai5_ipg_clk", "ipg_audio_root", base + 0x4370, 0, &share_count_sai5);
 	hws[IMX8MM_CLK_SAI6_ROOT] = imx_clk_hw_gate2_shared2("sai6_root_clk", "sai6", base + 0x4380, 0, &share_count_sai6);
 	hws[IMX8MM_CLK_SAI6_IPG] = imx_clk_hw_gate2_shared2("sai6_ipg_clk", "ipg_audio_root", base + 0x4380, 0, &share_count_sai6);
-	hws[IMX8MM_CLK_SNVS_ROOT] = imx_clk_hw_gate4("snvs_root_clk", "ipg_root", base + 0x4470, 0);
+	hws[IMX8MM_CLK_SNVS_ROOT] = imx_clk_hw_gate2_flags("snvs_root_clk", "ipg_root", base + 0x4470, 0, CLK_IS_CRITICAL);
 	hws[IMX8MM_CLK_UART1_ROOT] = imx_clk_hw_gate4("uart1_root_clk", "uart1", base + 0x4490, 0);
 	hws[IMX8MM_CLK_UART2_ROOT] = imx_clk_hw_gate4("uart2_root_clk", "uart2", base + 0x44a0, 0);
 	hws[IMX8MM_CLK_UART3_ROOT] = imx_clk_hw_gate4("uart3_root_clk", "uart3", base + 0x44b0, 0);
@@ -627,6 +644,12 @@ static int imx8mm_clocks_probe(struct platform_device *pdev)
 		goto unregister_hws;
 	}
 
+	imx_clk_init_on(np, hws);
+
+	clk_set_parent(hws[IMX8MM_CLK_CSI1_CORE]->clk, hws[IMX8MM_SYS_PLL2_1000M]->clk);
+	clk_set_parent(hws[IMX8MM_CLK_CSI1_PHY_REF]->clk, hws[IMX8MM_SYS_PLL2_1000M]->clk);
+	clk_set_parent(hws[IMX8MM_CLK_CSI1_ESC]->clk, hws[IMX8MM_SYS_PLL1_800M]->clk);
+
 	imx_register_uart_clocks(4);
 
 	return 0;
@@ -657,6 +680,83 @@ static struct platform_driver imx8mm_clk_driver = {
 };
 module_platform_driver(imx8mm_clk_driver);
 
+/*
+ * Debugfs interface for audio PLL K divider change dynamically.
+ * Monitor control for the Audio PLL K-Divider
+ */
+#ifdef CONFIG_DEBUG_FS
+
+#define KDIV_MASK	GENMASK(15, 0)
+#define MDIV_SHIFT	12
+#define MDIV_MASK	GENMASK(21, 12)
+#define PDIV_SHIFT	4
+#define PDIV_MASK	GENMASK(9, 4)
+#define SDIV_SHIFT	0
+#define SDIV_MASK	GENMASK(2, 0)
+
+static int pll_delta_k_set(void *data, u64 val)
+{
+	struct clk_hw *hw;
+	short int delta_k;
+
+	hw = data;
+	delta_k = (short int) (val & KDIV_MASK);
+
+	clk_set_delta_k(hw, val);
+
+	pr_debug("the delta k is %d\n", delta_k);
+	return 0;
+}
+DEFINE_DEBUGFS_ATTRIBUTE(delta_k_fops, NULL, pll_delta_k_set, "%lld\n");
+
+static int pll_setting_show(struct seq_file *s, void *data)
+{
+	struct clk_hw *hw;
+	u32 pll_div_ctrl0, pll_div_ctrl1;
+	u32 mdiv, pdiv, sdiv, kdiv;
+
+	hw = s->private;;
+
+	clk_get_pll_setting(hw, &pll_div_ctrl0, &pll_div_ctrl1);
+	mdiv = (pll_div_ctrl0 & MDIV_MASK) >> MDIV_SHIFT;
+	pdiv = (pll_div_ctrl0 & PDIV_MASK) >> PDIV_SHIFT;
+	sdiv = (pll_div_ctrl0 & SDIV_MASK) >> SDIV_SHIFT;
+	kdiv = (pll_div_ctrl1 & KDIV_MASK);
+
+	seq_printf(s, "Mdiv: 0x%x; Pdiv: 0x%x; Sdiv: 0x%x; Kdiv: 0x%x\n",
+		mdiv, pdiv, sdiv, kdiv);
+
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(pll_setting);
+
+#ifndef MODULE
+static int __init pll_debug_init(void)
+{
+	struct dentry *root, *audio_pll1, *audio_pll2;
+
+	if (of_machine_is_compatible("fsl,imx8mm") && hws) {
+		/* create a root dir for audio pll monitor */
+		root = debugfs_create_dir("audio_pll_monitor", NULL);
+		audio_pll1 = debugfs_create_dir("audio_pll1", root);
+		audio_pll2 = debugfs_create_dir("audio_pll2", root);
+
+		debugfs_create_file_unsafe("delta_k", 0444, audio_pll1,
+			hws[IMX8MM_AUDIO_PLL1], &delta_k_fops);
+		debugfs_create_file("pll_parameter", 0x444, audio_pll1,
+			hws[IMX8MM_AUDIO_PLL1], &pll_setting_fops);
+		debugfs_create_file_unsafe("delta_k", 0444, audio_pll2,
+			hws[IMX8MM_AUDIO_PLL2], &delta_k_fops);
+		debugfs_create_file("pll_parameter", 0x444, audio_pll2,
+			hws[IMX8MM_AUDIO_PLL2], &pll_setting_fops);
+	}
+
+	return 0;
+}
+late_initcall(pll_debug_init);
+#endif /* MODULE */
+#endif /* CONFIG_DEBUG_FS */
+
 MODULE_AUTHOR("Bai Ping <ping.bai@nxp.com>");
 MODULE_DESCRIPTION("NXP i.MX8MM clock driver");
 MODULE_LICENSE("GPL v2");
diff --git a/drivers/clk/imx/clk-imx8mn.c b/drivers/clk/imx/clk-imx8mn.c
index 021355a24..7b45de388 100644
--- a/drivers/clk/imx/clk-imx8mn.c
+++ b/drivers/clk/imx/clk-imx8mn.c
@@ -4,6 +4,7 @@
  */
 
 #include <dt-bindings/clock/imx8mn-clock.h>
+#include <linux/clk.h>
 #include <linux/clk-provider.h>
 #include <linux/err.h>
 #include <linux/io.h>
@@ -12,6 +13,7 @@
 #include <linux/platform_device.h>
 #include <linux/slab.h>
 #include <linux/types.h>
+#include <soc/imx/soc.h>
 
 #include "clk.h"
 
@@ -292,6 +294,34 @@ static const char * const clkout_sels[] = {"audio_pll1_out", "audio_pll2_out", "
 static struct clk_hw_onecell_data *clk_hw_data;
 static struct clk_hw **hws;
 
+static int imx_clk_init_on(struct device_node *np,
+				  struct clk_hw * const clks[])
+{
+	u32 *array;
+	int i, ret, elems;
+
+	elems = of_property_count_u32_elems(np, "init-on-array");
+	if (elems < 0)
+		return elems;
+	array = kcalloc(elems, sizeof(elems), GFP_KERNEL);
+	if (!array)
+		return -ENOMEM;
+
+	ret = of_property_read_u32_array(np, "init-on-array", array, elems);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < elems; i++) {
+		ret = clk_prepare_enable(clks[array[i]]->clk);
+		if (ret)
+			pr_err("clk_prepare_enable failed %d\n", array[i]);
+	}
+
+	kfree(array);
+
+	return 0;
+}
+
 static int imx8mn_clocks_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -299,6 +329,8 @@ static int imx8mn_clocks_probe(struct platform_device *pdev)
 	void __iomem *base;
 	int ret;
 
+	check_m4_enabled();
+
 	clk_hw_data = kzalloc(struct_size(clk_hw_data, hws,
 					  IMX8MN_CLK_END), GFP_KERNEL);
 	if (WARN_ON(!clk_hw_data))
@@ -364,45 +396,29 @@ static int imx8mn_clocks_probe(struct platform_device *pdev)
 	hws[IMX8MN_SYS_PLL3_OUT] = imx_clk_hw_gate("sys_pll3_out", "sys_pll3_bypass", base + 0x114, 11);
 
 	/* SYS PLL1 fixed output */
-	hws[IMX8MN_SYS_PLL1_40M_CG] = imx_clk_hw_gate("sys_pll1_40m_cg", "sys_pll1", base + 0x94, 27);
-	hws[IMX8MN_SYS_PLL1_80M_CG] = imx_clk_hw_gate("sys_pll1_80m_cg", "sys_pll1", base + 0x94, 25);
-	hws[IMX8MN_SYS_PLL1_100M_CG] = imx_clk_hw_gate("sys_pll1_100m_cg", "sys_pll1", base + 0x94, 23);
-	hws[IMX8MN_SYS_PLL1_133M_CG] = imx_clk_hw_gate("sys_pll1_133m_cg", "sys_pll1", base + 0x94, 21);
-	hws[IMX8MN_SYS_PLL1_160M_CG] = imx_clk_hw_gate("sys_pll1_160m_cg", "sys_pll1", base + 0x94, 19);
-	hws[IMX8MN_SYS_PLL1_200M_CG] = imx_clk_hw_gate("sys_pll1_200m_cg", "sys_pll1", base + 0x94, 17);
-	hws[IMX8MN_SYS_PLL1_266M_CG] = imx_clk_hw_gate("sys_pll1_266m_cg", "sys_pll1", base + 0x94, 15);
-	hws[IMX8MN_SYS_PLL1_400M_CG] = imx_clk_hw_gate("sys_pll1_400m_cg", "sys_pll1", base + 0x94, 13);
 	hws[IMX8MN_SYS_PLL1_OUT] = imx_clk_hw_gate("sys_pll1_out", "sys_pll1", base + 0x94, 11);
 
-	hws[IMX8MN_SYS_PLL1_40M] = imx_clk_hw_fixed_factor("sys_pll1_40m", "sys_pll1_40m_cg", 1, 20);
-	hws[IMX8MN_SYS_PLL1_80M] = imx_clk_hw_fixed_factor("sys_pll1_80m", "sys_pll1_80m_cg", 1, 10);
-	hws[IMX8MN_SYS_PLL1_100M] = imx_clk_hw_fixed_factor("sys_pll1_100m", "sys_pll1_100m_cg", 1, 8);
-	hws[IMX8MN_SYS_PLL1_133M] = imx_clk_hw_fixed_factor("sys_pll1_133m", "sys_pll1_133m_cg", 1, 6);
-	hws[IMX8MN_SYS_PLL1_160M] = imx_clk_hw_fixed_factor("sys_pll1_160m", "sys_pll1_160m_cg", 1, 5);
-	hws[IMX8MN_SYS_PLL1_200M] = imx_clk_hw_fixed_factor("sys_pll1_200m", "sys_pll1_200m_cg", 1, 4);
-	hws[IMX8MN_SYS_PLL1_266M] = imx_clk_hw_fixed_factor("sys_pll1_266m", "sys_pll1_266m_cg", 1, 3);
-	hws[IMX8MN_SYS_PLL1_400M] = imx_clk_hw_fixed_factor("sys_pll1_400m", "sys_pll1_400m_cg", 1, 2);
+	hws[IMX8MN_SYS_PLL1_40M] = imx_clk_hw_fixed_factor("sys_pll1_40m", "sys_pll1_out", 1, 20);
+	hws[IMX8MN_SYS_PLL1_80M] = imx_clk_hw_fixed_factor("sys_pll1_80m", "sys_pll1_out", 1, 10);
+	hws[IMX8MN_SYS_PLL1_100M] = imx_clk_hw_fixed_factor("sys_pll1_100m", "sys_pll1_out", 1, 8);
+	hws[IMX8MN_SYS_PLL1_133M] = imx_clk_hw_fixed_factor("sys_pll1_133m", "sys_pll1_out", 1, 6);
+	hws[IMX8MN_SYS_PLL1_160M] = imx_clk_hw_fixed_factor("sys_pll1_160m", "sys_pll1_out", 1, 5);
+	hws[IMX8MN_SYS_PLL1_200M] = imx_clk_hw_fixed_factor("sys_pll1_200m", "sys_pll1_out", 1, 4);
+	hws[IMX8MN_SYS_PLL1_266M] = imx_clk_hw_fixed_factor("sys_pll1_266m", "sys_pll1_out", 1, 3);
+	hws[IMX8MN_SYS_PLL1_400M] = imx_clk_hw_fixed_factor("sys_pll1_400m", "sys_pll1_out", 1, 2);
 	hws[IMX8MN_SYS_PLL1_800M] = imx_clk_hw_fixed_factor("sys_pll1_800m", "sys_pll1_out", 1, 1);
 
 	/* SYS PLL2 fixed output */
-	hws[IMX8MN_SYS_PLL2_50M_CG] = imx_clk_hw_gate("sys_pll2_50m_cg", "sys_pll2", base + 0x104, 27);
-	hws[IMX8MN_SYS_PLL2_100M_CG] = imx_clk_hw_gate("sys_pll2_100m_cg", "sys_pll2", base + 0x104, 25);
-	hws[IMX8MN_SYS_PLL2_125M_CG] = imx_clk_hw_gate("sys_pll2_125m_cg", "sys_pll2", base + 0x104, 23);
-	hws[IMX8MN_SYS_PLL2_166M_CG] = imx_clk_hw_gate("sys_pll2_166m_cg", "sys_pll2", base + 0x104, 21);
-	hws[IMX8MN_SYS_PLL2_200M_CG] = imx_clk_hw_gate("sys_pll2_200m_cg", "sys_pll2", base + 0x104, 19);
-	hws[IMX8MN_SYS_PLL2_250M_CG] = imx_clk_hw_gate("sys_pll2_250m_cg", "sys_pll2", base + 0x104, 17);
-	hws[IMX8MN_SYS_PLL2_333M_CG] = imx_clk_hw_gate("sys_pll2_333m_cg", "sys_pll2", base + 0x104, 15);
-	hws[IMX8MN_SYS_PLL2_500M_CG] = imx_clk_hw_gate("sys_pll2_500m_cg", "sys_pll2", base + 0x104, 13);
 	hws[IMX8MN_SYS_PLL2_OUT] = imx_clk_hw_gate("sys_pll2_out", "sys_pll2", base + 0x104, 11);
 
-	hws[IMX8MN_SYS_PLL2_50M] = imx_clk_hw_fixed_factor("sys_pll2_50m", "sys_pll2_50m_cg", 1, 20);
-	hws[IMX8MN_SYS_PLL2_100M] = imx_clk_hw_fixed_factor("sys_pll2_100m", "sys_pll2_100m_cg", 1, 10);
-	hws[IMX8MN_SYS_PLL2_125M] = imx_clk_hw_fixed_factor("sys_pll2_125m", "sys_pll2_125m_cg", 1, 8);
-	hws[IMX8MN_SYS_PLL2_166M] = imx_clk_hw_fixed_factor("sys_pll2_166m", "sys_pll2_166m_cg", 1, 6);
-	hws[IMX8MN_SYS_PLL2_200M] = imx_clk_hw_fixed_factor("sys_pll2_200m", "sys_pll2_200m_cg", 1, 5);
-	hws[IMX8MN_SYS_PLL2_250M] = imx_clk_hw_fixed_factor("sys_pll2_250m", "sys_pll2_250m_cg", 1, 4);
-	hws[IMX8MN_SYS_PLL2_333M] = imx_clk_hw_fixed_factor("sys_pll2_333m", "sys_pll2_333m_cg", 1, 3);
-	hws[IMX8MN_SYS_PLL2_500M] = imx_clk_hw_fixed_factor("sys_pll2_500m", "sys_pll2_500m_cg", 1, 2);
+	hws[IMX8MN_SYS_PLL2_50M] = imx_clk_hw_fixed_factor("sys_pll2_50m", "sys_pll2_out", 1, 20);
+	hws[IMX8MN_SYS_PLL2_100M] = imx_clk_hw_fixed_factor("sys_pll2_100m", "sys_pll2_out", 1, 10);
+	hws[IMX8MN_SYS_PLL2_125M] = imx_clk_hw_fixed_factor("sys_pll2_125m", "sys_pll2_out", 1, 8);
+	hws[IMX8MN_SYS_PLL2_166M] = imx_clk_hw_fixed_factor("sys_pll2_166m", "sys_pll2_out", 1, 6);
+	hws[IMX8MN_SYS_PLL2_200M] = imx_clk_hw_fixed_factor("sys_pll2_200m", "sys_pll2_out", 1, 5);
+	hws[IMX8MN_SYS_PLL2_250M] = imx_clk_hw_fixed_factor("sys_pll2_250m", "sys_pll2_out", 1, 4);
+	hws[IMX8MN_SYS_PLL2_333M] = imx_clk_hw_fixed_factor("sys_pll2_333m", "sys_pll2_out", 1, 3);
+	hws[IMX8MN_SYS_PLL2_500M] = imx_clk_hw_fixed_factor("sys_pll2_500m", "sys_pll2_out", 1, 2);
 	hws[IMX8MN_SYS_PLL2_1000M] = imx_clk_hw_fixed_factor("sys_pll2_1000m", "sys_pll2_out", 1, 1);
 
 	hws[IMX8MN_CLK_CLKOUT1_SEL] = imx_clk_hw_mux2("clkout1_sel", base + 0x128, 4, 4, clkout_sels, ARRAY_SIZE(clkout_sels));
@@ -540,7 +556,7 @@ static int imx8mn_clocks_probe(struct platform_device *pdev)
 	hws[IMX8MN_CLK_SAI5_IPG] = imx_clk_hw_gate2_shared2("sai5_ipg_clk", "ipg_audio_root", base + 0x4370, 0, &share_count_sai5);
 	hws[IMX8MN_CLK_SAI6_ROOT] = imx_clk_hw_gate2_shared2("sai6_root_clk", "sai6", base + 0x4380, 0, &share_count_sai6);
 	hws[IMX8MN_CLK_SAI6_IPG] = imx_clk_hw_gate2_shared2("sai6_ipg_clk", "ipg_audio_root", base + 0x4380, 0, &share_count_sai6);
-	hws[IMX8MN_CLK_SNVS_ROOT] = imx_clk_hw_gate4("snvs_root_clk", "ipg_root", base + 0x4470, 0);
+	hws[IMX8MN_CLK_SNVS_ROOT] = imx_clk_hw_gate2_flags("snvs_root_clk", "ipg_root", base + 0x4470, 0, CLK_IS_CRITICAL);
 	hws[IMX8MN_CLK_UART1_ROOT] = imx_clk_hw_gate4("uart1_root_clk", "uart1", base + 0x4490, 0);
 	hws[IMX8MN_CLK_UART2_ROOT] = imx_clk_hw_gate4("uart2_root_clk", "uart2", base + 0x44a0, 0);
 	hws[IMX8MN_CLK_UART3_ROOT] = imx_clk_hw_gate4("uart3_root_clk", "uart3", base + 0x44b0, 0);
@@ -566,6 +582,7 @@ static int imx8mn_clocks_probe(struct platform_device *pdev)
 	hws[IMX8MN_CLK_SDMA2_ROOT] = imx_clk_hw_gate4("sdma2_clk", "ipg_audio_root", base + 0x43b0, 0);
 	hws[IMX8MN_CLK_SDMA3_ROOT] = imx_clk_hw_gate4("sdma3_clk", "ipg_audio_root", base + 0x45f0, 0);
 	hws[IMX8MN_CLK_SAI7_ROOT] = imx_clk_hw_gate2_shared2("sai7_root_clk", "sai7", base + 0x4650, 0, &share_count_sai7);
+	hws[IMX8MN_CLK_SAI7_IPG] = imx_clk_hw_gate2_shared2("sai7_ipg_clk", "ipg_audio_root", base + 0x4650, 0, &share_count_sai7);
 
 	hws[IMX8MN_CLK_DRAM_ALT_ROOT] = imx_clk_hw_fixed_factor("dram_alt_root", "dram_alt", 1, 4);
 
@@ -583,6 +600,12 @@ static int imx8mn_clocks_probe(struct platform_device *pdev)
 		goto unregister_hws;
 	}
 
+	imx_clk_init_on(np, hws);
+
+	clk_set_parent(hws[IMX8MN_CLK_AUDIO_AHB]->clk, hws[IMX8MN_SYS_PLL1_800M]->clk);
+	clk_set_rate(hws[IMX8MN_CLK_AUDIO_AHB]->clk, 400000000);
+	clk_set_rate(hws[IMX8MN_CLK_IPG_AUDIO_ROOT]->clk, 400000000);
+
 	imx_register_uart_clocks(4);
 
 	return 0;
diff --git a/drivers/clk/imx/clk-imx8mp.c b/drivers/clk/imx/clk-imx8mp.c
index b173c3009..aa8033419 100644
--- a/drivers/clk/imx/clk-imx8mp.c
+++ b/drivers/clk/imx/clk-imx8mp.c
@@ -4,7 +4,10 @@
  */
 
 #include <dt-bindings/clock/imx8mp-clock.h>
+#include <dt-bindings/reset/imx8mp-reset.h>
+#include <linux/clk.h>
 #include <linux/clk-provider.h>
+#include <linux/debugfs.h>
 #include <linux/err.h>
 #include <linux/io.h>
 #include <linux/module.h>
@@ -12,11 +15,289 @@
 #include <linux/platform_device.h>
 #include <linux/slab.h>
 #include <linux/types.h>
+#include <soc/imx/soc.h>
 
 #include "clk.h"
+#include "clk-blk-ctrl.h"
+
+#define	IMX_AUDIO_BLK_CTRL_CLKEN0		0x0
+#define	IMX_AUDIO_BLK_CTRL_CLKEN1		0x4
+#define	IMX_AUDIO_BLK_CTRL_EARC			0x200
+#define	IMX_AUDIO_BLK_CTRL_SAI1_MCLK_SEL	0x300
+#define	IMX_AUDIO_BLK_CTRL_SAI2_MCLK_SEL	0x304
+#define	IMX_AUDIO_BLK_CTRL_SAI3_MCLK_SEL	0x308
+#define	IMX_AUDIO_BLK_CTRL_SAI5_MCLK_SEL	0x30C
+#define	IMX_AUDIO_BLK_CTRL_SAI6_MCLK_SEL	0x310
+#define	IMX_AUDIO_BLK_CTRL_SAI7_MCLK_SEL	0x314
+#define	IMX_AUDIO_BLK_CTRL_PDM_CLK		0x318
+#define	IMX_AUDIO_BLK_CTRL_SAI_PLL_GNRL_CTL	0x400
+#define	IMX_AUDIO_BLK_CTRL_SAI_PLL_FDIVL_CTL0	0x404
+#define	IMX_AUDIO_BLK_CTRL_SAI_PLL_FDIVL_CTL1	0x408
+#define	IMX_AUDIO_BLK_CTRL_SAI_PLL_SSCG_CTL	0x40C
+#define	IMX_AUDIO_BLK_CTRL_SAI_PLL_MNIT_CTL	0x410
+#define	IMX_AUDIO_BLK_CTRL_IPG_LP_CTRL		0x504
+
+#define IMX_MEDIA_BLK_CTRL_SFT_RSTN		0x0
+#define IMX_MEDIA_BLK_CTRL_CLK_EN		0x4
 
 static u32 share_count_nand;
 static u32 share_count_media;
+static u32 share_count_audio;
+
+static int shared_count_pdm;
+
+/* descending order */
+static const struct imx_pll14xx_rate_table imx_blk_ctrl_sai_pll_tbl[] = {
+	PLL_1443X_RATE(245760000U, 328, 4, 3, 0xae15),
+	PLL_1443X_RATE(225792000U, 226, 3, 3, 0xcac1),
+	PLL_1443X_RATE(122880000U, 328, 4, 4, 0xae15),
+	PLL_1443X_RATE(112896000U, 226,	3, 4, 0xcac1),
+	PLL_1443X_RATE(61440000U, 328, 4, 5, 0xae15),
+	PLL_1443X_RATE(56448000U, 226, 3, 5, 0xcac1),
+	PLL_1443X_RATE(49152000U, 393, 3, 6, 0x374c),
+	PLL_1443X_RATE(45158400U, 241, 2, 6, 0xd845),
+	PLL_1443X_RATE(40960000U, 109, 1, 6, 0x3a07),
+};
+
+static const struct imx_pll14xx_clk imx_blk_ctrl_sai_pll = {
+	.type = PLL_1443X,
+	.rate_table = imx_blk_ctrl_sai_pll_tbl,
+	.rate_count = ARRAY_SIZE(imx_blk_ctrl_sai_pll_tbl),
+};
+
+static const char *imx_sai_mclk2_sels[] = {"sai1_root", "sai2_root", "sai3_root", "dummy",
+					   "sai5_root", "sai6_root", "sai7_root", "sai1_mclk",
+					   "sai2_mclk", "sai3_mclk", "dummy",
+					   "sai5_mclk", "sai6_mclk", "sai7_mclk", "spdif1_ext_clk"};
+static const char *imx_sai1_mclk1_sels[] = {"sai1_root", "sai1_mclk", };
+static const char *imx_sai2_mclk1_sels[] = {"sai2_root", "sai2_mclk", };
+static const char *imx_sai3_mclk1_sels[] = {"sai3_root", "sai3_mclk", };
+static const char *imx_sai5_mclk1_sels[] = {"sai5_root", "sai5_mclk", };
+static const char *imx_sai6_mclk1_sels[] = {"sai6_root", "sai6_mclk", };
+static const char *imx_sai7_mclk1_sels[] = {"sai7_root", "sai7_mclk", };
+static const char *imx_pdm_sels[] = {"pdm_root", "sai_pll_div2", "dummy", "dummy" };
+static const char *imx_sai_pll_ref_sels[] = {"osc_24m", "dummy", "dummy", "dummy", };
+static const char *imx_sai_pll_bypass_sels[] = {"sai_pll", "sai_pll_ref_sel", };
+
+static const char *imx_hdmi_phy_clks_sels[] = { "hdmi_glb_24m", "dummy",};
+static const char *imx_lcdif_clks_sels[] = { "dummy", "hdmi_glb_pix", };
+static const char *imx_hdmi_pipe_clks_sels[] = {"dummy","hdmi_glb_pix", };
+
+static struct imx_blk_ctrl_hw imx8mp_hdmi_blk_ctrl_hws[] = {
+	/* clocks */
+	IMX_BLK_CTRL_CLK_GATE("hdmi_glb_apb", IMX8MP_CLK_HDMI_BLK_CTRL_GLOBAL_APB_CLK, 0x40, 0, "hdmi_apb"),
+	IMX_BLK_CTRL_CLK_GATE("hdmi_glb_b", IMX8MP_CLK_HDMI_BLK_CTRL_GLOBAL_B_CLK, 0x40, 1, "hdmi_axi"),
+	IMX_BLK_CTRL_CLK_GATE("hdmi_glb_ref_266m", IMX8MP_CLK_HDMI_BLK_CTRL_GLOBAL_REF266M_CLK, 0x40, 2, "hdmi_ref_266m"),
+	IMX_BLK_CTRL_CLK_GATE("hdmi_glb_24m", IMX8MP_CLK_HDMI_BLK_CTRL_GLOBAL_XTAL24M_CLK, 0x40, 4, "hdmi_24m"),
+	IMX_BLK_CTRL_CLK_GATE("hdmi_glb_32k", IMX8MP_CLK_HDMI_BLK_CTRL_GLOBAL_XTAL32K_CLK, 0x40, 5, "osc_32k"),
+	IMX_BLK_CTRL_CLK_GATE("hdmi_glb_pix", IMX8MP_CLK_HDMI_BLK_CTRL_GLOBAL_TX_PIX_CLK, 0x40, 7, "hdmi_phy"),
+	IMX_BLK_CTRL_CLK_GATE("hdmi_irq_steer", IMX8MP_CLK_HDMI_BLK_CTRL_IRQS_STEER_CLK, 0x40, 9, "hdmi_glb_apb"),
+	IMX_BLK_CTRL_CLK_GATE("hdmi_noc", IMX8MP_CLK_HDMI_BLK_CTRL_NOC_HDMI_CLK, 0x40, 10, "hdmi_glb_apb"),
+	IMX_BLK_CTRL_CLK_GATE("hdcp_noc", IMX8MP_CLK_HDMI_BLK_CTRL_NOC_HDCP_CLK, 0x40, 11,  "hdmi_glb_apb"),
+	IMX_BLK_CTRL_CLK_GATE("lcdif3_apb", IMX8MP_CLK_HDMI_BLK_CTRL_LCDIF_APB_CLK, 0x40, 16, "hdmi_glb_apb"),
+	IMX_BLK_CTRL_CLK_GATE("lcdif3_b", IMX8MP_CLK_HDMI_BLK_CTRL_LCDIF_B_CLK, 0x40, 17, "hdmi_glb_b"),
+	IMX_BLK_CTRL_CLK_GATE("lcdif3_pdi", IMX8MP_CLK_HDMI_BLK_CTRL_LCDIF_PDI_CLK, 0x40, 18, "hdmi_glb_apb"),
+	IMX_BLK_CTRL_CLK_GATE("lcdif3_pxl", IMX8MP_CLK_HDMI_BLK_CTRL_LCDIF_PIX_CLK, 0x40, 19, "hdmi_glb_pix"),
+	IMX_BLK_CTRL_CLK_GATE("lcdif3_spu", IMX8MP_CLK_HDMI_BLK_CTRL_LCDIF_SPU_CLK, 0x40, 20, "hdmi_glb_apb"),
+	IMX_BLK_CTRL_CLK_GATE("hdmi_fdcc_ref", IMX8MP_CLK_HDMI_BLK_CTRL_FDCC_REF_CLK, 0x50, 2, "hdmi_fdcc_tst"),
+	IMX_BLK_CTRL_CLK_GATE("hrv_mwr_apb", IMX8MP_CLK_HDMI_BLK_CTRL_HRV_MWR_APB_CLK, 0x50, 3, "hdmi_glb_apb"),
+	IMX_BLK_CTRL_CLK_GATE("hrv_mwr_b", IMX8MP_CLK_HDMI_BLK_CTRL_HRV_MWR_B_CLK, 0x50, 4, "hdmi_glb_axi"),
+	IMX_BLK_CTRL_CLK_GATE("hrv_mwr_cea", IMX8MP_CLK_HDMI_BLK_CTRL_HRV_MWR_CEA_CLK, 0x50, 5, "hdmi_glb_apb"),
+	IMX_BLK_CTRL_CLK_GATE("vsfd_cea", IMX8MP_CLK_HDMI_BLK_CTRL_VSFD_CEA_CLK, 0x50, 6, "hdmi_glb_apb"),
+	IMX_BLK_CTRL_CLK_GATE("hdmi_tx_hpi", IMX8MP_CLK_HDMI_BLK_CTRL_TX_HPI_CLK, 0x50, 13, "hdmi_glb_apb"),
+	IMX_BLK_CTRL_CLK_GATE("hdmi_tx_apb", IMX8MP_CLK_HDMI_BLK_CTRL_TX_APB_CLK, 0x50, 14, "hdmi_glb_apb"),
+	IMX_BLK_CTRL_CLK_GATE("hdmi_cec", IMX8MP_CLK_HDMI_BLK_CTRL_TX_CEC_CLK, 0x50, 15, "hdmi_glb_32k"),
+	IMX_BLK_CTRL_CLK_GATE("hdmi_esm", IMX8MP_CLK_HDMI_BLK_CTRL_TX_ESM_CLK, 0x50, 16, "hdmi_glb_ref_266m"),
+	IMX_BLK_CTRL_CLK_GATE("hdmi_tx_gpa", IMX8MP_CLK_HDMI_BLK_CTRL_TX_GPA_CLK, 0x50, 17, "hdmi_glb_apb"),
+	IMX_BLK_CTRL_CLK_GATE("hdmi_tx_pix", IMX8MP_CLK_HDMI_BLK_CTRL_TX_PIXEL_CLK, 0x50, 18, "hdmi_glb_pix"),
+	IMX_BLK_CTRL_CLK_GATE("hdmi_tx_sfr", IMX8MP_CLK_HDMI_BLK_CTRL_TX_SFR_CLK, 0x50, 19, "hdmi_glb_apb"),
+	IMX_BLK_CTRL_CLK_GATE("hdmi_tx_skp", IMX8MP_CLK_HDMI_BLK_CTRL_TX_SKP_CLK, 0x50, 20, "hdmi_glb_apb"),
+	IMX_BLK_CTRL_CLK_GATE("hdmi_tx_prep", IMX8MP_CLK_HDMI_BLK_CTRL_TX_PREP_CLK, 0x50, 21, "hdmi_glb_apb"),
+	IMX_BLK_CTRL_CLK_GATE("hdmi_phy_apb", IMX8MP_CLK_HDMI_BLK_CTRL_TX_PHY_APB_CLK, 0x50, 22, "hdmi_glb_apb"),
+	IMX_BLK_CTRL_CLK_GATE("hdmi_phy_int", IMX8MP_CLK_HDMI_BLK_CTRL_TX_PHY_INT_CLK, 0x50, 24, "hdmi_glb_apb"),
+	IMX_BLK_CTRL_CLK_GATE("hdmi_sec_mem", IMX8MP_CLK_HDMI_BLK_CTRL_TX_SEC_MEM_CLK, 0x50, 25, "hdmi_glb_ref_266m"),
+	IMX_BLK_CTRL_CLK_GATE("hdmi_trng_skp", IMX8MP_CLK_HDMI_BLK_CTRL_TX_TRNG_SKP_CLK, 0x50, 27, "hdmi_glb_apb"),
+	IMX_BLK_CTRL_CLK_GATE("hdmi_vid_pix",  IMX8MP_CLK_HDMI_BLK_CTRL_TX_VID_LINK_PIX_CLK, 0x50, 28, "hdmi_glb_pix"),
+	IMX_BLK_CTRL_CLK_GATE("hdmi_trng_apb", IMX8MP_CLK_HDMI_BLK_CTRL_TX_TRNG_APB_CLK, 0x50, 30, "hdmi_glb_apb"),
+	IMX_BLK_CTRL_CLK_MUX("hdmi_phy_sel", IMX8MP_CLK_HDMI_BLK_CTRL_HTXPHY_CLK_SEL, 0x50, 10, 1, imx_hdmi_phy_clks_sels),
+	IMX_BLK_CTRL_CLK_MUX("lcdif_clk_sel", IMX8MP_CLK_HDMI_BLK_CTRL_LCDIF_CLK_SEL, 0x50, 11, 1, imx_lcdif_clks_sels),
+	IMX_BLK_CTRL_CLK_MUX("hdmi_pipe_sel", IMX8MP_CLK_HDMI_BLK_CTRL_TX_PIPE_CLK_SEL, 0x50, 12, 1, imx_hdmi_pipe_clks_sels),
+
+	/* resets */
+	IMX_BLK_CTRL_RESET_MASK(IMX8MP_HDMI_BLK_CTRL_HDMI_TX_RESET, 0x20, 6, 0x33),
+	IMX_BLK_CTRL_RESET(IMX8MP_HDMI_BLK_CTRL_HDMI_PHY_RESET, 0x20, 12),
+	IMX_BLK_CTRL_RESET(IMX8MP_HDMI_BLK_CTRL_HDMI_PAI_RESET, 0x20, 18),
+	IMX_BLK_CTRL_RESET(IMX8MP_HDMI_BLK_CTRL_HDMI_PVI_RESET, 0x20, 22),
+	IMX_BLK_CTRL_RESET(IMX8MP_HDMI_BLK_CTRL_HDMI_TRNG_RESET, 0x20, 20),
+	IMX_BLK_CTRL_RESET(IMX8MP_HDMI_BLK_CTRL_IRQ_STEER_RESET, 0x20, 16),
+	IMX_BLK_CTRL_RESET(IMX8MP_HDMI_BLK_CTRL_HDMI_HDCP_RESET, 0x20, 13),
+	IMX_BLK_CTRL_RESET_MASK(IMX8MP_HDMI_BLK_CTRL_LCDIF_RESET, 0x20, 4, 0x3),
+};
+
+static struct imx_blk_ctrl_hw imx8mp_media_blk_ctrl_hws[] = {
+	/* clocks */
+	IMX_BLK_CTRL_CLK_GATE("mipi_dsi_pclk", IMX8MP_CLK_MEDIA_BLK_CTRL_MIPI_DSI_PCLK, 0x4, 0, "media_apb_root_clk"),
+	IMX_BLK_CTRL_CLK_GATE("mipi_dsi_clkref", IMX8MP_CLK_MEDIA_BLK_CTRL_MIPI_DSI_CLKREF, 0x4, 1, "media_mipi_phy1_ref"),
+	IMX_BLK_CTRL_CLK_GATE("mipi_csi_pclk", IMX8MP_CLK_MEDIA_BLK_CTRL_MIPI_CSI_PCLK, 0x4, 2, "media_apb_root_clk"),
+	IMX_BLK_CTRL_CLK_GATE("mipi_csi_aclk", IMX8MP_CLK_MEDIA_BLK_CTRL_MIPI_CSI_ACLK, 0x4, 3, "media_cam1_pix_root_clk"),
+	IMX_BLK_CTRL_CLK_GATE("lcdif_pixel_clk", IMX8MP_CLK_MEDIA_BLK_CTRL_LCDIF_PIXEL, 0x4, 4, "media_disp1_pix_root_clk"),
+	IMX_BLK_CTRL_CLK_GATE("lcdif_apb_clk", IMX8MP_CLK_MEDIA_BLK_CTRL_LCDIF_APB, 0x4, 5, "media_apb_root_clk"),
+	IMX_BLK_CTRL_CLK_GATE("isi_proc_clk", IMX8MP_CLK_MEDIA_BLK_CTRL_ISI_PROC, 0x4, 6, "media_axi_root_clk"),
+	IMX_BLK_CTRL_CLK_GATE("isi_apb_clk", IMX8MP_CLK_MEDIA_BLK_CTRL_ISI_APB, 0x4, 7, "media_apb_root_clk"),
+	IMX_BLK_CTRL_CLK_GATE("mipi_csi2_pclk", IMX8MP_CLK_MEDIA_BLK_CTRL_MIPI_CSI2_PCLK, 0x4, 9, "media_apb_root_clk"),
+	IMX_BLK_CTRL_CLK_GATE("mipi_csi2_aclk", IMX8MP_CLK_MEDIA_BLK_CTRL_MIPI_CSI2_ACLK, 0x4, 10, "media_cam2_pix_root_clk"),
+	IMX_BLK_CTRL_CLK_GATE("lcdif2_pixel_clk", IMX8MP_CLK_MEDIA_BLK_CTRL_LCDIF2_PIXEL, 0x4, 11, "media_disp2_pix_root_clk"),
+	IMX_BLK_CTRL_CLK_GATE("lcdif2_apb_clk", IMX8MP_CLK_MEDIA_BLK_CTRL_LCDIF2_APB, 0x4, 12, "media_apb_root_clk"),
+	IMX_BLK_CTRL_CLK_GATE("isp_cor_clk", IMX8MP_CLK_MEDIA_BLK_CTRL_ISP_COR, 0x4, 16, "media_isp_root_clk"),
+	IMX_BLK_CTRL_CLK_GATE("isp_axi_clk", IMX8MP_CLK_MEDIA_BLK_CTRL_ISP_AXI, 0x4, 17, "media_axi_root_clk"),
+	IMX_BLK_CTRL_CLK_GATE("isp_ahb_clk", IMX8MP_CLK_MEDIA_BLK_CTRL_ISP_AHB, 0x4, 18, "media_apb_root_clk"),
+	IMX_BLK_CTRL_CLK_GATE("dwe_cor_clk", IMX8MP_CLK_MEDIA_BLK_CTRL_DWE_COR, 0x4, 19, "media_axi_root_clk"),
+	IMX_BLK_CTRL_CLK_GATE("dwe_axi_clk", IMX8MP_CLK_MEDIA_BLK_CTRL_DWE_AXI, 0x4, 20, "media_axi_root_clk"),
+	IMX_BLK_CTRL_CLK_GATE("dwe_ahb_clk", IMX8MP_CLK_MEDIA_BLK_CTRL_DWE_AHB, 0x4, 21, "media_apb_root_clk"),
+	IMX_BLK_CTRL_CLK_GATE("mipi_dsi2_clk", IMX8MP_CLK_MEDIA_BLK_CTRL_MIPI_DSI2, 0x4, 22, "media_mipi_phy1_ref"),
+	IMX_BLK_CTRL_CLK_GATE("lcdif_axi_clk", IMX8MP_CLK_MEDIA_BLK_CTRL_LCDIF_AXI, 0x4, 23, "media_axi_root_clk"),
+	IMX_BLK_CTRL_CLK_GATE("lcdif2_axi_clk", IMX8MP_CLK_MEDIA_BLK_CTRL_LCDIF2_AXI, 0x4, 24, "media_axi_root_clk"),
+
+	/* resets */
+	IMX_BLK_CTRL_RESET(IMX8MP_MEDIA_BLK_CTRL_RESET_MIPI_DSI_PCLK, 0, 0),
+	IMX_BLK_CTRL_RESET(IMX8MP_MEDIA_BLK_CTRL_RESET_MIPI_DSI_CLKREF, 0, 1),
+	IMX_BLK_CTRL_RESET(IMX8MP_MEDIA_BLK_CTRL_RESET_MIPI_CSI_PCLK, 0, 2),
+	IMX_BLK_CTRL_RESET(IMX8MP_MEDIA_BLK_CTRL_RESET_MIPI_CSI_ACLK, 0, 3),
+	IMX_BLK_CTRL_RESET(IMX8MP_MEDIA_BLK_CTRL_RESET_LCDIF_PIXEL, 0, 4),
+	IMX_BLK_CTRL_RESET(IMX8MP_MEDIA_BLK_CTRL_RESET_LCDIF_APB, 0, 5),
+	IMX_BLK_CTRL_RESET(IMX8MP_MEDIA_BLK_CTRL_RESET_ISI_PROC, 0, 6),
+	IMX_BLK_CTRL_RESET(IMX8MP_MEDIA_BLK_CTRL_RESET_ISI_APB, 0, 7),
+	IMX_BLK_CTRL_RESET(IMX8MP_MEDIA_BLK_CTRL_RESET_BUS_BLK, 0, 8),
+	IMX_BLK_CTRL_RESET(IMX8MP_MEDIA_BLK_CTRL_RESET_MIPI_CSI2_PCLK, 0, 9),
+	IMX_BLK_CTRL_RESET(IMX8MP_MEDIA_BLK_CTRL_RESET_MIPI_CSI2_ACLK, 0, 10),
+	IMX_BLK_CTRL_RESET(IMX8MP_MEDIA_BLK_CTRL_RESET_LCDIF2_PIXEL, 0, 11),
+	IMX_BLK_CTRL_RESET(IMX8MP_MEDIA_BLK_CTRL_RESET_LCDIF2_APB, 0, 12),
+	IMX_BLK_CTRL_RESET(IMX8MP_MEDIA_BLK_CTRL_RESET_ISP1_COR, 0, 13),
+	IMX_BLK_CTRL_RESET(IMX8MP_MEDIA_BLK_CTRL_RESET_ISP1_AXI, 0, 14),
+	IMX_BLK_CTRL_RESET(IMX8MP_MEDIA_BLK_CTRL_RESET_ISP1_AHB, 0, 15),
+	IMX_BLK_CTRL_RESET(IMX8MP_MEDIA_BLK_CTRL_RESET_ISP0_COR, 0, 16),
+	IMX_BLK_CTRL_RESET(IMX8MP_MEDIA_BLK_CTRL_RESET_ISP0_AXI, 0, 17),
+	IMX_BLK_CTRL_RESET(IMX8MP_MEDIA_BLK_CTRL_RESET_ISP0_AHB, 0, 18),
+	IMX_BLK_CTRL_RESET(IMX8MP_MEDIA_BLK_CTRL_RESET_DWE_COR, 0, 19),
+	IMX_BLK_CTRL_RESET(IMX8MP_MEDIA_BLK_CTRL_RESET_DWE_AXI, 0, 20),
+	IMX_BLK_CTRL_RESET(IMX8MP_MEDIA_BLK_CTRL_RESET_DWE_AHB, 0, 21),
+	IMX_BLK_CTRL_RESET(IMX8MP_MEDIA_BLK_CTRL_RESET_MIPI_DSI2, 0, 22),
+	IMX_BLK_CTRL_RESET(IMX8MP_MEDIA_BLK_CTRL_RESET_LCDIF_AXI, 0, 23),
+	IMX_BLK_CTRL_RESET(IMX8MP_MEDIA_BLK_CTRL_RESET_LCDIF2_AXI, 0, 24)
+};
+
+static struct imx_blk_ctrl_hw imx8mp_audio_blk_ctrl_hws[] = {
+	/* clocks */
+	IMX_BLK_CTRL_CLK_MUX("sai_pll_ref_sel", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI_PLL_REF_SEL, 0x400, 0, 2, imx_sai_pll_ref_sels),
+	IMX_BLK_CTRL_CLK_PLL14XX("sai_pll", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI_PLL, 0x400, "sai_pll_ref_sel", &imx_blk_ctrl_sai_pll),
+	IMX_BLK_CTRL_CLK_MUX_FLAGS("sai_pll_bypass", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI_PLL_BYPASS, 0x400, 4, 1, imx_sai_pll_bypass_sels, CLK_SET_RATE_PARENT),
+	IMX_BLK_CTRL_CLK_GATE("sai_pll_out", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI_PLL_OUT, 0x400, 13, "sai_pll_bypass"),
+	IMX_BLK_CTRL_CLK_MUX_FLAGS("sai1_mclk1_sel", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI1_MCLK1_SEL, 0x300, 0, 1, imx_sai1_mclk1_sels, CLK_SET_RATE_PARENT),
+	IMX_BLK_CTRL_CLK_MUX("sai1_mclk2_sel", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI1_MCLK2_SEL, 0x300, 1, 4, imx_sai_mclk2_sels),
+	IMX_BLK_CTRL_CLK_MUX_FLAGS("sai2_mclk1_sel", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI2_MCLK1_SEL, 0x304, 0, 1, imx_sai2_mclk1_sels, CLK_SET_RATE_PARENT),
+	IMX_BLK_CTRL_CLK_MUX("sai2_mclk2_sel", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI2_MCLK2_SEL, 0x304, 1, 4, imx_sai_mclk2_sels),
+	IMX_BLK_CTRL_CLK_MUX_FLAGS("sai3_mclk1_sel", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI3_MCLK1_SEL, 0x308, 0, 1, imx_sai3_mclk1_sels, CLK_SET_RATE_PARENT),
+	IMX_BLK_CTRL_CLK_MUX("sai3_mclk2_sel", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI3_MCLK2_SEL, 0x308, 1, 4, imx_sai_mclk2_sels),
+	IMX_BLK_CTRL_CLK_MUX("sai5_mclk1_sel", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI5_MCLK1_SEL, 0x30C, 0, 1, imx_sai5_mclk1_sels),
+	IMX_BLK_CTRL_CLK_MUX("sai5_mclk2_sel", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI5_MCLK2_SEL, 0x30C, 1, 4, imx_sai_mclk2_sels),
+	IMX_BLK_CTRL_CLK_MUX("sai6_mclk1_sel", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI6_MCLK1_SEL, 0x310, 0, 1, imx_sai6_mclk1_sels),
+	IMX_BLK_CTRL_CLK_MUX("sai6_mclk2_sel", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI6_MCLK2_SEL, 0x310, 1, 4, imx_sai_mclk2_sels),
+	IMX_BLK_CTRL_CLK_MUX("sai7_mclk1_sel", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI7_MCLK1_SEL, 0x314, 0, 1, imx_sai7_mclk1_sels),
+	IMX_BLK_CTRL_CLK_MUX("sai7_mclk2_sel", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI7_MCLK2_SEL, 0x314, 1, 4, imx_sai_mclk2_sels),
+	IMX_BLK_CTRL_CLK_MUX_FLAGS("pdm_sel", IMX8MP_CLK_AUDIO_BLK_CTRL_PDM_SEL, 0x318, 0, 2, imx_pdm_sels, CLK_SET_RATE_PARENT),
+	IMX_BLK_CTRL_CLK_GATE("sai1_ipg_clk",   IMX8MP_CLK_AUDIO_BLK_CTRL_SAI1_IPG, 0, 0, "audio_ahb_root"),
+	IMX_BLK_CTRL_CLK_GATE("sai1_mclk1_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI1_MCLK1, 0, 1, "sai1_mclk1_sel"),
+	IMX_BLK_CTRL_CLK_GATE("sai1_mclk2_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI1_MCLK2, 0, 2, "sai1_mclk2_sel"),
+	IMX_BLK_CTRL_CLK_GATE("sai1_mclk3_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI1_MCLK3, 0, 3, "sai_pll_out"),
+	IMX_BLK_CTRL_CLK_GATE("sai2_ipg_clk",   IMX8MP_CLK_AUDIO_BLK_CTRL_SAI2_IPG, 0, 4, "audio_ahb_root"),
+	IMX_BLK_CTRL_CLK_GATE("sai2_mclk1_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI2_MCLK1, 0, 5, "sai2_mclk1_sel"),
+	IMX_BLK_CTRL_CLK_GATE("sai2_mclk2_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI2_MCLK2, 0, 6, "sai2_mclk2_sel"),
+	IMX_BLK_CTRL_CLK_GATE("sai2_mclk3_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI2_MCLK3, 0, 7, "sai_pll_out"),
+	IMX_BLK_CTRL_CLK_GATE("sai3_ipg_clk",   IMX8MP_CLK_AUDIO_BLK_CTRL_SAI3_IPG, 0, 8, "audio_ahb_root"),
+	IMX_BLK_CTRL_CLK_GATE("sai3_mclk1_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI3_MCLK1, 0, 9, "sai3_mclk1_sel"),
+	IMX_BLK_CTRL_CLK_GATE("sai3_mclk2_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI3_MCLK2, 0, 10, "sai3_mclk2_sel"),
+	IMX_BLK_CTRL_CLK_GATE("sai3_mclk3_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI3_MCLK3, 0, 11, "sai_pll_out"),
+	IMX_BLK_CTRL_CLK_GATE("sai5_ipg_clk",   IMX8MP_CLK_AUDIO_BLK_CTRL_SAI5_IPG, 0, 12, "audio_ahb_root"),
+	IMX_BLK_CTRL_CLK_GATE("sai5_mclk1_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI5_MCLK1, 0, 13, "sai5_mclk1_sel"),
+	IMX_BLK_CTRL_CLK_GATE("sai5_mclk2_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI5_MCLK2, 0, 14, "sai5_mclk2_sel"),
+	IMX_BLK_CTRL_CLK_GATE("sai5_mclk3_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI5_MCLK3, 0, 15, "sai_pll_out"),
+	IMX_BLK_CTRL_CLK_GATE("sai6_ipg_clk",   IMX8MP_CLK_AUDIO_BLK_CTRL_SAI6_IPG, 0, 16, "audio_ahb_root"),
+	IMX_BLK_CTRL_CLK_GATE("sai6_mclk1_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI6_MCLK1, 0, 17, "sai6_mclk1_sel"),
+	IMX_BLK_CTRL_CLK_GATE("sai6_mclk2_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI6_MCLK2, 0, 18, "sai6_mclk2_sel"),
+	IMX_BLK_CTRL_CLK_GATE("sai6_mclk3_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI6_MCLK3, 0, 19, "sai_pll_out"),
+	IMX_BLK_CTRL_CLK_GATE("sai7_ipg_clk",   IMX8MP_CLK_AUDIO_BLK_CTRL_SAI7_IPG, 0, 20, "audio_ahb_root"),
+	IMX_BLK_CTRL_CLK_GATE("sai7_mclk1_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI7_MCLK1, 0, 21, "sai7_mclk1_sel"),
+	IMX_BLK_CTRL_CLK_GATE("sai7_mclk2_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI7_MCLK2, 0, 22, "sai7_mclk2_sel"),
+	IMX_BLK_CTRL_CLK_GATE("sai7_mclk3_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI7_MCLK3, 0, 23, "sai_pll_out"),
+	IMX_BLK_CTRL_CLK_GATE("asrc_ipg_clk",   IMX8MP_CLK_AUDIO_BLK_CTRL_ASRC_IPG, 0, 24, "audio_ahb_root"),
+	IMX_BLK_CTRL_CLK_SHARED_GATE("pdm_ipg_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_PDM_IPG, 0, 25, "audio_ahb_root", &shared_count_pdm),
+	IMX_BLK_CTRL_CLK_SHARED_GATE("pdm_root_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_PDM_ROOT, 0, 25, "pdm_sel", &shared_count_pdm),
+	IMX_BLK_CTRL_CLK_GATE("sdma3_root_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_SDMA3_ROOT, 0, 27, "audio_ahb_root"),
+	IMX_BLK_CTRL_CLK_GATE("spba2_root_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_SPBA2_ROOT, 0, 28, "audio_ahb_root"),
+	IMX_BLK_CTRL_CLK_GATE("dsp_root_clk",   IMX8MP_CLK_AUDIO_BLK_CTRL_DSP_ROOT, 0, 29, "audio_axi_root"),
+	IMX_BLK_CTRL_CLK_GATE("dsp_dbg_clk",    IMX8MP_CLK_AUDIO_BLK_CTRL_DSPDBG_ROOT, 0, 30, "audio_axi_root"),
+	IMX_BLK_CTRL_CLK_GATE("earc_ipg_clk",   IMX8MP_CLK_AUDIO_BLK_CTRL_EARC_IPG, 0, 31, "audio_ahb_root"),
+	IMX_BLK_CTRL_CLK_GATE("ocram_a_ipg_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_OCRAMA_IPG, 4, 0, "audio_axi_root"),
+	IMX_BLK_CTRL_CLK_GATE("aud2htx_ipg_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_AUD2HTX_IPG, 4, 1, "audio_ahb_root"),
+	IMX_BLK_CTRL_CLK_GATE("edma_root_clk",   IMX8MP_CLK_AUDIO_BLK_CTRL_EDMA_ROOT, 4, 2, "audio_ahb_root"),
+	IMX_BLK_CTRL_CLK_GATE("aud_pll_clk",  IMX8MP_CLK_AUDIO_BLK_CTRL_AUDPLL_ROOT, 4, 3, "osc_24m"),
+	IMX_BLK_CTRL_CLK_GATE("mu2_root_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_MU2_ROOT, 4, 4, "audio_ahb_root"),
+	IMX_BLK_CTRL_CLK_GATE("mu3_root_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_MU3_ROOT, 4, 5, "audio_ahb_root"),
+	IMX_BLK_CTRL_CLK_GATE("earc_phy_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_EARC_PHY, 4, 6, "sai_pll_out"),
+
+	/* resets */
+	IMX_BLK_CTRL_RESET(IMX8MP_AUDIO_BLK_CTRL_EARC_RESET, 0x200, 0),
+	IMX_BLK_CTRL_RESET(IMX8MP_AUDIO_BLK_CTRL_EARC_PHY_RESET, 0x200, 1),
+};
+
+const struct imx_blk_ctrl_dev_data imx8mp_hdmi_blk_ctrl_dev_data = {
+	.hws = imx8mp_hdmi_blk_ctrl_hws,
+	.hws_num = ARRAY_SIZE(imx8mp_hdmi_blk_ctrl_hws),
+	.clocks_max = IMX8MP_CLK_HDMI_BLK_CTRL_END,
+	.resets_max = IMX8MP_HDMI_BLK_CTRL_RESET_NUM,
+	.pm_runtime_saved_regs_num = 0
+};
+EXPORT_SYMBOL_GPL(imx8mp_hdmi_blk_ctrl_dev_data);
+
+const struct imx_blk_ctrl_dev_data imx8mp_media_blk_ctrl_dev_data = {
+	.hws = imx8mp_media_blk_ctrl_hws,
+	.hws_num = ARRAY_SIZE(imx8mp_media_blk_ctrl_hws),
+	.clocks_max = IMX8MP_CLK_MEDIA_BLK_CTRL_END,
+	.resets_max = IMX8MP_MEDIA_BLK_CTRL_RESET_NUM,
+	.pm_runtime_saved_regs_num = 2,
+	.pm_runtime_saved_regs = {
+		IMX_MEDIA_BLK_CTRL_SFT_RSTN,
+		IMX_MEDIA_BLK_CTRL_CLK_EN,
+	},
+};
+EXPORT_SYMBOL_GPL(imx8mp_media_blk_ctrl_dev_data);
+
+const struct imx_blk_ctrl_dev_data imx8mp_audio_blk_ctrl_dev_data = {
+	.hws = imx8mp_audio_blk_ctrl_hws,
+	.hws_num = ARRAY_SIZE(imx8mp_audio_blk_ctrl_hws),
+	.clocks_max = IMX8MP_CLK_AUDIO_BLK_CTRL_END,
+	.resets_max = IMX8MP_AUDIO_BLK_CTRL_RESET_NUM,
+	.pm_runtime_saved_regs_num = 16,
+	.pm_runtime_saved_regs = {
+		IMX_AUDIO_BLK_CTRL_CLKEN0,
+		IMX_AUDIO_BLK_CTRL_CLKEN1,
+		IMX_AUDIO_BLK_CTRL_EARC,
+		IMX_AUDIO_BLK_CTRL_SAI1_MCLK_SEL,
+		IMX_AUDIO_BLK_CTRL_SAI2_MCLK_SEL,
+		IMX_AUDIO_BLK_CTRL_SAI3_MCLK_SEL,
+		IMX_AUDIO_BLK_CTRL_SAI5_MCLK_SEL,
+		IMX_AUDIO_BLK_CTRL_SAI6_MCLK_SEL,
+		IMX_AUDIO_BLK_CTRL_SAI7_MCLK_SEL,
+		IMX_AUDIO_BLK_CTRL_PDM_CLK,
+		IMX_AUDIO_BLK_CTRL_SAI_PLL_GNRL_CTL,
+		IMX_AUDIO_BLK_CTRL_SAI_PLL_FDIVL_CTL0,
+		IMX_AUDIO_BLK_CTRL_SAI_PLL_FDIVL_CTL1,
+		IMX_AUDIO_BLK_CTRL_SAI_PLL_SSCG_CTL,
+		IMX_AUDIO_BLK_CTRL_SAI_PLL_MNIT_CTL,
+		IMX_AUDIO_BLK_CTRL_IPG_LP_CTRL
+	},
+};
+EXPORT_SYMBOL_GPL(imx8mp_audio_blk_ctrl_dev_data);
 
 static const char * const pll_ref_sels[] = { "osc_24m", "dummy", "dummy", "dummy", };
 static const char * const audio_pll1_bypass_sels[] = {"audio_pll1", "audio_pll1_ref_sel", };
@@ -128,6 +409,10 @@ static const char * const imx8mp_mipi_dsi_esc_rx_sels[] = {"osc_24m", "sys_pll2_
 							   "sys_pll1_800m", "sys_pll2_1000m",
 							   "sys_pll3_out", "clk_ext3", "audio_pll2_out", };
 
+static const char * const imx8mp_media_disp2_pix_sels[] = {"osc_24m", "video_pll1_out", "audio_pll2_out",
+							   "audio_pll1_out", "sys_pll1_800m", "sys_pll2_1000m",
+							   "sys_pll3_out", "clk_ext4", };
+
 static const char * const imx8mp_dram_alt_sels[] = {"osc_24m", "sys_pll1_800m", "sys_pll1_100m",
 						    "sys_pll2_500m", "sys_pll2_1000m", "sys_pll3_out",
 						    "audio_pll1_out", "sys_pll1_266m", };
@@ -402,12 +687,42 @@ static const char * const imx8mp_dram_core_sels[] = {"dram_pll_out", "dram_alt_r
 static struct clk_hw **hws;
 static struct clk_hw_onecell_data *clk_hw_data;
 
+static int imx_clk_init_on(struct device_node *np,
+				  struct clk_hw * const clks[])
+{
+	u32 *array;
+	int i, ret, elems;
+
+	elems = of_property_count_u32_elems(np, "init-on-array");
+	if (elems < 0)
+		return elems;
+	array = kcalloc(elems, sizeof(elems), GFP_KERNEL);
+	if (!array)
+		return -ENOMEM;
+
+	ret = of_property_read_u32_array(np, "init-on-array", array, elems);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < elems; i++) {
+		ret = clk_prepare_enable(clks[array[i]]->clk);
+		if (ret)
+			pr_err("clk_prepare_enable failed %d\n", array[i]);
+	}
+
+	kfree(array);
+
+	return 0;
+}
+
 static int imx8mp_clocks_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	struct device_node *np;
 	void __iomem *anatop_base, *ccm_base;
 
+	check_m4_enabled();
+
 	np = of_find_compatible_node(NULL, NULL, "fsl,imx8mp-anatop");
 	anatop_base = of_iomap(np, 0);
 	of_node_put(np);
@@ -480,44 +795,28 @@ static int imx8mp_clocks_probe(struct platform_device *pdev)
 	hws[IMX8MP_ARM_PLL_OUT] = imx_clk_hw_gate("arm_pll_out", "arm_pll_bypass", anatop_base + 0x84, 11);
 	hws[IMX8MP_SYS_PLL3_OUT] = imx_clk_hw_gate("sys_pll3_out", "sys_pll3_bypass", anatop_base + 0x114, 11);
 
-	hws[IMX8MP_SYS_PLL1_40M_CG] = imx_clk_hw_gate("sys_pll1_40m_cg", "sys_pll1_bypass", anatop_base + 0x94, 27);
-	hws[IMX8MP_SYS_PLL1_80M_CG] = imx_clk_hw_gate("sys_pll1_80m_cg", "sys_pll1_bypass", anatop_base + 0x94, 25);
-	hws[IMX8MP_SYS_PLL1_100M_CG] = imx_clk_hw_gate("sys_pll1_100m_cg", "sys_pll1_bypass", anatop_base + 0x94, 23);
-	hws[IMX8MP_SYS_PLL1_133M_CG] = imx_clk_hw_gate("sys_pll1_133m_cg", "sys_pll1_bypass", anatop_base + 0x94, 21);
-	hws[IMX8MP_SYS_PLL1_160M_CG] = imx_clk_hw_gate("sys_pll1_160m_cg", "sys_pll1_bypass", anatop_base + 0x94, 19);
-	hws[IMX8MP_SYS_PLL1_200M_CG] = imx_clk_hw_gate("sys_pll1_200m_cg", "sys_pll1_bypass", anatop_base + 0x94, 17);
-	hws[IMX8MP_SYS_PLL1_266M_CG] = imx_clk_hw_gate("sys_pll1_266m_cg", "sys_pll1_bypass", anatop_base + 0x94, 15);
-	hws[IMX8MP_SYS_PLL1_400M_CG] = imx_clk_hw_gate("sys_pll1_400m_cg", "sys_pll1_bypass", anatop_base + 0x94, 13);
 	hws[IMX8MP_SYS_PLL1_OUT] = imx_clk_hw_gate("sys_pll1_out", "sys_pll1_bypass", anatop_base + 0x94, 11);
 
-	hws[IMX8MP_SYS_PLL1_40M] = imx_clk_hw_fixed_factor("sys_pll1_40m", "sys_pll1_40m_cg", 1, 20);
-	hws[IMX8MP_SYS_PLL1_80M] = imx_clk_hw_fixed_factor("sys_pll1_80m", "sys_pll1_80m_cg", 1, 10);
-	hws[IMX8MP_SYS_PLL1_100M] = imx_clk_hw_fixed_factor("sys_pll1_100m", "sys_pll1_100m_cg", 1, 8);
-	hws[IMX8MP_SYS_PLL1_133M] = imx_clk_hw_fixed_factor("sys_pll1_133m", "sys_pll1_133m_cg", 1, 6);
-	hws[IMX8MP_SYS_PLL1_160M] = imx_clk_hw_fixed_factor("sys_pll1_160m", "sys_pll1_160m_cg", 1, 5);
-	hws[IMX8MP_SYS_PLL1_200M] = imx_clk_hw_fixed_factor("sys_pll1_200m", "sys_pll1_200m_cg", 1, 4);
-	hws[IMX8MP_SYS_PLL1_266M] = imx_clk_hw_fixed_factor("sys_pll1_266m", "sys_pll1_266m_cg", 1, 3);
-	hws[IMX8MP_SYS_PLL1_400M] = imx_clk_hw_fixed_factor("sys_pll1_400m", "sys_pll1_400m_cg", 1, 2);
+	hws[IMX8MP_SYS_PLL1_40M] = imx_clk_hw_fixed_factor("sys_pll1_40m", "sys_pll1_out", 1, 20);
+	hws[IMX8MP_SYS_PLL1_80M] = imx_clk_hw_fixed_factor("sys_pll1_80m", "sys_pll1_out", 1, 10);
+	hws[IMX8MP_SYS_PLL1_100M] = imx_clk_hw_fixed_factor("sys_pll1_100m", "sys_pll1_out", 1, 8);
+	hws[IMX8MP_SYS_PLL1_133M] = imx_clk_hw_fixed_factor("sys_pll1_133m", "sys_pll1_out", 1, 6);
+	hws[IMX8MP_SYS_PLL1_160M] = imx_clk_hw_fixed_factor("sys_pll1_160m", "sys_pll1_out", 1, 5);
+	hws[IMX8MP_SYS_PLL1_200M] = imx_clk_hw_fixed_factor("sys_pll1_200m", "sys_pll1_out", 1, 4);
+	hws[IMX8MP_SYS_PLL1_266M] = imx_clk_hw_fixed_factor("sys_pll1_266m", "sys_pll1_out", 1, 3);
+	hws[IMX8MP_SYS_PLL1_400M] = imx_clk_hw_fixed_factor("sys_pll1_400m", "sys_pll1_out", 1, 2);
 	hws[IMX8MP_SYS_PLL1_800M] = imx_clk_hw_fixed_factor("sys_pll1_800m", "sys_pll1_out", 1, 1);
 
-	hws[IMX8MP_SYS_PLL2_50M_CG] = imx_clk_hw_gate("sys_pll2_50m_cg", "sys_pll2_bypass", anatop_base + 0x104, 27);
-	hws[IMX8MP_SYS_PLL2_100M_CG] = imx_clk_hw_gate("sys_pll2_100m_cg", "sys_pll2_bypass", anatop_base + 0x104, 25);
-	hws[IMX8MP_SYS_PLL2_125M_CG] = imx_clk_hw_gate("sys_pll2_125m_cg", "sys_pll2_bypass", anatop_base + 0x104, 23);
-	hws[IMX8MP_SYS_PLL2_166M_CG] = imx_clk_hw_gate("sys_pll2_166m_cg", "sys_pll2_bypass", anatop_base + 0x104, 21);
-	hws[IMX8MP_SYS_PLL2_200M_CG] = imx_clk_hw_gate("sys_pll2_200m_cg", "sys_pll2_bypass", anatop_base + 0x104, 19);
-	hws[IMX8MP_SYS_PLL2_250M_CG] = imx_clk_hw_gate("sys_pll2_250m_cg", "sys_pll2_bypass", anatop_base + 0x104, 17);
-	hws[IMX8MP_SYS_PLL2_333M_CG] = imx_clk_hw_gate("sys_pll2_333m_cg", "sys_pll2_bypass", anatop_base + 0x104, 15);
-	hws[IMX8MP_SYS_PLL2_500M_CG] = imx_clk_hw_gate("sys_pll2_500m_cg", "sys_pll2_bypass", anatop_base + 0x104, 13);
 	hws[IMX8MP_SYS_PLL2_OUT] = imx_clk_hw_gate("sys_pll2_out", "sys_pll2_bypass", anatop_base + 0x104, 11);
 
-	hws[IMX8MP_SYS_PLL2_50M] = imx_clk_hw_fixed_factor("sys_pll2_50m", "sys_pll2_50m_cg", 1, 20);
-	hws[IMX8MP_SYS_PLL2_100M] = imx_clk_hw_fixed_factor("sys_pll2_100m", "sys_pll2_100m_cg", 1, 10);
-	hws[IMX8MP_SYS_PLL2_125M] = imx_clk_hw_fixed_factor("sys_pll2_125m", "sys_pll2_125m_cg", 1, 8);
-	hws[IMX8MP_SYS_PLL2_166M] = imx_clk_hw_fixed_factor("sys_pll2_166m", "sys_pll2_166m_cg", 1, 6);
-	hws[IMX8MP_SYS_PLL2_200M] = imx_clk_hw_fixed_factor("sys_pll2_200m", "sys_pll2_200m_cg", 1, 5);
-	hws[IMX8MP_SYS_PLL2_250M] = imx_clk_hw_fixed_factor("sys_pll2_250m", "sys_pll2_250m_cg", 1, 4);
-	hws[IMX8MP_SYS_PLL2_333M] = imx_clk_hw_fixed_factor("sys_pll2_333m", "sys_pll2_333m_cg", 1, 3);
-	hws[IMX8MP_SYS_PLL2_500M] = imx_clk_hw_fixed_factor("sys_pll2_500m", "sys_pll2_500m_cg", 1, 2);
+	hws[IMX8MP_SYS_PLL2_50M] = imx_clk_hw_fixed_factor("sys_pll2_50m", "sys_pll2_out", 1, 20);
+	hws[IMX8MP_SYS_PLL2_100M] = imx_clk_hw_fixed_factor("sys_pll2_100m", "sys_pll2_out", 1, 10);
+	hws[IMX8MP_SYS_PLL2_125M] = imx_clk_hw_fixed_factor("sys_pll2_125m", "sys_pll2_out", 1, 8);
+	hws[IMX8MP_SYS_PLL2_166M] = imx_clk_hw_fixed_factor("sys_pll2_166m", "sys_pll2_out", 1, 6);
+	hws[IMX8MP_SYS_PLL2_200M] = imx_clk_hw_fixed_factor("sys_pll2_200m", "sys_pll2_out", 1, 5);
+	hws[IMX8MP_SYS_PLL2_250M] = imx_clk_hw_fixed_factor("sys_pll2_250m", "sys_pll2_out", 1, 4);
+	hws[IMX8MP_SYS_PLL2_333M] = imx_clk_hw_fixed_factor("sys_pll2_333m", "sys_pll2_out", 1, 3);
+	hws[IMX8MP_SYS_PLL2_500M] = imx_clk_hw_fixed_factor("sys_pll2_500m", "sys_pll2_out", 1, 2);
 	hws[IMX8MP_SYS_PLL2_1000M] = imx_clk_hw_fixed_factor("sys_pll2_1000m", "sys_pll2_out", 1, 1);
 
 	hws[IMX8MP_CLK_A53_DIV] = imx8m_clk_hw_composite_core("arm_a53_div", imx8mp_a53_sels, ccm_base + 0x8000);
@@ -538,7 +837,7 @@ static int imx8mp_clocks_probe(struct platform_device *pdev)
 
 	hws[IMX8MP_CLK_MAIN_AXI] = imx8m_clk_hw_composite_bus_critical("main_axi", imx8mp_main_axi_sels, ccm_base + 0x8800);
 	hws[IMX8MP_CLK_ENET_AXI] = imx8m_clk_hw_composite_bus("enet_axi", imx8mp_enet_axi_sels, ccm_base + 0x8880);
-	hws[IMX8MP_CLK_NAND_USDHC_BUS] = imx8m_clk_hw_composite_bus_critical("nand_usdhc_bus", imx8mp_nand_usdhc_sels, ccm_base + 0x8900);
+	hws[IMX8MP_CLK_NAND_USDHC_BUS] = imx8m_clk_hw_composite("nand_usdhc_bus", imx8mp_nand_usdhc_sels, ccm_base + 0x8900);
 	hws[IMX8MP_CLK_VPU_BUS] = imx8m_clk_hw_composite_bus("vpu_bus", imx8mp_vpu_bus_sels, ccm_base + 0x8980);
 	hws[IMX8MP_CLK_MEDIA_AXI] = imx8m_clk_hw_composite_bus("media_axi", imx8mp_media_axi_sels, ccm_base + 0x8a00);
 	hws[IMX8MP_CLK_MEDIA_APB] = imx8m_clk_hw_composite_bus("media_apb", imx8mp_media_apb_sels, ccm_base + 0x8a80);
@@ -554,6 +853,7 @@ static int imx8mp_clocks_probe(struct platform_device *pdev)
 	hws[IMX8MP_CLK_AHB] = imx8m_clk_hw_composite_bus_critical("ahb_root", imx8mp_ahb_sels, ccm_base + 0x9000);
 	hws[IMX8MP_CLK_AUDIO_AHB] = imx8m_clk_hw_composite_bus("audio_ahb", imx8mp_audio_ahb_sels, ccm_base + 0x9100);
 	hws[IMX8MP_CLK_MIPI_DSI_ESC_RX] = imx8m_clk_hw_composite_bus("mipi_dsi_esc_rx", imx8mp_mipi_dsi_esc_rx_sels, ccm_base + 0x9200);
+	hws[IMX8MP_CLK_MEDIA_DISP2_PIX] = imx8m_clk_hw_composite_bus("media_disp2_pix", imx8mp_media_disp2_pix_sels, ccm_base + 0x9300);
 
 	hws[IMX8MP_CLK_IPG_ROOT] = imx_clk_hw_divider2("ipg_root", "ahb_root", ccm_base + 0x9080, 0, 1);
 
@@ -670,12 +970,12 @@ static int imx8mp_clocks_probe(struct platform_device *pdev)
 	hws[IMX8MP_CLK_SIM_ENET_ROOT] = imx_clk_hw_gate4("sim_enet_root_clk", "enet_axi", ccm_base + 0x4400, 0);
 	hws[IMX8MP_CLK_GPU2D_ROOT] = imx_clk_hw_gate4("gpu2d_root_clk", "gpu2d_core", ccm_base + 0x4450, 0);
 	hws[IMX8MP_CLK_GPU3D_ROOT] = imx_clk_hw_gate4("gpu3d_root_clk", "gpu3d_core", ccm_base + 0x4460, 0);
-	hws[IMX8MP_CLK_SNVS_ROOT] = imx_clk_hw_gate4("snvs_root_clk", "ipg_root", ccm_base + 0x4470, 0);
+	hws[IMX8MP_CLK_SNVS_ROOT] = imx_clk_hw_gate2_flags("snvs_root_clk", "ipg_root", ccm_base + 0x4470, 0, CLK_IS_CRITICAL);
 	hws[IMX8MP_CLK_UART1_ROOT] = imx_clk_hw_gate4("uart1_root_clk", "uart1", ccm_base + 0x4490, 0);
 	hws[IMX8MP_CLK_UART2_ROOT] = imx_clk_hw_gate4("uart2_root_clk", "uart2", ccm_base + 0x44a0, 0);
 	hws[IMX8MP_CLK_UART3_ROOT] = imx_clk_hw_gate4("uart3_root_clk", "uart3", ccm_base + 0x44b0, 0);
 	hws[IMX8MP_CLK_UART4_ROOT] = imx_clk_hw_gate4("uart4_root_clk", "uart4", ccm_base + 0x44c0, 0);
-	hws[IMX8MP_CLK_USB_ROOT] = imx_clk_hw_gate4("usb_root_clk", "hsio_axi", ccm_base + 0x44d0, 0);
+	hws[IMX8MP_CLK_USB_ROOT] = imx_clk_hw_gate4("usb_root_clk", "osc_32k", ccm_base + 0x44d0, 0);
 	hws[IMX8MP_CLK_USB_PHY_ROOT] = imx_clk_hw_gate4("usb_phy_root_clk", "usb_phy_ref", ccm_base + 0x44f0, 0);
 	hws[IMX8MP_CLK_USDHC1_ROOT] = imx_clk_hw_gate4("usdhc1_root_clk", "usdhc1", ccm_base + 0x4510, 0);
 	hws[IMX8MP_CLK_USDHC2_ROOT] = imx_clk_hw_gate4("usdhc2_root_clk", "usdhc2", ccm_base + 0x4520, 0);
@@ -694,13 +994,23 @@ static int imx8mp_clocks_probe(struct platform_device *pdev)
 	hws[IMX8MP_CLK_MEDIA_CAM2_PIX_ROOT] = imx_clk_hw_gate2_shared2("media_cam2_pix_root_clk", "media_cam2_pix", ccm_base + 0x45d0, 0, &share_count_media);
 	hws[IMX8MP_CLK_MEDIA_DISP1_PIX_ROOT] = imx_clk_hw_gate2_shared2("media_disp1_pix_root_clk", "media_disp1_pix", ccm_base + 0x45d0, 0, &share_count_media);
 	hws[IMX8MP_CLK_MEDIA_DISP2_PIX_ROOT] = imx_clk_hw_gate2_shared2("media_disp2_pix_root_clk", "media_disp2_pix", ccm_base + 0x45d0, 0, &share_count_media);
+	hws[IMX8MP_CLK_MEDIA_LDB_ROOT] = imx_clk_hw_gate2_shared2("media_ldb_root_clk", "media_ldb", ccm_base + 0x45d0, 0, &share_count_media);
 	hws[IMX8MP_CLK_MEDIA_ISP_ROOT] = imx_clk_hw_gate2_shared2("media_isp_root_clk", "media_isp", ccm_base + 0x45d0, 0, &share_count_media);
 
 	hws[IMX8MP_CLK_USDHC3_ROOT] = imx_clk_hw_gate4("usdhc3_root_clk", "usdhc3", ccm_base + 0x45e0, 0);
 	hws[IMX8MP_CLK_HDMI_ROOT] = imx_clk_hw_gate4("hdmi_root_clk", "hdmi_axi", ccm_base + 0x45f0, 0);
 	hws[IMX8MP_CLK_TSENSOR_ROOT] = imx_clk_hw_gate4("tsensor_root_clk", "ipg_root", ccm_base + 0x4620, 0);
 	hws[IMX8MP_CLK_VPU_ROOT] = imx_clk_hw_gate4("vpu_root_clk", "vpu_bus", ccm_base + 0x4630, 0);
-	hws[IMX8MP_CLK_AUDIO_ROOT] = imx_clk_hw_gate4("audio_root_clk", "ipg_root", ccm_base + 0x4650, 0);
+
+	hws[IMX8MP_CLK_AUDIO_AHB_ROOT] = imx_clk_hw_gate2_shared2("audio_ahb_root", "audio_ahb", ccm_base + 0x4650, 0, &share_count_audio);
+	hws[IMX8MP_CLK_AUDIO_AXI_ROOT] = imx_clk_hw_gate2_shared2("audio_axi_root", "audio_axi", ccm_base + 0x4650, 0, &share_count_audio);
+	hws[IMX8MP_CLK_SAI1_ROOT] = imx_clk_hw_gate2_shared2("sai1_root", "sai1", ccm_base + 0x4650, 0, &share_count_audio);
+	hws[IMX8MP_CLK_SAI2_ROOT] = imx_clk_hw_gate2_shared2("sai2_root", "sai2", ccm_base + 0x4650, 0, &share_count_audio);
+	hws[IMX8MP_CLK_SAI3_ROOT] = imx_clk_hw_gate2_shared2("sai3_root", "sai3", ccm_base + 0x4650, 0, &share_count_audio);
+	hws[IMX8MP_CLK_SAI5_ROOT] = imx_clk_hw_gate2_shared2("sai5_root", "sai5", ccm_base + 0x4650, 0, &share_count_audio);
+	hws[IMX8MP_CLK_SAI6_ROOT] = imx_clk_hw_gate2_shared2("sai6_root", "sai6", ccm_base + 0x4650, 0, &share_count_audio);
+	hws[IMX8MP_CLK_SAI7_ROOT] = imx_clk_hw_gate2_shared2("sai7_root", "sai7", ccm_base + 0x4650, 0, &share_count_audio);
+	hws[IMX8MP_CLK_PDM_ROOT] = imx_clk_hw_gate2_shared2("pdm_root", "pdm", ccm_base + 0x4650, 0, &share_count_audio);
 
 	hws[IMX8MP_CLK_ARM] = imx_clk_hw_cpu("arm", "arm_a53_core",
 					     hws[IMX8MP_CLK_A53_CORE]->clk,
@@ -712,6 +1022,8 @@ static int imx8mp_clocks_probe(struct platform_device *pdev)
 
 	of_clk_add_hw_provider(np, of_clk_hw_onecell_get, clk_hw_data);
 
+	imx_clk_init_on(np, hws);
+	
 	imx_register_uart_clocks(4);
 
 	return 0;
@@ -740,3 +1052,80 @@ module_platform_driver(imx8mp_clk_driver);
 MODULE_AUTHOR("Anson Huang <Anson.Huang@nxp.com>");
 MODULE_DESCRIPTION("NXP i.MX8MP clock driver");
 MODULE_LICENSE("GPL v2");
+
+#ifndef MODULE
+/*
+ * Debugfs interface for audio PLL K divider change dynamically.
+ * Monitor control for the Audio PLL K-Divider
+ */
+#ifdef CONFIG_DEBUG_FS
+
+#define KDIV_MASK	GENMASK(15, 0)
+#define MDIV_SHIFT	12
+#define MDIV_MASK	GENMASK(21, 12)
+#define PDIV_SHIFT	4
+#define PDIV_MASK	GENMASK(9, 4)
+#define SDIV_SHIFT	0
+#define SDIV_MASK	GENMASK(2, 0)
+
+static int pll_delta_k_set(void *data, u64 val)
+{
+	struct clk_hw *hw;
+	short int delta_k;
+
+	hw = data;
+	delta_k = (short int) (val & KDIV_MASK);
+
+	clk_set_delta_k(hw, val);
+
+	pr_debug("the delta k is %d\n", delta_k);
+	return 0;
+}
+DEFINE_DEBUGFS_ATTRIBUTE(delta_k_fops, NULL, pll_delta_k_set, "%lld\n");
+
+static int pll_setting_show(struct seq_file *s, void *data)
+{
+	struct clk_hw *hw;
+	u32 pll_div_ctrl0, pll_div_ctrl1;
+	u32 mdiv, pdiv, sdiv, kdiv;
+
+	hw = s->private;
+
+	clk_get_pll_setting(hw, &pll_div_ctrl0, &pll_div_ctrl1);
+	mdiv = (pll_div_ctrl0 & MDIV_MASK) >> MDIV_SHIFT;
+	pdiv = (pll_div_ctrl0 & PDIV_MASK) >> PDIV_SHIFT;
+	sdiv = (pll_div_ctrl0 & SDIV_MASK) >> SDIV_SHIFT;
+	kdiv = (pll_div_ctrl1 & KDIV_MASK);
+
+	seq_printf(s, "Mdiv: 0x%x; Pdiv: 0x%x; Sdiv: 0x%x; Kdiv: 0x%x\n",
+		mdiv, pdiv, sdiv, kdiv);
+
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(pll_setting);
+
+static int __init pll_debug_init(void)
+{
+	struct dentry *root, *audio_pll1, *audio_pll2;
+
+	if (of_machine_is_compatible("fsl,imx8mp") && hws) {
+		/* create a root dir for audio pll monitor */
+		root = debugfs_create_dir("audio_pll_monitor", NULL);
+		audio_pll1 = debugfs_create_dir("audio_pll1", root);
+		audio_pll2 = debugfs_create_dir("audio_pll2", root);
+
+		debugfs_create_file_unsafe("delta_k", 0444, audio_pll1,
+			hws[IMX8MP_AUDIO_PLL1], &delta_k_fops);
+		debugfs_create_file("pll_parameter", 0x444, audio_pll1,
+			hws[IMX8MP_AUDIO_PLL1], &pll_setting_fops);
+		debugfs_create_file_unsafe("delta_k", 0444, audio_pll2,
+			hws[IMX8MP_AUDIO_PLL2], &delta_k_fops);
+		debugfs_create_file("pll_parameter", 0x444, audio_pll2,
+			hws[IMX8MP_AUDIO_PLL2], &pll_setting_fops);
+	}
+
+	return 0;
+}
+late_initcall(pll_debug_init);
+#endif /* CONFIG_DEBUG_FS */
+#endif /* MODULE */
diff --git a/drivers/clk/imx/clk-imx8mq.c b/drivers/clk/imx/clk-imx8mq.c
index 83cc2b1c3..55323f416 100644
--- a/drivers/clk/imx/clk-imx8mq.c
+++ b/drivers/clk/imx/clk-imx8mq.c
@@ -5,6 +5,7 @@
  */
 
 #include <dt-bindings/clock/imx8mq-clock.h>
+#include <linux/clk.h>
 #include <linux/clk-provider.h>
 #include <linux/err.h>
 #include <linux/io.h>
@@ -13,6 +14,8 @@
 #include <linux/types.h>
 #include <linux/slab.h>
 #include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <soc/imx/soc.h>
 
 #include "clk.h"
 
@@ -25,7 +28,7 @@ static u32 share_count_sai6;
 static u32 share_count_dcss;
 static u32 share_count_nand;
 
-static const char * const pll_ref_sels[] = { "osc_25m", "osc_27m", "dummy", "dummy", };
+static const char * const pll_ref_sels[] = { "osc_25m", "osc_27m", "phy_27m", "dummy", };
 static const char * const arm_pll_bypass_sels[] = {"arm_pll", "arm_pll_ref_sel", };
 static const char * const gpu_pll_bypass_sels[] = {"gpu_pll", "gpu_pll_ref_sel", };
 static const char * const vpu_pll_bypass_sels[] = {"vpu_pll", "vpu_pll_ref_sel", };
@@ -281,6 +284,34 @@ static const char * const pllout_monitor_sels[] = {"osc_25m", "osc_27m", "dummy"
 static struct clk_hw_onecell_data *clk_hw_data;
 static struct clk_hw **hws;
 
+static int imx_clk_init_on(struct device_node *np,
+				  struct clk_hw * const clks[])
+{
+	u32 *array;
+	int i, ret, elems;
+
+	elems = of_property_count_u32_elems(np, "init-on-array");
+	if (elems < 0)
+		return elems;
+	array = kzalloc(elems * sizeof(elems), GFP_KERNEL);
+	if (!array)
+		return -ENOMEM;
+
+	ret = of_property_read_u32_array(np, "init-on-array", array, elems);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < elems; i++) {
+		ret = clk_prepare_enable(clks[array[i]]->clk);
+		if (ret)
+			pr_err("clk_prepare_enable failed %d\n", array[i]);
+	}
+
+	kfree(array);
+
+	return 0;
+}
+
 static int imx8mq_clocks_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -288,6 +319,8 @@ static int imx8mq_clocks_probe(struct platform_device *pdev)
 	void __iomem *base;
 	int err;
 
+	check_m4_enabled();
+
 	clk_hw_data = kzalloc(struct_size(clk_hw_data, hws,
 					  IMX8MQ_CLK_END), GFP_KERNEL);
 	if (WARN_ON(!clk_hw_data))
@@ -304,6 +337,7 @@ static int imx8mq_clocks_probe(struct platform_device *pdev)
 	hws[IMX8MQ_CLK_EXT2] = imx_obtain_fixed_clk_hw(np, "clk_ext2");
 	hws[IMX8MQ_CLK_EXT3] = imx_obtain_fixed_clk_hw(np, "clk_ext3");
 	hws[IMX8MQ_CLK_EXT4] = imx_obtain_fixed_clk_hw(np, "clk_ext4");
+	hws[IMX8MQ_CLK_PHY_27MHZ] = imx_clk_hw_fixed("phy_27m", 27000000);
 
 	np = of_find_compatible_node(NULL, NULL, "fsl,imx8mq-anatop");
 	base = of_iomap(np, 0);
@@ -343,6 +377,13 @@ static int imx8mq_clocks_probe(struct platform_device *pdev)
 	hws[IMX8MQ_AUDIO_PLL2_BYPASS] = imx_clk_hw_mux("audio_pll2_bypass", base + 0x8, 14, 1, audio_pll2_bypass_sels, ARRAY_SIZE(audio_pll2_bypass_sels));
 	hws[IMX8MQ_VIDEO_PLL1_BYPASS] = imx_clk_hw_mux("video_pll1_bypass", base + 0x10, 14, 1, video_pll1_bypass_sels, ARRAY_SIZE(video_pll1_bypass_sels));
 
+	/* unbypass all the plls */
+	clk_set_parent(hws[IMX8MQ_GPU_PLL_BYPASS]->clk, hws[IMX8MQ_GPU_PLL]->clk);
+	clk_set_parent(hws[IMX8MQ_VPU_PLL_BYPASS]->clk, hws[IMX8MQ_VPU_PLL]->clk);
+	clk_set_parent(hws[IMX8MQ_AUDIO_PLL1_BYPASS]->clk, hws[IMX8MQ_AUDIO_PLL1]->clk);
+	clk_set_parent(hws[IMX8MQ_AUDIO_PLL2_BYPASS]->clk, hws[IMX8MQ_AUDIO_PLL2]->clk);
+	clk_set_parent(hws[IMX8MQ_VIDEO_PLL1_BYPASS]->clk, hws[IMX8MQ_VIDEO_PLL1]->clk);
+
 	/* PLL OUT GATE */
 	hws[IMX8MQ_ARM_PLL_OUT] = imx_clk_hw_gate("arm_pll_out", "arm_pll_bypass", base + 0x28, 21);
 	hws[IMX8MQ_GPU_PLL_OUT] = imx_clk_hw_gate("gpu_pll_out", "gpu_pll_bypass", base + 0x18, 21);
@@ -557,7 +598,7 @@ static int imx8mq_clocks_probe(struct platform_device *pdev)
 	hws[IMX8MQ_CLK_SAI5_IPG] = imx_clk_hw_gate2_shared2("sai5_ipg_clk", "ipg_audio_root", base + 0x4370, 0, &share_count_sai5);
 	hws[IMX8MQ_CLK_SAI6_ROOT] = imx_clk_hw_gate2_shared2("sai6_root_clk", "sai6", base + 0x4380, 0, &share_count_sai6);
 	hws[IMX8MQ_CLK_SAI6_IPG] = imx_clk_hw_gate2_shared2("sai6_ipg_clk", "ipg_audio_root", base + 0x4380, 0, &share_count_sai6);
-	hws[IMX8MQ_CLK_SNVS_ROOT] = imx_clk_hw_gate4("snvs_root_clk", "ipg_root", base + 0x4470, 0);
+	hws[IMX8MQ_CLK_SNVS_ROOT] = imx_clk_hw_gate2_flags("snvs_root_clk", "ipg_root", base + 0x4470, 0, CLK_IS_CRITICAL);
 	hws[IMX8MQ_CLK_UART1_ROOT] = imx_clk_hw_gate4("uart1_root_clk", "uart1", base + 0x4490, 0);
 	hws[IMX8MQ_CLK_UART2_ROOT] = imx_clk_hw_gate4("uart2_root_clk", "uart2", base + 0x44a0, 0);
 	hws[IMX8MQ_CLK_UART3_ROOT] = imx_clk_hw_gate4("uart3_root_clk", "uart3", base + 0x44b0, 0);
@@ -602,6 +643,16 @@ static int imx8mq_clocks_probe(struct platform_device *pdev)
 		goto unregister_hws;
 	}
 
+	/* enable all the clocks just for bringup */
+	imx_clk_init_on(np, hws);
+
+	clk_set_parent(hws[IMX8MQ_CLK_CSI1_CORE]->clk, hws[IMX8MQ_SYS1_PLL_266M]->clk);
+	clk_set_parent(hws[IMX8MQ_CLK_CSI1_PHY_REF]->clk, hws[IMX8MQ_SYS2_PLL_1000M]->clk);
+	clk_set_parent(hws[IMX8MQ_CLK_CSI1_ESC]->clk, hws[IMX8MQ_SYS1_PLL_800M]->clk);
+	clk_set_parent(hws[IMX8MQ_CLK_CSI2_CORE]->clk, hws[IMX8MQ_SYS1_PLL_266M]->clk);
+	clk_set_parent(hws[IMX8MQ_CLK_CSI2_PHY_REF]->clk, hws[IMX8MQ_SYS2_PLL_1000M]->clk);
+	clk_set_parent(hws[IMX8MQ_CLK_CSI2_ESC]->clk, hws[IMX8MQ_SYS1_PLL_800M]->clk);
+
 	imx_register_uart_clocks(4);
 
 	return 0;
diff --git a/drivers/clk/imx/clk-imx8qm-acm.c b/drivers/clk/imx/clk-imx8qm-acm.c
new file mode 100644
index 000000000..d531294e7
--- /dev/null
+++ b/drivers/clk/imx/clk-imx8qm-acm.c
@@ -0,0 +1,297 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2018 NXP
+ *	Dong Aisheng <aisheng.dong@nxp.com>
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/pm_domain.h>
+#include <linux/pm_runtime.h>
+
+#include "clk.h"
+#include "clk-scu.h"
+#include "clk-imx-acm-utils.h"
+
+#include <dt-bindings/clock/imx8-clock.h>
+
+struct imx8qm_acm_priv {
+	struct clk_imx_acm_pm_domains dev_pm;
+	void __iomem *reg;
+	u32 regs[32];
+};
+
+static const char *aud_clk_sels[] = {
+	"aud_rec_clk0_lpcg_clk",
+	"aud_rec_clk1_lpcg_clk",
+	"dummy",
+	"hdmi_rx_mclk",
+	"ext_aud_mclk0",
+	"ext_aud_mclk1",
+	"esai0_rx_clk",
+	"esai0_rx_hf_clk",
+	"esai0_tx_clk",
+	"esai0_tx_hf_clk",
+	"esai1_rx_clk",
+	"esai1_rx_hf_clk",
+	"esai1_tx_clk",
+	"esai1_tx_hf_clk",
+	"spdif0_rx",
+	"spdif1_rx",
+	"sai0_rx_bclk",
+	"sai0_tx_bclk",
+	"sai1_rx_bclk",
+	"sai1_tx_bclk",
+	"sai2_rx_bclk",
+	"sai3_rx_bclk",
+	"sai4_rx_bclk",
+};
+
+static const char *mclk_out_sels[] = {
+	"aud_rec_clk0_lpcg_clk",
+	"aud_rec_clk1_lpcg_clk",
+	"dummy",
+	"hdmi_rx_mclk",
+	"spdif0_rx",
+	"spdif1_rx",
+	"sai4_rx_bclk",
+	"sai6_rx_bclk",
+};
+
+static const char *sai_mclk_sels[] = {
+	"aud_pll_div_clk0_lpcg_clk",
+	"aud_pll_div_clk1_lpcg_clk",
+	"acm_aud_clk0_sel",
+	"acm_aud_clk1_sel",
+};
+
+static const char *asrc_mux_clk_sels[] = {
+	"sai4_rx_bclk",
+	"sai5_tx_bclk",
+	"dummy",
+	"dummy",
+};
+
+static const char *esai_mclk_sels[] = {
+	"aud_pll_div_clk0_lpcg_clk",
+	"aud_pll_div_clk1_lpcg_clk",
+	"acm_aud_clk0_sel",
+	"acm_aud_clk1_sel",
+};
+
+static const char *spdif_mclk_sels[] = {
+	"aud_pll_div_clk0_lpcg_clk",
+	"aud_pll_div_clk1_lpcg_clk",
+	"acm_aud_clk0_sel",
+	"acm_aud_clk1_sel",
+};
+
+static const char *mqs_mclk_sels[] = {
+	"aud_pll_div_clk0_lpcg_clk",
+	"aud_pll_div_clk1_lpcg_clk",
+	"acm_aud_clk0_sel",
+	"acm_aud_clk1_sel",
+};
+
+static int imx8qm_acm_clk_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	struct clk_onecell_data *clk_data;
+	struct imx8qm_acm_priv *priv;
+	struct resource *res;
+	struct clk **clks;
+	void __iomem *base;
+	int ret;
+	int i;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	base = devm_ioremap(dev, res->start, resource_size(res));
+	if (!base)
+		return -ENOMEM;
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->reg = base;
+
+	platform_set_drvdata(pdev, priv);
+
+	clk_data = devm_kzalloc(&pdev->dev, sizeof(*clk_data), GFP_KERNEL);
+	if (!clk_data)
+		return -ENOMEM;
+
+	clk_data->clks = devm_kcalloc(&pdev->dev, IMX_ADMA_ACM_CLK_END,
+					sizeof(*clk_data->clks), GFP_KERNEL);
+	if (!clk_data->clks)
+		return -ENOMEM;
+
+	clk_data->clk_num = IMX_ADMA_ACM_CLK_END;
+
+	clks = clk_data->clks;
+
+	ret = clk_imx_acm_attach_pm_domains(&pdev->dev, &priv->dev_pm);
+	if (ret)
+		return ret;
+
+	pm_runtime_enable(&pdev->dev);
+	pm_runtime_get_sync(&pdev->dev);
+
+	clks[IMX_ADMA_EXT_AUD_MCLK0]     = imx_clk_fixed("ext_aud_mclk0", 0);
+	clks[IMX_ADMA_EXT_AUD_MCLK1]     = imx_clk_fixed("ext_aud_mclk1", 0);
+	clks[IMX_ADMA_ESAI0_RX_CLK]      = imx_clk_fixed("esai0_rx_clk", 0);
+	clks[IMX_ADMA_ESAI0_RX_HF_CLK]   = imx_clk_fixed("esai0_rx_hf_clk", 0);
+	clks[IMX_ADMA_ESAI0_TX_CLK]      = imx_clk_fixed("esai0_tx_clk", 0);
+	clks[IMX_ADMA_ESAI0_TX_HF_CLK]   = imx_clk_fixed("esai0_tx_hf_clk", 0);
+	clks[IMX_ADMA_ESAI1_RX_CLK]      = imx_clk_fixed("esai1_rx_clk", 0);
+	clks[IMX_ADMA_ESAI1_RX_HF_CLK]   = imx_clk_fixed("esai1_rx_hf_clk", 0);
+	clks[IMX_ADMA_ESAI1_TX_CLK]      = imx_clk_fixed("esai1_tx_clk", 0);
+	clks[IMX_ADMA_ESAI1_TX_HF_CLK]   = imx_clk_fixed("esai1_tx_hf_clk", 0);
+	clks[IMX_ADMA_SPDIF0_RX]         = imx_clk_fixed("spdif0_rx", 0);
+	clks[IMX_ADMA_SPDIF1_RX]         = imx_clk_fixed("spdif1_rx", 0);
+	clks[IMX_ADMA_SAI0_RX_BCLK]      = imx_clk_fixed("sai0_rx_bclk", 0);
+	clks[IMX_ADMA_SAI0_TX_BCLK]      = imx_clk_fixed("sai0_tx_bclk", 0);
+	clks[IMX_ADMA_SAI1_RX_BCLK]      = imx_clk_fixed("sai1_rx_bclk", 0);
+	clks[IMX_ADMA_SAI1_TX_BCLK]      = imx_clk_fixed("sai1_tx_bclk", 0);
+	clks[IMX_ADMA_SAI2_RX_BCLK]      = imx_clk_fixed("sai2_rx_bclk", 0);
+	clks[IMX_ADMA_SAI3_RX_BCLK]      = imx_clk_fixed("sai3_rx_bclk", 0);
+	clks[IMX_ADMA_SAI4_RX_BCLK]      = imx_clk_fixed("sai4_rx_bclk", 0);
+	clks[IMX_ADMA_SAI5_TX_BCLK]      = imx_clk_fixed("sai5_tx_bclk", 0);
+	clks[IMX_ADMA_SAI6_RX_BCLK]      = imx_clk_fixed("sai6_rx_bclk", 0);
+	clks[IMX_ADMA_HDMI_RX_MCLK]      = imx_clk_fixed("hdmi_rx_mclk", 0);
+
+
+	clks[IMX_ADMA_ACM_AUD_CLK0_SEL] = imx_dev_clk_mux(dev, "acm_aud_clk0_sel", base+0x000000, 0, 5, aud_clk_sels, ARRAY_SIZE(aud_clk_sels));
+	clks[IMX_ADMA_ACM_AUD_CLK1_SEL]	= imx_dev_clk_mux(dev, "acm_aud_clk1_sel", base+0x010000, 0, 5, aud_clk_sels, ARRAY_SIZE(aud_clk_sels));
+
+	clks[IMX_ADMA_ACM_MCLKOUT0_SEL]	= imx_dev_clk_mux(dev, "acm_mclkout0_sel", base+0x020000, 0, 3, mclk_out_sels, ARRAY_SIZE(mclk_out_sels));
+	clks[IMX_ADMA_ACM_MCLKOUT1_SEL]	= imx_dev_clk_mux(dev, "acm_mclkout1_sel", base+0x030000, 0, 3, mclk_out_sels, ARRAY_SIZE(mclk_out_sels));
+
+	clks[IMX_ADMA_ACM_ASRC0_MUX_CLK_SEL] = imx_dev_clk_mux(dev, "acm_asrc0_mclk_sel", base+0x040000, 0, 2, asrc_mux_clk_sels, ARRAY_SIZE(asrc_mux_clk_sels));
+
+	clks[IMX_ADMA_ACM_ESAI0_MCLK_SEL] = imx_dev_clk_mux(dev, "acm_esai0_mclk_sel", base+0x060000, 0, 2, esai_mclk_sels, ARRAY_SIZE(esai_mclk_sels));
+	clks[IMX_ADMA_ACM_ESAI1_MCLK_SEL] = imx_dev_clk_mux(dev, "acm_esai1_mclk_sel", base+0x070000, 0, 2, esai_mclk_sels, ARRAY_SIZE(esai_mclk_sels));
+	clks[IMX_ADMA_ACM_SAI0_MCLK_SEL] = imx_dev_clk_mux(dev, "acm_sai0_mclk_sel", base+0x0E0000, 0, 2, sai_mclk_sels, ARRAY_SIZE(sai_mclk_sels));
+	clks[IMX_ADMA_ACM_SAI1_MCLK_SEL] = imx_dev_clk_mux(dev, "acm_sai1_mclk_sel", base+0x0F0000, 0, 2, sai_mclk_sels, ARRAY_SIZE(sai_mclk_sels));
+	clks[IMX_ADMA_ACM_SAI2_MCLK_SEL] = imx_dev_clk_mux(dev, "acm_sai2_mclk_sel", base+0x100000, 0, 2, sai_mclk_sels, ARRAY_SIZE(sai_mclk_sels));
+	clks[IMX_ADMA_ACM_SAI3_MCLK_SEL] = imx_dev_clk_mux(dev, "acm_sai3_mclk_sel", base+0x110000, 0, 2, sai_mclk_sels, ARRAY_SIZE(sai_mclk_sels));
+	clks[IMX_ADMA_ACM_SAI4_MCLK_SEL] = imx_dev_clk_mux(dev, "acm_sai4_mclk_sel", base+0x120000, 0, 2, sai_mclk_sels, ARRAY_SIZE(sai_mclk_sels));
+	clks[IMX_ADMA_ACM_SAI5_MCLK_SEL] = imx_dev_clk_mux(dev, "acm_sai5_mclk_sel", base+0x130000, 0, 2, sai_mclk_sels, ARRAY_SIZE(sai_mclk_sels));
+	clks[IMX_ADMA_ACM_SAI6_MCLK_SEL] = imx_dev_clk_mux(dev, "acm_sai6_mclk_sel", base+0x140000, 0, 2, sai_mclk_sels, ARRAY_SIZE(sai_mclk_sels));
+	clks[IMX_ADMA_ACM_SAI7_MCLK_SEL] = imx_dev_clk_mux(dev, "acm_sai7_mclk_sel", base+0x150000, 0, 2, sai_mclk_sels, ARRAY_SIZE(sai_mclk_sels));
+
+	clks[IMX_ADMA_ACM_SPDIF0_TX_CLK_SEL] = imx_dev_clk_mux(dev, "acm_spdif0_mclk_sel", base+0x1A0000, 0, 2, spdif_mclk_sels, ARRAY_SIZE(spdif_mclk_sels));
+	clks[IMX_ADMA_ACM_SPDIF1_TX_CLK_SEL] = imx_dev_clk_mux(dev, "acm_spdif1_mclk_sel", base+0x1B0000, 0, 2, spdif_mclk_sels, ARRAY_SIZE(spdif_mclk_sels));
+	clks[IMX_ADMA_ACM_MQS_TX_CLK_SEL] = imx_dev_clk_mux(dev, "acm_mqs_mclk_sel", base+0x1C0000, 0, 2, mqs_mclk_sels, ARRAY_SIZE(mqs_mclk_sels));
+
+	for (i = 0; i < clk_data->clk_num; i++) {
+		if (IS_ERR(clks[i]))
+			pr_warn("i.MX clk %u: register failed with %ld\n",
+				i, PTR_ERR(clks[i]));
+	}
+
+	ret = of_clk_add_provider(np, of_clk_src_onecell_get, clk_data);
+
+	pm_runtime_put_sync(&pdev->dev);
+
+	return ret;
+}
+
+static int imx8qm_acm_clk_remove(struct platform_device *pdev)
+{
+	struct imx8qm_acm_priv *priv = dev_get_drvdata(&pdev->dev);
+
+	pm_runtime_disable(&pdev->dev);
+
+	clk_imx_acm_detach_pm_domains(&pdev->dev, &priv->dev_pm);
+
+	return 0;
+}
+
+static const struct of_device_id imx8qm_acm_match[] = {
+	{ .compatible = "nxp,imx8qm-acm", },
+	{ /* sentinel */ }
+};
+
+static int __maybe_unused imx8qm_acm_runtime_suspend(struct device *dev)
+{
+	struct imx8qm_acm_priv *priv = dev_get_drvdata(dev);
+
+	priv->regs[0]  = readl_relaxed(priv->reg + 0x000000);
+	priv->regs[1]  = readl_relaxed(priv->reg + 0x010000);
+	priv->regs[2]  = readl_relaxed(priv->reg + 0x020000);
+	priv->regs[3]  = readl_relaxed(priv->reg + 0x030000);
+	priv->regs[4]  = readl_relaxed(priv->reg + 0x040000);
+	priv->regs[6]  = readl_relaxed(priv->reg + 0x060000);
+	priv->regs[7]  = readl_relaxed(priv->reg + 0x070000);
+	priv->regs[14] = readl_relaxed(priv->reg + 0x0E0000);
+	priv->regs[15] = readl_relaxed(priv->reg + 0x0F0000);
+	priv->regs[16] = readl_relaxed(priv->reg + 0x100000);
+	priv->regs[17] = readl_relaxed(priv->reg + 0x110000);
+	priv->regs[18] = readl_relaxed(priv->reg + 0x120000);
+	priv->regs[19] = readl_relaxed(priv->reg + 0x130000);
+	priv->regs[20] = readl_relaxed(priv->reg + 0x140000);
+	priv->regs[21] = readl_relaxed(priv->reg + 0x150000);
+	priv->regs[26] = readl_relaxed(priv->reg + 0x1A0000);
+	priv->regs[27] = readl_relaxed(priv->reg + 0x1B0000);
+	priv->regs[28] = readl_relaxed(priv->reg + 0x1C0000);
+
+	return 0;
+}
+
+static int __maybe_unused imx8qm_acm_runtime_resume(struct device *dev)
+{
+	struct imx8qm_acm_priv *priv = dev_get_drvdata(dev);
+
+	writel_relaxed(priv->regs[0],  priv->reg + 0x000000);
+	writel_relaxed(priv->regs[1],  priv->reg + 0x010000);
+	writel_relaxed(priv->regs[2],  priv->reg + 0x020000);
+	writel_relaxed(priv->regs[3],  priv->reg + 0x030000);
+	writel_relaxed(priv->regs[4],  priv->reg + 0x040000);
+	writel_relaxed(priv->regs[6],  priv->reg + 0x060000);
+	writel_relaxed(priv->regs[7],  priv->reg + 0x070000);
+	writel_relaxed(priv->regs[14], priv->reg + 0x0E0000);
+	writel_relaxed(priv->regs[15], priv->reg + 0x0F0000);
+	writel_relaxed(priv->regs[16], priv->reg + 0x100000);
+	writel_relaxed(priv->regs[17], priv->reg + 0x110000);
+	writel_relaxed(priv->regs[18], priv->reg + 0x120000);
+	writel_relaxed(priv->regs[19], priv->reg + 0x130000);
+	writel_relaxed(priv->regs[20], priv->reg + 0x140000);
+	writel_relaxed(priv->regs[21], priv->reg + 0x150000);
+	writel_relaxed(priv->regs[26], priv->reg + 0x1A0000);
+	writel_relaxed(priv->regs[27], priv->reg + 0x1B0000);
+	writel_relaxed(priv->regs[28], priv->reg + 0x1C0000);
+
+	return 0;
+}
+
+static const struct dev_pm_ops imx8qm_acm_pm_ops = {
+	SET_RUNTIME_PM_OPS(imx8qm_acm_runtime_suspend,
+			   imx8qm_acm_runtime_resume, NULL)
+	SET_NOIRQ_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,
+				      pm_runtime_force_resume)
+};
+
+static struct platform_driver imx8qm_acm_clk_driver = {
+	.driver = {
+		.name = "imx8qm-acm",
+		.of_match_table = imx8qm_acm_match,
+		.pm = &imx8qm_acm_pm_ops,
+		.suppress_bind_attrs = true,
+	},
+	.probe = imx8qm_acm_clk_probe,
+	.remove = imx8qm_acm_clk_remove,
+};
+
+static int __init imx8qm_acm_init(void)
+{
+	return platform_driver_register(&imx8qm_acm_clk_driver);
+}
+fs_initcall(imx8qm_acm_init);
diff --git a/drivers/clk/imx/clk-imx8qm-rsrc.c b/drivers/clk/imx/clk-imx8qm-rsrc.c
index 87e0b6ac0..77f678f3a 100644
--- a/drivers/clk/imx/clk-imx8qm-rsrc.c
+++ b/drivers/clk/imx/clk-imx8qm-rsrc.c
@@ -43,6 +43,8 @@ static const u32 imx8qm_clk_scu_rsrc_table[] = {
 	IMX_SC_R_FTM_0,
 	IMX_SC_R_FTM_1,
 	IMX_SC_R_CAN_0,
+	IMX_SC_R_CAN_1,
+	IMX_SC_R_CAN_2,
 	IMX_SC_R_GPU_0_PID0,
 	IMX_SC_R_GPU_1_PID0,
 	IMX_SC_R_PWM_0,
@@ -65,7 +67,6 @@ static const u32 imx8qm_clk_scu_rsrc_table[] = {
 	IMX_SC_R_SDHC_2,
 	IMX_SC_R_ENET_0,
 	IMX_SC_R_ENET_1,
-	IMX_SC_R_MLB_0,
 	IMX_SC_R_USB_2,
 	IMX_SC_R_NAND,
 	IMX_SC_R_LVDS_0,
diff --git a/drivers/clk/imx/clk-imx8qxp-acm.c b/drivers/clk/imx/clk-imx8qxp-acm.c
new file mode 100644
index 000000000..8968061cf
--- /dev/null
+++ b/drivers/clk/imx/clk-imx8qxp-acm.c
@@ -0,0 +1,258 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2018 NXP
+ *	Dong Aisheng <aisheng.dong@nxp.com>
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/pm_domain.h>
+#include <linux/pm_runtime.h>
+
+#include "clk.h"
+#include "clk-scu.h"
+#include "clk-imx-acm-utils.h"
+
+#include <dt-bindings/clock/imx8-clock.h>
+
+struct imx8qxp_acm_priv {
+	struct clk_imx_acm_pm_domains dev_pm;
+	void __iomem *reg;
+	u32 regs[0x20];
+};
+
+static const char *aud_clk_sels[] = {
+	"aud_rec_clk0_lpcg_clk",
+	"aud_rec_clk1_lpcg_clk",
+	"ext_aud_mclk0",
+	"ext_aud_mclk1",
+	"esai0_rx_clk",
+	"esai0_rx_hf_clk",
+	"esai0_tx_clk",
+	"esai0_tx_hf_clk",
+	"spdif0_rx",
+	"sai0_rx_bclk",
+	"sai0_tx_bclk",
+	"sai1_rx_bclk",
+	"sai1_tx_bclk",
+	"sai2_rx_bclk",
+	"sai3_rx_bclk",
+};
+
+static const char *mclk_out_sels[] = {
+	"aud_rec_clk0_lpcg_clk",
+	"aud_rec_clk1_lpcg_clk",
+	"dummy",
+	"dummy",
+	"spdif0_rx",
+	"dummy",
+	"dummy",
+	"sai4_rx_bclk",
+};
+
+static const char *sai_mclk_sels[] = {
+	"aud_pll_div_clk0_lpcg_clk",
+	"aud_pll_div_clk1_lpcg_clk",
+	"acm_aud_clk0_sel",
+	"acm_aud_clk1_sel",
+};
+
+static const char *esai_mclk_sels[] = {
+	"aud_pll_div_clk0_lpcg_clk",
+	"aud_pll_div_clk1_lpcg_clk",
+	"acm_aud_clk0_sel",
+	"acm_aud_clk1_sel",
+};
+
+static const char *spdif_mclk_sels[] = {
+	"aud_pll_div_clk0_lpcg_clk",
+	"aud_pll_div_clk1_lpcg_clk",
+	"acm_aud_clk0_sel",
+	"acm_aud_clk1_sel",
+};
+
+static const char *mqs_mclk_sels[] = {
+	"aud_pll_div_clk0_lpcg_clk",
+	"aud_pll_div_clk1_lpcg_clk",
+	"acm_aud_clk0_sel",
+	"acm_aud_clk1_sel",
+};
+
+static int imx8qxp_acm_clk_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	struct clk_onecell_data *clk_data;
+	struct imx8qxp_acm_priv *priv;
+	struct resource *res;
+	struct clk **clks;
+	void __iomem *base;
+	int ret;
+	int i;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	base = devm_ioremap(dev, res->start, resource_size(res));
+	if (!base)
+		return -ENOMEM;
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->reg = base;
+
+	platform_set_drvdata(pdev, priv);
+
+	clk_data = devm_kzalloc(&pdev->dev, sizeof(*clk_data), GFP_KERNEL);
+	if (!clk_data)
+		return -ENOMEM;
+
+	clk_data->clks = devm_kcalloc(&pdev->dev, IMX_ADMA_ACM_CLK_END,
+					sizeof(*clk_data->clks), GFP_KERNEL);
+	if (!clk_data->clks)
+		return -ENOMEM;
+
+	clk_data->clk_num = IMX_ADMA_ACM_CLK_END;
+
+	clks = clk_data->clks;
+
+	ret = clk_imx_acm_attach_pm_domains(&pdev->dev, &priv->dev_pm);
+	if (ret)
+		return ret;
+
+	pm_runtime_enable(&pdev->dev);
+	pm_runtime_get_sync(&pdev->dev);
+
+	clks[IMX_ADMA_EXT_AUD_MCLK0]     = imx_clk_fixed("ext_aud_mclk0", 0);
+	clks[IMX_ADMA_EXT_AUD_MCLK1]     = imx_clk_fixed("ext_aud_mclk1", 0);
+	clks[IMX_ADMA_ESAI0_RX_CLK]      = imx_clk_fixed("esai0_rx_clk", 0);
+	clks[IMX_ADMA_ESAI0_RX_HF_CLK]   = imx_clk_fixed("esai0_rx_hf_clk", 0);
+	clks[IMX_ADMA_ESAI0_TX_CLK]      = imx_clk_fixed("esai0_tx_clk", 0);
+	clks[IMX_ADMA_ESAI0_TX_HF_CLK]   = imx_clk_fixed("esai0_tx_hf_clk", 0);
+	clks[IMX_ADMA_SPDIF0_RX]         = imx_clk_fixed("spdif0_rx", 0);
+	clks[IMX_ADMA_SAI0_RX_BCLK]      = imx_clk_fixed("sai0_rx_bclk", 0);
+	clks[IMX_ADMA_SAI0_TX_BCLK]      = imx_clk_fixed("sai0_tx_bclk", 0);
+	clks[IMX_ADMA_SAI1_RX_BCLK]      = imx_clk_fixed("sai1_rx_bclk", 0);
+	clks[IMX_ADMA_SAI1_TX_BCLK]      = imx_clk_fixed("sai1_tx_bclk", 0);
+	clks[IMX_ADMA_SAI2_RX_BCLK]      = imx_clk_fixed("sai2_rx_bclk", 0);
+	clks[IMX_ADMA_SAI3_RX_BCLK]      = imx_clk_fixed("sai3_rx_bclk", 0);
+	clks[IMX_ADMA_SAI4_RX_BCLK]      = imx_clk_fixed("sai4_rx_bclk", 0);
+
+
+	clks[IMX_ADMA_ACM_AUD_CLK0_SEL] = imx_dev_clk_mux(dev, "acm_aud_clk0_sel", base+0x000000, 0, 5, aud_clk_sels, ARRAY_SIZE(aud_clk_sels));
+	clks[IMX_ADMA_ACM_AUD_CLK1_SEL]	= imx_dev_clk_mux(dev, "acm_aud_clk1_sel", base+0x010000, 0, 5, aud_clk_sels, ARRAY_SIZE(aud_clk_sels));
+
+	clks[IMX_ADMA_ACM_MCLKOUT0_SEL]	= imx_dev_clk_mux(dev, "acm_mclkout0_sel", base+0x020000, 0, 3, mclk_out_sels, ARRAY_SIZE(mclk_out_sels));
+	clks[IMX_ADMA_ACM_MCLKOUT1_SEL]	= imx_dev_clk_mux(dev, "acm_mclkout1_sel", base+0x030000, 0, 3, mclk_out_sels, ARRAY_SIZE(mclk_out_sels));
+
+	clks[IMX_ADMA_ACM_ESAI0_MCLK_SEL] = imx_dev_clk_mux(dev, "acm_esai0_mclk_sel", base+0x060000, 0, 2, esai_mclk_sels, ARRAY_SIZE(esai_mclk_sels));
+	clks[IMX_ADMA_ACM_SAI0_MCLK_SEL] = imx_dev_clk_mux(dev, "acm_sai0_mclk_sel", base+0x0E0000, 0, 2, sai_mclk_sels, ARRAY_SIZE(sai_mclk_sels));
+	clks[IMX_ADMA_ACM_SAI1_MCLK_SEL] = imx_dev_clk_mux(dev, "acm_sai1_mclk_sel", base+0x0F0000, 0, 2, sai_mclk_sels, ARRAY_SIZE(sai_mclk_sels));
+	clks[IMX_ADMA_ACM_SAI2_MCLK_SEL] = imx_dev_clk_mux(dev, "acm_sai2_mclk_sel", base+0x100000, 0, 2, sai_mclk_sels, ARRAY_SIZE(sai_mclk_sels));
+	clks[IMX_ADMA_ACM_SAI3_MCLK_SEL] = imx_dev_clk_mux(dev, "acm_sai3_mclk_sel", base+0x110000, 0, 2, sai_mclk_sels, ARRAY_SIZE(sai_mclk_sels));
+	clks[IMX_ADMA_ACM_SAI4_MCLK_SEL] = imx_dev_clk_mux(dev, "acm_sai4_mclk_sel", base+0x140000, 0, 2, sai_mclk_sels, ARRAY_SIZE(sai_mclk_sels));
+	clks[IMX_ADMA_ACM_SAI5_MCLK_SEL] = imx_dev_clk_mux(dev, "acm_sai5_mclk_sel", base+0x150000, 0, 2, sai_mclk_sels, ARRAY_SIZE(sai_mclk_sels));
+
+	clks[IMX_ADMA_ACM_SPDIF0_TX_CLK_SEL] = imx_dev_clk_mux(dev, "acm_spdif0_mclk_sel", base+0x1A0000, 0, 2, spdif_mclk_sels, ARRAY_SIZE(spdif_mclk_sels));
+	clks[IMX_ADMA_ACM_MQS_TX_CLK_SEL] = imx_dev_clk_mux(dev, "acm_mqs_mclk_sel", base+0x1C0000, 0, 2, mqs_mclk_sels, ARRAY_SIZE(mqs_mclk_sels));
+
+	for (i = 0; i < clk_data->clk_num; i++) {
+		if (IS_ERR(clks[i]))
+			pr_warn("i.MX clk %u: register failed with %ld\n",
+				i, PTR_ERR(clks[i]));
+	}
+
+	ret = of_clk_add_provider(np, of_clk_src_onecell_get, clk_data);
+
+	pm_runtime_put_sync(&pdev->dev);
+
+	return ret;
+}
+
+static int imx8qxp_acm_clk_remove(struct platform_device *pdev)
+{
+	struct imx8qxp_acm_priv *priv = dev_get_drvdata(&pdev->dev);
+
+	pm_runtime_disable(&pdev->dev);
+
+	clk_imx_acm_detach_pm_domains(&pdev->dev, &priv->dev_pm);
+
+	return 0;
+}
+
+static const struct of_device_id imx8qxp_acm_match[] = {
+	{ .compatible = "nxp,imx8qxp-acm", },
+	{ /* sentinel */ }
+};
+
+static int __maybe_unused imx8qxp_acm_runtime_suspend(struct device *dev)
+{
+	struct imx8qxp_acm_priv *priv = dev_get_drvdata(dev);
+
+	priv->regs[0]  = readl_relaxed(priv->reg + 0x000000);
+	priv->regs[1]  = readl_relaxed(priv->reg + 0x010000);
+	priv->regs[2]  = readl_relaxed(priv->reg + 0x020000);
+	priv->regs[3]  = readl_relaxed(priv->reg + 0x030000);
+	priv->regs[6]  = readl_relaxed(priv->reg + 0x060000);
+	priv->regs[14] = readl_relaxed(priv->reg + 0x0E0000);
+	priv->regs[15] = readl_relaxed(priv->reg + 0x0F0000);
+	priv->regs[16] = readl_relaxed(priv->reg + 0x100000);
+	priv->regs[17] = readl_relaxed(priv->reg + 0x110000);
+	priv->regs[20] = readl_relaxed(priv->reg + 0x140000);
+	priv->regs[21] = readl_relaxed(priv->reg + 0x150000);
+	priv->regs[26] = readl_relaxed(priv->reg + 0x1A0000);
+	priv->regs[28] = readl_relaxed(priv->reg + 0x1C0000);
+
+	return 0;
+}
+
+static int __maybe_unused imx8qxp_acm_runtime_resume(struct device *dev)
+{
+	struct imx8qxp_acm_priv *priv = dev_get_drvdata(dev);
+
+	writel_relaxed(priv->regs[0],  priv->reg + 0x000000);
+	writel_relaxed(priv->regs[1],  priv->reg + 0x010000);
+	writel_relaxed(priv->regs[2],  priv->reg + 0x020000);
+	writel_relaxed(priv->regs[3],  priv->reg + 0x030000);
+	writel_relaxed(priv->regs[6],  priv->reg + 0x060000);
+	writel_relaxed(priv->regs[14], priv->reg + 0x0E0000);
+	writel_relaxed(priv->regs[15], priv->reg + 0x0F0000);
+	writel_relaxed(priv->regs[16], priv->reg + 0x100000);
+	writel_relaxed(priv->regs[17], priv->reg + 0x110000);
+	writel_relaxed(priv->regs[20], priv->reg + 0x140000);
+	writel_relaxed(priv->regs[21], priv->reg + 0x150000);
+	writel_relaxed(priv->regs[26], priv->reg + 0x1A0000);
+	writel_relaxed(priv->regs[28], priv->reg + 0x1C0000);
+
+	return 0;
+}
+
+const struct dev_pm_ops imx8qxp_acm_pm_ops = {
+	SET_RUNTIME_PM_OPS(imx8qxp_acm_runtime_suspend,
+			   imx8qxp_acm_runtime_resume, NULL)
+	SET_NOIRQ_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,
+				      pm_runtime_force_resume)
+};
+
+static struct platform_driver imx8qxp_acm_clk_driver = {
+	.driver = {
+		.name = "imx8qxp-acm",
+		.of_match_table = imx8qxp_acm_match,
+		.pm = &imx8qxp_acm_pm_ops,
+		.suppress_bind_attrs = true,
+	},
+	.probe = imx8qxp_acm_clk_probe,
+	.remove = imx8qxp_acm_clk_remove,
+};
+
+static int __init imx8qxp_acm_init(void)
+{
+	return platform_driver_register(&imx8qxp_acm_clk_driver);
+}
+fs_initcall(imx8qxp_acm_init);
diff --git a/drivers/clk/imx/clk-imx8qxp-lpcg.c b/drivers/clk/imx/clk-imx8qxp-lpcg.c
index 5e31a6a24..abd969aad 100644
--- a/drivers/clk/imx/clk-imx8qxp-lpcg.c
+++ b/drivers/clk/imx/clk-imx8qxp-lpcg.c
@@ -16,168 +16,12 @@
 #include <linux/slab.h>
 
 #include "clk-scu.h"
-#include "clk-imx8qxp-lpcg.h"
-
-#include <dt-bindings/clock/imx8-clock.h>
-
-/*
- * struct imx8qxp_lpcg_data - Description of one LPCG clock
- * @id: clock ID
- * @name: clock name
- * @parent: parent clock name
- * @flags: common clock flags
- * @offset: offset of this LPCG clock
- * @bit_idx: bit index of this LPCG clock
- * @hw_gate: whether supports HW autogate
- *
- * This structure describes one LPCG clock
- */
-struct imx8qxp_lpcg_data {
-	int id;
-	char *name;
-	char *parent;
-	unsigned long flags;
-	u32 offset;
-	u8 bit_idx;
-	bool hw_gate;
-};
-
-/*
- * struct imx8qxp_ss_lpcg - Description of one subsystem LPCG clocks
- * @lpcg: LPCG clocks array of one subsystem
- * @num_lpcg: the number of LPCG clocks
- * @num_max: the maximum number of LPCG clocks
- *
- * This structure describes each subsystem LPCG clocks information
- * which then will be used to create respective LPCGs clocks
- */
-struct imx8qxp_ss_lpcg {
-	const struct imx8qxp_lpcg_data *lpcg;
-	u8 num_lpcg;
-	u8 num_max;
-};
-
-static const struct imx8qxp_lpcg_data imx8qxp_lpcg_adma[] = {
-	{ IMX_ADMA_LPCG_UART0_IPG_CLK, "uart0_lpcg_ipg_clk", "dma_ipg_clk_root", 0, ADMA_LPUART_0_LPCG, 16, 0, },
-	{ IMX_ADMA_LPCG_UART0_BAUD_CLK, "uart0_lpcg_baud_clk", "uart0_clk", 0, ADMA_LPUART_0_LPCG, 0, 0, },
-	{ IMX_ADMA_LPCG_UART1_IPG_CLK, "uart1_lpcg_ipg_clk", "dma_ipg_clk_root", 0, ADMA_LPUART_1_LPCG, 16, 0, },
-	{ IMX_ADMA_LPCG_UART1_BAUD_CLK, "uart1_lpcg_baud_clk", "uart1_clk", 0, ADMA_LPUART_1_LPCG, 0, 0, },
-	{ IMX_ADMA_LPCG_UART2_IPG_CLK, "uart2_lpcg_ipg_clk", "dma_ipg_clk_root", 0, ADMA_LPUART_2_LPCG, 16, 0, },
-	{ IMX_ADMA_LPCG_UART2_BAUD_CLK, "uart2_lpcg_baud_clk", "uart2_clk", 0, ADMA_LPUART_2_LPCG, 0, 0, },
-	{ IMX_ADMA_LPCG_UART3_IPG_CLK, "uart3_lpcg_ipg_clk", "dma_ipg_clk_root", 0, ADMA_LPUART_3_LPCG, 16, 0, },
-	{ IMX_ADMA_LPCG_UART3_BAUD_CLK, "uart3_lpcg_baud_clk", "uart3_clk", 0, ADMA_LPUART_3_LPCG, 0, 0, },
-	{ IMX_ADMA_LPCG_I2C0_IPG_CLK, "i2c0_lpcg_ipg_clk", "dma_ipg_clk_root", 0, ADMA_LPI2C_0_LPCG, 16, 0, },
-	{ IMX_ADMA_LPCG_I2C0_CLK, "i2c0_lpcg_clk", "i2c0_clk", 0, ADMA_LPI2C_0_LPCG, 0, 0, },
-	{ IMX_ADMA_LPCG_I2C1_IPG_CLK, "i2c1_lpcg_ipg_clk", "dma_ipg_clk_root", 0, ADMA_LPI2C_1_LPCG, 16, 0, },
-	{ IMX_ADMA_LPCG_I2C1_CLK, "i2c1_lpcg_clk", "i2c1_clk", 0, ADMA_LPI2C_1_LPCG, 0, 0, },
-	{ IMX_ADMA_LPCG_I2C2_IPG_CLK, "i2c2_lpcg_ipg_clk", "dma_ipg_clk_root", 0, ADMA_LPI2C_2_LPCG, 16, 0, },
-	{ IMX_ADMA_LPCG_I2C2_CLK, "i2c2_lpcg_clk", "i2c2_clk", 0, ADMA_LPI2C_2_LPCG, 0, 0, },
-	{ IMX_ADMA_LPCG_I2C3_IPG_CLK, "i2c3_lpcg_ipg_clk", "dma_ipg_clk_root", 0, ADMA_LPI2C_3_LPCG, 16, 0, },
-	{ IMX_ADMA_LPCG_I2C3_CLK, "i2c3_lpcg_clk", "i2c3_clk", 0, ADMA_LPI2C_3_LPCG, 0, 0, },
-
-	{ IMX_ADMA_LPCG_DSP_CORE_CLK, "dsp_lpcg_core_clk", "dma_ipg_clk_root", 0, ADMA_HIFI_LPCG, 28, 0, },
-	{ IMX_ADMA_LPCG_DSP_IPG_CLK, "dsp_lpcg_ipg_clk", "dma_ipg_clk_root", 0, ADMA_HIFI_LPCG, 20, 0, },
-	{ IMX_ADMA_LPCG_DSP_ADB_CLK, "dsp_lpcg_adb_clk", "dma_ipg_clk_root", 0, ADMA_HIFI_LPCG, 16, 0, },
-	{ IMX_ADMA_LPCG_OCRAM_IPG_CLK, "ocram_lpcg_ipg_clk", "dma_ipg_clk_root", 0, ADMA_OCRAM_LPCG, 16, 0, },
-};
-
-static const struct imx8qxp_ss_lpcg imx8qxp_ss_adma = {
-	.lpcg = imx8qxp_lpcg_adma,
-	.num_lpcg = ARRAY_SIZE(imx8qxp_lpcg_adma),
-	.num_max = IMX_ADMA_LPCG_CLK_END,
-};
-
-static const struct imx8qxp_lpcg_data imx8qxp_lpcg_conn[] = {
-	{ IMX_CONN_LPCG_SDHC0_PER_CLK, "sdhc0_lpcg_per_clk", "sdhc0_clk", 0, CONN_USDHC_0_LPCG, 0, 0, },
-	{ IMX_CONN_LPCG_SDHC0_IPG_CLK, "sdhc0_lpcg_ipg_clk", "conn_ipg_clk_root", 0, CONN_USDHC_0_LPCG, 16, 0, },
-	{ IMX_CONN_LPCG_SDHC0_HCLK, "sdhc0_lpcg_ahb_clk", "conn_axi_clk_root", 0, CONN_USDHC_0_LPCG, 20, 0, },
-	{ IMX_CONN_LPCG_SDHC1_PER_CLK, "sdhc1_lpcg_per_clk", "sdhc1_clk", 0, CONN_USDHC_1_LPCG, 0, 0, },
-	{ IMX_CONN_LPCG_SDHC1_IPG_CLK, "sdhc1_lpcg_ipg_clk", "conn_ipg_clk_root", 0, CONN_USDHC_1_LPCG, 16, 0, },
-	{ IMX_CONN_LPCG_SDHC1_HCLK, "sdhc1_lpcg_ahb_clk", "conn_axi_clk_root", 0, CONN_USDHC_1_LPCG, 20, 0, },
-	{ IMX_CONN_LPCG_SDHC2_PER_CLK, "sdhc2_lpcg_per_clk", "sdhc2_clk", 0, CONN_USDHC_2_LPCG, 0, 0, },
-	{ IMX_CONN_LPCG_SDHC2_IPG_CLK, "sdhc2_lpcg_ipg_clk", "conn_ipg_clk_root", 0, CONN_USDHC_2_LPCG, 16, 0, },
-	{ IMX_CONN_LPCG_SDHC2_HCLK, "sdhc2_lpcg_ahb_clk", "conn_axi_clk_root", 0, CONN_USDHC_2_LPCG, 20, 0, },
-	{ IMX_CONN_LPCG_ENET0_ROOT_CLK, "enet0_ipg_root_clk", "enet0_clk", 0, CONN_ENET_0_LPCG, 0, 0, },
-	{ IMX_CONN_LPCG_ENET0_TX_CLK, "enet0_tx_clk", "enet0_clk", 0, CONN_ENET_0_LPCG, 4, 0, },
-	{ IMX_CONN_LPCG_ENET0_AHB_CLK, "enet0_ahb_clk", "conn_axi_clk_root", 0, CONN_ENET_0_LPCG, 8, 0, },
-	{ IMX_CONN_LPCG_ENET0_IPG_S_CLK, "enet0_ipg_s_clk", "conn_ipg_clk_root", 0, CONN_ENET_0_LPCG, 20, 0, },
-	{ IMX_CONN_LPCG_ENET0_IPG_CLK, "enet0_ipg_clk", "enet0_ipg_s_clk", 0, CONN_ENET_0_LPCG, 16, 0, },
-	{ IMX_CONN_LPCG_ENET1_ROOT_CLK, "enet1_ipg_root_clk", "enet1_clk", 0, CONN_ENET_1_LPCG, 0, 0, },
-	{ IMX_CONN_LPCG_ENET1_TX_CLK, "enet1_tx_clk", "enet1_clk", 0, CONN_ENET_1_LPCG, 4, 0, },
-	{ IMX_CONN_LPCG_ENET1_AHB_CLK, "enet1_ahb_clk", "conn_axi_clk_root", 0, CONN_ENET_1_LPCG, 8, 0, },
-	{ IMX_CONN_LPCG_ENET1_IPG_S_CLK, "enet1_ipg_s_clk", "conn_ipg_clk_root", 0, CONN_ENET_1_LPCG, 20, 0, },
-	{ IMX_CONN_LPCG_ENET1_IPG_CLK, "enet1_ipg_clk", "enet0_ipg_s_clk", 0, CONN_ENET_1_LPCG, 16, 0, },
-};
-
-static const struct imx8qxp_ss_lpcg imx8qxp_ss_conn = {
-	.lpcg = imx8qxp_lpcg_conn,
-	.num_lpcg = ARRAY_SIZE(imx8qxp_lpcg_conn),
-	.num_max = IMX_CONN_LPCG_CLK_END,
-};
-
-static const struct imx8qxp_lpcg_data imx8qxp_lpcg_lsio[] = {
-	{ IMX_LSIO_LPCG_PWM0_IPG_CLK, "pwm0_lpcg_ipg_clk", "pwm0_clk", 0, LSIO_PWM_0_LPCG, 0, 0, },
-	{ IMX_LSIO_LPCG_PWM0_IPG_HF_CLK, "pwm0_lpcg_ipg_hf_clk", "pwm0_clk", 0, LSIO_PWM_0_LPCG, 4, 0, },
-	{ IMX_LSIO_LPCG_PWM0_IPG_S_CLK, "pwm0_lpcg_ipg_s_clk", "pwm0_clk", 0, LSIO_PWM_0_LPCG, 16, 0, },
-	{ IMX_LSIO_LPCG_PWM0_IPG_SLV_CLK, "pwm0_lpcg_ipg_slv_clk", "lsio_bus_clk_root", 0, LSIO_PWM_0_LPCG, 20, 0, },
-	{ IMX_LSIO_LPCG_PWM0_IPG_MSTR_CLK, "pwm0_lpcg_ipg_mstr_clk", "pwm0_clk", 0, LSIO_PWM_0_LPCG, 24, 0, },
-	{ IMX_LSIO_LPCG_PWM1_IPG_CLK, "pwm1_lpcg_ipg_clk", "pwm1_clk", 0, LSIO_PWM_1_LPCG, 0, 0, },
-	{ IMX_LSIO_LPCG_PWM1_IPG_HF_CLK, "pwm1_lpcg_ipg_hf_clk", "pwm1_clk", 0, LSIO_PWM_1_LPCG, 4, 0, },
-	{ IMX_LSIO_LPCG_PWM1_IPG_S_CLK, "pwm1_lpcg_ipg_s_clk", "pwm1_clk", 0, LSIO_PWM_1_LPCG, 16, 0, },
-	{ IMX_LSIO_LPCG_PWM1_IPG_SLV_CLK, "pwm1_lpcg_ipg_slv_clk", "lsio_bus_clk_root", 0, LSIO_PWM_1_LPCG, 20, 0, },
-	{ IMX_LSIO_LPCG_PWM1_IPG_MSTR_CLK, "pwm1_lpcg_ipg_mstr_clk", "pwm1_clk", 0, LSIO_PWM_1_LPCG, 24, 0, },
-	{ IMX_LSIO_LPCG_PWM2_IPG_CLK, "pwm2_lpcg_ipg_clk", "pwm2_clk", 0, LSIO_PWM_2_LPCG, 0, 0, },
-	{ IMX_LSIO_LPCG_PWM2_IPG_HF_CLK, "pwm2_lpcg_ipg_hf_clk", "pwm2_clk", 0, LSIO_PWM_2_LPCG, 4, 0, },
-	{ IMX_LSIO_LPCG_PWM2_IPG_S_CLK, "pwm2_lpcg_ipg_s_clk", "pwm2_clk", 0, LSIO_PWM_2_LPCG, 16, 0, },
-	{ IMX_LSIO_LPCG_PWM2_IPG_SLV_CLK, "pwm2_lpcg_ipg_slv_clk", "lsio_bus_clk_root", 0, LSIO_PWM_2_LPCG, 20, 0, },
-	{ IMX_LSIO_LPCG_PWM2_IPG_MSTR_CLK, "pwm2_lpcg_ipg_mstr_clk", "pwm2_clk", 0, LSIO_PWM_2_LPCG, 24, 0, },
-	{ IMX_LSIO_LPCG_PWM3_IPG_CLK, "pwm3_lpcg_ipg_clk", "pwm3_clk", 0, LSIO_PWM_3_LPCG, 0, 0, },
-	{ IMX_LSIO_LPCG_PWM3_IPG_HF_CLK, "pwm3_lpcg_ipg_hf_clk", "pwm3_clk", 0, LSIO_PWM_3_LPCG, 4, 0, },
-	{ IMX_LSIO_LPCG_PWM3_IPG_S_CLK, "pwm3_lpcg_ipg_s_clk", "pwm3_clk", 0, LSIO_PWM_3_LPCG, 16, 0, },
-	{ IMX_LSIO_LPCG_PWM3_IPG_SLV_CLK, "pwm3_lpcg_ipg_slv_clk", "lsio_bus_clk_root", 0, LSIO_PWM_3_LPCG, 20, 0, },
-	{ IMX_LSIO_LPCG_PWM3_IPG_MSTR_CLK, "pwm3_lpcg_ipg_mstr_clk", "pwm3_clk", 0, LSIO_PWM_3_LPCG, 24, 0, },
-	{ IMX_LSIO_LPCG_PWM4_IPG_CLK, "pwm4_lpcg_ipg_clk", "pwm4_clk", 0, LSIO_PWM_4_LPCG, 0, 0, },
-	{ IMX_LSIO_LPCG_PWM4_IPG_HF_CLK, "pwm4_lpcg_ipg_hf_clk", "pwm4_clk", 0, LSIO_PWM_4_LPCG, 4, 0, },
-	{ IMX_LSIO_LPCG_PWM4_IPG_S_CLK, "pwm4_lpcg_ipg_s_clk", "pwm4_clk", 0, LSIO_PWM_4_LPCG, 16, 0, },
-	{ IMX_LSIO_LPCG_PWM4_IPG_SLV_CLK, "pwm4_lpcg_ipg_slv_clk", "lsio_bus_clk_root", 0, LSIO_PWM_4_LPCG, 20, 0, },
-	{ IMX_LSIO_LPCG_PWM4_IPG_MSTR_CLK, "pwm4_lpcg_ipg_mstr_clk", "pwm4_clk", 0, LSIO_PWM_4_LPCG, 24, 0, },
-	{ IMX_LSIO_LPCG_PWM5_IPG_CLK, "pwm5_lpcg_ipg_clk", "pwm5_clk", 0, LSIO_PWM_5_LPCG, 0, 0, },
-	{ IMX_LSIO_LPCG_PWM5_IPG_HF_CLK, "pwm5_lpcg_ipg_hf_clk", "pwm5_clk", 0, LSIO_PWM_5_LPCG, 4, 0, },
-	{ IMX_LSIO_LPCG_PWM5_IPG_S_CLK, "pwm5_lpcg_ipg_s_clk", "pwm5_clk", 0, LSIO_PWM_5_LPCG, 16, 0, },
-	{ IMX_LSIO_LPCG_PWM5_IPG_SLV_CLK, "pwm5_lpcg_ipg_slv_clk", "lsio_bus_clk_root", 0, LSIO_PWM_5_LPCG, 20, 0, },
-	{ IMX_LSIO_LPCG_PWM5_IPG_MSTR_CLK, "pwm5_lpcg_ipg_mstr_clk", "pwm5_clk", 0, LSIO_PWM_5_LPCG, 24, 0, },
-	{ IMX_LSIO_LPCG_PWM6_IPG_CLK, "pwm6_lpcg_ipg_clk", "pwm6_clk", 0, LSIO_PWM_6_LPCG, 0, 0, },
-	{ IMX_LSIO_LPCG_PWM6_IPG_HF_CLK, "pwm6_lpcg_ipg_hf_clk", "pwm6_clk", 0, LSIO_PWM_6_LPCG, 4, 0, },
-	{ IMX_LSIO_LPCG_PWM6_IPG_S_CLK, "pwm6_lpcg_ipg_s_clk", "pwm6_clk", 0, LSIO_PWM_6_LPCG, 16, 0, },
-	{ IMX_LSIO_LPCG_PWM6_IPG_SLV_CLK, "pwm6_lpcg_ipg_slv_clk", "lsio_bus_clk_root", 0, LSIO_PWM_6_LPCG, 20, 0, },
-	{ IMX_LSIO_LPCG_PWM6_IPG_MSTR_CLK, "pwm6_lpcg_ipg_mstr_clk", "pwm6_clk", 0, LSIO_PWM_6_LPCG, 24, 0, },
-};
-
-static const struct imx8qxp_ss_lpcg imx8qxp_ss_lsio = {
-	.lpcg = imx8qxp_lpcg_lsio,
-	.num_lpcg = ARRAY_SIZE(imx8qxp_lpcg_lsio),
-	.num_max = IMX_LSIO_LPCG_CLK_END,
-};
 
 #define IMX_LPCG_MAX_CLKS	8
 
-static struct clk_hw *imx_lpcg_of_clk_src_get(struct of_phandle_args *clkspec,
-					      void *data)
-{
-	struct clk_hw_onecell_data *hw_data = data;
-	unsigned int idx = clkspec->args[0] / 4;
-
-	if (idx >= hw_data->num) {
-		pr_err("%s: invalid index %u\n", __func__, idx);
-		return ERR_PTR(-EINVAL);
-	}
-
-	return hw_data->hws[idx];
-}
-
-static int imx_lpcg_parse_clks_from_dt(struct platform_device *pdev,
-				       struct device_node *np)
+static int imx8qxp_lpcg_clk_probe(struct platform_device *pdev)
 {
+	struct device_node *np = pdev->dev.of_node;
 	const char *output_names[IMX_LPCG_MAX_CLKS];
 	const char *parent_names[IMX_LPCG_MAX_CLKS];
 	unsigned int bit_offset[IMX_LPCG_MAX_CLKS];
@@ -185,88 +29,78 @@ static int imx_lpcg_parse_clks_from_dt(struct platform_device *pdev,
 	struct clk_hw **clk_hws;
 	struct resource *res;
 	void __iomem *base;
+	bool autogate;
 	int count;
-	int idx;
 	int ret;
 	int i;
 
-	if (!of_device_is_compatible(np, "fsl,imx8qxp-lpcg"))
-		return -EINVAL;
-
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	base = devm_ioremap_resource(&pdev->dev, res);
 	if (IS_ERR(base))
 		return PTR_ERR(base);
 
-	count = of_property_count_u32_elems(np, "clock-indices");
+	count = of_property_count_u32_elems(np, "bit-offset");
 	if (count < 0) {
 		dev_err(&pdev->dev, "failed to count clocks\n");
 		return -EINVAL;
 	}
 
-	/*
-	 * A trick here is that we set the num of clks to the MAX instead
-	 * of the count from clock-indices because one LPCG supports up to
-	 * 8 clock outputs which each of them is fixed to 4 bits. Then we can
-	 * easily get the clock by clk-indices (bit-offset) / 4.
-	 * And the cost is very limited few pointers.
-	 */
-
-	clk_data = devm_kzalloc(&pdev->dev, struct_size(clk_data, hws,
-				IMX_LPCG_MAX_CLKS), GFP_KERNEL);
+	clk_data = devm_kzalloc(&pdev->dev, struct_size(clk_data, hws, count),
+				GFP_KERNEL);
 	if (!clk_data)
 		return -ENOMEM;
 
-	clk_data->num = IMX_LPCG_MAX_CLKS;
+	clk_data->num = count;
 	clk_hws = clk_data->hws;
 
-	ret = of_property_read_u32_array(np, "clock-indices", bit_offset,
-					 count);
+	ret = of_property_read_u32_array(np, "bit-offset", bit_offset,
+					 clk_data->num);
 	if (ret < 0) {
-		dev_err(&pdev->dev, "failed to read clock-indices\n");
+		dev_err(&pdev->dev, "failed to read clocks bit-offset\n");
 		return -EINVAL;
 	}
 
-	ret = of_clk_parent_fill(np, parent_names, count);
-	if (ret != count) {
+	ret = of_clk_parent_fill(np, parent_names, clk_data->num);
+	if (ret != clk_data->num) {
 		dev_err(&pdev->dev, "failed to get clock parent names\n");
-		return count;
+		return -EINVAL;
 	}
 
 	ret = of_property_read_string_array(np, "clock-output-names",
-					    output_names, count);
-	if (ret != count) {
+					    output_names, clk_data->num);
+	if (ret != clk_data->num) {
 		dev_err(&pdev->dev, "failed to read clock-output-names\n");
 		return -EINVAL;
 	}
 
+	autogate = of_property_read_bool(np, "hw-autogate");
+
 	pm_runtime_get_noresume(&pdev->dev);
 	pm_runtime_set_active(&pdev->dev);
 	pm_runtime_set_autosuspend_delay(&pdev->dev, 500);
 	pm_runtime_use_autosuspend(&pdev->dev);
 	pm_runtime_enable(&pdev->dev);
 
-	for (i = 0; i < count; i++) {
-		idx = bit_offset[i] / 4;
-		if (idx >= IMX_LPCG_MAX_CLKS) {
+	for (i = 0; i < clk_data->num; i++) {
+		if (bit_offset[i] > 31) {
 			dev_warn(&pdev->dev, "invalid bit offset of clock %d\n",
 				 i);
 			ret = -EINVAL;
 			goto unreg;
 		}
 
-		clk_hws[idx] = imx_clk_lpcg_scu_dev(&pdev->dev, output_names[i],
-						    parent_names[i], 0, base,
-						    bit_offset[i], false);
-		if (IS_ERR(clk_hws[idx])) {
+		clk_hws[i] = imx_clk_lpcg_scu_dev(&pdev->dev, output_names[i],
+						  parent_names[i], 0, base,
+						  bit_offset[i], autogate);
+		if (IS_ERR(clk_hws[i])) {
 			dev_warn(&pdev->dev, "failed to register clock %d\n",
-				 idx);
-			ret = PTR_ERR(clk_hws[idx]);
+				 i);
+			ret = PTR_ERR(clk_hws[i]);
 			goto unreg;
 		}
 	}
 
-	ret = devm_of_clk_add_hw_provider(&pdev->dev, imx_lpcg_of_clk_src_get,
+	ret = devm_of_clk_add_hw_provider(&pdev->dev, of_clk_hw_onecell_get,
 					  clk_data);
 	if (ret)
 		goto unreg;
@@ -278,9 +112,8 @@ static int imx_lpcg_parse_clks_from_dt(struct platform_device *pdev,
 
 unreg:
 	while (--i >= 0) {
-		idx = bit_offset[i] / 4;
-		if (clk_hws[idx])
-			imx_clk_lpcg_scu_unregister(clk_hws[idx]);
+		if (clk_hws[i])
+			imx_clk_lpcg_scu_unregister(clk_hws[i]);
 	}
 
 	pm_runtime_disable(&pdev->dev);
@@ -288,74 +121,7 @@ static int imx_lpcg_parse_clks_from_dt(struct platform_device *pdev,
 	return ret;
 }
 
-static int imx8qxp_lpcg_clk_probe(struct platform_device *pdev)
-{
-	struct device *dev = &pdev->dev;
-	struct device_node *np = dev->of_node;
-	struct clk_hw_onecell_data *clk_data;
-	const struct imx8qxp_ss_lpcg *ss_lpcg;
-	const struct imx8qxp_lpcg_data *lpcg;
-	struct resource *res;
-	struct clk_hw **clks;
-	void __iomem *base;
-	int ret;
-	int i;
-
-	/* try new binding to parse clocks from device tree first */
-	ret = imx_lpcg_parse_clks_from_dt(pdev, np);
-	if (!ret)
-		return 0;
-
-	ss_lpcg = of_device_get_match_data(dev);
-	if (!ss_lpcg)
-		return -ENODEV;
-
-	/*
-	 * Please don't replace this with devm_platform_ioremap_resource.
-	 *
-	 * devm_platform_ioremap_resource calls devm_ioremap_resource which
-	 * differs from devm_ioremap by also calling devm_request_mem_region
-	 * and preventing other mappings in the same area.
-	 *
-	 * On imx8 the LPCG nodes map entire subsystems and overlap
-	 * peripherals, this means that using devm_platform_ioremap_resource
-	 * will cause many devices to fail to probe including serial ports.
-	 */
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res)
-		return -EINVAL;
-	base = devm_ioremap(dev, res->start, resource_size(res));
-	if (!base)
-		return -ENOMEM;
-
-	clk_data = devm_kzalloc(&pdev->dev, struct_size(clk_data, hws,
-				ss_lpcg->num_max), GFP_KERNEL);
-	if (!clk_data)
-		return -ENOMEM;
-
-	clk_data->num = ss_lpcg->num_max;
-	clks = clk_data->hws;
-
-	for (i = 0; i < ss_lpcg->num_lpcg; i++) {
-		lpcg = ss_lpcg->lpcg + i;
-		clks[lpcg->id] = imx_clk_lpcg_scu(lpcg->name, lpcg->parent,
-						  lpcg->flags, base + lpcg->offset,
-						  lpcg->bit_idx, lpcg->hw_gate);
-	}
-
-	for (i = 0; i < clk_data->num; i++) {
-		if (IS_ERR(clks[i]))
-			pr_warn("i.MX clk %u: register failed with %ld\n",
-				i, PTR_ERR(clks[i]));
-	}
-
-	return of_clk_add_hw_provider(np, of_clk_hw_onecell_get, clk_data);
-}
-
 static const struct of_device_id imx8qxp_lpcg_match[] = {
-	{ .compatible = "fsl,imx8qxp-lpcg-adma", &imx8qxp_ss_adma, },
-	{ .compatible = "fsl,imx8qxp-lpcg-conn", &imx8qxp_ss_conn, },
-	{ .compatible = "fsl,imx8qxp-lpcg-lsio", &imx8qxp_ss_lsio, },
 	{ .compatible = "fsl,imx8qxp-lpcg", NULL },
 	{ /* sentinel */ }
 };
diff --git a/drivers/clk/imx/clk-imx8qxp-lpcg.h b/drivers/clk/imx/clk-imx8qxp-lpcg.h
index 2a37ce57c..ebca8fa92 100644
--- a/drivers/clk/imx/clk-imx8qxp-lpcg.h
+++ b/drivers/clk/imx/clk-imx8qxp-lpcg.h
@@ -42,7 +42,6 @@
 #define CONN_ENET_0_LPCG		0x30000
 #define CONN_ENET_1_LPCG		0x40000
 #define CONN_DTCP_LPCG			0x50000
-#define CONN_MLB_LPCG			0x60000
 #define CONN_USB_2_LPCG			0x70000
 #define CONN_USB_3_LPCG			0x80000
 #define CONN_NAND_LPCG			0x90000
diff --git a/drivers/clk/imx/clk-imx8qxp-rsrc.c b/drivers/clk/imx/clk-imx8qxp-rsrc.c
index df09f2a79..585c42552 100644
--- a/drivers/clk/imx/clk-imx8qxp-rsrc.c
+++ b/drivers/clk/imx/clk-imx8qxp-rsrc.c
@@ -54,15 +54,17 @@ static const u32 imx8qxp_clk_scu_rsrc_table[] = {
 	IMX_SC_R_SDHC_2,
 	IMX_SC_R_ENET_0,
 	IMX_SC_R_ENET_1,
-	IMX_SC_R_MLB_0,
 	IMX_SC_R_USB_2,
 	IMX_SC_R_NAND,
 	IMX_SC_R_LVDS_0,
 	IMX_SC_R_LVDS_1,
+	IMX_SC_R_M4_0_UART,
 	IMX_SC_R_M4_0_I2C,
 	IMX_SC_R_ELCDIF_PLL,
 	IMX_SC_R_AUDIO_PLL_0,
 	IMX_SC_R_PI_0,
+	IMX_SC_R_PI_0_PWM_0,
+	IMX_SC_R_PI_0_I2C_0,
 	IMX_SC_R_PI_0_PLL,
 	IMX_SC_R_MIPI_0,
 	IMX_SC_R_MIPI_0_PWM_0,
diff --git a/drivers/clk/imx/clk-imx8qxp.c b/drivers/clk/imx/clk-imx8qxp.c
index e1dea4609..73efd7c46 100644
--- a/drivers/clk/imx/clk-imx8qxp.c
+++ b/drivers/clk/imx/clk-imx8qxp.c
@@ -121,7 +121,6 @@ static int imx8qxp_clk_probe(struct platform_device *pdev)
 	imx_clk_scu("pwm5_clk", IMX_SC_R_PWM_5, IMX_SC_PM_CLK_PER);
 	imx_clk_scu("pwm6_clk", IMX_SC_R_PWM_6, IMX_SC_PM_CLK_PER);
 	imx_clk_scu("pwm7_clk", IMX_SC_R_PWM_7, IMX_SC_PM_CLK_PER);
-	imx_clk_scu("gpt0_clk", IMX_SC_R_GPT_0, IMX_SC_PM_CLK_PER);
 	imx_clk_scu("gpt1_clk", IMX_SC_R_GPT_1, IMX_SC_PM_CLK_PER);
 	imx_clk_scu("gpt2_clk", IMX_SC_R_GPT_2, IMX_SC_PM_CLK_PER);
 	imx_clk_scu("gpt3_clk", IMX_SC_R_GPT_3, IMX_SC_PM_CLK_PER);
@@ -153,10 +152,10 @@ static int imx8qxp_clk_probe(struct platform_device *pdev)
 	imx_clk_scu("adc0_clk",  IMX_SC_R_ADC_0, IMX_SC_PM_CLK_PER);
 	imx_clk_scu("adc1_clk",  IMX_SC_R_ADC_1, IMX_SC_PM_CLK_PER);
 	imx_clk_scu("pwm_clk",   IMX_SC_R_LCD_0_PWM_0, IMX_SC_PM_CLK_PER);
+	imx_clk_scu("elcdif_pll", IMX_SC_R_ELCDIF_PLL, IMX_SC_PM_CLK_PLL);
 	imx_clk_scu2("lcd_clk", lcd_sels, ARRAY_SIZE(lcd_sels), IMX_SC_R_LCD_0, IMX_SC_PM_CLK_PER);
 	imx_clk_scu2("lcd_pxl_clk", lcd_pxl_sels, ARRAY_SIZE(lcd_pxl_sels), IMX_SC_R_LCD_0, IMX_SC_PM_CLK_MISC0);
 	imx_clk_scu("lcd_pxl_bypass_div_clk", IMX_SC_R_LCD_0, IMX_SC_PM_CLK_BYPASS);
-	imx_clk_scu("elcdif_pll", IMX_SC_R_ELCDIF_PLL, IMX_SC_PM_CLK_PLL);
 
 	/* Audio SS */
 	imx_clk_scu("audio_pll0_clk", IMX_SC_R_AUDIO_PLL_0, IMX_SC_PM_CLK_PLL);
@@ -304,6 +303,7 @@ static const struct of_device_id imx8qxp_match[] = {
 	{ .compatible = "fsl,scu-clk", },
 	{ .compatible = "fsl,imx8qxp-clk", &imx_clk_scu_rsrc_imx8qxp, },
 	{ .compatible = "fsl,imx8qm-clk", &imx_clk_scu_rsrc_imx8qm, },
+	{ .compatible = "fsl,imx8dxl-clk", &imx_clk_scu_rsrc_imx8dxl, },
 	{ /* sentinel */ }
 };
 
diff --git a/drivers/clk/imx/clk-imx8ulp.c b/drivers/clk/imx/clk-imx8ulp.c
new file mode 100644
index 000000000..909d121ec
--- /dev/null
+++ b/drivers/clk/imx/clk-imx8ulp.c
@@ -0,0 +1,577 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2021 NXP
+ */
+
+#include <dt-bindings/clock/imx8ulp-clock.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/reset-controller.h>
+#include <linux/slab.h>
+
+#include "clk.h"
+
+static const char * const pll_pre_sels[] = { "sosc", "frosc", };
+static const char * const a35_sels[] = { "frosc", "spll2", "sosc", "lvds", };
+static const char * const nic_sels[] = { "frosc", "spll3_pfd0", "sosc", "lvds", };
+static const char * const pcc3_periph_bus_sels[] = { "dummy", "lposc", "sosc_div2",
+						     "frosc_div2", "xbar_divbus", "spll3_pfd1_div1",
+						     "spll3_pfd0_div2", "spll3_pfd0_div1", };
+static const char * const pcc4_periph_bus_sels[] = { "dummy", "dummy", "lposc",
+						     "sosc_div2", "frosc_div2", "xbar_divbus",
+						     "spll3_vcodiv", "spll3_pfd0_div1", };
+static const char * const pcc4_periph_plat_sels[] = { "dummy", "sosc_div1", "frosc_div1",
+						      "spll3_pfd3_div2", "spll3_pfd3_div1",
+						      "spll3_pfd2_div2", "spll3_pfd2_div1",
+						      "spll3_pfd1_div2", };
+static const char * const pcc5_periph_bus_sels[] = { "dummy", "dummy", "lposc",
+						     "sosc_div2", "frosc_div2", "lpav_bus_clk",
+						     "pll4_vcodiv", "pll4_pfd3_div1", };
+static const char * const pcc5_periph_plat_sels[] = { "dummy", "pll4_pfd3_div2", "pll4_pfd2_div2",
+						      "pll4_pfd2_div1", "pll4_pfd1_div2",
+						      "pll4_pfd1_div1", "pll4_pfd0_div2",
+						      "pll4_pfd0_div1", };
+static const char * const hifi_sels[] = { "frosc", "pll4", "pll4_pfd0", "sosc",
+					 "lvds", "dummy", "dummy", "dummy", };
+static const char * const ddr_sels[] = { "frosc", "pll4_pfd1", "sosc", "lvds",
+					 "pll4", "pll4", "pll4", "pll4", };
+static const char * const lpav_sels[] = { "frosc", "pll4_pfd1", "sosc", "lvds", };
+static const char * const sai45_sels[] = { "spll3_pfd1_div1", "aud_clk1", "aud_clk2", "sosc", };
+static const char * const sai67_sels[] = { "spll1_pfd2_div", "spll3_pfd1_div1", "aud_clk0", "aud_clk1", "aud_clk2", "sosc", "dummy", "dummy", };
+static const char * const aud_clk1_sels[] = { "ext_aud_mclk2", "sai4_rx_bclk", "sai4_tx_bclk", "sai5_rx_bclk", "sai5_tx_bclk", "dummy", "dummy", "dummy", };
+static const char * const aud_clk2_sels[] = { "ext_aud_mclk3", "sai6_rx_bclk", "sai6_tx_bclk", "sai7_rx_bclk", "sai7_tx_bclk", "spdif_rx", "dummy", "dummy", };
+static const char * const enet_ts_sels[] = { "ext_rmii_clk", "ext_ts_clk", "rosc", "ext_aud_mclk", "sosc", "dummy", "dummy", "dummy"};
+static const char * const xbar_divbus[] = { "xbar_divbus" };
+static const char * const nic_per_divplat[] = { "nic_per_divplat" };
+static const char * const lpav_axi_div[] = { "lpav_axi_div" };
+static const char * const lpav_bus_div[] = { "lpav_bus_div" };
+
+struct pcc_reset_dev {
+	void __iomem *base;
+	struct reset_controller_dev rcdev;
+	const u32 *resets;
+	spinlock_t *lock;
+};
+
+#define PCC_SW_RST	BIT(28)
+#define to_pcc_reset_dev(_rcdev)	container_of(_rcdev, struct pcc_reset_dev, rcdev)
+
+static const u32 pcc3_resets[] = {
+	0xa8, 0xac, 0xc8, 0xcc, 0xd0,
+	0xd4, 0xd8, 0xdc, 0xe0, 0xe4,
+	0xe8, 0xec, 0xf0
+};
+
+static const u32 pcc4_resets[] = {
+	0x4, 0x8, 0xc, 0x10, 0x14,
+	0x18, 0x1c, 0x20, 0x24, 0x34,
+	0x38, 0x3c, 0x40, 0x44, 0x48,
+	0x4c, 0x54
+};
+
+static const u32 pcc5_resets[] = {
+	0xa0, 0xa4, 0xa8, 0xac, 0xb0,
+	0xb4, 0xbc, 0xc0, 0xc8, 0xcc,
+	0xd0, 0xf0, 0xf4, 0xf8
+};
+
+static int imx8ulp_pcc_assert(struct reset_controller_dev *rcdev, unsigned long id)
+{
+	struct pcc_reset_dev *pcc_reset = to_pcc_reset_dev(rcdev);
+	u8 offset = pcc_reset->resets[id];
+	unsigned long flags;
+	u32 val;
+
+	spin_lock_irqsave(pcc_reset->lock, flags);
+
+	val = readl(pcc_reset->base + offset);
+	val &= ~PCC_SW_RST;
+	writel(val, pcc_reset->base + offset);
+
+	spin_unlock_irqrestore(pcc_reset->lock, flags);
+
+	return 0;
+}
+
+static int imx8ulp_pcc_deassert(struct reset_controller_dev *rcdev, unsigned long id)
+{
+	struct pcc_reset_dev *pcc_reset = to_pcc_reset_dev(rcdev);
+	u8 offset = pcc_reset->resets[id];
+	unsigned long flags;
+	u32 val;
+
+	spin_lock_irqsave(pcc_reset->lock, flags);
+
+	val = readl(pcc_reset->base + offset);
+	val |= PCC_SW_RST;
+	writel(val, pcc_reset->base + offset);
+
+	spin_unlock_irqrestore(pcc_reset->lock, flags);
+
+	return 0;
+}
+
+static const struct reset_control_ops imx8ulp_pcc_reset_ops = {
+	.assert = imx8ulp_pcc_assert,
+	.deassert = imx8ulp_pcc_deassert,
+};
+
+static int imx8ulp_pcc_reset_init(struct platform_device *pdev, void __iomem *base,
+	 const u32 *resets, unsigned int nr_resets)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct device *dev = &pdev->dev;
+	struct pcc_reset_dev *pcc_reset;
+
+	pcc_reset = devm_kzalloc(dev, sizeof(*pcc_reset), GFP_KERNEL);
+	if (!pcc_reset)
+		return -ENOMEM;
+
+	pcc_reset->base = base;
+	pcc_reset->lock = &imx_ccm_lock;
+	pcc_reset->resets = resets;
+	pcc_reset->rcdev.owner = THIS_MODULE;
+	pcc_reset->rcdev.nr_resets = nr_resets;
+	pcc_reset->rcdev.ops = &imx8ulp_pcc_reset_ops;
+	pcc_reset->rcdev.of_node = np;
+
+	return devm_reset_controller_register(dev, &pcc_reset->rcdev);
+}
+
+static int imx8ulp_clk_cgc1_init(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct device *dev = &pdev->dev;
+	struct clk_hw_onecell_data *clk_data;
+	struct clk_hw **clks;
+	void __iomem *base;
+
+	clk_data = devm_kzalloc(dev, struct_size(clk_data, hws, IMX8ULP_CLK_CGC1_END),
+			   GFP_KERNEL);
+	if (!clk_data)
+		return -ENOMEM;
+
+	clk_data->num = IMX8ULP_CLK_CGC1_END;
+	clks = clk_data->hws;
+
+	clks[IMX8ULP_CLK_DUMMY] = imx_clk_hw_fixed("dummy", 0);
+
+	clks[IMX8ULP_CLK_FROSC] = imx_obtain_fixed_clk_hw(np, "frosc");
+	clks[IMX8ULP_CLK_LPOSC] = imx_obtain_fixed_clk_hw(np, "lposc");
+	clks[IMX8ULP_CLK_ROSC] = imx_obtain_fixed_clk_hw(np, "rosc");
+	clks[IMX8ULP_CLK_SOSC] = imx_obtain_fixed_clk_hw(np, "sosc");
+
+	/* CGC1 */
+	base = of_iomap(np, 0);
+	WARN_ON(!base);
+
+	clks[IMX8ULP_CLK_SPLL2_PRE_SEL]	= imx_clk_hw_mux_flags("spll2_pre_sel", base + 0x510, 0, 1, pll_pre_sels, ARRAY_SIZE(pll_pre_sels), CLK_SET_PARENT_GATE);
+	clks[IMX8ULP_CLK_SPLL3_PRE_SEL]	= imx_clk_hw_mux_flags("spll3_pre_sel", base + 0x610, 0, 1, pll_pre_sels, ARRAY_SIZE(pll_pre_sels), CLK_SET_PARENT_GATE);
+
+	clks[IMX8ULP_CLK_SPLL2] = imx_clk_hw_pllv4(IMX_PLLV4_IMX8ULP, "spll2", "spll2_pre_sel", base + 0x500);
+	clks[IMX8ULP_CLK_SPLL3] = imx_clk_hw_pllv4(IMX_PLLV4_IMX8ULP, "spll3", "spll3_pre_sel", base + 0x600);
+	clks[IMX8ULP_CLK_SPLL3_VCODIV] = imx_clk_hw_divider("spll3_vcodiv", "spll3", base + 0x604, 0, 6);
+
+	clks[IMX8ULP_CLK_SPLL3_PFD0] = imx_clk_hw_pfdv2(IMX_PFDV2_IMX8ULP, "spll3_pfd0", "spll3_vcodiv", base + 0x614, 0);
+	clks[IMX8ULP_CLK_SPLL3_PFD1] = imx_clk_hw_pfdv2(IMX_PFDV2_IMX8ULP, "spll3_pfd1", "spll3_vcodiv", base + 0x614, 1);
+	clks[IMX8ULP_CLK_SPLL3_PFD2] = imx_clk_hw_pfdv2(IMX_PFDV2_IMX8ULP, "spll3_pfd2", "spll3_vcodiv", base + 0x614, 2);
+	clks[IMX8ULP_CLK_SPLL3_PFD3] = imx_clk_hw_pfdv2(IMX_PFDV2_IMX8ULP, "spll3_pfd3", "spll3_vcodiv", base + 0x614, 3);
+
+	clks[IMX8ULP_CLK_SPLL3_PFD0_DIV1_GATE] = imx_clk_hw_gate_dis("spll3_pfd0_div1_gate", "spll3_pfd0", base + 0x608, 7);
+	clks[IMX8ULP_CLK_SPLL3_PFD0_DIV2_GATE] = imx_clk_hw_gate_dis("spll3_pfd0_div2_gate", "spll3_pfd0", base + 0x608, 15);
+	clks[IMX8ULP_CLK_SPLL3_PFD1_DIV1_GATE] = imx_clk_hw_gate_dis("spll3_pfd1_div1_gate", "spll3_pfd1", base + 0x608, 23);
+	clks[IMX8ULP_CLK_SPLL3_PFD1_DIV2_GATE] = imx_clk_hw_gate_dis("spll3_pfd1_div2_gate", "spll3_pfd1", base + 0x608, 31);
+	clks[IMX8ULP_CLK_SPLL3_PFD2_DIV1_GATE] = imx_clk_hw_gate_dis("spll3_pfd2_div1_gate", "spll3_pfd2", base + 0x60c, 7);
+	clks[IMX8ULP_CLK_SPLL3_PFD2_DIV2_GATE] = imx_clk_hw_gate_dis("spll3_pfd2_div2_gate", "spll3_pfd2", base + 0x60c, 15);
+	clks[IMX8ULP_CLK_SPLL3_PFD3_DIV1_GATE] = imx_clk_hw_gate_dis("spll3_pfd3_div1_gate", "spll3_pfd3", base + 0x60c, 23);
+	clks[IMX8ULP_CLK_SPLL3_PFD3_DIV2_GATE] = imx_clk_hw_gate_dis("spll3_pfd3_div2_gate", "spll3_pfd3", base + 0x60c, 31);
+	clks[IMX8ULP_CLK_SPLL3_PFD0_DIV1] = imx_clk_hw_divider("spll3_pfd0_div1", "spll3_pfd0_div1_gate", base + 0x608, 0, 6);
+	clks[IMX8ULP_CLK_SPLL3_PFD0_DIV2] = imx_clk_hw_divider("spll3_pfd0_div2", "spll3_pfd0_div2_gate", base + 0x608, 8, 6);
+	clks[IMX8ULP_CLK_SPLL3_PFD1_DIV1] = imx_clk_hw_divider("spll3_pfd1_div1", "spll3_pfd1_div1_gate", base + 0x608, 16, 6);
+	clks[IMX8ULP_CLK_SPLL3_PFD1_DIV2] = imx_clk_hw_divider("spll3_pfd1_div2", "spll3_pfd1_div2_gate", base + 0x608, 24, 6);
+	clks[IMX8ULP_CLK_SPLL3_PFD2_DIV1] = imx_clk_hw_divider("spll3_pfd2_div1", "spll3_pfd2_div1_gate", base + 0x60c, 0, 6);
+	clks[IMX8ULP_CLK_SPLL3_PFD2_DIV2] = imx_clk_hw_divider("spll3_pfd2_div2", "spll3_pfd2_div2_gate", base + 0x60c, 8, 6);
+	clks[IMX8ULP_CLK_SPLL3_PFD3_DIV1] = imx_clk_hw_divider("spll3_pfd3_div1", "spll3_pfd3_div1_gate", base + 0x60c, 16, 6);
+	clks[IMX8ULP_CLK_SPLL3_PFD3_DIV2] = imx_clk_hw_divider("spll3_pfd3_div2", "spll3_pfd3_div2_gate", base + 0x60c, 24, 6);
+
+	clks[IMX8ULP_CLK_A35_SEL] = imx_clk_hw_mux2("a35_sel", base + 0x14, 28, 2, a35_sels, ARRAY_SIZE(a35_sels));
+	clks[IMX8ULP_CLK_A35_DIV] = imx_clk_hw_divider_flags("a35_div", "a35_sel", base + 0x14, 21, 6, CLK_SET_RATE_PARENT | CLK_IS_CRITICAL);
+
+	clks[IMX8ULP_CLK_NIC_SEL] = imx_clk_hw_mux2("nic_sel", base + 0x34, 28, 2, nic_sels, ARRAY_SIZE(nic_sels));
+	clks[IMX8ULP_CLK_NIC_AD_DIVPLAT] = imx_clk_hw_divider_flags("nic_ad_divplat", "nic_sel", base + 0x34, 21, 6, CLK_SET_RATE_PARENT | CLK_IS_CRITICAL);
+	clks[IMX8ULP_CLK_NIC_PER_DIVPLAT] = imx_clk_hw_divider_flags("nic_per_divplat", "nic_ad_divplat", base + 0x34, 14, 6, CLK_SET_RATE_PARENT | CLK_IS_CRITICAL);
+	clks[IMX8ULP_CLK_XBAR_AD_DIVPLAT] = imx_clk_hw_divider_flags("xbar_ad_divplat", "nic_ad_divplat", base + 0x38, 14, 6, CLK_SET_RATE_PARENT | CLK_IS_CRITICAL);
+	clks[IMX8ULP_CLK_XBAR_DIVBUS] = imx_clk_hw_divider_flags("xbar_divbus", "nic_ad_divplat", base + 0x38, 7, 6, CLK_SET_RATE_PARENT | CLK_IS_CRITICAL);
+	clks[IMX8ULP_CLK_XBAR_AD_SLOW] = imx_clk_hw_divider_flags("xbar_ad_slow", "nic_ad_divplat", base + 0x38, 0, 6, CLK_SET_RATE_PARENT | CLK_IS_CRITICAL);
+
+	clks[IMX8ULP_CLK_SOSC_DIV1_GATE] = imx_clk_hw_gate_dis("sosc_div1_gate", "sosc", base + 0x108, 7);
+	clks[IMX8ULP_CLK_SOSC_DIV2_GATE] = imx_clk_hw_gate_dis("sosc_div2_gate", "sosc", base + 0x108, 15);
+	clks[IMX8ULP_CLK_SOSC_DIV3_GATE] = imx_clk_hw_gate_dis("sosc_div3_gate", "sosc", base + 0x108, 23);
+	clks[IMX8ULP_CLK_SOSC_DIV1] = imx_clk_hw_divider("sosc_div1", "sosc_div1_gate", base + 0x108, 0, 6);
+	clks[IMX8ULP_CLK_SOSC_DIV2] = imx_clk_hw_divider("sosc_div2", "sosc_div2_gate", base + 0x108, 8, 6);
+	clks[IMX8ULP_CLK_SOSC_DIV3] = imx_clk_hw_divider("sosc_div3", "sosc_div3_gate", base + 0x108, 16, 6);
+
+	clks[IMX8ULP_CLK_FROSC_DIV1_GATE] = imx_clk_hw_gate_dis("frosc_div1_gate", "frosc", base + 0x208, 7);
+	clks[IMX8ULP_CLK_FROSC_DIV2_GATE] = imx_clk_hw_gate_dis("frosc_div2_gate", "frosc", base + 0x208, 15);
+	clks[IMX8ULP_CLK_FROSC_DIV3_GATE] = imx_clk_hw_gate_dis("frosc_div3_gate", "frosc", base + 0x208, 23);
+	clks[IMX8ULP_CLK_FROSC_DIV1] = imx_clk_hw_divider("frosc_div1", "frosc_div1_gate", base + 0x208, 0, 6);
+	clks[IMX8ULP_CLK_FROSC_DIV2] = imx_clk_hw_divider("frosc_div2", "frosc_div2_gate", base + 0x208, 8, 6);
+	clks[IMX8ULP_CLK_FROSC_DIV3] = imx_clk_hw_divider("frosc_div3", "frosc_div3_gate", base + 0x208, 16, 6);
+	clks[IMX8ULP_CLK_AUD_CLK1] = imx_clk_hw_mux2("aud_clk1", base + 0x900, 0, 3, aud_clk1_sels, ARRAY_SIZE(aud_clk1_sels));
+	clks[IMX8ULP_CLK_SAI4_SEL] = imx_clk_hw_mux2("sai4_sel", base + 0x904, 0, 2, sai45_sels, ARRAY_SIZE(sai45_sels));
+	clks[IMX8ULP_CLK_SAI5_SEL] = imx_clk_hw_mux2("sai5_sel", base + 0x904, 8, 2, sai45_sels, ARRAY_SIZE(sai45_sels));
+	clks[IMX8ULP_CLK_ENET_TS_SEL] = imx_clk_hw_mux2("enet_ts", base + 0x700, 24, 3, enet_ts_sels, ARRAY_SIZE(enet_ts_sels));
+
+	imx_check_clk_hws(clks, clk_data->num);
+
+	return devm_of_clk_add_hw_provider(dev, of_clk_hw_onecell_get, clk_data);
+}
+
+static int imx8ulp_clk_cgc2_init(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct device *dev = &pdev->dev;
+	struct clk_hw_onecell_data *clk_data;
+	struct clk_hw **clks;
+	void __iomem *base;
+
+	clk_data = devm_kzalloc(dev, struct_size(clk_data, hws, IMX8ULP_CLK_CGC2_END),
+			   GFP_KERNEL);
+	if (!clk_data)
+		return -ENOMEM;
+
+	clk_data->num = IMX8ULP_CLK_CGC2_END;
+	clks = clk_data->hws;
+
+	/* CGC2 */
+	base = of_iomap(np, 0);
+	WARN_ON(!base);
+
+	clks[IMX8ULP_CLK_PLL4_PRE_SEL] = imx_clk_hw_mux_flags("pll4_pre_sel", base + 0x610, 0, 1, pll_pre_sels, ARRAY_SIZE(pll_pre_sels), CLK_SET_PARENT_GATE);
+
+	clks[IMX8ULP_CLK_PLL4]	= imx_clk_hw_pllv4(IMX_PLLV4_IMX8ULP, "pll4", "pll4_pre_sel", base + 0x600);
+	clks[IMX8ULP_CLK_PLL4_VCODIV] = imx_clk_hw_divider("pll4_vcodiv", "pll4", base + 0x604, 0, 6);
+
+	clks[IMX8ULP_CLK_HIFI_SEL] = imx_clk_hw_mux_flags("hifi_sel", base + 0x14, 28, 3, hifi_sels, ARRAY_SIZE(hifi_sels), CLK_SET_PARENT_GATE);
+	clks[IMX8ULP_CLK_HIFI_DIVCORE] = imx_clk_hw_divider("hifi_core_div", "hifi_sel", base + 0x14, 21, 6);
+	clks[IMX8ULP_CLK_HIFI_DIVPLAT] = imx_clk_hw_divider("hifi_plat_div", "hifi_core_div", base + 0x14, 14, 6);
+
+	clks[IMX8ULP_CLK_DDR_SEL] = imx_clk_hw_mux_flags("ddr_sel", base + 0x40, 28, 3, ddr_sels, ARRAY_SIZE(ddr_sels), CLK_GET_RATE_NOCACHE);
+	clks[IMX8ULP_CLK_DDR_DIV] = imx_clk_hw_divider_flags("ddr_div", "ddr_sel", base + 0x40, 21, 6, CLK_IS_CRITICAL | CLK_GET_RATE_NOCACHE);
+	clks[IMX8ULP_CLK_LPAV_AXI_SEL] = imx_clk_hw_mux_flags("lpav_sel", base + 0x3c, 28, 2, lpav_sels, ARRAY_SIZE(lpav_sels), CLK_SET_PARENT_GATE);
+	clks[IMX8ULP_CLK_LPAV_AXI_DIV] = imx_clk_hw_divider_flags("lpav_axi_div", "lpav_sel", base + 0x3c, 21, 6, CLK_IS_CRITICAL);
+	clks[IMX8ULP_CLK_LPAV_AHB_DIV] = imx_clk_hw_divider_flags("lpav_ahb_div", "lpav_axi_div", base + 0x3c, 14, 6, CLK_IS_CRITICAL);
+	clks[IMX8ULP_CLK_LPAV_BUS_DIV] = imx_clk_hw_divider_flags("lpav_bus_div", "lpav_axi_div", base + 0x3c, 7, 6, CLK_IS_CRITICAL);
+
+	clks[IMX8ULP_CLK_PLL4_PFD0] = imx_clk_hw_pfdv2(IMX_PFDV2_IMX8ULP, "pll4_pfd0", "pll4_vcodiv", base + 0x614, 0);
+	clks[IMX8ULP_CLK_PLL4_PFD1] = imx_clk_hw_pfdv2(IMX_PFDV2_IMX8ULP, "pll4_pfd1", "pll4_vcodiv", base + 0x614, 1);
+	clks[IMX8ULP_CLK_PLL4_PFD2] = imx_clk_hw_pfdv2(IMX_PFDV2_IMX8ULP, "pll4_pfd2", "pll4_vcodiv", base + 0x614, 2);
+	clks[IMX8ULP_CLK_PLL4_PFD3] = imx_clk_hw_pfdv2(IMX_PFDV2_IMX8ULP, "pll4_pfd3", "pll4_vcodiv", base + 0x614, 3);
+
+	clks[IMX8ULP_CLK_PLL4_PFD0_DIV1_GATE] = imx_clk_hw_gate_dis("pll4_pfd0_div1_gate", "pll4_pfd0", base + 0x608, 7);
+	clks[IMX8ULP_CLK_PLL4_PFD0_DIV2_GATE] = imx_clk_hw_gate_dis("pll4_pfd0_div2_gate", "pll4_pfd0", base + 0x608, 15);
+	clks[IMX8ULP_CLK_PLL4_PFD1_DIV1_GATE] = imx_clk_hw_gate_dis("pll4_pfd1_div1_gate", "pll4_pfd1", base + 0x608, 23);
+	clks[IMX8ULP_CLK_PLL4_PFD1_DIV2_GATE] = imx_clk_hw_gate_dis("pll4_pfd1_div2_gate", "pll4_pfd1", base + 0x608, 31);
+	clks[IMX8ULP_CLK_PLL4_PFD2_DIV1_GATE] = imx_clk_hw_gate_dis("pll4_pfd2_div1_gate", "pll4_pfd2", base + 0x60c, 7);
+	clks[IMX8ULP_CLK_PLL4_PFD2_DIV2_GATE] = imx_clk_hw_gate_dis("pll4_pfd2_div2_gate", "pll4_pfd2", base + 0x60c, 15);
+	clks[IMX8ULP_CLK_PLL4_PFD3_DIV1_GATE] = imx_clk_hw_gate_dis("pll4_pfd3_div1_gate", "pll4_pfd3", base + 0x60c, 23);
+	clks[IMX8ULP_CLK_PLL4_PFD3_DIV2_GATE] = imx_clk_hw_gate_dis("pll4_pfd3_div2_gate", "pll4_pfd3", base + 0x60c, 31);
+	clks[IMX8ULP_CLK_PLL4_PFD0_DIV1] = imx_clk_hw_divider_closest("pll4_pfd0_div1", "pll4_pfd0_div1_gate", base + 0x608, 0, 6);
+	clks[IMX8ULP_CLK_PLL4_PFD0_DIV2] = imx_clk_hw_divider_closest("pll4_pfd0_div2", "pll4_pfd0_div2_gate", base + 0x608, 8, 6);
+	clks[IMX8ULP_CLK_PLL4_PFD1_DIV1] = imx_clk_hw_divider_closest("pll4_pfd1_div1", "pll4_pfd1_div1_gate", base + 0x608, 16, 6);
+	clks[IMX8ULP_CLK_PLL4_PFD1_DIV2] = imx_clk_hw_divider_closest("pll4_pfd1_div2", "pll4_pfd1_div2_gate", base + 0x608, 24, 6);
+	clks[IMX8ULP_CLK_PLL4_PFD2_DIV1] = imx_clk_hw_divider_closest("pll4_pfd2_div1", "pll4_pfd2_div1_gate", base + 0x60c, 0, 6);
+	clks[IMX8ULP_CLK_PLL4_PFD2_DIV2] = imx_clk_hw_divider_closest("pll4_pfd2_div2", "pll4_pfd2_div2_gate", base + 0x60c, 8, 6);
+	clks[IMX8ULP_CLK_PLL4_PFD3_DIV1] = imx_clk_hw_divider_closest("pll4_pfd3_div1", "pll4_pfd3_div1_gate", base + 0x60c, 16, 6);
+	clks[IMX8ULP_CLK_PLL4_PFD3_DIV2] = imx_clk_hw_divider_closest("pll4_pfd3_div2", "pll4_pfd3_div2_gate", base + 0x60c, 24, 6);
+
+	clks[IMX8ULP_CLK_CGC2_SOSC_DIV1_GATE] = imx_clk_hw_gate_dis("cgc2_sosc_div1_gate", "sosc", base + 0x108, 7);
+	clks[IMX8ULP_CLK_CGC2_SOSC_DIV2_GATE] = imx_clk_hw_gate_dis("cgc2_sosc_div2_gate", "sosc", base + 0x108, 15);
+	clks[IMX8ULP_CLK_CGC2_SOSC_DIV3_GATE] = imx_clk_hw_gate_dis("cgc2_sosc_div3_gate", "sosc", base + 0x108, 23);
+	clks[IMX8ULP_CLK_CGC2_SOSC_DIV1] = imx_clk_hw_divider("cgc2_sosc_div1", "cgc2_sosc_div1_gate", base + 0x108, 0, 6);
+	clks[IMX8ULP_CLK_CGC2_SOSC_DIV2] = imx_clk_hw_divider("cgc2_sosc_div2", "cgc2_sosc_div2_gate", base + 0x108, 8, 6);
+	clks[IMX8ULP_CLK_CGC2_SOSC_DIV3] = imx_clk_hw_divider("cgc2_sosc_div3", "cgc2_sosc_div3_gate", base + 0x108, 16, 6);
+
+	clks[IMX8ULP_CLK_CGC2_FROSC_DIV1_GATE] = imx_clk_hw_gate_dis("cgc2_frosc_div1_gate", "frosc", base + 0x208, 7);
+	clks[IMX8ULP_CLK_CGC2_FROSC_DIV2_GATE] = imx_clk_hw_gate_dis("cgc2_frosc_div2_gate", "frosc", base + 0x208, 15);
+	clks[IMX8ULP_CLK_CGC2_FROSC_DIV3_GATE] = imx_clk_hw_gate_dis("cgc2_frosc_div3_gate", "frosc", base + 0x208, 23);
+	clks[IMX8ULP_CLK_CGC2_FROSC_DIV1] = imx_clk_hw_divider("cgc2_frosc_div1", "cgc2_frosc_div1_gate", base + 0x208, 0, 6);
+	clks[IMX8ULP_CLK_CGC2_FROSC_DIV2] = imx_clk_hw_divider("cgc2_frosc_div2", "cgc2_frosc_div2_gate", base + 0x208, 8, 6);
+	clks[IMX8ULP_CLK_CGC2_FROSC_DIV3] = imx_clk_hw_divider("cgc2_frosc_div3", "cgc2_frosc_div3_gate", base + 0x208, 16, 6);
+	clks[IMX8ULP_CLK_AUD_CLK2]  = imx_clk_hw_mux2("aud_clk2", base + 0x900, 0, 3, aud_clk2_sels, ARRAY_SIZE(aud_clk2_sels));
+	clks[IMX8ULP_CLK_SAI6_SEL]  = imx_clk_hw_mux2("sai6_sel", base + 0x904, 0, 3, sai67_sels, ARRAY_SIZE(sai67_sels));
+	clks[IMX8ULP_CLK_SAI7_SEL]  = imx_clk_hw_mux2("sai7_sel", base + 0x904, 8, 3, sai67_sels, ARRAY_SIZE(sai67_sels));
+	clks[IMX8ULP_CLK_SPDIF_SEL] = imx_clk_hw_mux2("spdif_sel", base + 0x910, 0, 3, sai67_sels, ARRAY_SIZE(sai67_sels));
+	clks[IMX8ULP_CLK_DSI_PHY_REF] = imx_clk_hw_fixed("dsi_phy_ref", 24000000);
+
+	imx_check_clk_hws(clks, clk_data->num);
+
+	return devm_of_clk_add_hw_provider(dev, of_clk_hw_onecell_get, clk_data);
+}
+
+static int imx8ulp_clk_pcc3_init(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct device *dev = &pdev->dev;
+	struct clk_hw_onecell_data *clk_data;
+	struct clk_hw **clks;
+	void __iomem *base;
+	int ret;
+
+	clk_data = devm_kzalloc(dev, struct_size(clk_data, hws, IMX8ULP_CLK_PCC3_END),
+			   GFP_KERNEL);
+	if (!clk_data)
+		return -ENOMEM;
+
+	clk_data->num = IMX8ULP_CLK_PCC3_END;
+	clks = clk_data->hws;
+
+	/* PCC3 */
+	base = of_iomap(np, 0);
+	WARN_ON(!base);
+
+	clks[IMX8ULP_CLK_WDOG3] = imx8ulp_clk_hw_composite("wdog3", pcc3_periph_bus_sels, ARRAY_SIZE(pcc3_periph_bus_sels), true, true, true, base + 0xa8, 1);
+	clks[IMX8ULP_CLK_WDOG4] = imx8ulp_clk_hw_composite("wdog4", pcc3_periph_bus_sels, ARRAY_SIZE(pcc3_periph_bus_sels), true, true, true, base + 0xac, 1);
+	clks[IMX8ULP_CLK_LPIT1] = imx8ulp_clk_hw_composite("lpit1", pcc3_periph_bus_sels, ARRAY_SIZE(pcc3_periph_bus_sels), true, true, true, base + 0xc8, 1);
+	clks[IMX8ULP_CLK_TPM4] = imx8ulp_clk_hw_composite("tpm4", pcc3_periph_bus_sels, ARRAY_SIZE(pcc3_periph_bus_sels), true, true, true, base + 0xcc, 1);
+	clks[IMX8ULP_CLK_FLEXIO1] = imx8ulp_clk_hw_composite("flexio1", pcc3_periph_bus_sels, ARRAY_SIZE(pcc3_periph_bus_sels), true, true, true, base + 0xd4, 1);
+	clks[IMX8ULP_CLK_I3C2] = imx8ulp_clk_hw_composite("i3c2", pcc3_periph_bus_sels, ARRAY_SIZE(pcc3_periph_bus_sels), true, true, true, base + 0xd8, 1);
+	clks[IMX8ULP_CLK_LPI2C4] = imx8ulp_clk_hw_composite("lpi2c4", pcc3_periph_bus_sels, ARRAY_SIZE(pcc3_periph_bus_sels), true, true, true, base + 0xdc, 1);
+	clks[IMX8ULP_CLK_LPI2C5] = imx8ulp_clk_hw_composite("lpi2c5", pcc3_periph_bus_sels, ARRAY_SIZE(pcc3_periph_bus_sels), true, true, true, base + 0xe0, 1);
+	clks[IMX8ULP_CLK_LPUART4] = imx8ulp_clk_hw_composite("lpuart4", pcc3_periph_bus_sels, ARRAY_SIZE(pcc3_periph_bus_sels), true, true, true, base + 0xe4, 1);
+	clks[IMX8ULP_CLK_LPUART5] = imx8ulp_clk_hw_composite("lpuart5", pcc3_periph_bus_sels, ARRAY_SIZE(pcc3_periph_bus_sels), true, true, true, base + 0xe8, 1);
+	clks[IMX8ULP_CLK_LPSPI4] = imx8ulp_clk_hw_composite("lpspi4", pcc3_periph_bus_sels, ARRAY_SIZE(pcc3_periph_bus_sels), true, true, true, base + 0xec, 1);
+	clks[IMX8ULP_CLK_LPSPI5] = imx8ulp_clk_hw_composite("lpspi5", pcc3_periph_bus_sels, ARRAY_SIZE(pcc3_periph_bus_sels), true, true, true, base + 0xf0, 1);
+
+	clks[IMX8ULP_CLK_DMA1_MP] = imx_clk_hw_gate("pcc_dma1_mp", "xbar_ad_divplat", base + 0x4, 30);
+	clks[IMX8ULP_CLK_DMA1_CH0] = imx_clk_hw_gate("pcc_dma1_ch0", "xbar_ad_divplat", base + 0x8, 30);
+	clks[IMX8ULP_CLK_DMA1_CH1] = imx_clk_hw_gate("pcc_dma1_ch1", "xbar_ad_divplat", base + 0xc, 30);
+	clks[IMX8ULP_CLK_DMA1_CH2] = imx_clk_hw_gate("pcc_dma1_ch2", "xbar_ad_divplat", base + 0x10, 30);
+	clks[IMX8ULP_CLK_DMA1_CH3] = imx_clk_hw_gate("pcc_dma1_ch3", "xbar_ad_divplat", base + 0x14, 30);
+	clks[IMX8ULP_CLK_DMA1_CH4] = imx_clk_hw_gate("pcc_dma1_ch4", "xbar_ad_divplat", base + 0x18, 30);
+	clks[IMX8ULP_CLK_DMA1_CH5] = imx_clk_hw_gate("pcc_dma1_ch5", "xbar_ad_divplat", base + 0x1c, 30);
+	clks[IMX8ULP_CLK_DMA1_CH6] = imx_clk_hw_gate("pcc_dma1_ch6", "xbar_ad_divplat", base + 0x20, 30);
+	clks[IMX8ULP_CLK_DMA1_CH7] = imx_clk_hw_gate("pcc_dma1_ch7", "xbar_ad_divplat", base + 0x24, 30);
+	clks[IMX8ULP_CLK_DMA1_CH8] = imx_clk_hw_gate("pcc_dma1_ch8", "xbar_ad_divplat", base + 0x28, 30);
+	clks[IMX8ULP_CLK_DMA1_CH9] = imx_clk_hw_gate("pcc_dma1_ch9", "xbar_ad_divplat", base + 0x2c, 30);
+	clks[IMX8ULP_CLK_DMA1_CH10] = imx_clk_hw_gate("pcc_dma1_ch10", "xbar_ad_divplat", base + 0x30, 30);
+	clks[IMX8ULP_CLK_DMA1_CH11] = imx_clk_hw_gate("pcc_dma1_ch11", "xbar_ad_divplat", base + 0x34, 30);
+	clks[IMX8ULP_CLK_DMA1_CH12] = imx_clk_hw_gate("pcc_dma1_ch12", "xbar_ad_divplat", base + 0x38, 30);
+	clks[IMX8ULP_CLK_DMA1_CH13] = imx_clk_hw_gate("pcc_dma1_ch13", "xbar_ad_divplat", base + 0x3c, 30);
+	clks[IMX8ULP_CLK_DMA1_CH14] = imx_clk_hw_gate("pcc_dma1_ch14", "xbar_ad_divplat", base + 0x40, 30);
+	clks[IMX8ULP_CLK_DMA1_CH15] = imx_clk_hw_gate("pcc_dma1_ch15", "xbar_ad_divplat", base + 0x44, 30);
+	clks[IMX8ULP_CLK_DMA1_CH16] = imx_clk_hw_gate("pcc_dma1_ch16", "xbar_ad_divplat", base + 0x48, 30);
+	clks[IMX8ULP_CLK_DMA1_CH17] = imx_clk_hw_gate("pcc_dma1_ch17", "xbar_ad_divplat", base + 0x4c, 30);
+	clks[IMX8ULP_CLK_DMA1_CH18] = imx_clk_hw_gate("pcc_dma1_ch18", "xbar_ad_divplat", base + 0x50, 30);
+	clks[IMX8ULP_CLK_DMA1_CH19] = imx_clk_hw_gate("pcc_dma1_ch19", "xbar_ad_divplat", base + 0x54, 30);
+	clks[IMX8ULP_CLK_DMA1_CH20] = imx_clk_hw_gate("pcc_dma1_ch20", "xbar_ad_divplat", base + 0x58, 30);
+	clks[IMX8ULP_CLK_DMA1_CH21] = imx_clk_hw_gate("pcc_dma1_ch21", "xbar_ad_divplat", base + 0x5c, 30);
+	clks[IMX8ULP_CLK_DMA1_CH22] = imx_clk_hw_gate("pcc_dma1_ch22", "xbar_ad_divplat", base + 0x60, 30);
+	clks[IMX8ULP_CLK_DMA1_CH23] = imx_clk_hw_gate("pcc_dma1_ch23", "xbar_ad_divplat", base + 0x64, 30);
+	clks[IMX8ULP_CLK_DMA1_CH24] = imx_clk_hw_gate("pcc_dma1_ch24", "xbar_ad_divplat", base + 0x68, 30);
+	clks[IMX8ULP_CLK_DMA1_CH25] = imx_clk_hw_gate("pcc_dma1_ch25", "xbar_ad_divplat", base + 0x6c, 30);
+	clks[IMX8ULP_CLK_DMA1_CH26] = imx_clk_hw_gate("pcc_dma1_ch26", "xbar_ad_divplat", base + 0x70, 30);
+	clks[IMX8ULP_CLK_DMA1_CH27] = imx_clk_hw_gate("pcc_dma1_ch27", "xbar_ad_divplat", base + 0x74, 30);
+	clks[IMX8ULP_CLK_DMA1_CH28] = imx_clk_hw_gate("pcc_dma1_ch28", "xbar_ad_divplat", base + 0x78, 30);
+	clks[IMX8ULP_CLK_DMA1_CH29] = imx_clk_hw_gate("pcc_dma1_ch29", "xbar_ad_divplat", base + 0x7c, 30);
+	clks[IMX8ULP_CLK_DMA1_CH30] = imx_clk_hw_gate("pcc_dma1_ch30", "xbar_ad_divplat", base + 0x80, 30);
+	clks[IMX8ULP_CLK_DMA1_CH31] = imx_clk_hw_gate("pcc_dma1_ch31", "xbar_ad_divplat", base + 0x84, 30);
+	clks[IMX8ULP_CLK_MU0_B] = imx_clk_hw_gate_flags("mu0_b", "xbar_ad_divplat", base + 0x88, 30, CLK_IS_CRITICAL);
+	clks[IMX8ULP_CLK_MU3_A] = imx_clk_hw_gate("mu3_a", "xbar_ad_divplat", base + 0x8c, 30);
+	clks[IMX8ULP_CLK_TPM5] = imx_clk_hw_gate_flags("tpm5", "sosc_div2",  base + 0xd0, 30, CLK_IS_CRITICAL);
+
+	imx_check_clk_hws(clks, clk_data->num);
+
+	ret = devm_of_clk_add_hw_provider(dev, of_clk_hw_onecell_get, clk_data);
+	if (ret)
+		return ret;
+
+	imx_register_uart_clocks(1);
+
+	/* register the pcc3 reset controller */
+	return imx8ulp_pcc_reset_init(pdev, base, pcc3_resets, ARRAY_SIZE(pcc3_resets));
+}
+
+static int imx8ulp_clk_pcc4_init(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct device *dev = &pdev->dev;
+	struct clk_hw_onecell_data *clk_data;
+	struct clk_hw **clks;
+	void __iomem *base;
+	int ret;
+
+	clk_data = devm_kzalloc(dev, struct_size(clk_data, hws, IMX8ULP_CLK_PCC4_END),
+			   GFP_KERNEL);
+	if (!clk_data)
+		return -ENOMEM;
+
+	clk_data->num = IMX8ULP_CLK_PCC4_END;
+	clks = clk_data->hws;
+
+	/* PCC4 */
+	base = of_iomap(np, 0);
+	WARN_ON(!base);
+
+	clks[IMX8ULP_CLK_FLEXSPI2] = imx8ulp_clk_hw_composite("flexspi2", pcc4_periph_plat_sels, ARRAY_SIZE(pcc4_periph_plat_sels), true, true, true, base + 0x4, 1);
+	clks[IMX8ULP_CLK_TPM6] = imx8ulp_clk_hw_composite("tpm6", pcc4_periph_bus_sels, ARRAY_SIZE(pcc4_periph_bus_sels), true, true, true, base + 0x8, 1);
+	clks[IMX8ULP_CLK_TPM7] = imx8ulp_clk_hw_composite("tpm7", pcc4_periph_bus_sels, ARRAY_SIZE(pcc4_periph_bus_sels), true, true, true, base + 0xc, 1);
+	clks[IMX8ULP_CLK_LPI2C6] = imx8ulp_clk_hw_composite("lpi2c6", pcc4_periph_bus_sels, ARRAY_SIZE(pcc4_periph_bus_sels), true, true, true, base + 0x10, 1);
+	clks[IMX8ULP_CLK_LPI2C7] = imx8ulp_clk_hw_composite("lpi2c7", pcc4_periph_bus_sels, ARRAY_SIZE(pcc4_periph_bus_sels), true, true, true, base + 0x14, 1);
+	clks[IMX8ULP_CLK_LPUART6] = imx8ulp_clk_hw_composite("lpuart6", pcc4_periph_bus_sels, ARRAY_SIZE(pcc4_periph_bus_sels), true, true, true, base + 0x18, 1);
+	clks[IMX8ULP_CLK_LPUART7] = imx8ulp_clk_hw_composite("lpuart7", pcc4_periph_bus_sels, ARRAY_SIZE(pcc4_periph_bus_sels), true, true, true, base + 0x1c, 1);
+	clks[IMX8ULP_CLK_SAI4] = imx8ulp_clk_hw_composite("sai4", xbar_divbus, 1, false, false, true, base + 0x20, 1); /* sai ipg, NOT from sai sel */
+	clks[IMX8ULP_CLK_SAI5] = imx8ulp_clk_hw_composite("sai5", xbar_divbus, 1, false, false, true, base + 0x24, 1); /* sai ipg */
+	clks[IMX8ULP_CLK_PCTLE] = imx_clk_hw_gate("pctle", "xbar_divbus", base + 0x28, 30);
+	clks[IMX8ULP_CLK_PCTLF] = imx_clk_hw_gate("pctlf", "xbar_divbus", base + 0x2c, 30);
+	clks[IMX8ULP_CLK_USDHC0] = imx8ulp_clk_hw_composite("usdhc0", pcc4_periph_plat_sels, ARRAY_SIZE(pcc4_periph_plat_sels), true, false, true, base + 0x34, 1);
+	clks[IMX8ULP_CLK_USDHC1] = imx8ulp_clk_hw_composite("usdhc1", pcc4_periph_plat_sels, ARRAY_SIZE(pcc4_periph_plat_sels), true, false, true, base + 0x38, 1);
+	clks[IMX8ULP_CLK_USDHC2] = imx8ulp_clk_hw_composite("usdhc2", pcc4_periph_plat_sels, ARRAY_SIZE(pcc4_periph_plat_sels), true, false, true, base + 0x3c, 1);
+	clks[IMX8ULP_CLK_USB0] = imx8ulp_clk_hw_composite("usb0", nic_per_divplat, 1, false, false, true, base + 0x40, 1);
+	clks[IMX8ULP_CLK_USB0_PHY] = imx8ulp_clk_hw_composite("usb0_phy", xbar_divbus, 1, false, false, true, base + 0x44, 1);
+	clks[IMX8ULP_CLK_USB1] = imx8ulp_clk_hw_composite("usb1", nic_per_divplat, 1, false, false, true, base + 0x48, 1);
+	clks[IMX8ULP_CLK_USB1_PHY] = imx8ulp_clk_hw_composite("usb1_phy", xbar_divbus, 1, false, false, true, base + 0x4c, 1);
+	clks[IMX8ULP_CLK_USB_XBAR] = imx_clk_hw_gate("usb_xbar", "xbar_divbus", base + 0x50, 30);
+	clks[IMX8ULP_CLK_ENET] = imx8ulp_clk_hw_composite("enet", nic_per_divplat, 1, false, false, true, base + 0x54, 1);
+	clks[IMX8ULP_CLK_RGPIOE] = imx_clk_hw_gate("rgpioe", "nic_per_divplat", base + 0x78, 30);
+	clks[IMX8ULP_CLK_RGPIOF] = imx_clk_hw_gate("rgpiof", "nic_per_divplat", base + 0x7c, 30);
+
+	imx_check_clk_hws(clks, clk_data->num);
+
+	ret = devm_of_clk_add_hw_provider(dev, of_clk_hw_onecell_get, clk_data);
+	if (ret)
+		return ret;
+
+	/* register the pcc4 reset controller */
+	return imx8ulp_pcc_reset_init(pdev, base, pcc4_resets, ARRAY_SIZE(pcc4_resets));
+
+}
+
+static int imx8ulp_clk_pcc5_init(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct device *dev = &pdev->dev;
+	struct clk_hw_onecell_data *clk_data;
+	struct clk_hw **clks;
+	void __iomem *base;
+	int ret;
+
+	clk_data = devm_kzalloc(dev, struct_size(clk_data, hws, IMX8ULP_CLK_PCC5_END),
+			   GFP_KERNEL);
+	if (!clk_data)
+		return -ENOMEM;
+
+	clk_data->num = IMX8ULP_CLK_PCC5_END;
+	clks = clk_data->hws;
+
+	/* PCC5 */
+	base = of_iomap(np, 0);
+	WARN_ON(!base);
+
+	clks[IMX8ULP_CLK_DMA2_MP] = imx_clk_hw_gate("pcc_dma2_mp", "lpav_axi_div", base + 0x0, 30);
+	clks[IMX8ULP_CLK_DMA2_CH0] = imx_clk_hw_gate("pcc_dma2_ch0", "lpav_axi_div", base + 0x4, 30);
+	clks[IMX8ULP_CLK_DMA2_CH1] = imx_clk_hw_gate("pcc_dma2_ch1", "lpav_axi_div", base + 0x8, 30);
+	clks[IMX8ULP_CLK_DMA2_CH2] = imx_clk_hw_gate("pcc_dma2_ch2", "lpav_axi_div", base + 0xc, 30);
+	clks[IMX8ULP_CLK_DMA2_CH3] = imx_clk_hw_gate("pcc_dma2_ch3", "lpav_axi_div", base + 0x10, 30);
+	clks[IMX8ULP_CLK_DMA2_CH4] = imx_clk_hw_gate("pcc_dma2_ch4", "lpav_axi_div", base + 0x14, 30);
+	clks[IMX8ULP_CLK_DMA2_CH5] = imx_clk_hw_gate("pcc_dma2_ch5", "lpav_axi_div", base + 0x18, 30);
+	clks[IMX8ULP_CLK_DMA2_CH6] = imx_clk_hw_gate("pcc_dma2_ch6", "lpav_axi_div", base + 0x1c, 30);
+	clks[IMX8ULP_CLK_DMA2_CH7] = imx_clk_hw_gate("pcc_dma2_ch7", "lpav_axi_div", base + 0x20, 30);
+	clks[IMX8ULP_CLK_DMA2_CH8] = imx_clk_hw_gate("pcc_dma2_ch8", "lpav_axi_div", base + 0x24, 30);
+	clks[IMX8ULP_CLK_DMA2_CH9] = imx_clk_hw_gate("pcc_dma2_ch9", "lpav_axi_div", base + 0x28, 30);
+	clks[IMX8ULP_CLK_DMA2_CH10] = imx_clk_hw_gate("pcc_dma2_ch10", "lpav_axi_div", base + 0x2c, 30);
+	clks[IMX8ULP_CLK_DMA2_CH11] = imx_clk_hw_gate("pcc_dma2_ch11", "lpav_axi_div", base + 0x30, 30);
+	clks[IMX8ULP_CLK_DMA2_CH12] = imx_clk_hw_gate("pcc_dma2_ch12", "lpav_axi_div", base + 0x34, 30);
+	clks[IMX8ULP_CLK_DMA2_CH13] = imx_clk_hw_gate("pcc_dma2_ch13", "lpav_axi_div", base + 0x38, 30);
+	clks[IMX8ULP_CLK_DMA2_CH14] = imx_clk_hw_gate("pcc_dma2_ch14", "lpav_axi_div", base + 0x3c, 30);
+	clks[IMX8ULP_CLK_DMA2_CH15] = imx_clk_hw_gate("pcc_dma2_ch15", "lpav_axi_div", base + 0x40, 30);
+	clks[IMX8ULP_CLK_DMA2_CH16] = imx_clk_hw_gate("pcc_dma2_ch16", "lpav_axi_div", base + 0x44, 30);
+	clks[IMX8ULP_CLK_DMA2_CH17] = imx_clk_hw_gate("pcc_dma2_ch17", "lpav_axi_div", base + 0x48, 30);
+	clks[IMX8ULP_CLK_DMA2_CH18] = imx_clk_hw_gate("pcc_dma2_ch18", "lpav_axi_div", base + 0x4c, 30);
+	clks[IMX8ULP_CLK_DMA2_CH19] = imx_clk_hw_gate("pcc_dma2_ch19", "lpav_axi_div", base + 0x50, 30);
+	clks[IMX8ULP_CLK_DMA2_CH20] = imx_clk_hw_gate("pcc_dma2_ch20", "lpav_axi_div", base + 0x54, 30);
+	clks[IMX8ULP_CLK_DMA2_CH21] = imx_clk_hw_gate("pcc_dma2_ch21", "lpav_axi_div", base + 0x58, 30);
+	clks[IMX8ULP_CLK_DMA2_CH22] = imx_clk_hw_gate("pcc_dma2_ch22", "lpav_axi_div", base + 0x5c, 30);
+	clks[IMX8ULP_CLK_DMA2_CH23] = imx_clk_hw_gate("pcc_dma2_ch23", "lpav_axi_div", base + 0x60, 30);
+	clks[IMX8ULP_CLK_DMA2_CH24] = imx_clk_hw_gate("pcc_dma2_ch24", "lpav_axi_div", base + 0x64, 30);
+	clks[IMX8ULP_CLK_DMA2_CH25] = imx_clk_hw_gate("pcc_dma2_ch25", "lpav_axi_div", base + 0x68, 30);
+	clks[IMX8ULP_CLK_DMA2_CH26] = imx_clk_hw_gate("pcc_dma2_ch26", "lpav_axi_div", base + 0x6c, 30);
+	clks[IMX8ULP_CLK_DMA2_CH27] = imx_clk_hw_gate("pcc_dma2_ch27", "lpav_axi_div", base + 0x70, 30);
+	clks[IMX8ULP_CLK_DMA2_CH28] = imx_clk_hw_gate("pcc_dma2_ch28", "lpav_axi_div", base + 0x74, 30);
+	clks[IMX8ULP_CLK_DMA2_CH29] = imx_clk_hw_gate("pcc_dma2_ch29", "lpav_axi_div", base + 0x78, 30);
+	clks[IMX8ULP_CLK_DMA2_CH30] = imx_clk_hw_gate("pcc_dma2_ch30", "lpav_axi_div", base + 0x7c, 30);
+	clks[IMX8ULP_CLK_DMA2_CH31] = imx_clk_hw_gate("pcc_dma2_ch31", "lpav_axi_div", base + 0x80, 30);
+
+	clks[IMX8ULP_CLK_AVD_SIM] = imx_clk_hw_gate("avd_sim", "lpav_bus_div", base + 0x94, 30);
+	clks[IMX8ULP_CLK_TPM8] = imx8ulp_clk_hw_composite("tpm8", pcc5_periph_bus_sels, ARRAY_SIZE(pcc5_periph_bus_sels), true, true, true, base + 0xa0, 1);
+	clks[IMX8ULP_CLK_MU2_B] = imx_clk_hw_gate("mu2_b", "lpav_bus_div", base + 0x84, 30);
+	clks[IMX8ULP_CLK_MU3_B] = imx_clk_hw_gate("mu3_b", "lpav_bus_div", base + 0x88, 30);
+	clks[IMX8ULP_CLK_SAI6] = imx8ulp_clk_hw_composite("sai6", lpav_bus_div, 1, false, false, true, base + 0xa4, 1);
+	clks[IMX8ULP_CLK_SAI7] = imx8ulp_clk_hw_composite("sai7", lpav_bus_div, 1, false, false, true, base + 0xa8, 1);
+	clks[IMX8ULP_CLK_SPDIF] = imx8ulp_clk_hw_composite("spdif", lpav_bus_div, 1, false, false, true, base + 0xac, 1);
+	clks[IMX8ULP_CLK_ISI] = imx8ulp_clk_hw_composite("isi", lpav_axi_div, 1, false, false, true, base + 0xb0, 1);
+	clks[IMX8ULP_CLK_CSI_REGS] = imx8ulp_clk_hw_composite("csi_regs", lpav_bus_div, 1, false, false, true, base + 0xb4, 1);
+	clks[IMX8ULP_CLK_CSI] = imx8ulp_clk_hw_composite("csi", pcc5_periph_plat_sels, ARRAY_SIZE(pcc5_periph_plat_sels), true, true, true, base + 0xbc, 1);
+	clks[IMX8ULP_CLK_DSI] = imx8ulp_clk_hw_composite("dsi", pcc5_periph_plat_sels, ARRAY_SIZE(pcc5_periph_plat_sels), true, true, true, base + 0xc0, 1);
+	clks[IMX8ULP_CLK_WDOG5] = imx8ulp_clk_hw_composite("wdog5", pcc5_periph_bus_sels, ARRAY_SIZE(pcc5_periph_bus_sels), true, true, true, base + 0xc8, 1);
+	clks[IMX8ULP_CLK_EPDC] = imx8ulp_clk_hw_composite("epdc", pcc5_periph_plat_sels, ARRAY_SIZE(pcc5_periph_plat_sels), true, true, true, base + 0xcc, 1);
+	clks[IMX8ULP_CLK_PXP] = imx8ulp_clk_hw_composite("pxp", lpav_axi_div, 1, false, false, true, base + 0xd0, 1);
+	clks[IMX8ULP_CLK_GPU2D] = imx8ulp_clk_hw_composite("gpu2d", pcc5_periph_plat_sels, ARRAY_SIZE(pcc5_periph_plat_sels), true, true, true, base + 0xf0, 1);
+	clks[IMX8ULP_CLK_GPU3D] = imx8ulp_clk_hw_composite("gpu3d", pcc5_periph_plat_sels, ARRAY_SIZE(pcc5_periph_plat_sels), true, true, true, base + 0xf4, 1);
+	clks[IMX8ULP_CLK_DC_NANO] = imx8ulp_clk_hw_composite("dc_nano", pcc5_periph_plat_sels, ARRAY_SIZE(pcc5_periph_plat_sels), true, true, true, base + 0xf8, 1);
+	clks[IMX8ULP_CLK_CSI_CLK_UI] = imx8ulp_clk_hw_composite("csi_clk_ui", pcc5_periph_plat_sels, ARRAY_SIZE(pcc5_periph_plat_sels), true, true, true, base + 0x10c, 1);
+	clks[IMX8ULP_CLK_CSI_CLK_ESC] = imx8ulp_clk_hw_composite("csi_clk_esc", pcc5_periph_plat_sels, ARRAY_SIZE(pcc5_periph_plat_sels), true, true, true, base + 0x110, 1);
+	clks[IMX8ULP_CLK_RGPIOD] = imx_clk_hw_gate("rgpiod", "lpav_axi_div", base + 0x114, 30);
+	clks[IMX8ULP_CLK_DSI_TX_ESC] = imx_clk_hw_fixed_factor("mipi_dsi_tx_esc", "dsi", 1, 4);
+
+	imx_check_clk_hws(clks, clk_data->num);
+
+	ret = devm_of_clk_add_hw_provider(dev, of_clk_hw_onecell_get, clk_data);
+	if (ret)
+		return ret;
+
+	/* register the pcc5 reset controller */
+	return imx8ulp_pcc_reset_init(pdev, base, pcc5_resets, ARRAY_SIZE(pcc5_resets));
+}
+
+static int imx8ulp_clk_probe(struct platform_device *pdev)
+{
+	int (*probe)(struct platform_device *pdev);
+
+	probe = of_device_get_match_data(&pdev->dev);
+
+	if (probe)
+		return probe(pdev);
+
+	return 0;
+}
+
+static const struct of_device_id imx8ulp_clk_dt_ids[] = {
+	{ .compatible = "fsl,imx8ulp-pcc3", .data = imx8ulp_clk_pcc3_init },
+	{ .compatible = "fsl,imx8ulp-pcc4", .data = imx8ulp_clk_pcc4_init },
+	{ .compatible = "fsl,imx8ulp-pcc5", .data = imx8ulp_clk_pcc5_init },
+	{ .compatible = "fsl,imx8ulp-cgc2", .data = imx8ulp_clk_cgc2_init },
+	{ .compatible = "fsl,imx8ulp-cgc1", .data = imx8ulp_clk_cgc1_init },
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, imx8ulp_clk_dt_ids);
+
+static struct platform_driver imx8ulp_clk_driver = {
+	.probe	= imx8ulp_clk_probe,
+	.driver = {
+		.name		= KBUILD_MODNAME,
+		.of_match_table	= imx8ulp_clk_dt_ids,
+	},
+};
+module_platform_driver(imx8ulp_clk_driver);
+
+MODULE_AUTHOR("Peng Fan <peng.fan@nxp.com>");
+MODULE_DESCRIPTION("NXP i.MX8ULP clock driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/clk/imx/clk-lpcg-scu.c b/drivers/clk/imx/clk-lpcg-scu.c
index dd5abd09f..42513c9b2 100644
--- a/drivers/clk/imx/clk-lpcg-scu.c
+++ b/drivers/clk/imx/clk-lpcg-scu.c
@@ -6,6 +6,7 @@
 
 #include <linux/bits.h>
 #include <linux/clk-provider.h>
+#include <linux/delay.h>
 #include <linux/err.h>
 #include <linux/io.h>
 #include <linux/slab.h>
@@ -41,6 +42,31 @@ struct clk_lpcg_scu {
 
 #define to_clk_lpcg_scu(_hw) container_of(_hw, struct clk_lpcg_scu, hw)
 
+/* e10858 -LPCG clock gating register synchronization errata */
+static void do_lpcg_workaround(u32 rate, void __iomem *reg, u32 val)
+{
+	writel(val, reg);
+
+	if (rate >= 24000000 || rate == 0) {
+		u32 reg1;
+
+		/*
+		 * The time taken to access the LPCG registers from the AP core
+		 * through the interconnect is longer than the minimum delay
+		 * of 4 clock cycles required by the errata.
+		 * Adding a readl will provide sufficient delay to prevent
+		 * back-to-back writes.
+		 */
+		reg1 = readl(reg);
+	} else {
+		/*
+		 * For clocks running below 24MHz, wait a minimum of
+		 * 4 clock cycles.
+		 */
+		ndelay(4 * (DIV_ROUND_UP(1000000000, rate)));
+	}
+}
+
 static int clk_lpcg_scu_enable(struct clk_hw *hw)
 {
 	struct clk_lpcg_scu *clk = to_clk_lpcg_scu(hw);
@@ -57,7 +83,8 @@ static int clk_lpcg_scu_enable(struct clk_hw *hw)
 		val |= CLK_GATE_SCU_LPCG_HW_SEL;
 
 	reg |= val << clk->bit_idx;
-	writel(reg, clk->reg);
+
+	do_lpcg_workaround(clk_hw_get_rate(hw), clk->reg, reg);
 
 	spin_unlock_irqrestore(&imx_lpcg_scu_lock, flags);
 
@@ -74,7 +101,7 @@ static void clk_lpcg_scu_disable(struct clk_hw *hw)
 
 	reg = readl_relaxed(clk->reg);
 	reg &= ~(CLK_GATE_SCU_LPCG_MASK << clk->bit_idx);
-	writel(reg, clk->reg);
+	do_lpcg_workaround(clk_hw_get_rate(hw), clk->reg, reg);
 
 	spin_unlock_irqrestore(&imx_lpcg_scu_lock, flags);
 }
@@ -135,6 +162,9 @@ static int __maybe_unused imx_clk_lpcg_scu_suspend(struct device *dev)
 {
 	struct clk_lpcg_scu *clk = dev_get_drvdata(dev);
 
+	if (!strncmp("hdmi_lpcg", clk_hw_get_name(&clk->hw), strlen("hdmi_lpcg")))
+		return 0;
+
 	clk->state = readl_relaxed(clk->reg);
 	dev_dbg(dev, "save lpcg state 0x%x\n", clk->state);
 
@@ -145,13 +175,16 @@ static int __maybe_unused imx_clk_lpcg_scu_resume(struct device *dev)
 {
 	struct clk_lpcg_scu *clk = dev_get_drvdata(dev);
 
+	if (!strncmp("hdmi_lpcg", clk_hw_get_name(&clk->hw), strlen("hdmi_lpcg")))
+		return 0;
+
 	/*
 	 * FIXME: Sometimes writes don't work unless the CPU issues
 	 * them twice
 	 */
 
 	writel(clk->state, clk->reg);
-	writel(clk->state, clk->reg);
+	do_lpcg_workaround(0, clk->reg, clk->state);
 	dev_dbg(dev, "restore lpcg state 0x%x\n", clk->state);
 
 	return 0;
diff --git a/drivers/clk/imx/clk-pfd.c b/drivers/clk/imx/clk-pfd.c
index 5d2a9a3be..6c39b8c5a 100644
--- a/drivers/clk/imx/clk-pfd.c
+++ b/drivers/clk/imx/clk-pfd.c
@@ -5,9 +5,11 @@
  */
 
 #include <linux/clk-provider.h>
+#include <linux/imx_sema4.h>
 #include <linux/io.h>
 #include <linux/slab.h>
 #include <linux/err.h>
+#include <soc/imx/src.h>
 #include "clk.h"
 
 /**
@@ -32,20 +34,57 @@ struct clk_pfd {
 #define CLR	0x8
 #define OTG	0xc
 
-static int clk_pfd_enable(struct clk_hw *hw)
+static void clk_pfd_do_hardware(struct clk_pfd *pfd, bool enable)
+{
+	if (enable)
+		writel_relaxed(1 << ((pfd->idx + 1) * 8 - 1), pfd->reg + CLR);
+	else
+		writel_relaxed(1 << ((pfd->idx + 1) * 8 - 1), pfd->reg + SET);
+}
+
+static void clk_pfd_do_shared_clks(struct clk_hw *hw, bool enable)
 {
 	struct clk_pfd *pfd = to_clk_pfd(hw);
 
-	writel_relaxed(1 << ((pfd->idx + 1) * 8 - 1), pfd->reg + CLR);
+	if (imx_src_is_m4_enabled() && clk_on_imx6sx()) {
+#ifdef CONFIG_SOC_IMX6SX
+		if (!amp_power_mutex || !shared_mem) {
+			if (enable)
+				clk_pfd_do_hardware(pfd, enable);
+			return;
+		}
+
+		imx_sema4_mutex_lock(amp_power_mutex);
+		if (shared_mem->ca9_valid != SHARED_MEM_MAGIC_NUMBER ||
+			shared_mem->cm4_valid != SHARED_MEM_MAGIC_NUMBER) {
+			imx_sema4_mutex_unlock(amp_power_mutex);
+			return;
+		}
+
+		if (!imx_update_shared_mem(hw, enable)) {
+			imx_sema4_mutex_unlock(amp_power_mutex);
+			return;
+		}
+
+		clk_pfd_do_hardware(pfd, enable);
+
+		imx_sema4_mutex_unlock(amp_power_mutex);
+#endif
+	} else {
+		clk_pfd_do_hardware(pfd, enable);
+	}
+}
+
+static int clk_pfd_enable(struct clk_hw *hw)
+{
+	clk_pfd_do_shared_clks(hw, true);
 
 	return 0;
 }
 
 static void clk_pfd_disable(struct clk_hw *hw)
 {
-	struct clk_pfd *pfd = to_clk_pfd(hw);
-
-	writel_relaxed(1 << ((pfd->idx + 1) * 8 - 1), pfd->reg + SET);
+	clk_pfd_do_shared_clks(hw, false);
 }
 
 static unsigned long clk_pfd_recalc_rate(struct clk_hw *hw,
diff --git a/drivers/clk/imx/clk-pfdv2.c b/drivers/clk/imx/clk-pfdv2.c
index 6b744c842..6ca53a960 100644
--- a/drivers/clk/imx/clk-pfdv2.c
+++ b/drivers/clk/imx/clk-pfdv2.c
@@ -161,8 +161,17 @@ static int clk_pfdv2_set_rate(struct clk_hw *hw, unsigned long rate,
 	if (!rate)
 		return -EINVAL;
 
-	/* PFD can NOT change rate without gating */
-	WARN_ON(clk_pfdv2_is_enabled(hw));
+	/*
+	 * PFD can NOT change rate without gating.
+	 * as the PFDs may enabled in HW by default but no
+	 * consumer used it, the enable count is '0', so the
+	 * 'SET_RATE_GATE' can NOT help on blocking the set_rate
+	 * ops especially for 'assigned-clock-xxx'. In order
+	 * to simplify the case, just disable the PFD if it is
+	 * enabled in HW but not in SW.
+	 */
+	if (clk_pfdv2_is_enabled(hw))
+		clk_pfdv2_disable(hw);
 
 	tmp = tmp * 18 + rate / 2;
 	do_div(tmp, rate);
@@ -191,8 +200,8 @@ static const struct clk_ops clk_pfdv2_ops = {
 	.is_enabled     = clk_pfdv2_is_enabled,
 };
 
-struct clk_hw *imx_clk_hw_pfdv2(const char *name, const char *parent_name,
-			     void __iomem *reg, u8 idx)
+struct clk_hw *imx_clk_hw_pfdv2(enum imx_pfdv2_type type, const char *name,
+			     const char *parent_name, void __iomem *reg, u8 idx)
 {
 	struct clk_init_data init;
 	struct clk_pfdv2 *pfd;
@@ -214,7 +223,10 @@ struct clk_hw *imx_clk_hw_pfdv2(const char *name, const char *parent_name,
 	init.ops = &clk_pfdv2_ops;
 	init.parent_names = &parent_name;
 	init.num_parents = 1;
-	init.flags = CLK_SET_RATE_GATE | CLK_SET_RATE_PARENT;
+	if (type == IMX_PFDV2_IMX7ULP)
+		init.flags = CLK_SET_RATE_GATE | CLK_SET_RATE_PARENT;
+	else
+		init.flags = CLK_SET_RATE_GATE;
 
 	pfd->hw.init = &init;
 
@@ -227,3 +239,4 @@ struct clk_hw *imx_clk_hw_pfdv2(const char *name, const char *parent_name,
 
 	return hw;
 }
+EXPORT_SYMBOL_GPL(imx_clk_hw_pfdv2);
diff --git a/drivers/clk/imx/clk-pll14xx.c b/drivers/clk/imx/clk-pll14xx.c
index 2b5ed86b9..1563a7bff 100644
--- a/drivers/clk/imx/clk-pll14xx.c
+++ b/drivers/clk/imx/clk-pll14xx.c
@@ -137,9 +137,12 @@ static unsigned long clk_pll1443x_recalc_rate(struct clk_hw *hw,
 						  unsigned long parent_rate)
 {
 	struct clk_pll14xx *pll = to_clk_pll14xx(hw);
+	const struct imx_pll14xx_rate_table *rate_table = pll->rate_table;
 	u32 mdiv, pdiv, sdiv, pll_div_ctl0, pll_div_ctl1;
 	short int kdiv;
 	u64 fvco = parent_rate;
+	long rate = 0;
+	int i;
 
 	pll_div_ctl0 = readl_relaxed(pll->base + 4);
 	pll_div_ctl1 = readl_relaxed(pll->base + 8);
@@ -148,13 +151,25 @@ static unsigned long clk_pll1443x_recalc_rate(struct clk_hw *hw,
 	sdiv = (pll_div_ctl0 & SDIV_MASK) >> SDIV_SHIFT;
 	kdiv = pll_div_ctl1 & KDIV_MASK;
 
+	/*
+	 * Sometimes, the recalculated rate has deviation due to
+	 * the frac part. So find the accurate pll rate from the table
+	 * first, if no match rate in the table, use the rate calculated
+	 * from the equation below.
+	 */
+	for (i = 0; i < pll->rate_count; i++) {
+		if (rate_table[i].pdiv == pdiv && rate_table[i].mdiv == mdiv &&
+		    rate_table[i].sdiv == sdiv && rate_table[i].kdiv == kdiv)
+			rate = rate_table[i].rate;
+	}
+
 	/* fvco = (m * 65536 + k) * Fin / (p * 65536) */
 	fvco *= (mdiv * 65536 + kdiv);
 	pdiv *= 65536;
 
 	do_div(fvco, pdiv << sdiv);
 
-	return fvco;
+	return rate ? (unsigned long) rate : (unsigned long)fvco;
 }
 
 static inline bool clk_pll14xx_mp_change(const struct imx_pll14xx_rate_table *rate,
@@ -360,6 +375,26 @@ static void clk_pll14xx_unprepare(struct clk_hw *hw)
 	writel_relaxed(val, pll->base + GNRL_CTL);
 }
 
+void clk_set_delta_k(struct clk_hw *hw, short int delta_k)
+{
+	struct clk_pll14xx *pll = to_clk_pll14xx(hw);
+	short int k;
+	u32 val;
+
+	val = readl_relaxed(pll->base + 8);
+	k = (val & KDIV_MASK) + delta_k;
+	writel_relaxed(k << KDIV_SHIFT, pll->base + 8);
+}
+
+void clk_get_pll_setting(struct clk_hw *hw, u32 *pll_div_ctrl0,
+	u32 *pll_div_ctrl1)
+{
+	struct clk_pll14xx *pll = to_clk_pll14xx(hw);
+
+	*pll_div_ctrl0 = readl_relaxed(pll->base + 4);
+	*pll_div_ctrl1 = readl_relaxed(pll->base + 8);
+}
+
 static const struct clk_ops clk_pll1416x_ops = {
 	.prepare	= clk_pll14xx_prepare,
 	.unprepare	= clk_pll14xx_unprepare,
diff --git a/drivers/clk/imx/clk-pllv3.c b/drivers/clk/imx/clk-pllv3.c
index 20ee9611b..5fd4765e6 100644
--- a/drivers/clk/imx/clk-pllv3.c
+++ b/drivers/clk/imx/clk-pllv3.c
@@ -8,9 +8,11 @@
 #include <linux/delay.h>
 #include <linux/io.h>
 #include <linux/iopoll.h>
+#include <linux/imx_sema4.h>
 #include <linux/slab.h>
 #include <linux/jiffies.h>
 #include <linux/err.h>
+#include <soc/imx/src.h>
 #include "clk.h"
 
 #define PLL_NUM_OFFSET		0x10
@@ -65,36 +67,82 @@ static int clk_pllv3_wait_lock(struct clk_pllv3 *pll)
 	if ((pll->powerup_set && !val) || (!pll->powerup_set && val))
 		return 0;
 
-	return readl_relaxed_poll_timeout(pll->base, val, val & BM_PLL_LOCK,
-					  500, PLL_LOCK_TIMEOUT);
+	if (!(imx_src_is_m4_enabled() && clk_on_imx6sx()))
+		return readl_relaxed_poll_timeout(pll->base, val, val & BM_PLL_LOCK,
+						  500, PLL_LOCK_TIMEOUT);
+	else
+		return readl_relaxed_poll_timeout_atomic(pll->base, val, val & BM_PLL_LOCK,
+						  10, PLL_LOCK_TIMEOUT);
 }
 
-static int clk_pllv3_prepare(struct clk_hw *hw)
+static int clk_pllv3_do_hardware(struct clk_hw *hw, bool enable)
 {
 	struct clk_pllv3 *pll = to_clk_pllv3(hw);
+	int ret;
 	u32 val;
 
 	val = readl_relaxed(pll->base);
-	if (pll->powerup_set)
-		val |= pll->power_bit;
-	else
-		val &= ~pll->power_bit;
-	writel_relaxed(val, pll->base);
+	if (enable) {
+		if (pll->powerup_set)
+			val |= pll->power_bit;
+		else
+			val &= ~pll->power_bit;
+		writel_relaxed(val, pll->base);
+
+		ret = clk_pllv3_wait_lock(pll);
+		if (ret)
+			return ret;
+	} else {
+		if (pll->powerup_set)
+			val &= ~pll->power_bit;
+		else
+			val |= pll->power_bit;
+		writel_relaxed(val, pll->base);
+	}
 
-	return clk_pllv3_wait_lock(pll);
+	return 0;
 }
 
-static void clk_pllv3_unprepare(struct clk_hw *hw)
+static void clk_pllv3_do_shared_clks(struct clk_hw *hw, bool enable)
 {
-	struct clk_pllv3 *pll = to_clk_pllv3(hw);
-	u32 val;
+	if (imx_src_is_m4_enabled() && clk_on_imx6sx()) {
+#ifdef CONFIG_SOC_IMX6SX
+		if (!amp_power_mutex || !shared_mem) {
+			if (enable)
+				clk_pllv3_do_hardware(hw, enable);
+			return;
+		}
+
+		imx_sema4_mutex_lock(amp_power_mutex);
+		if (shared_mem->ca9_valid != SHARED_MEM_MAGIC_NUMBER ||
+			shared_mem->cm4_valid != SHARED_MEM_MAGIC_NUMBER) {
+			imx_sema4_mutex_unlock(amp_power_mutex);
+			return;
+		}
+
+		if (!imx_update_shared_mem(hw, enable)) {
+			imx_sema4_mutex_unlock(amp_power_mutex);
+			return;
+		}
+		clk_pllv3_do_hardware(hw, enable);
+
+		imx_sema4_mutex_unlock(amp_power_mutex);
+#endif
+	} else {
+		clk_pllv3_do_hardware(hw, enable);
+	}
+}
 
-	val = readl_relaxed(pll->base);
-	if (pll->powerup_set)
-		val &= ~pll->power_bit;
-	else
-		val |= pll->power_bit;
-	writel_relaxed(val, pll->base);
+static int clk_pllv3_prepare(struct clk_hw *hw)
+{
+	clk_pllv3_do_shared_clks(hw, true);
+
+	return 0;
+}
+
+static void clk_pllv3_unprepare(struct clk_hw *hw)
+{
+	clk_pllv3_do_shared_clks(hw, false);
 }
 
 static int clk_pllv3_is_prepared(struct clk_hw *hw)
diff --git a/drivers/clk/imx/clk-pllv4.c b/drivers/clk/imx/clk-pllv4.c
index 8ec703f27..6e7e34571 100644
--- a/drivers/clk/imx/clk-pllv4.c
+++ b/drivers/clk/imx/clk-pllv4.c
@@ -23,14 +23,17 @@
 
 /* PLL Configuration Register (xPLLCFG) */
 #define PLL_CFG_OFFSET		0x08
+#define IMX8ULP_PLL_CFG_OFFSET	0x10
 #define BP_PLL_MULT		16
 #define BM_PLL_MULT		(0x7f << 16)
 
 /* PLL Numerator Register (xPLLNUM) */
 #define PLL_NUM_OFFSET		0x10
+#define IMX8ULP_PLL_NUM_OFFSET	0x1c
 
 /* PLL Denominator Register (xPLLDENOM) */
 #define PLL_DENOM_OFFSET	0x14
+#define IMX8ULP_PLL_DENOM_OFFSET	0x18
 
 #define MAX_MFD			0x3fffffff
 #define DEFAULT_MFD		1000000
@@ -38,6 +41,9 @@
 struct clk_pllv4 {
 	struct clk_hw	hw;
 	void __iomem	*base;
+	u32		cfg_offset;
+	u32		num_offset;
+	u32		denom_offset;
 };
 
 /* Valid PLL MULT Table */
@@ -72,12 +78,12 @@ static unsigned long clk_pllv4_recalc_rate(struct clk_hw *hw,
 	u32 mult, mfn, mfd;
 	u64 temp64;
 
-	mult = readl_relaxed(pll->base + PLL_CFG_OFFSET);
+	mult = readl_relaxed(pll->base + pll->cfg_offset);
 	mult &= BM_PLL_MULT;
 	mult >>= BP_PLL_MULT;
 
-	mfn = readl_relaxed(pll->base + PLL_NUM_OFFSET);
-	mfd = readl_relaxed(pll->base + PLL_DENOM_OFFSET);
+	mfn = readl_relaxed(pll->base + pll->num_offset);
+	mfd = readl_relaxed(pll->base + pll->denom_offset);
 	temp64 = parent_rate;
 	temp64 *= mfn;
 	do_div(temp64, mfd);
@@ -165,13 +171,13 @@ static int clk_pllv4_set_rate(struct clk_hw *hw, unsigned long rate,
 	do_div(temp64, parent_rate);
 	mfn = temp64;
 
-	val = readl_relaxed(pll->base + PLL_CFG_OFFSET);
+	val = readl_relaxed(pll->base + pll->cfg_offset);
 	val &= ~BM_PLL_MULT;
 	val |= mult << BP_PLL_MULT;
-	writel_relaxed(val, pll->base + PLL_CFG_OFFSET);
+	writel_relaxed(val, pll->base + pll->cfg_offset);
 
-	writel_relaxed(mfn, pll->base + PLL_NUM_OFFSET);
-	writel_relaxed(mfd, pll->base + PLL_DENOM_OFFSET);
+	writel_relaxed(mfn, pll->base + pll->num_offset);
+	writel_relaxed(mfd, pll->base + pll->denom_offset);
 
 	return 0;
 }
@@ -207,8 +213,8 @@ static const struct clk_ops clk_pllv4_ops = {
 	.is_prepared	= clk_pllv4_is_prepared,
 };
 
-struct clk_hw *imx_clk_hw_pllv4(const char *name, const char *parent_name,
-			  void __iomem *base)
+struct clk_hw *imx_clk_hw_pllv4(enum imx_pllv4_type type, const char *name,
+		 const char *parent_name, void __iomem *base)
 {
 	struct clk_pllv4 *pll;
 	struct clk_hw *hw;
@@ -221,6 +227,16 @@ struct clk_hw *imx_clk_hw_pllv4(const char *name, const char *parent_name,
 
 	pll->base = base;
 
+	if (type == IMX_PLLV4_IMX8ULP) {
+		pll->cfg_offset = IMX8ULP_PLL_CFG_OFFSET;
+		pll->num_offset = IMX8ULP_PLL_NUM_OFFSET;
+		pll->denom_offset = IMX8ULP_PLL_DENOM_OFFSET;
+	} else {
+		pll->cfg_offset = PLL_CFG_OFFSET;
+		pll->num_offset = PLL_NUM_OFFSET;
+		pll->denom_offset = PLL_DENOM_OFFSET;
+	}
+
 	init.name = name;
 	init.ops = &clk_pllv4_ops;
 	init.parent_names = &parent_name;
@@ -238,3 +254,4 @@ struct clk_hw *imx_clk_hw_pllv4(const char *name, const char *parent_name,
 
 	return hw;
 }
+EXPORT_SYMBOL_GPL(imx_clk_hw_pllv4);
diff --git a/drivers/clk/imx/clk-scu.c b/drivers/clk/imx/clk-scu.c
index 083da31dc..97eb44ea2 100644
--- a/drivers/clk/imx/clk-scu.c
+++ b/drivers/clk/imx/clk-scu.c
@@ -9,11 +9,13 @@
 #include <linux/bsearch.h>
 #include <linux/clk-provider.h>
 #include <linux/err.h>
+#include <linux/firmware/imx/svc/rm.h>
 #include <linux/of_platform.h>
 #include <linux/platform_device.h>
 #include <linux/pm_domain.h>
 #include <linux/pm_runtime.h>
 #include <linux/slab.h>
+#include <xen/xen.h>
 
 #include "clk-scu.h"
 
@@ -481,7 +483,7 @@ struct clk_hw *__imx_clk_scu(struct device *dev, const char *name,
 	 * clock status from HW instead of using the possible invalid
 	 * cached rate.
 	 */
-	init.flags = CLK_GET_RATE_NOCACHE;
+	init.flags = CLK_GET_RATE_NOCACHE | CLK_SET_PARENT_NOCACHE;
 	clk->hw.init = &init;
 
 	hw = &clk->hw;
@@ -577,6 +579,7 @@ static int __maybe_unused imx_clk_scu_suspend(struct device *dev)
 		clk->rate = clk_scu_recalc_rate(&clk->hw, 0);
 	else
 		clk->rate = clk_hw_get_rate(&clk->hw);
+
 	clk->is_enabled = clk_hw_is_enabled(&clk->hw);
 
 	if (clk->parent)
@@ -650,9 +653,34 @@ static int imx_clk_scu_attach_pd(struct device *dev, u32 rsrc_id)
 	    rsrc_id == IMX_SC_R_A72)
 		return 0;
 
+	/*
+	 * Temp fix to avoid the uart clk attached pd power off uart_0
+	 */
+	if (rsrc_id == IMX_SC_R_UART_0 && xen_initial_domain())
+			return 0;
+
 	return of_genpd_add_device(&genpdspec, dev);
 }
 
+static bool imx_clk_is_resource_owned(u32 rsrc)
+{
+	/*
+	 * A-core resources are special. SCFW reports they are not "owned" by
+	 * current partition but linux can still adjust them for cpufreq.
+	 *
+	 * So force this to return false when running as a VM guest and always
+	 * true otherwise.
+	 */
+	if (rsrc == IMX_SC_R_A53 || rsrc == IMX_SC_R_A72 ||
+	    rsrc == IMX_SC_R_A35) {
+		if (xen_domain() && !xen_initial_domain())
+			return false;
+		return true;
+	}
+
+	return imx_sc_rm_is_resource_owned(ccm_ipc_handle, rsrc);
+}
+
 struct clk_hw *imx_clk_scu_alloc_dev(const char *name,
 				     const char * const *parents,
 				     int num_parents, u32 rsrc_id, u8 clk_type)
@@ -670,6 +698,9 @@ struct clk_hw *imx_clk_scu_alloc_dev(const char *name,
 	if (!imx_scu_clk_is_valid(rsrc_id))
 		return ERR_PTR(-EINVAL);
 
+	if (!imx_clk_is_resource_owned(rsrc_id))
+		return NULL;
+
 	pdev = platform_device_alloc(name, PLATFORM_DEVID_NONE);
 	if (!pdev) {
 		pr_err("%s: failed to allocate scu clk dev rsrc %d type %d\n",
@@ -833,13 +864,13 @@ struct clk_hw *__imx_clk_gpr_scu(const char *name, const char * const *parent_na
 	if (rsrc_id >= IMX_SC_R_LAST || gpr_id >= IMX_SC_C_LAST)
 		return ERR_PTR(-EINVAL);
 
+	if (!imx_scu_clk_is_valid(rsrc_id))
+		return ERR_PTR(-EINVAL);
+
 	clk_node = kzalloc(sizeof(*clk_node), GFP_KERNEL);
 	if (!clk_node)
 		return ERR_PTR(-ENOMEM);
 
-	if (!imx_scu_clk_is_valid(rsrc_id))
-		return ERR_PTR(-EINVAL);
-
 	clk = kzalloc(sizeof(*clk), GFP_KERNEL);
 	if (!clk) {
 		kfree(clk_node);
diff --git a/drivers/clk/imx/clk-scu.h b/drivers/clk/imx/clk-scu.h
index 22156e93b..7d8069886 100644
--- a/drivers/clk/imx/clk-scu.h
+++ b/drivers/clk/imx/clk-scu.h
@@ -23,6 +23,7 @@ extern struct list_head imx_scu_clks[];
 extern const struct dev_pm_ops imx_clk_lpcg_scu_pm_ops;
 extern const struct imx_clk_scu_rsrc_table imx_clk_scu_rsrc_imx8qxp;
 extern const struct imx_clk_scu_rsrc_table imx_clk_scu_rsrc_imx8qm;
+extern const struct imx_clk_scu_rsrc_table imx_clk_scu_rsrc_imx8dxl;
 
 int imx_clk_scu_init(struct device_node *np,
 		     const struct imx_clk_scu_rsrc_table *data);
diff --git a/drivers/clk/imx/clk.c b/drivers/clk/imx/clk.c
index 7cc669934..c7e6020f6 100644
--- a/drivers/clk/imx/clk.c
+++ b/drivers/clk/imx/clk.c
@@ -17,6 +17,8 @@
 DEFINE_SPINLOCK(imx_ccm_lock);
 EXPORT_SYMBOL_GPL(imx_ccm_lock);
 
+bool uart_from_osc;
+
 void imx_unregister_clocks(struct clk *clks[], unsigned int count)
 {
 	unsigned int i;
@@ -194,6 +196,9 @@ void imx_register_uart_clocks(unsigned int clk_count)
 
 static int __init imx_clk_disable_uart(void)
 {
+	if (imx_src_is_m4_enabled())
+		return 0;
+
 	if (imx_keep_uart_clocks && imx_enabled_uart_clocks) {
 		int i;
 
@@ -207,6 +212,14 @@ static int __init imx_clk_disable_uart(void)
 	return 0;
 }
 late_initcall_sync(imx_clk_disable_uart);
+
+static int __init setup_uart_clk(char *uart_rate)
+{
+       uart_from_osc = true;
+       return 1;
+}
+__setup("uart_from_osc", setup_uart_clk);
+
 #endif
 
 MODULE_LICENSE("GPL v2");
diff --git a/drivers/clk/imx/clk.h b/drivers/clk/imx/clk.h
index fd362fbfe..69213778a 100644
--- a/drivers/clk/imx/clk.h
+++ b/drivers/clk/imx/clk.h
@@ -5,6 +5,7 @@
 #include <linux/bits.h>
 #include <linux/spinlock.h>
 #include <linux/clk-provider.h>
+#include <soc/imx/src.h>
 
 extern spinlock_t imx_ccm_lock;
 
@@ -22,6 +23,9 @@ void imx_unregister_clocks(struct clk *clks[], unsigned int count);
 void imx_unregister_hw_clocks(struct clk_hw *hws[], unsigned int count);
 
 extern void imx_cscmr1_fixup(u32 *val);
+extern struct imx_sema4_mutex *amp_power_mutex;
+extern struct imx_shared_mem *shared_mem;
+extern bool uart_from_osc;
 
 enum imx_pllv1_type {
 	IMX_PLLV1_IMX1,
@@ -42,6 +46,16 @@ enum imx_pll14xx_type {
 	PLL_1443X,
 };
 
+enum imx_pllv4_type {
+	IMX_PLLV4_IMX7ULP,
+	IMX_PLLV4_IMX8ULP,
+};
+
+enum imx_pfdv2_type {
+	IMX_PFDV2_IMX7ULP,
+	IMX_PFDV2_IMX8ULP,
+};
+
 /* NOTE: Rate table should be kept sorted in descending order. */
 struct imx_pll14xx_rate_table {
 	unsigned int rate;
@@ -192,6 +206,25 @@ enum imx_pllv3_type {
 	IMX_PLLV3_AV_IMX7,
 };
 
+#define MAX_SHARED_CLK_NUMBER		100
+#define SHARED_MEM_MAGIC_NUMBER		0x12345678
+#define MCC_POWER_SHMEM_NUMBER		(6)
+
+struct imx_shared_clk {
+	struct clk *self;
+	struct clk *parent;
+	void *m4_clk;
+	void *m4_clk_parent;
+	u8 ca9_enabled;
+	u8 cm4_enabled;
+};
+
+struct imx_shared_mem {
+	u32 ca9_valid;
+	u32 cm4_valid;
+	struct imx_shared_clk imx_clk[MAX_SHARED_CLK_NUMBER];
+};
+
 struct clk_hw *imx_clk_hw_pllv3(enum imx_pllv3_type type, const char *name,
 		const char *parent_name, void __iomem *base, u32 div_mask);
 
@@ -212,8 +245,8 @@ struct clk_hw *imx_clk_hw_pllv3(enum imx_pllv3_type type, const char *name,
 		.kdiv	=	(_k),			\
 	}
 
-struct clk_hw *imx_clk_hw_pllv4(const char *name, const char *parent_name,
-			     void __iomem *base);
+struct clk_hw *imx_clk_hw_pllv4(enum imx_pllv4_type type, const char *name,
+		const char *parent_name, void __iomem *base);
 
 struct clk_hw *clk_hw_register_gate2(struct device *dev, const char *name,
 		const char *parent_name, unsigned long flags,
@@ -236,8 +269,8 @@ struct clk_hw *imx_clk_hw_gate_exclusive(const char *name, const char *parent,
 struct clk_hw *imx_clk_hw_pfd(const char *name, const char *parent_name,
 		void __iomem *reg, u8 idx);
 
-struct clk_hw *imx_clk_hw_pfdv2(const char *name, const char *parent_name,
-			     void __iomem *reg, u8 idx);
+struct clk_hw *imx_clk_hw_pfdv2(enum imx_pfdv2_type type, const char *name,
+	 const char *parent_name, void __iomem *reg, u8 idx);
 
 struct clk_hw *imx_clk_hw_busy_divider(const char *name, const char *parent_name,
 				 void __iomem *reg, u8 shift, u8 width,
@@ -247,12 +280,25 @@ struct clk_hw *imx_clk_hw_busy_mux(const char *name, void __iomem *reg, u8 shift
 			     u8 width, void __iomem *busy_reg, u8 busy_shift,
 			     const char * const *parent_names, int num_parents);
 
+int imx_update_shared_mem(struct clk_hw *hw, bool enable);
+
+static inline int clk_on_imx6sx(void)
+{
+	return of_machine_is_compatible("fsl,imx6sx");
+}
+
 struct clk_hw *imx7ulp_clk_hw_composite(const char *name,
 				     const char * const *parent_names,
 				     int num_parents, bool mux_present,
 				     bool rate_present, bool gate_present,
 				     void __iomem *reg);
 
+struct clk_hw *imx8ulp_clk_hw_composite(const char *name,
+				     const char * const *parent_names,
+				     int num_parents, bool mux_present,
+				     bool rate_present, bool gate_present,
+				     void __iomem *reg, bool has_swrst);
+
 struct clk_hw *imx_clk_hw_fixup_divider(const char *name, const char *parent,
 				  void __iomem *reg, u8 shift, u8 width,
 				  void (*fixup)(u32 *val));
@@ -305,6 +351,15 @@ static inline struct clk_hw *imx_clk_hw_divider(const char *name,
 				       reg, shift, width, 0, &imx_ccm_lock);
 }
 
+static inline struct clk_hw *imx_clk_hw_divider_closest(const char *name,
+						const char *parent,
+						void __iomem *reg, u8 shift,
+						u8 width)
+{
+	return clk_hw_register_divider(NULL, name, parent, 0,
+				       reg, shift, width, CLK_DIVIDER_ROUND_CLOSEST, &imx_ccm_lock);
+}
+
 static inline struct clk_hw *imx_clk_hw_divider_flags(const char *name,
 						   const char *parent,
 						   void __iomem *reg, u8 shift,
@@ -402,7 +457,7 @@ static inline struct clk_hw *imx_dev_clk_hw_gate_shared(struct device *dev,
 				void __iomem *reg, u8 shift,
 				unsigned int *share_count)
 {
-	return clk_hw_register_gate2(NULL, name, parent, CLK_SET_RATE_PARENT |
+	return clk_hw_register_gate2(dev, name, parent, CLK_SET_RATE_PARENT |
 					CLK_OPS_PARENT_ENABLE, reg, shift, 0x1,
 					0x1, 0, &imx_ccm_lock, share_count);
 }
@@ -417,7 +472,17 @@ static inline struct clk *imx_clk_gate2_cgr(const char *name,
 static inline struct clk_hw *imx_clk_hw_gate3(const char *name, const char *parent,
 		void __iomem *reg, u8 shift)
 {
-	return clk_hw_register_gate(NULL, name, parent,
+	/*
+	 * per design team's suggestion, clk root is NOT consuming
+	 * much power, and clk root enable/disable does NOT have domain
+	 * control, so they suggest to leave clk root always on when
+	 * M4 is enabled.
+	 */
+	if (imx_src_is_m4_enabled())
+		return clk_hw_register_fixed_factor(NULL, name, parent,
+						 CLK_SET_RATE_PARENT, 1, 1);
+	else
+		return clk_hw_register_gate(NULL, name, parent,
 			CLK_SET_RATE_PARENT | CLK_OPS_PARENT_ENABLE,
 			reg, shift, 0, &imx_ccm_lock);
 }
@@ -472,6 +537,15 @@ static inline struct clk_hw *imx_dev_clk_hw_mux(struct device *dev,
 			reg, shift, width, 0, &imx_ccm_lock);
 }
 
+static inline struct clk *imx_dev_clk_mux(struct device *dev, const char *name,
+			void __iomem *reg, u8 shift, u8 width,
+			const char * const *parents, int num_parents)
+{
+	return clk_register_mux(dev, name, parents, num_parents,
+			CLK_SET_RATE_NO_REPARENT | CLK_SET_PARENT_GATE,
+			reg, shift, width, 0, &imx_ccm_lock);
+}
+
 static inline struct clk *imx_clk_mux2(const char *name, void __iomem *reg,
 			u8 shift, u8 width, const char * const *parents,
 			int num_parents)
@@ -628,4 +702,7 @@ struct clk_hw *imx_clk_hw_divider_gate(const char *name, const char *parent_name
 		unsigned long flags, void __iomem *reg, u8 shift, u8 width,
 		u8 clk_divider_flags, const struct clk_div_table *table,
 		spinlock_t *lock);
+
+void clk_set_delta_k(struct clk_hw *hw, short int delta_k);
+void clk_get_pll_setting(struct clk_hw *hw, u32 *pll_div_ctrl0, u32 *pll_div_ctrl1);
 #endif
diff --git a/drivers/firmware/imx/imx-scu-irq.c b/drivers/firmware/imx/imx-scu-irq.c
index d9dcc2094..6ce53c1ff 100644
--- a/drivers/firmware/imx/imx-scu-irq.c
+++ b/drivers/firmware/imx/imx-scu-irq.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0+
 /*
- * Copyright 2019 NXP
+ * Copyright 2019-2020 NXP
  *
  * Implementation of the SCU IRQ functions using MU.
  *
@@ -11,10 +11,11 @@
 #include <linux/firmware/imx/sci.h>
 #include <linux/mailbox_client.h>
 #include <linux/suspend.h>
+#include <linux/sysfs.h>
+#include <linux/kobject.h>
 
 #define IMX_SC_IRQ_FUNC_ENABLE	1
 #define IMX_SC_IRQ_FUNC_STATUS	2
-#define IMX_SC_IRQ_NUM_GROUP	4
 
 static u32 mu_resource_id;
 
@@ -40,63 +41,100 @@ struct imx_sc_msg_irq_enable {
 	u8 enable;
 } __packed;
 
+struct scu_wakeup {
+	u32 mask;
+	u32 wakeup_src;
+	bool valid;
+};
+
+/* Sysfs functions */
+struct kobject *wakeup_obj;
+static ssize_t wakeup_source_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf);
+static struct kobj_attribute wakeup_source_attr = __ATTR(wakeup_src, 0660, wakeup_source_show, NULL);
+
+static struct scu_wakeup scu_irq_wakeup[IMX_SC_IRQ_NUM_GROUP];
+
+
 static struct imx_sc_ipc *imx_sc_irq_ipc_handle;
 static struct work_struct imx_sc_irq_work;
-static ATOMIC_NOTIFIER_HEAD(imx_scu_irq_notifier_chain);
+static BLOCKING_NOTIFIER_HEAD(imx_scu_irq_notifier_chain);
 
 int imx_scu_irq_register_notifier(struct notifier_block *nb)
 {
-	return atomic_notifier_chain_register(
+	return blocking_notifier_chain_register(
 		&imx_scu_irq_notifier_chain, nb);
 }
 EXPORT_SYMBOL(imx_scu_irq_register_notifier);
 
 int imx_scu_irq_unregister_notifier(struct notifier_block *nb)
 {
-	return atomic_notifier_chain_unregister(
+	return blocking_notifier_chain_unregister(
 		&imx_scu_irq_notifier_chain, nb);
 }
 EXPORT_SYMBOL(imx_scu_irq_unregister_notifier);
 
 static int imx_scu_irq_notifier_call_chain(unsigned long status, u8 *group)
 {
-	return atomic_notifier_call_chain(&imx_scu_irq_notifier_chain,
+	return blocking_notifier_call_chain(&imx_scu_irq_notifier_chain,
 		status, (void *)group);
 }
 
 static void imx_scu_irq_work_handler(struct work_struct *work)
 {
-	struct imx_sc_msg_irq_get_status msg;
-	struct imx_sc_rpc_msg *hdr = &msg.hdr;
 	u32 irq_status;
 	int ret;
 	u8 i;
 
 	for (i = 0; i < IMX_SC_IRQ_NUM_GROUP; i++) {
-		hdr->ver = IMX_SC_RPC_VERSION;
-		hdr->svc = IMX_SC_RPC_SVC_IRQ;
-		hdr->func = IMX_SC_IRQ_FUNC_STATUS;
-		hdr->size = 2;
-
-		msg.data.req.resource = mu_resource_id;
-		msg.data.req.group = i;
-
-		ret = imx_scu_call_rpc(imx_sc_irq_ipc_handle, &msg, true);
+		if (scu_irq_wakeup[i].mask) {
+			scu_irq_wakeup[i].valid = false;
+			scu_irq_wakeup[i].wakeup_src = 0;
+		}
+		ret = imx_scu_irq_get_status(i, &irq_status);
 		if (ret) {
 			pr_err("get irq group %d status failed, ret %d\n",
 			       i, ret);
 			return;
 		}
 
-		irq_status = msg.data.resp.status;
 		if (!irq_status)
 			continue;
-
+		if (scu_irq_wakeup[i].mask & irq_status) {
+			scu_irq_wakeup[i].valid = true;
+			scu_irq_wakeup[i].wakeup_src = irq_status & scu_irq_wakeup[i].mask;
+		} else {
+			scu_irq_wakeup[i].wakeup_src = irq_status;
+		}
 		pm_system_wakeup();
 		imx_scu_irq_notifier_call_chain(irq_status, &i);
 	}
 }
 
+int imx_scu_irq_get_status(u8 group, u32 *irq_status)
+{
+	struct imx_sc_msg_irq_get_status msg;
+	struct imx_sc_rpc_msg *hdr = &msg.hdr;
+	int ret;
+
+	hdr->ver = IMX_SC_RPC_VERSION;
+	hdr->svc = IMX_SC_RPC_SVC_IRQ;
+	hdr->func = IMX_SC_IRQ_FUNC_STATUS;
+	hdr->size = 2;
+
+	msg.data.req.resource = mu_resource_id;
+	msg.data.req.group = group;
+
+	ret = imx_scu_call_rpc(imx_sc_irq_ipc_handle, &msg, true);
+	if (ret)
+		return ret;
+
+	if (irq_status)
+		*irq_status = msg.data.resp.status;
+
+	return 0;
+}
+EXPORT_SYMBOL(imx_scu_irq_get_status);
+
 int imx_scu_irq_group_enable(u8 group, u32 mask, u8 enable)
 {
 	struct imx_sc_msg_irq_enable msg;
@@ -121,6 +159,11 @@ int imx_scu_irq_group_enable(u8 group, u32 mask, u8 enable)
 		pr_err("enable irq failed, group %d, mask %d, ret %d\n",
 			group, mask, ret);
 
+	if (enable)
+		scu_irq_wakeup[group].mask |= mask;
+	else
+		scu_irq_wakeup[group].mask &= ~mask;
+
 	return ret;
 }
 EXPORT_SYMBOL(imx_scu_irq_group_enable);
@@ -130,6 +173,24 @@ static void imx_scu_irq_callback(struct mbox_client *c, void *msg)
 	schedule_work(&imx_sc_irq_work);
 }
 
+static ssize_t wakeup_source_show(struct kobject *kobj,
+					struct kobj_attribute *attr, char *buf)
+{
+	u8 i = 0, size = 0;
+
+	for (i = 0; i < IMX_SC_IRQ_NUM_GROUP; i++) {
+		if (scu_irq_wakeup[i].wakeup_src != 0) {
+			if (scu_irq_wakeup[i].valid)
+				size += sprintf(buf + size, "Wakeup source group = %d, irq = 0x%x\n",
+							i, scu_irq_wakeup[i].wakeup_src);
+			else
+				size += sprintf(buf + size, "Spurious SCU wakeup, group = %d, irq = 0x%x\n",
+							i, scu_irq_wakeup[i].wakeup_src);
+		}
+	}
+	return strlen(buf);
+}
+
 int imx_scu_enable_general_irq_channel(struct device *dev)
 {
 	struct of_phandle_args spec;
@@ -169,6 +230,15 @@ int imx_scu_enable_general_irq_channel(struct device *dev)
 
 	mu_resource_id = IMX_SC_R_MU_0A + i;
 
+	/* Create directory under /sysfs/firmware */
+	wakeup_obj = kobject_create_and_add("scu_wakeup_source", firmware_kobj);
+
+	if (sysfs_create_file(wakeup_obj, &wakeup_source_attr.attr)) {
+		pr_err("Cannot create sysfs file......\n");
+		kobject_put(wakeup_obj);
+		sysfs_remove_file(firmware_kobj, &wakeup_source_attr.attr);
+	}
+
 	return ret;
 }
 EXPORT_SYMBOL(imx_scu_enable_general_irq_channel);
diff --git a/drivers/firmware/imx/scu-pd.c b/drivers/firmware/imx/scu-pd.c
index ff6569c4a..fbef30aa4 100644
--- a/drivers/firmware/imx/scu-pd.c
+++ b/drivers/firmware/imx/scu-pd.c
@@ -1,7 +1,7 @@
 // SPDX-License-Identifier: GPL-2.0+
 /*
  * Copyright (C) 2016 Freescale Semiconductor, Inc.
- * Copyright 2017-2018 NXP
+ * Copyright 2017-2018,2020 NXP
  *	Dong Aisheng <aisheng.dong@nxp.com>
  *
  * Implementation of the SCU based Power Domains
@@ -51,10 +51,13 @@
  *
  */
 
+#include <linux/arm-smccc.h>
 #include <dt-bindings/firmware/imx/rsrc.h>
+#include <linux/console.h>
 #include <linux/firmware/imx/sci.h>
 #include <linux/firmware/imx/svc/rm.h>
 #include <linux/io.h>
+#include <linux/irqchip/arm-gic-v3.h>
 #include <linux/module.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
@@ -63,6 +66,17 @@
 #include <linux/pm.h>
 #include <linux/pm_domain.h>
 #include <linux/slab.h>
+#include <linux/syscore_ops.h>
+
+#define IMX_WU_MAX_IRQS	(((IMX_SC_R_LAST + 31) / 32 ) * 32 )
+
+#define IMX_SIP_WAKEUP_SRC              0xc2000009
+#define IMX_SIP_WAKEUP_SRC_SCU          0x1
+#define IMX_SIP_WAKEUP_SRC_IRQSTEER     0x2
+
+static u32 wu[IMX_WU_MAX_IRQS];
+static int wu_num;
+static void __iomem *gic_dist_base;
 
 /* SCU Power Mode Protocol definition */
 struct imx_sc_msg_req_set_resource_power_mode {
@@ -108,24 +122,29 @@ static const struct imx_sc_pd_range imx8qxp_scu_pd_ranges[] = {
 	/* CONN SS */
 	{ "usb", IMX_SC_R_USB_0, 2, true, 0 },
 	{ "usb0phy", IMX_SC_R_USB_0_PHY, 1, false, 0 },
+	{ "usb1phy", IMX_SC_R_USB_1_PHY, 1, false, 0},
 	{ "usb2", IMX_SC_R_USB_2, 1, false, 0 },
 	{ "usb2phy", IMX_SC_R_USB_2_PHY, 1, false, 0 },
 	{ "sdhc", IMX_SC_R_SDHC_0, 3, true, 0 },
 	{ "enet", IMX_SC_R_ENET_0, 2, true, 0 },
 	{ "nand", IMX_SC_R_NAND, 1, false, 0 },
-	{ "mlb", IMX_SC_R_MLB_0, 1, true, 0 },
 
 	/* AUDIO SS */
 	{ "audio-pll0", IMX_SC_R_AUDIO_PLL_0, 1, false, 0 },
 	{ "audio-pll1", IMX_SC_R_AUDIO_PLL_1, 1, false, 0 },
 	{ "audio-clk-0", IMX_SC_R_AUDIO_CLK_0, 1, false, 0 },
 	{ "audio-clk-1", IMX_SC_R_AUDIO_CLK_1, 1, false, 0 },
-	{ "dma0-ch", IMX_SC_R_DMA_0_CH0, 16, true, 0 },
+	{ "mclk-out-0", IMX_SC_R_MCLK_OUT_0, 1, false, 0 },
+	{ "mclk-out-1", IMX_SC_R_MCLK_OUT_1, 1, false, 0 },
+	{ "dma0-ch", IMX_SC_R_DMA_0_CH0, 32, true, 0 },
 	{ "dma1-ch", IMX_SC_R_DMA_1_CH0, 16, true, 0 },
-	{ "dma2-ch", IMX_SC_R_DMA_2_CH0, 5, true, 0 },
+	{ "dma2-ch-0", IMX_SC_R_DMA_2_CH0, 5, true, 0 },
+	{ "dma2-ch-1", IMX_SC_R_DMA_2_CH5, 27, true, 0 },
+	{ "dma3-ch", IMX_SC_R_DMA_3_CH0, 32, true, 0 },
 	{ "asrc0", IMX_SC_R_ASRC_0, 1, false, 0 },
 	{ "asrc1", IMX_SC_R_ASRC_1, 1, false, 0 },
 	{ "esai0", IMX_SC_R_ESAI_0, 1, false, 0 },
+	{ "esai1", IMX_SC_R_ESAI_1, 1, false, 0 },
 	{ "spdif0", IMX_SC_R_SPDIF_0, 1, false, 0 },
 	{ "spdif1", IMX_SC_R_SPDIF_1, 1, false, 0 },
 	{ "sai", IMX_SC_R_SAI_0, 3, true, 0 },
@@ -142,11 +161,13 @@ static const struct imx_sc_pd_range imx8qxp_scu_pd_ranges[] = {
 	/* DMA SS */
 	{ "can", IMX_SC_R_CAN_0, 3, true, 0 },
 	{ "ftm", IMX_SC_R_FTM_0, 2, true, 0 },
-	{ "lpi2c", IMX_SC_R_I2C_0, 4, true, 0 },
+	{ "lpi2c", IMX_SC_R_I2C_0, 5, true, 0 },
 	{ "adc", IMX_SC_R_ADC_0, 2, true, 0 },
 	{ "lcd", IMX_SC_R_LCD_0, 1, true, 0 },
+	{ "lcd-pll", IMX_SC_R_ELCDIF_PLL, 1, true, 0 },
 	{ "lcd0-pwm", IMX_SC_R_LCD_0_PWM_0, 1, true, 0 },
-	{ "lpuart", IMX_SC_R_UART_0, 4, true, 0 },
+	{ "lpuart", IMX_SC_R_UART_0, 5, true, 0 },
+	{ "sim", IMX_SC_R_EMVSIM_0, 2, true, 0 },
 	{ "lpspi", IMX_SC_R_SPI_0, 4, true, 0 },
 	{ "irqstr_dsp", IMX_SC_R_IRQSTR_DSP, 1, false, 0 },
 
@@ -155,13 +176,22 @@ static const struct imx_sc_pd_range imx8qxp_scu_pd_ranges[] = {
 	{ "vpu-pid", IMX_SC_R_VPU_PID0, 8, true, 0 },
 	{ "vpu-dec0", IMX_SC_R_VPU_DEC_0, 1, false, 0 },
 	{ "vpu-enc0", IMX_SC_R_VPU_ENC_0, 1, false, 0 },
+	{ "vpu-enc1", IMX_SC_R_VPU_ENC_1, 1, false, 0 },
+	{ "vpu-mu0", IMX_SC_R_VPU_MU_0, 1, false, 0 },
+	{ "vpu-mu1", IMX_SC_R_VPU_MU_1, 1, false, 0 },
+	{ "vpu-mu2", IMX_SC_R_VPU_MU_2, 1, false, 0 },
 
 	/* GPU SS */
 	{ "gpu0-pid", IMX_SC_R_GPU_0_PID0, 4, true, 0 },
+	{ "gpu1-pid", IMX_SC_R_GPU_1_PID0, 4, true, 0 },
+
 
 	/* HSIO SS */
+	{ "pcie-a", IMX_SC_R_PCIE_A, 1, false, 0 },
+	{ "serdes-0", IMX_SC_R_SERDES_0, 1, false, 0 },
 	{ "pcie-b", IMX_SC_R_PCIE_B, 1, false, 0 },
 	{ "serdes-1", IMX_SC_R_SERDES_1, 1, false, 0 },
+	{ "sata-0", IMX_SC_R_SATA_0, 1, false, 0 },
 	{ "hsio-gpio", IMX_SC_R_HSIO_GPIO, 1, false, 0 },
 
 	/* MIPI SS */
@@ -175,13 +205,26 @@ static const struct imx_sc_pd_range imx8qxp_scu_pd_ranges[] = {
 
 	/* LVDS SS */
 	{ "lvds0", IMX_SC_R_LVDS_0, 1, false, 0 },
+	{ "lvds0-pwm", IMX_SC_R_LVDS_0_PWM_0, 1, false, 0 },
+	{ "lvds0-lpi2c", IMX_SC_R_LVDS_0_I2C_0, 2, true, 0 },
 	{ "lvds1", IMX_SC_R_LVDS_1, 1, false, 0 },
+	{ "lvds1-pwm", IMX_SC_R_LVDS_1_PWM_0, 1, false, 0 },
+	{ "lvds1-lpi2c", IMX_SC_R_LVDS_1_I2C_0, 2, true, 0 },
+
+	{ "mipi1", IMX_SC_R_MIPI_1, 1, 0 },
+	{ "mipi1-pwm0", IMX_SC_R_MIPI_1_PWM_0, 1, 0 },
+	{ "mipi1-i2c", IMX_SC_R_MIPI_1_I2C_0, 2, 1 },
+	{ "lvds1", IMX_SC_R_LVDS_1, 1, 0 },
 
 	/* DC SS */
 	{ "dc0", IMX_SC_R_DC_0, 1, false, 0 },
 	{ "dc0-pll", IMX_SC_R_DC_0_PLL_0, 2, true, 0 },
 	{ "dc0-video", IMX_SC_R_DC_0_VIDEO0, 2, true, 0 },
 
+	{ "dc1", IMX_SC_R_DC_1, 1, false, 0 },
+	{ "dc1-pll", IMX_SC_R_DC_1_PLL_0, 2, true, 0 },
+	{ "dc1-video", IMX_SC_R_DC_1_VIDEO0, 2, true, 0 },
+
 	/* CM40 SS */
 	{ "cm40-i2c", IMX_SC_R_M4_0_I2C, 1, false, 0 },
 	{ "cm40-intmux", IMX_SC_R_M4_0_INTMUX, 1, false, 0 },
@@ -196,11 +239,56 @@ static const struct imx_sc_pd_range imx8qxp_scu_pd_ranges[] = {
 	{ "cm41-mu-a1", IMX_SC_R_M4_1_MU_1A, 1, false, 0},
 	{ "cm41-lpuart", IMX_SC_R_M4_1_UART, 1, false, 0},
 
+	/* CM41 SS */
+	{ "cm41_i2c", IMX_SC_R_M4_1_I2C, 1, false, 0 },
+	{ "cm41_intmux", IMX_SC_R_M4_1_INTMUX, 1, false, 0 },
+
+	/* DB SS */
+	{ "perf", IMX_SC_R_PERF, 1, false, 0},
+
 	/* IMAGE SS */
 	{ "img-jpegdec-mp", IMX_SC_R_MJPEG_DEC_MP, 1, false, 0 },
 	{ "img-jpegdec-s0", IMX_SC_R_MJPEG_DEC_S0, 4, true, 0 },
 	{ "img-jpegenc-mp", IMX_SC_R_MJPEG_ENC_MP, 1, false, 0 },
 	{ "img-jpegenc-s0", IMX_SC_R_MJPEG_ENC_S0, 4, true, 0 },
+
+	/* SECO SS */
+	{ "seco_mu", IMX_SC_R_SECO_MU_2, 3, true, 2},
+
+	/* V2X SS */
+	{ "v2x_mu", IMX_SC_R_V2X_MU_0, 2, true, 0},
+	{ "v2x_mu", IMX_SC_R_V2X_MU_2, 1, true, 2},
+	{ "v2x_mu", IMX_SC_R_V2X_MU_3, 2, true, 3},
+	{ "img-pdma", IMX_SC_R_ISI_CH0, 8, true, 0 },
+	{ "img-csi0", IMX_SC_R_CSI_0, 1, false, 0 },
+	{ "img-csi0-i2c0", IMX_SC_R_CSI_0_I2C_0, 1, false, 0 },
+	{ "img-csi0-pwm0", IMX_SC_R_CSI_0_PWM_0, 1, false, 0 },
+	{ "img-csi1", IMX_SC_R_CSI_1, 1, false, 0 },
+	{ "img-csi1-i2c0", IMX_SC_R_CSI_1_I2C_0, 1, false, 0 },
+	{ "img-csi1-pwm0", IMX_SC_R_CSI_1_PWM_0, 1, false, 0 },
+	{ "img-parallel", IMX_SC_R_PI_0, 1, false, 0 },
+	{ "img-parallel-i2c0", IMX_SC_R_PI_0_I2C_0, 1, false, 0 },
+	{ "img-parallel-pwm0", IMX_SC_R_PI_0_PWM_0, 2, true, 0 },
+	{ "img-parallel-pll", IMX_SC_R_PI_0_PLL, 1, false, 0 },
+
+	/* HDMI TX SS */
+	{ "hdmi-tx", IMX_SC_R_HDMI, 1, false, 0},
+	{ "hdmi-tx-i2s", IMX_SC_R_HDMI_I2S, 1, false, 0},
+	{ "hdmi-tx-i2c0", IMX_SC_R_HDMI_I2C_0, 1, false, 0},
+	{ "hdmi-tx-pll0", IMX_SC_R_HDMI_PLL_0, 1, false, 0},
+	{ "hdmi-tx-pll1", IMX_SC_R_HDMI_PLL_1, 1, false, 0},
+
+	/* HDMI RX SS */
+	{ "hdmi-rx", IMX_SC_R_HDMI_RX, 1, false, 0},
+	{ "hdmi-rx-pwm", IMX_SC_R_HDMI_RX_PWM_0, 1, false, 0},
+	{ "hdmi-rx-i2c0", IMX_SC_R_HDMI_RX_I2C_0, 1, false, 0},
+	{ "hdmi-rx-bypass", IMX_SC_R_HDMI_RX_BYPASS, 1, false, 0},
+
+	/* SECURITY SS */
+	{ "sec-jr", IMX_SC_R_CAAM_JR2, 2, true, 2},
+
+	/* BOARD SS */
+	{ "board", IMX_SC_R_BOARD_R0, 8, true, 0},
 };
 
 static const struct imx_sc_pd_soc imx8qxp_scu_pd = {
@@ -216,6 +304,56 @@ to_imx_sc_pd(struct generic_pm_domain *genpd)
 	return container_of(genpd, struct imx_sc_pm_domain, pd);
 }
 
+static int imx_pm_domains_suspend(void)
+{
+	struct arm_smccc_res res;
+	u32 offset;
+	int i;
+
+	for (i = 0; i < wu_num; i++) {
+		offset = GICD_ISENABLER + ((wu[i] + 32) / 32) * 4;
+		if (BIT(wu[i] % 32) & readl_relaxed(gic_dist_base + offset)) {
+			arm_smccc_smc(IMX_SIP_WAKEUP_SRC,
+				      IMX_SIP_WAKEUP_SRC_IRQSTEER,
+				      0, 0, 0, 0, 0, 0, &res);
+			return 0;
+		}
+	}
+
+	arm_smccc_smc(IMX_SIP_WAKEUP_SRC,
+		      IMX_SIP_WAKEUP_SRC_SCU,
+		      0, 0, 0, 0, 0, 0, &res);
+
+	return 0;
+}
+
+struct syscore_ops imx_pm_domains_syscore_ops = {
+	.suspend = imx_pm_domains_suspend,
+};
+
+static void imx_sc_pd_enable_irqsteer_wakeup(struct device_node *np)
+{
+	struct device_node *gic_node;
+	unsigned int i;
+
+	wu_num = of_property_count_u32_elems(np, "wakeup-irq");
+	if (wu_num <= 0) {
+		pr_warn("no irqsteer wakeup source supported!\n");
+		return;
+	}
+
+	gic_node = of_find_compatible_node(NULL, NULL, "arm,gic-v3");
+	WARN_ON(!gic_node);
+
+	gic_dist_base = of_iomap(gic_node, 0);
+	WARN_ON(!gic_dist_base);
+
+	for (i = 0; i < wu_num; i++)
+		WARN_ON(of_property_read_u32_index(np, "wakeup-irq", i, &wu[i]));
+
+	register_syscore_ops(&imx_pm_domains_syscore_ops);
+}
+
 static void imx_sc_pd_get_console_rsrc(void)
 {
 	struct of_phandle_args specs;
@@ -248,9 +386,20 @@ static int imx_sc_pd_power(struct generic_pm_domain *domain, bool power_on)
 	hdr->size = 2;
 
 	msg.resource = pd->rsrc;
-	msg.mode = power_on ? IMX_SC_PM_PW_MODE_ON : IMX_SC_PM_PW_MODE_LP;
+	msg.mode = power_on ? IMX_SC_PM_PW_MODE_ON : pd->pd.state_idx ?
+		   IMX_SC_PM_PW_MODE_OFF : IMX_SC_PM_PW_MODE_LP;
+
+	/* keep uart console power on for no_console_suspend */
+        if (imx_con_rsrc == pd->rsrc && !console_suspend_enabled && !power_on)
+                return 0;
 
 	ret = imx_scu_call_rpc(pm_ipc_handle, &msg, true);
+	if (ret == -EACCES)
+	{
+		pr_warn("Resource %d not owned by partition, power state unchanged\n",
+			pd->rsrc);
+		return 0;
+	}
 	if (ret)
 		dev_err(&domain->dev, "failed to power %s resource %d ret %d\n",
 			power_on ? "up" : "off", pd->rsrc, ret);
@@ -293,6 +442,7 @@ imx_scu_add_pm_domain(struct device *dev, int idx,
 		      const struct imx_sc_pd_range *pd_ranges)
 {
 	struct imx_sc_pm_domain *sc_pd;
+	struct genpd_power_state *states;
 	bool is_off = true;
 	int ret;
 
@@ -303,9 +453,23 @@ imx_scu_add_pm_domain(struct device *dev, int idx,
 	if (!sc_pd)
 		return ERR_PTR(-ENOMEM);
 
+	states = devm_kcalloc(dev, 2, sizeof(*states), GFP_KERNEL);
+	if (!states) {
+		devm_kfree(dev, sc_pd);
+		return ERR_PTR(-ENOMEM);
+	}
+
 	sc_pd->rsrc = pd_ranges->rsrc + idx;
 	sc_pd->pd.power_off = imx_sc_pd_power_off;
 	sc_pd->pd.power_on = imx_sc_pd_power_on;
+	sc_pd->pd.flags |= GENPD_FLAG_ACTIVE_WAKEUP;
+	states[0].power_off_latency_ns = 25000;
+	states[0].power_on_latency_ns =  25000;
+	states[1].power_off_latency_ns = 2500000;
+	states[1].power_on_latency_ns =  2500000;
+
+	sc_pd->pd.states = states;
+	sc_pd->pd.state_count = 2;
 
 	if (pd_ranges->postfix)
 		snprintf(sc_pd->name, sizeof(sc_pd->name),
@@ -316,7 +480,7 @@ imx_scu_add_pm_domain(struct device *dev, int idx,
 
 	sc_pd->pd.name = sc_pd->name;
 	if (imx_con_rsrc == sc_pd->rsrc) {
-		sc_pd->pd.flags = GENPD_FLAG_RPM_ALWAYS_ON;
+		sc_pd->pd.flags |= GENPD_FLAG_RPM_ALWAYS_ON;
 		is_off = false;
 	}
 
@@ -325,6 +489,7 @@ imx_scu_add_pm_domain(struct device *dev, int idx,
 			 sc_pd->name, sc_pd->rsrc);
 
 		devm_kfree(dev, sc_pd);
+		devm_kfree(dev, states);
 		return NULL;
 	}
 
@@ -333,6 +498,7 @@ imx_scu_add_pm_domain(struct device *dev, int idx,
 		dev_warn(dev, "failed to init pd %s rsrc id %d",
 			 sc_pd->name, sc_pd->rsrc);
 		devm_kfree(dev, sc_pd);
+		devm_kfree(dev, states);
 		return NULL;
 	}
 
@@ -395,6 +561,7 @@ static int imx_sc_pd_probe(struct platform_device *pdev)
 		return -ENODEV;
 
 	imx_sc_pd_get_console_rsrc();
+	imx_sc_pd_enable_irqsteer_wakeup(pdev->dev.of_node);
 
 	return imx_scu_init_pm_domains(&pdev->dev, pd_soc);
 }
@@ -412,7 +579,12 @@ static struct platform_driver imx_sc_pd_driver = {
 	},
 	.probe = imx_sc_pd_probe,
 };
-builtin_platform_driver(imx_sc_pd_driver);
+
+static int __init imx_sc_pd_driver_init(void)
+{
+	return platform_driver_register(&imx_sc_pd_driver);
+}
+subsys_initcall(imx_sc_pd_driver_init);
 
 MODULE_AUTHOR("Dong Aisheng <aisheng.dong@nxp.com>");
 MODULE_DESCRIPTION("IMX SCU Power Domain driver");
diff --git a/drivers/soc/imx/soc-imx8m.c b/drivers/soc/imx/soc-imx8m.c
index cc57a384d..07902131a 100644
--- a/drivers/soc/imx/soc-imx8m.c
+++ b/drivers/soc/imx/soc-imx8m.c
@@ -3,8 +3,10 @@
  * Copyright 2019 NXP.
  */
 
+#include <linux/arm-smccc.h>
 #include <linux/init.h>
 #include <linux/io.h>
+#include <linux/module.h>
 #include <linux/of_address.h>
 #include <linux/slab.h>
 #include <linux/sys_soc.h>
@@ -12,6 +14,8 @@
 #include <linux/arm-smccc.h>
 #include <linux/of.h>
 
+#include <soc/imx/src.h>
+
 #define REV_B1				0x21
 
 #define IMX8MQ_SW_INFO_B1		0x40
@@ -19,6 +23,15 @@
 
 #define IMX_SIP_GET_SOC_INFO		0xc2000006
 
+#define IMX_SIP_NOC			0xc2000008
+#define IMX_SIP_NOC_LCDIF		0x0
+#define IMX_SIP_NOC_PRIORITY		0x1
+#define NOC_GPU_PRIORITY		0x10
+#define NOC_DCSS_PRIORITY		0x11
+#define NOC_VPU_PRIORITY		0x12
+#define NOC_CPU_PRIORITY		0x13
+#define NOC_MIX_PRIORITY		0x14
+
 #define OCOTP_UID_LOW			0x410
 #define OCOTP_UID_HIGH			0x420
 
@@ -158,6 +171,23 @@ static __maybe_unused const struct of_device_id imx8_soc_match[] = {
 	{ }
 };
 
+static void imx8mq_noc_init(void)
+{
+	struct arm_smccc_res res;
+
+	pr_info("Config NOC for VPU and CPU\n");
+
+	arm_smccc_smc(IMX_SIP_NOC, IMX_SIP_NOC_PRIORITY, NOC_CPU_PRIORITY,
+			0x80000300, 0, 0, 0, 0, &res);
+	if (res.a0)
+		pr_err("Config NOC for CPU fail!\n");
+
+	arm_smccc_smc(IMX_SIP_NOC, IMX_SIP_NOC_PRIORITY, NOC_VPU_PRIORITY,
+			0x80000300, 0, 0, 0, 0, &res);
+	if (res.a0)
+		pr_err("Config NOC for VPU fail!\n");
+}
+
 #define imx8_revision(soc_rev) \
 	soc_rev ? \
 	kasprintf(GFP_KERNEL, "%d.%d", (soc_rev >> 4) & 0xf,  soc_rev & 0xf) : \
@@ -219,6 +249,9 @@ static int __init imx8_soc_init(void)
 	if (IS_ENABLED(CONFIG_ARM_IMX_CPUFREQ_DT))
 		platform_device_register_simple("imx-cpufreq-dt", -1, NULL, 0);
 
+	if (of_machine_is_compatible("fsl,imx8mq"))
+		imx8mq_noc_init();
+
 	return 0;
 
 free_serial_number:
@@ -230,4 +263,35 @@ static int __init imx8_soc_init(void)
 	kfree(soc_dev_attr);
 	return ret;
 }
+
 device_initcall(imx8_soc_init);
+
+#define FSL_SIP_SRC                    0xc2000005
+#define FSL_SIP_SRC_M4_START           0x00
+#define FSL_SIP_SRC_M4_STARTED         0x01
+
+/* To indicate M4 enabled or not on i.MX8MQ */
+static bool m4_is_enabled;
+bool imx_src_is_m4_enabled(void)
+{
+	return m4_is_enabled;
+}
+EXPORT_SYMBOL_GPL(imx_src_is_m4_enabled);
+
+int check_m4_enabled(void)
+{
+	struct arm_smccc_res res;
+
+	arm_smccc_smc(FSL_SIP_SRC, FSL_SIP_SRC_M4_STARTED, 0,
+		      0, 0, 0, 0, 0, &res);
+		      m4_is_enabled = !!res.a0;
+
+	if (m4_is_enabled)
+		printk("M4 is started\n");
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(check_m4_enabled);
+
+MODULE_DESCRIPTION("i.MX8M SoC driver");
+MODULE_LICENSE("GPL v2");
diff --git a/include/drm/bridge/cdns-mhdp.h b/include/drm/bridge/cdns-mhdp.h
new file mode 100644
index 000000000..f3bdff5c3
--- /dev/null
+++ b/include/drm/bridge/cdns-mhdp.h
@@ -0,0 +1,921 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) Fuzhou Rockchip Electronics Co.Ltd
+ * Author: Chris Zhong <zyw@rock-chips.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef CDNS_MHDP_H_
+#define CDNS_MHDP_H_
+
+#include <drm/drm_bridge.h>
+#include <drm/drm_connector.h>
+#include <drm/drm_dp_helper.h>
+#include <drm/drm_dp_mst_helper.h>
+#include <media/cec.h>
+#include <linux/bitops.h>
+#include <sound/hdmi-codec.h>
+
+#define ADDR_IMEM		0x10000
+#define ADDR_DMEM		0x20000
+#define ADDR_PHY_AFE	0x80000
+
+/* APB CFG addr */
+#define APB_CTRL			0
+#define XT_INT_CTRL			0x04
+#define MAILBOX_FULL_ADDR		0x08
+#define MAILBOX_EMPTY_ADDR		0x0c
+#define MAILBOX0_WR_DATA		0x10
+#define MAILBOX0_RD_DATA		0x14
+#define KEEP_ALIVE			0x18
+#define VER_L				0x1c
+#define VER_H				0x20
+#define VER_LIB_L_ADDR			0x24
+#define VER_LIB_H_ADDR			0x28
+#define SW_DEBUG_L			0x2c
+#define SW_DEBUG_H			0x30
+#define MAILBOX_INT_MASK		0x34
+#define MAILBOX_INT_STATUS		0x38
+#define SW_CLK_L			0x3c
+#define SW_CLK_H			0x40
+#define SW_EVENTS0			0x44
+#define SW_EVENTS1			0x48
+#define SW_EVENTS2			0x4c
+#define SW_EVENTS3			0x50
+#define XT_OCD_CTRL			0x60
+#define APB_INT_MASK			0x6c
+#define APB_STATUS_MASK			0x70
+
+/* audio decoder addr */
+#define AUDIO_SRC_CNTL			0x30000
+#define AUDIO_SRC_CNFG			0x30004
+#define COM_CH_STTS_BITS		0x30008
+#define STTS_BIT_CH(x)			(0x3000c + ((x) << 2))
+#define SPDIF_CTRL_ADDR			0x3004c
+#define SPDIF_CH1_CS_3100_ADDR		0x30050
+#define SPDIF_CH1_CS_6332_ADDR		0x30054
+#define SPDIF_CH1_CS_9564_ADDR		0x30058
+#define SPDIF_CH1_CS_12796_ADDR		0x3005c
+#define SPDIF_CH1_CS_159128_ADDR	0x30060
+#define SPDIF_CH1_CS_191160_ADDR	0x30064
+#define SPDIF_CH2_CS_3100_ADDR		0x30068
+#define SPDIF_CH2_CS_6332_ADDR		0x3006c
+#define SPDIF_CH2_CS_9564_ADDR		0x30070
+#define SPDIF_CH2_CS_12796_ADDR		0x30074
+#define SPDIF_CH2_CS_159128_ADDR	0x30078
+#define SPDIF_CH2_CS_191160_ADDR	0x3007c
+#define SMPL2PKT_CNTL			0x30080
+#define SMPL2PKT_CNFG			0x30084
+#define FIFO_CNTL			0x30088
+#define FIFO_STTS			0x3008c
+
+/* source pif addr */
+#define SOURCE_PIF_WR_ADDR		0x30800
+#define SOURCE_PIF_WR_REQ		0x30804
+#define SOURCE_PIF_RD_ADDR		0x30808
+#define SOURCE_PIF_RD_REQ		0x3080c
+#define SOURCE_PIF_DATA_WR		0x30810
+#define SOURCE_PIF_DATA_RD		0x30814
+#define SOURCE_PIF_FIFO1_FLUSH		0x30818
+#define SOURCE_PIF_FIFO2_FLUSH		0x3081c
+#define SOURCE_PIF_STATUS		0x30820
+#define SOURCE_PIF_INTERRUPT_SOURCE	0x30824
+#define SOURCE_PIF_INTERRUPT_MASK	0x30828
+#define SOURCE_PIF_PKT_ALLOC_REG	0x3082c
+#define SOURCE_PIF_PKT_ALLOC_WR_EN	0x30830
+#define SOURCE_PIF_SW_RESET		0x30834
+
+/* bellow registers need access by mailbox */
+/* source phy comp */
+#define PHY_DATA_SEL			0x0818
+#define LANES_CONFIG			0x0814
+
+/* source car addr */
+#define SOURCE_HDTX_CAR			0x0900
+#define SOURCE_DPTX_CAR			0x0904
+#define SOURCE_PHY_CAR			0x0908
+#define SOURCE_CEC_CAR			0x090c
+#define SOURCE_CBUS_CAR			0x0910
+#define SOURCE_PKT_CAR			0x0918
+#define SOURCE_AIF_CAR			0x091c
+#define SOURCE_CIPHER_CAR		0x0920
+#define SOURCE_CRYPTO_CAR		0x0924
+
+/* mhdp tx_top_comp */
+#define SCHEDULER_H_SIZE		0x1000
+#define SCHEDULER_V_SIZE		0x1004
+#define HDTX_SIGNAL_FRONT_WIDTH	0x100c
+#define HDTX_SIGNAL_SYNC_WIDTH	0x1010
+#define HDTX_SIGNAL_BACK_WIDTH	0x1014
+#define HDTX_CONTROLLER			0x1018
+#define HDTX_HPD				0x1020
+#define HDTX_CLOCK_REG_0		0x1024
+#define HDTX_CLOCK_REG_1		0x1028
+
+/* clock meters addr */
+#define CM_CTRL				0x0a00
+#define CM_I2S_CTRL			0x0a04
+#define CM_SPDIF_CTRL			0x0a08
+#define CM_VID_CTRL			0x0a0c
+#define CM_LANE_CTRL			0x0a10
+#define I2S_NM_STABLE			0x0a14
+#define I2S_NCTS_STABLE			0x0a18
+#define SPDIF_NM_STABLE			0x0a1c
+#define SPDIF_NCTS_STABLE		0x0a20
+#define NMVID_MEAS_STABLE		0x0a24
+#define I2S_MEAS			0x0a40
+#define SPDIF_MEAS			0x0a80
+#define NMVID_MEAS			0x0ac0
+
+/* source vif addr */
+#define BND_HSYNC2VSYNC			0x0b00
+#define HSYNC2VSYNC_F1_L1		0x0b04
+#define HSYNC2VSYNC_F2_L1		0x0b08
+#define HSYNC2VSYNC_STATUS		0x0b0c
+#define HSYNC2VSYNC_POL_CTRL		0x0b10
+
+/* dptx phy addr */
+#define DP_TX_PHY_CONFIG_REG		0x2000
+#define DP_TX_PHY_SW_RESET		0x2004
+#define DP_TX_PHY_SCRAMBLER_SEED	0x2008
+#define DP_TX_PHY_TRAINING_01_04	0x200c
+#define DP_TX_PHY_TRAINING_05_08	0x2010
+#define DP_TX_PHY_TRAINING_09_10	0x2014
+#define TEST_COR			0x23fc
+
+/* dptx hpd addr */
+#define HPD_IRQ_DET_MIN_TIMER		0x2100
+#define HPD_IRQ_DET_MAX_TIMER		0x2104
+#define HPD_UNPLGED_DET_MIN_TIMER	0x2108
+#define HPD_STABLE_TIMER		0x210c
+#define HPD_FILTER_TIMER		0x2110
+#define HPD_EVENT_MASK			0x211c
+#define HPD_EVENT_DET			0x2120
+
+/* dpyx framer addr */
+#define DP_FRAMER_GLOBAL_CONFIG		0x2200
+#define DP_SW_RESET			0x2204
+#define DP_FRAMER_TU			0x2208
+#define DP_FRAMER_PXL_REPR		0x220c
+#define DP_FRAMER_SP			0x2210
+#define AUDIO_PACK_CONTROL		0x2214
+#define DP_VC_TABLE(x)			(0x2218 + ((x) << 2))
+#define DP_VB_ID			0x2258
+#define DP_MTPH_LVP_CONTROL		0x225c
+#define DP_MTPH_SYMBOL_VALUES		0x2260
+#define DP_MTPH_ECF_CONTROL		0x2264
+#define DP_MTPH_ACT_CONTROL		0x2268
+#define DP_MTPH_STATUS			0x226c
+#define DP_INTERRUPT_SOURCE		0x2270
+#define DP_INTERRUPT_MASK		0x2274
+#define DP_FRONT_BACK_PORCH		0x2278
+#define DP_BYTE_COUNT			0x227c
+
+/* dptx stream addr */
+#define MSA_HORIZONTAL_0		0x2280
+#define MSA_HORIZONTAL_1		0x2284
+#define MSA_VERTICAL_0			0x2288
+#define MSA_VERTICAL_1			0x228c
+#define MSA_MISC			0x2290
+#define STREAM_CONFIG			0x2294
+#define AUDIO_PACK_STATUS		0x2298
+#define VIF_STATUS			0x229c
+#define PCK_STUFF_STATUS_0		0x22a0
+#define PCK_STUFF_STATUS_1		0x22a4
+#define INFO_PACK_STATUS		0x22a8
+#define RATE_GOVERNOR_STATUS		0x22ac
+#define DP_HORIZONTAL			0x22b0
+#define DP_VERTICAL_0			0x22b4
+#define DP_VERTICAL_1			0x22b8
+#define DP_BLOCK_SDP			0x22bc
+
+/* dptx glbl addr */
+#define DPTX_LANE_EN			0x2300
+#define DPTX_ENHNCD			0x2304
+#define DPTX_INT_MASK			0x2308
+#define DPTX_INT_STATUS			0x230c
+
+/* dp aux addr */
+#define DP_AUX_HOST_CONTROL		0x2800
+#define DP_AUX_INTERRUPT_SOURCE		0x2804
+#define DP_AUX_INTERRUPT_MASK		0x2808
+#define DP_AUX_SWAP_INVERSION_CONTROL	0x280c
+#define DP_AUX_SEND_NACK_TRANSACTION	0x2810
+#define DP_AUX_CLEAR_RX			0x2814
+#define DP_AUX_CLEAR_TX			0x2818
+#define DP_AUX_TIMER_STOP		0x281c
+#define DP_AUX_TIMER_CLEAR		0x2820
+#define DP_AUX_RESET_SW			0x2824
+#define DP_AUX_DIVIDE_2M		0x2828
+#define DP_AUX_TX_PREACHARGE_LENGTH	0x282c
+#define DP_AUX_FREQUENCY_1M_MAX		0x2830
+#define DP_AUX_FREQUENCY_1M_MIN		0x2834
+#define DP_AUX_RX_PRE_MIN		0x2838
+#define DP_AUX_RX_PRE_MAX		0x283c
+#define DP_AUX_TIMER_PRESET		0x2840
+#define DP_AUX_NACK_FORMAT		0x2844
+#define DP_AUX_TX_DATA			0x2848
+#define DP_AUX_RX_DATA			0x284c
+#define DP_AUX_TX_STATUS		0x2850
+#define DP_AUX_RX_STATUS		0x2854
+#define DP_AUX_RX_CYCLE_COUNTER		0x2858
+#define DP_AUX_MAIN_STATES		0x285c
+#define DP_AUX_MAIN_TIMER		0x2860
+#define DP_AUX_AFE_OUT			0x2864
+
+/* crypto addr */
+#define CRYPTO_HDCP_REVISION		0x5800
+#define HDCP_CRYPTO_CONFIG		0x5804
+#define CRYPTO_INTERRUPT_SOURCE		0x5808
+#define CRYPTO_INTERRUPT_MASK		0x580c
+#define CRYPTO22_CONFIG			0x5818
+#define CRYPTO22_STATUS			0x581c
+#define SHA_256_DATA_IN			0x583c
+#define SHA_256_DATA_OUT_(x)		(0x5850 + ((x) << 2))
+#define AES_32_KEY_(x)			(0x5870 + ((x) << 2))
+#define AES_32_DATA_IN			0x5880
+#define AES_32_DATA_OUT_(x)		(0x5884 + ((x) << 2))
+#define CRYPTO14_CONFIG			0x58a0
+#define CRYPTO14_STATUS			0x58a4
+#define CRYPTO14_PRNM_OUT		0x58a8
+#define CRYPTO14_KM_0			0x58ac
+#define CRYPTO14_KM_1			0x58b0
+#define CRYPTO14_AN_0			0x58b4
+#define CRYPTO14_AN_1			0x58b8
+#define CRYPTO14_YOUR_KSV_0		0x58bc
+#define CRYPTO14_YOUR_KSV_1		0x58c0
+#define CRYPTO14_MI_0			0x58c4
+#define CRYPTO14_MI_1			0x58c8
+#define CRYPTO14_TI_0			0x58cc
+#define CRYPTO14_KI_0			0x58d0
+#define CRYPTO14_KI_1			0x58d4
+#define CRYPTO14_BLOCKS_NUM		0x58d8
+#define CRYPTO14_KEY_MEM_DATA_0		0x58dc
+#define CRYPTO14_KEY_MEM_DATA_1		0x58e0
+#define CRYPTO14_SHA1_MSG_DATA		0x58e4
+#define CRYPTO14_SHA1_V_VALUE_(x)	(0x58e8 + ((x) << 2))
+#define TRNG_CTRL			0x58fc
+#define TRNG_DATA_RDY			0x5900
+#define TRNG_DATA			0x5904
+
+/* cipher addr */
+#define HDCP_REVISION			0x60000
+#define INTERRUPT_SOURCE		0x60004
+#define INTERRUPT_MASK			0x60008
+#define HDCP_CIPHER_CONFIG		0x6000c
+#define AES_128_KEY_0			0x60010
+#define AES_128_KEY_1			0x60014
+#define AES_128_KEY_2			0x60018
+#define AES_128_KEY_3			0x6001c
+#define AES_128_RANDOM_0		0x60020
+#define AES_128_RANDOM_1		0x60024
+#define CIPHER14_KM_0			0x60028
+#define CIPHER14_KM_1			0x6002c
+#define CIPHER14_STATUS			0x60030
+#define CIPHER14_RI_PJ_STATUS		0x60034
+#define CIPHER_MODE			0x60038
+#define CIPHER14_AN_0			0x6003c
+#define CIPHER14_AN_1			0x60040
+#define CIPHER22_AUTH			0x60044
+#define CIPHER14_R0_DP_STATUS		0x60048
+#define CIPHER14_BOOTSTRAP		0x6004c
+
+#define DPTX_FRMR_DATA_CLK_RSTN_EN	BIT(11)
+#define DPTX_FRMR_DATA_CLK_EN		BIT(10)
+#define DPTX_PHY_DATA_RSTN_EN		BIT(9)
+#define DPTX_PHY_DATA_CLK_EN		BIT(8)
+#define DPTX_PHY_CHAR_RSTN_EN		BIT(7)
+#define DPTX_PHY_CHAR_CLK_EN		BIT(6)
+#define SOURCE_AUX_SYS_CLK_RSTN_EN	BIT(5)
+#define SOURCE_AUX_SYS_CLK_EN		BIT(4)
+#define DPTX_SYS_CLK_RSTN_EN		BIT(3)
+#define DPTX_SYS_CLK_EN			BIT(2)
+#define CFG_DPTX_VIF_CLK_RSTN_EN	BIT(1)
+#define CFG_DPTX_VIF_CLK_EN		BIT(0)
+
+#define SOURCE_PHY_RSTN_EN		BIT(1)
+#define SOURCE_PHY_CLK_EN		BIT(0)
+
+#define SOURCE_PKT_SYS_RSTN_EN		BIT(3)
+#define SOURCE_PKT_SYS_CLK_EN		BIT(2)
+#define SOURCE_PKT_DATA_RSTN_EN		BIT(1)
+#define SOURCE_PKT_DATA_CLK_EN		BIT(0)
+
+#define SPDIF_CDR_CLK_RSTN_EN		BIT(5)
+#define SPDIF_CDR_CLK_EN		BIT(4)
+#define SOURCE_AIF_SYS_RSTN_EN		BIT(3)
+#define SOURCE_AIF_SYS_CLK_EN		BIT(2)
+#define SOURCE_AIF_CLK_RSTN_EN		BIT(1)
+#define SOURCE_AIF_CLK_EN		BIT(0)
+
+#define SOURCE_CIPHER_SYSTEM_CLK_RSTN_EN	BIT(3)
+#define SOURCE_CIPHER_SYS_CLK_EN		BIT(2)
+#define SOURCE_CIPHER_CHAR_CLK_RSTN_EN		BIT(1)
+#define SOURCE_CIPHER_CHAR_CLK_EN		BIT(0)
+
+#define SOURCE_CRYPTO_SYS_CLK_RSTN_EN	BIT(1)
+#define SOURCE_CRYPTO_SYS_CLK_EN	BIT(0)
+
+#define APB_IRAM_PATH			BIT(2)
+#define APB_DRAM_PATH			BIT(1)
+#define APB_XT_RESET			BIT(0)
+
+#define MAILBOX_INT_MASK_BIT		BIT(1)
+#define PIF_INT_MASK_BIT		BIT(0)
+#define ALL_INT_MASK			3
+
+/* mailbox */
+#define MB_OPCODE_ID			0
+#define MB_MODULE_ID			1
+#define MB_SIZE_MSB_ID			2
+#define MB_SIZE_LSB_ID			3
+#define MB_DATA_ID			4
+
+#define MB_MODULE_ID_DP_TX			0x01
+#define MB_MODULE_ID_HDMI_TX		0x03
+#define MB_MODULE_ID_HDCP_TX		0x07
+#define MB_MODULE_ID_HDCP_RX		0x08
+#define MB_MODULE_ID_HDCP_GENERAL	0x09
+#define MB_MODULE_ID_GENERAL		0x0A
+
+/* general opcode */
+#define GENERAL_MAIN_CONTROL            0x01
+#define GENERAL_TEST_ECHO               0x02
+#define GENERAL_BUS_SETTINGS            0x03
+#define GENERAL_TEST_ACCESS             0x04
+#define GENERAL_WRITE_REGISTER          0x05
+#define GENERAL_WRITE_FIELD             0x06
+#define GENERAL_READ_REGISTER           0x07
+#define GENERAL_GET_HPD_STATE           0x11
+#define GENERAL_ASSERT_PHY_BUS_RESET    0x12
+#define GENERAL_DEASSERT_PHY_BUS_RESET  0x13
+#define GENERAL_LOAD_HDCP_RX            0x20
+#define GENERAL_UNLOAD_HDCP_RX          0x21
+
+/* DPTX opcode */
+#define DPTX_SET_POWER_MNG			0x00
+#define DPTX_SET_HOST_CAPABILITIES		0x01
+#define DPTX_GET_EDID				0x02
+#define DPTX_READ_DPCD				0x03
+#define DPTX_WRITE_DPCD				0x04
+#define DPTX_ENABLE_EVENT			0x05
+#define DPTX_WRITE_REGISTER			0x06
+#define DPTX_READ_REGISTER			0x07
+#define DPTX_WRITE_FIELD			0x08
+#define DPTX_TRAINING_CONTROL			0x09
+#define DPTX_READ_EVENT				0x0a
+#define DPTX_READ_LINK_STAT			0x0b
+#define DPTX_SET_VIDEO				0x0c
+#define DPTX_SET_AUDIO				0x0d
+#define DPTX_GET_LAST_AUX_STAUS			0x0e
+#define DPTX_SET_LINK_BREAK_POINT		0x0f
+#define DPTX_FORCE_LANES			0x10
+#define DPTX_HPD_STATE				0x11
+#define DPTX_ADJUST_LT				0x12
+#define DPTX_I2C_READ              0x15
+#define DPTX_I2C_WRITE             0x16
+#define DPTX_GET_LAST_I2C_STATUS   0x17
+
+
+
+/* HDMI TX opcode */
+#define HDMI_TX_READ				0x00
+#define HDMI_TX_WRITE				0x01
+#define HDMI_TX_UPDATE_READ			0x02
+#define HDMI_TX_EDID				0x03
+#define HDMI_TX_EVENTS				0x04
+#define HDMI_TX_HPD_STATUS			0x05
+#define HDMI_TX_DEBUG_ECHO			0xAA
+#define HDMI_TX_TEST				0xBB
+#define HDMI_TX_EDID_INTERNAL		0xF0
+
+/* HDCP General opcode */
+#define HDCP_GENERAL_SET_LC_128		0x00
+#define HDCP_GENERAL_SET_SEED		0x01
+
+/* HDCP TX opcode */
+#define HDCP_TX_CONFIGURATION				0x00
+#define HDCP2_TX_SET_PUBLIC_KEY_PARAMS		0x01
+#define HDCP2_TX_SET_DEBUG_RANDOM_NUMBERS	0x02
+#define HDCP2_TX_RESPOND_KM					0x03
+#define HDCP1_TX_SEND_KEYS					0x04
+#define HDCP1_TX_SEND_RANDOM_AN				0x05
+#define HDCP_TX_STATUS_CHANGE				0x06
+#define HDCP2_TX_IS_KM_STORED				0x07
+#define HDCP2_TX_STORE_KM					0x08
+#define HDCP_TX_IS_RECEIVER_ID_VALID		0x09
+#define HDCP_TX_RESPOND_RECEIVER_ID_VALID	0x0A
+#define HDCP_TX_TEST_KEYS					0x0B
+#define HDCP2_TX_SET_KM_KEY_PARAMS			0x0C
+#define HDCP_TX_SET_CP_IRQ					0x0D
+#define HDCP_TX_DO_AUTH_REQ					0x0E
+
+#define FW_STANDBY				0
+#define FW_ACTIVE				1
+
+#define MHDP_EVENT_ENABLE_HPD			BIT(0)
+#define MHDP_EVENT_ENABLE_TRAINING		BIT(1)
+
+#define LINK_TRAINING_NOT_ACTIVE		0
+#define LINK_TRAINING_RUN			1
+#define LINK_TRAINING_RESTART			2
+
+#define CONTROL_VIDEO_IDLE			0
+#define CONTROL_VIDEO_VALID			1
+
+#define TU_CNT_RST_EN				BIT(15)
+#define VIF_BYPASS_INTERLACE			BIT(13)
+#define INTERLACE_FMT_DET			BIT(12)
+#define INTERLACE_DTCT_WIN			0x20
+
+#define DP_FRAMER_SP_INTERLACE_EN		BIT(2)
+#define DP_FRAMER_SP_HSP			BIT(1)
+#define DP_FRAMER_SP_VSP			BIT(0)
+
+/* capability */
+#define AUX_HOST_INVERT				3
+#define	FAST_LT_SUPPORT				1
+#define FAST_LT_NOT_SUPPORT			0
+#define LANE_MAPPING_NORMAL			0x1b
+#define LANE_MAPPING_FLIPPED			0xe4
+#define ENHANCED				1
+#define SCRAMBLER_EN				BIT(4)
+
+#define	FULL_LT_STARTED				BIT(0)
+#define FASE_LT_STARTED				BIT(1)
+#define CLK_RECOVERY_FINISHED			BIT(2)
+#define EQ_PHASE_FINISHED			BIT(3)
+#define FASE_LT_START_FINISHED			BIT(4)
+#define CLK_RECOVERY_FAILED			BIT(5)
+#define EQ_PHASE_FAILED				BIT(6)
+#define FASE_LT_FAILED				BIT(7)
+
+#define DPTX_HPD_EVENT						   BIT(0)
+#define HDMI_TX_HPD_EVENT					   BIT(0)
+#define HDMI_RX_5V_EVENT					   BIT(0)
+#define DPTX_TRAINING_EVENT					   BIT(1)
+#define HDMI_RX_SCDC_CHANGE_EVENT			   BIT(1)
+#define HDCPTX_STATUS_EVENT					   BIT(4)
+#define HDCPRX_STATUS_EVENT					   BIT(4)
+#define HDCPTX_IS_KM_STORED_EVENT			   BIT(5)
+#define HDCPTX_STORE_KM_EVENT				   BIT(6)
+#define HDCPTX_IS_RECEIVER_ID_VALID_EVENT	   BIT(7)
+
+#define TU_SIZE					30
+#define CDNS_DP_MAX_LINK_RATE	540000
+
+#define F_HDMI_ENCODING(x) (((x) & ((1 << 2) - 1)) << 16)
+#define F_VIF_DATA_WIDTH(x) (((x) & ((1 << 2) - 1)) << 2)
+#define F_HDMI_MODE(x) (((x) & ((1 << 2) - 1)) << 0)
+#define F_GCP_EN(x) (((x) & ((1 << 1) - 1)) << 12)
+#define F_CLEAR_AVMUTE(x) (((x) & ((1 << 1) - 1)) << 14)
+#define F_DATA_EN(x) (((x) & ((1 << 1) - 1)) << 15)
+#define F_HDMI2_PREAMBLE_EN(x) (((x) & ((1 << 1) - 1)) << 18)
+#define F_PIC_3D(x) (((x) & ((1 << 4) - 1)) << 7)
+#define F_BCH_EN(x) (((x) & ((1 << 1) - 1)) << 11)
+#define F_SOURCE_PHY_MHDP_SEL(x) (((x) & ((1 << 2) - 1)) << 3)
+#define F_HPD_VALID_WIDTH(x) (((x) & ((1 << 12) - 1)) << 0)
+#define F_HPD_GLITCH_WIDTH(x) (((x) & ((1 << 8) - 1)) << 12)
+#define F_HDMI2_CTRL_IL_MODE(x) (((x) & ((1 << 1) - 1)) << 19)
+#define F_SOURCE_PHY_LANE0_SWAP(x) (((x) & ((1 << 2) - 1)) << 0)
+#define F_SOURCE_PHY_LANE1_SWAP(x) (((x) & ((1 << 2) - 1)) << 2)
+#define F_SOURCE_PHY_LANE2_SWAP(x) (((x) & ((1 << 2) - 1)) << 4)
+#define F_SOURCE_PHY_LANE3_SWAP(x) (((x) & ((1 << 2) - 1)) << 6)
+#define F_SOURCE_PHY_COMB_BYPASS(x) (((x) & ((1 << 1) - 1)) << 21)
+#define F_SOURCE_PHY_20_10(x) (((x) & ((1 << 1) - 1)) << 22)
+#define F_PKT_ALLOC_ADDRESS(x) (((x) & ((1 << 4) - 1)) << 0)
+#define F_ACTIVE_IDLE_TYPE(x) (((x) & ((1 << 1) - 1)) << 17)
+#define F_FIFO1_FLUSH(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_PKT_ALLOC_WR_EN(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_DATA_WR(x) (x)
+#define F_WR_ADDR(x) (((x) & ((1 << 4) - 1)) << 0)
+#define F_HOST_WR(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_TYPE_VALID(x) (((x) & ((1 << 1) - 1)) << 16)
+#define F_PACKET_TYPE(x) (((x) & ((1 << 8) - 1)) << 8)
+
+/* audio */
+#define AUDIO_PACK_EN				BIT(8)
+#define SAMPLING_FREQ(x)			(((x) & 0xf) << 16)
+#define ORIGINAL_SAMP_FREQ(x)			(((x) & 0xf) << 24)
+#define SYNC_WR_TO_CH_ZERO			BIT(1)
+#define I2S_DEC_START				BIT(1)
+#define AUDIO_SW_RST				BIT(0)
+#define SMPL2PKT_EN				BIT(1)
+#define MAX_NUM_CH(x)				(((x) & 0x1f) - 1)
+#define NUM_OF_I2S_PORTS(x)			((((x) / 2 - 1) & 0x3) << 5)
+#define AUDIO_TYPE_LPCM				(2 << 7)
+#define CFG_SUB_PCKT_NUM(x)			((((x) - 1) & 0x7) << 11)
+#define AUDIO_CH_NUM(x)				((((x) - 1) & 0x1f) << 2)
+#define TRANS_SMPL_WIDTH_16			0
+#define TRANS_SMPL_WIDTH_24			BIT(11)
+#define TRANS_SMPL_WIDTH_32			(2 << 11)
+#define I2S_DEC_PORT_EN(x)			(((x) & 0xf) << 17)
+#define SPDIF_ENABLE				BIT(21)
+#define SPDIF_AVG_SEL				BIT(20)
+#define SPDIF_JITTER_BYPASS			BIT(19)
+#define SPDIF_FIFO_MID_RANGE(x)			(((x) & 0xff) << 11)
+#define SPDIF_JITTER_THRSH(x)			(((x) & 0xff) << 3)
+#define SPDIF_JITTER_AVG_WIN(x)			((x) & 0x7)
+
+/* Reference cycles when using lane clock as reference */
+#define LANE_REF_CYC				0x8000
+
+#define HOTPLUG_DEBOUNCE_MS		50
+
+#define IRQ_IN    0
+#define IRQ_OUT   1
+#define IRQ_NUM   2
+
+#define cdns_mhdp_plat_call(mhdp, operation)			\
+	(!(mhdp) ? -ENODEV : (((mhdp)->plat_data && (mhdp)->plat_data->operation) ?	\
+	 (mhdp)->plat_data->operation(mhdp) : ENOIOCTLCMD))
+
+/* bus access type */
+enum {
+	BUS_TYPE_NORMAL_APB = 0,
+	BUS_TYPE_NORMAL_SAPB = 1,
+	BUS_TYPE_LOW4K_APB = 2,
+	BUS_TYPE_LOW4K_SAPB = 3,
+	BUS_TYPE_LOW4K_HDMI_RX = 4,
+};
+
+enum voltage_swing_level {
+	VOLTAGE_LEVEL_0,
+	VOLTAGE_LEVEL_1,
+	VOLTAGE_LEVEL_2,
+	VOLTAGE_LEVEL_3,
+};
+
+enum pre_emphasis_level {
+	PRE_EMPHASIS_LEVEL_0,
+	PRE_EMPHASIS_LEVEL_1,
+	PRE_EMPHASIS_LEVEL_2,
+	PRE_EMPHASIS_LEVEL_3,
+};
+
+enum pattern_set {
+	PTS1		= BIT(0),
+	PTS2		= BIT(1),
+	PTS3		= BIT(2),
+	PTS4		= BIT(3),
+	DP_NONE		= BIT(4)
+};
+
+enum vic_color_depth {
+	BCS_6 = 0x1,
+	BCS_8 = 0x2,
+	BCS_10 = 0x4,
+	BCS_12 = 0x8,
+	BCS_16 = 0x10,
+};
+
+enum vic_bt_type {
+	BT_601 = 0x0,
+	BT_709 = 0x1,
+};
+
+enum audio_format {
+	AFMT_I2S = 0,
+	AFMT_SPDIF_INT = 1,
+	AFMT_SPDIF_EXT = 2,
+	AFMT_UNUSED,
+};
+
+enum {
+	MODE_DVI,
+	MODE_HDMI_1_4,
+	MODE_HDMI_2_0,
+};
+
+struct audio_info {
+	enum audio_format format;
+	int sample_rate;
+	int channels;
+	int sample_width;
+	int connector_type;
+	bool non_pcm;
+};
+
+enum vic_pxl_encoding_format {
+	PXL_RGB = 0x1,
+	YCBCR_4_4_4 = 0x2,
+	YCBCR_4_2_2 = 0x4,
+	YCBCR_4_2_0 = 0x8,
+	Y_ONLY = 0x10,
+};
+
+enum link_training_type {
+	DP_TX_FULL_LINK_TRAINING,
+	DP_TX_FAST_LINK_TRAINING,
+	DP_TX_NO_AUX_LINK_TRAINING
+};
+
+struct video_info {
+	bool h_sync_polarity;
+	bool v_sync_polarity;
+	bool interlaced;
+	int color_depth;
+	enum vic_pxl_encoding_format color_fmt;
+};
+
+struct cdns_mhdp_host {
+	unsigned int	link_rate;
+	u8	lanes_cnt;
+	u8	volt_swing;
+	u8	pre_emphasis;
+	u8	pattern_supp;
+	u8	fast_link;
+	u8	lane_mapping;
+	u8	enhanced;
+};
+
+struct cdns_mhdp_sink {
+	unsigned int	link_rate;
+	u8	lanes_cnt;
+	u8	pattern_supp;
+	u8	fast_link;
+	u8	enhanced;
+};
+
+struct cdns_mhdp_bridge;
+struct cdns_mhdp_connector;
+
+struct cdns_mhdp_bridge {
+	struct cdns_mhdp_device *mhdp;
+	struct drm_bridge base;
+	int pbn;
+	int8_t stream_id;
+	struct cdns_mhdp_connector *connector;
+	bool is_active;
+};
+
+struct cdns_mhdp_connector {
+	struct drm_connector base;
+	struct drm_connector_state new_state;
+	bool is_mst_connector;
+	struct drm_dp_mst_port *port;
+	struct cdns_mhdp_bridge *bridge;
+};
+
+struct cdns_mhdp_cec {
+	struct cec_adapter *adap;
+	struct device *dev;
+	struct mutex *iolock;
+	void __iomem		*regs_base;
+	void __iomem		*regs_sec;
+	int bus_type;
+
+	struct cec_msg msg;
+	struct task_struct *cec_worker;
+};
+
+struct cdns_plat_data {
+	/* Vendor PHY support */
+	int (*bind)(struct platform_device *pdev,
+			struct drm_encoder *encoder,
+			struct cdns_mhdp_device *mhdp);
+	void (*unbind)(struct device *dev);
+
+	void (*plat_init)(struct cdns_mhdp_device *mhdp);
+	void (*plat_deinit)(struct cdns_mhdp_device *mhdp);
+
+	int (*phy_set)(struct cdns_mhdp_device *mhdp);
+	bool (*phy_video_valid)(struct cdns_mhdp_device *mhdp);
+	int (*firmware_init)(struct cdns_mhdp_device *mhdp);
+	void (*pclk_rate)(struct cdns_mhdp_device *mhdp);
+
+	int (*suspend)(struct cdns_mhdp_device *mhdp);
+	int (*resume)(struct cdns_mhdp_device *mhdp);
+
+	int (*power_on)(struct cdns_mhdp_device *mhdp);
+	int (*power_off)(struct cdns_mhdp_device *mhdp);
+
+	int bus_type;
+	int video_format;
+	char is_dp;
+	char *plat_name;
+};
+
+/* HDCP */
+#define MAX_STORED_KM 64
+#define HDCP_PAIRING_M_LEN 16
+#define HDCP_PAIRING_M_EKH 16
+#define HDCP_PAIRING_R_ID 5
+
+/* HDCP2_TX_SET_DEBUG_RANDOM_NUMBERS */
+#define DEBUG_RANDOM_NUMBERS_KM_LEN 16
+#define DEBUG_RANDOM_NUMBERS_RN_LEN 8
+#define DEBUG_RANDOM_NUMBERS_KS_LEN 16
+#define DEBUG_RANDOM_NUMBERS_RIV_LEN 8
+#define DEBUG_RANDOM_NUMBERS_RTX_LEN 8
+
+struct hdcp_trans_pairing_data {
+	u8 receiver_id[HDCP_PAIRING_R_ID];
+	u8 m[HDCP_PAIRING_M_LEN];
+	u8 km[DEBUG_RANDOM_NUMBERS_KM_LEN];
+	u8 ekh[HDCP_PAIRING_M_EKH];
+};
+
+enum hdmi_hdcp_state {
+	HDCP_STATE_NO_AKSV,
+	HDCP_STATE_INACTIVE,
+	HDCP_STATE_ENABLING,
+	HDCP_STATE_AUTHENTICATING,
+	HDCP_STATE_REAUTHENTICATING,
+	HDCP_STATE_AUTHENTICATED,
+	HDCP_STATE_DISABLING,
+	HDCP_STATE_AUTH_FAILED
+};
+
+struct cdns_mhdp_hdcp {
+	struct mutex mutex;
+	u64 value; /* protected by hdcp_mutex */
+	struct delayed_work check_work;
+	struct work_struct prop_work;
+	u8 state;
+	u8 cancel;
+	u8 bus_type;
+	u8 config;
+	struct hdcp_trans_pairing_data pairing[MAX_STORED_KM];
+	u8 num_paired;
+
+	u8 events;
+	u8 sink_is_repeater;
+	u8 reauth_in_progress;
+	u8 hdcp_version;
+};
+
+struct cdns_mhdp_device {
+	void __iomem		*regs_base;
+	void __iomem		*regs_sec;
+
+	int bus_type;
+
+	struct device		*dev;
+	struct drm_device *drm_dev;
+
+	struct cdns_mhdp_connector  connector;
+	struct clk		*spdif_clk;
+	struct reset_control	*spdif_rst;
+
+	struct platform_device	*audio_pdev;
+	struct audio_info	audio_info;
+
+	struct cdns_mhdp_bridge	bridge;
+	struct phy		*phy;
+
+	struct video_info	video_info;
+	struct drm_display_mode	mode;
+	const struct drm_display_mode	*valid_mode;
+	unsigned int		fw_version;
+
+	struct drm_dp_mst_topology_mgr mst_mgr;
+	struct delayed_work hotplug_work;
+
+	u32 lane_mapping;
+	bool link_up;
+	bool force_disconnected_sts;
+	bool power_up;
+	bool plugged;
+	bool force_mode_set;
+	bool is_hpd;
+	bool is_dp;
+	bool is_ls1028a;
+	struct mutex lock;
+	struct mutex api_lock;
+	struct mutex iolock;
+
+	int irq[IRQ_NUM];
+
+	union {
+		struct _dp_data {
+			u8 dpcd[DP_RECEIVER_CAP_SIZE];
+			u32 rate;
+			u8 num_lanes;
+			u8 vswing[4];
+			u8 preemphasis[4];
+			u8 force_vswing;
+			u8 force_preemphasis;
+			enum link_training_type link_training_type;
+			struct drm_dp_aux	aux;
+			struct cdns_mhdp_host	host;
+			struct cdns_mhdp_sink	sink;
+			bool is_mst;
+			bool can_mst;
+		} dp;
+		struct _hdmi_data {
+			struct cdns_mhdp_cec cec;
+			u32 char_rate;
+			u32 hdmi_type;
+		} hdmi;
+	};
+	const struct cdns_plat_data *plat_data;
+
+	hdmi_codec_plugged_cb plugged_cb;
+	struct device *codec_dev;
+	enum drm_connector_status last_connector_result;
+	struct cdns_mhdp_hdcp hdcp;
+};
+
+u32 cdns_mhdp_bus_read(struct cdns_mhdp_device *mhdp, u32 offset);
+void cdns_mhdp_bus_write(u32 val, struct cdns_mhdp_device *mhdp, u32 offset);
+void cdns_mhdp_clock_reset(struct cdns_mhdp_device *mhdp);
+void cdns_mhdp_set_fw_clk(struct cdns_mhdp_device *mhdp, unsigned long clk);
+int cdns_mhdp_load_firmware(struct cdns_mhdp_device *mhdp, const u32 *i_mem,
+			    u32 i_size, const u32 *d_mem, u32 d_size);
+int cdns_mhdp_set_firmware_active(struct cdns_mhdp_device *mhdp, bool enable);
+int cdns_mhdp_set_host_cap(struct cdns_mhdp_device *mhdp);
+int cdns_mhdp_event_config(struct cdns_mhdp_device *mhdp);
+u32 cdns_mhdp_get_event(struct cdns_mhdp_device *mhdp);
+int cdns_mhdp_dpcd_write(struct cdns_mhdp_device *mhdp, u32 addr, u8 value);
+int cdns_mhdp_dpcd_read(struct cdns_mhdp_device *mhdp,
+			u32 addr, u8 *data, u16 len);
+
+int cdns_mhdp_get_last_i2c_status(struct cdns_mhdp_device *mhdp, u8 *resp);
+int cdns_mhdp_i2c_write(struct cdns_mhdp_device *mhdp, u8 addr,
+			u8 *value, u8 mot, u16 len, u16 *respLength);
+int cdns_mhdp_i2c_read(struct cdns_mhdp_device *mhdp, u8 addr, u8 *data,
+	u16 len, u8 mot, u16 *respLength);
+int cdns_mhdp_get_edid_block(void *mhdp, u8 *edid,
+			     unsigned int block, size_t length);
+int cdns_mhdp_train_link(struct cdns_mhdp_device *mhdp);
+int cdns_mhdp_set_video_status(struct cdns_mhdp_device *mhdp, int active);
+int cdns_mhdp_config_video(struct cdns_mhdp_device *mhdp);
+int cdns_mhdp_apb_conf(struct cdns_mhdp_device *mhdp, u8 sel);
+
+/* Audio */
+int cdns_mhdp_audio_stop(struct cdns_mhdp_device *mhdp,
+			 struct audio_info *audio);
+int cdns_mhdp_audio_mute(struct cdns_mhdp_device *mhdp, bool enable);
+int cdns_mhdp_audio_config(struct cdns_mhdp_device *mhdp,
+			   struct audio_info *audio);
+int cdns_mhdp_register_audio_driver(struct device *dev);
+void cdns_mhdp_unregister_audio_driver(struct device *dev);
+
+int cdns_mhdp_reg_read(struct cdns_mhdp_device *mhdp, u32 addr);
+int cdns_mhdp_reg_write(struct cdns_mhdp_device *mhdp, u32 addr, u32 val);
+int cdns_mhdp_reg_write_bit(struct cdns_mhdp_device *mhdp, u16 addr,
+			    u8 start_bit, u8 bits_no, u32 val);
+int cdns_mhdp_adjust_lt(struct cdns_mhdp_device *mhdp, u8 nlanes,
+			u16 udelay, u8 *lanes_data,
+			u8 *dpcd);
+
+int cdns_mhdp_read_hpd(struct cdns_mhdp_device *mhdp);
+u32 cdns_phy_reg_read(struct cdns_mhdp_device *mhdp, u32 addr);
+int cdns_phy_reg_write(struct cdns_mhdp_device *mhdp, u32 addr, u32 val);
+int cdns_mhdp_mailbox_send(struct cdns_mhdp_device *mhdp, u8 module_id,
+				  u8 opcode, u16 size, u8 *message);
+int cdns_mhdp_mailbox_read_receive(struct cdns_mhdp_device *mhdp,
+					  u8 *buff, u16 buff_size);
+int cdns_mhdp_mailbox_validate_receive(struct cdns_mhdp_device *mhdp,
+					      u8 module_id, u8 opcode,
+					      u16 req_size);
+void cdns_mhdp_infoframe_set(struct cdns_mhdp_device *mhdp,
+					u8 entry_id, u8 packet_len, u8 *packet, u8 packet_type);
+int cdns_hdmi_get_edid_block(void *data, u8 *edid, u32 block, size_t length);
+int cdns_hdmi_scdc_read(struct cdns_mhdp_device *mhdp, u8 addr, u8 *data);
+int cdns_hdmi_scdc_write(struct cdns_mhdp_device *mhdp, u8 addr, u8 value);
+int cdns_hdmi_ctrl_init(struct cdns_mhdp_device *mhdp, int protocol, u32 char_rate);
+int cdns_hdmi_mode_config(struct cdns_mhdp_device *mhdp, struct drm_display_mode *mode,
+				struct video_info *video_info);
+int cdns_hdmi_disable_gcp(struct cdns_mhdp_device *mhdp);
+int cdns_hdmi_enable_gcp(struct cdns_mhdp_device *mhdp);
+
+bool cdns_mhdp_check_alive(struct cdns_mhdp_device *mhdp);
+
+/* HDMI */
+int cdns_hdmi_probe(struct platform_device *pdev,
+		 struct cdns_mhdp_device *mhdp);
+void cdns_hdmi_remove(struct platform_device *pdev);
+void cdns_hdmi_unbind(struct device *dev);
+int cdns_hdmi_bind(struct platform_device *pdev,
+			struct drm_encoder *encoder, struct cdns_mhdp_device *mhdp);
+void cdns_hdmi_set_sample_rate(struct cdns_mhdp_device *mhdp, unsigned int rate);
+void cdns_hdmi_audio_enable(struct cdns_mhdp_device *mhdp);
+void cdns_hdmi_audio_disable(struct cdns_mhdp_device *mhdp);
+
+/* DP  */
+int cdns_dp_probe(struct platform_device *pdev,
+		 struct cdns_mhdp_device *mhdp);
+void cdns_dp_remove(struct platform_device *pdev);
+void cdns_dp_unbind(struct device *dev);
+int cdns_dp_bind(struct platform_device *pdev,
+			struct drm_encoder *encoder, struct cdns_mhdp_device *mhdp);
+int cdns_hdmi_set_plugged_cb(struct cdns_mhdp_device *mhdp, hdmi_codec_plugged_cb fn,
+			     struct device *codec_dev);
+
+/* CEC */
+#ifdef CONFIG_DRM_CDNS_HDMI_CEC
+int cdns_mhdp_register_cec_driver(struct cdns_mhdp_cec *cec);
+int cdns_mhdp_unregister_cec_driver(struct cdns_mhdp_cec *cec);
+#endif
+
+#endif /* CDNS_MHDP_H_ */
diff --git a/include/dt-bindings/clock/imx6qdl-clock.h b/include/dt-bindings/clock/imx6qdl-clock.h
index e20c43cc3..15118e76e 100644
--- a/include/dt-bindings/clock/imx6qdl-clock.h
+++ b/include/dt-bindings/clock/imx6qdl-clock.h
@@ -273,6 +273,11 @@
 #define IMX6QDL_CLK_MMDC_P0_IPG			263
 #define IMX6QDL_CLK_DCIC1			264
 #define IMX6QDL_CLK_DCIC2			265
-#define IMX6QDL_CLK_END				266
+#define IMX6QDL_CLK_AXI_ALT_SEL			266
+#define IMX6QDL_CLK_LDB_DI0_DIV_7		267
+#define IMX6QDL_CLK_LDB_DI1_DIV_7		268
+#define IMX6QDL_CLK_LDB_DI0_DIV_SEL		269
+#define IMX6QDL_CLK_LDB_DI1_DIV_SEL		270
+#define IMX6QDL_CLK_END				271
 
 #endif /* __DT_BINDINGS_CLOCK_IMX6QDL_H */
diff --git a/include/dt-bindings/clock/imx7d-clock.h b/include/dt-bindings/clock/imx7d-clock.h
index 1d4c0dfe0..8ee3b08a7 100644
--- a/include/dt-bindings/clock/imx7d-clock.h
+++ b/include/dt-bindings/clock/imx7d-clock.h
@@ -451,6 +451,8 @@
 #define IMX7D_SNVS_CLK			442
 #define IMX7D_CAAM_CLK			443
 #define IMX7D_KPP_ROOT_CLK		444
-#define IMX7D_PXP_CLK			445
-#define IMX7D_CLK_END			446
+#define IMX7D_PXP_IPG_CLK		445
+#define IMX7D_PXP_AXI_CLK		446
+#define IMX7D_CLK_END			447
+
 #endif /* __DT_BINDINGS_CLOCK_IMX7D_H */
diff --git a/include/dt-bindings/clock/imx8-clock.h b/include/dt-bindings/clock/imx8-clock.h
index 2e60ce4d2..2a1122928 100644
--- a/include/dt-bindings/clock/imx8-clock.h
+++ b/include/dt-bindings/clock/imx8-clock.h
@@ -7,161 +7,58 @@
 #ifndef __DT_BINDINGS_CLOCK_IMX_H
 #define __DT_BINDINGS_CLOCK_IMX_H
 
-/* LPCG clocks */
+#define IMX_ADMA_ACM_AUD_CLK0_SEL			0
+#define IMX_ADMA_ACM_AUD_CLK0_CLK			1
+#define IMX_ADMA_ACM_AUD_CLK1_SEL			2
+#define IMX_ADMA_ACM_AUD_CLK1_CLK			3
+#define IMX_ADMA_ACM_MCLKOUT0_SEL			4
+#define IMX_ADMA_ACM_MCLKOUT1_SEL			5
+#define IMX_ADMA_ACM_ESAI0_MCLK_SEL			6
+#define IMX_ADMA_ACM_GPT0_MUX_CLK_SEL			7
+#define IMX_ADMA_ACM_GPT1_MUX_CLK_SEL			8
+#define IMX_ADMA_ACM_GPT2_MUX_CLK_SEL			9
+#define IMX_ADMA_ACM_GPT3_MUX_CLK_SEL			10
+#define IMX_ADMA_ACM_GPT4_MUX_CLK_SEL			11
+#define IMX_ADMA_ACM_GPT5_MUX_CLK_SEL			12
+#define IMX_ADMA_ACM_SAI0_MCLK_SEL			13
+#define IMX_ADMA_ACM_SAI1_MCLK_SEL			14
+#define IMX_ADMA_ACM_SAI2_MCLK_SEL			15
+#define IMX_ADMA_ACM_SAI3_MCLK_SEL			16
+#define IMX_ADMA_ACM_SAI4_MCLK_SEL			17
+#define IMX_ADMA_ACM_SAI5_MCLK_SEL			18
+#define IMX_ADMA_ACM_SPDIF0_TX_CLK_SEL			19
+#define IMX_ADMA_ACM_MQS_TX_CLK_SEL			20
+#define IMX_ADMA_ACM_ASRC0_MUX_CLK_SEL			21
+#define IMX_ADMA_ACM_ASRC1_MUX_CLK_SEL			22
 
-/* LSIO SS LPCG */
-#define IMX_LSIO_LPCG_PWM0_IPG_CLK			0
-#define IMX_LSIO_LPCG_PWM0_IPG_S_CLK			1
-#define IMX_LSIO_LPCG_PWM0_IPG_HF_CLK			2
-#define IMX_LSIO_LPCG_PWM0_IPG_SLV_CLK			3
-#define IMX_LSIO_LPCG_PWM0_IPG_MSTR_CLK			4
-#define IMX_LSIO_LPCG_PWM1_IPG_CLK			5
-#define IMX_LSIO_LPCG_PWM1_IPG_S_CLK			6
-#define IMX_LSIO_LPCG_PWM1_IPG_HF_CLK			7
-#define IMX_LSIO_LPCG_PWM1_IPG_SLV_CLK			8
-#define IMX_LSIO_LPCG_PWM1_IPG_MSTR_CLK			9
-#define IMX_LSIO_LPCG_PWM2_IPG_CLK			10
-#define IMX_LSIO_LPCG_PWM2_IPG_S_CLK			11
-#define IMX_LSIO_LPCG_PWM2_IPG_HF_CLK			12
-#define IMX_LSIO_LPCG_PWM2_IPG_SLV_CLK			13
-#define IMX_LSIO_LPCG_PWM2_IPG_MSTR_CLK			14
-#define IMX_LSIO_LPCG_PWM3_IPG_CLK			15
-#define IMX_LSIO_LPCG_PWM3_IPG_S_CLK			16
-#define IMX_LSIO_LPCG_PWM3_IPG_HF_CLK			17
-#define IMX_LSIO_LPCG_PWM3_IPG_SLV_CLK			18
-#define IMX_LSIO_LPCG_PWM3_IPG_MSTR_CLK			19
-#define IMX_LSIO_LPCG_PWM4_IPG_CLK			20
-#define IMX_LSIO_LPCG_PWM4_IPG_S_CLK			21
-#define IMX_LSIO_LPCG_PWM4_IPG_HF_CLK			22
-#define IMX_LSIO_LPCG_PWM4_IPG_SLV_CLK			23
-#define IMX_LSIO_LPCG_PWM4_IPG_MSTR_CLK			24
-#define IMX_LSIO_LPCG_PWM5_IPG_CLK			25
-#define IMX_LSIO_LPCG_PWM5_IPG_S_CLK			26
-#define IMX_LSIO_LPCG_PWM5_IPG_HF_CLK			27
-#define IMX_LSIO_LPCG_PWM5_IPG_SLV_CLK			28
-#define IMX_LSIO_LPCG_PWM5_IPG_MSTR_CLK			29
-#define IMX_LSIO_LPCG_PWM6_IPG_CLK			30
-#define IMX_LSIO_LPCG_PWM6_IPG_S_CLK			31
-#define IMX_LSIO_LPCG_PWM6_IPG_HF_CLK			32
-#define IMX_LSIO_LPCG_PWM6_IPG_SLV_CLK			33
-#define IMX_LSIO_LPCG_PWM6_IPG_MSTR_CLK			34
-#define IMX_LSIO_LPCG_PWM7_IPG_CLK			35
-#define IMX_LSIO_LPCG_PWM7_IPG_S_CLK			36
-#define IMX_LSIO_LPCG_PWM7_IPG_HF_CLK			37
-#define IMX_LSIO_LPCG_PWM7_IPG_SLV_CLK			38
-#define IMX_LSIO_LPCG_PWM7_IPG_MSTR_CLK			39
-#define IMX_LSIO_LPCG_GPT0_IPG_CLK			40
-#define IMX_LSIO_LPCG_GPT0_IPG_S_CLK			41
-#define IMX_LSIO_LPCG_GPT0_IPG_HF_CLK			42
-#define IMX_LSIO_LPCG_GPT0_IPG_SLV_CLK			43
-#define IMX_LSIO_LPCG_GPT0_IPG_MSTR_CLK			44
-#define IMX_LSIO_LPCG_GPT1_IPG_CLK			45
-#define IMX_LSIO_LPCG_GPT1_IPG_S_CLK			46
-#define IMX_LSIO_LPCG_GPT1_IPG_HF_CLK			47
-#define IMX_LSIO_LPCG_GPT1_IPG_SLV_CLK			48
-#define IMX_LSIO_LPCG_GPT1_IPG_MSTR_CLK			49
-#define IMX_LSIO_LPCG_GPT2_IPG_CLK			50
-#define IMX_LSIO_LPCG_GPT2_IPG_S_CLK			51
-#define IMX_LSIO_LPCG_GPT2_IPG_HF_CLK			52
-#define IMX_LSIO_LPCG_GPT2_IPG_SLV_CLK			53
-#define IMX_LSIO_LPCG_GPT2_IPG_MSTR_CLK			54
-#define IMX_LSIO_LPCG_GPT3_IPG_CLK			55
-#define IMX_LSIO_LPCG_GPT3_IPG_S_CLK			56
-#define IMX_LSIO_LPCG_GPT3_IPG_HF_CLK			57
-#define IMX_LSIO_LPCG_GPT3_IPG_SLV_CLK			58
-#define IMX_LSIO_LPCG_GPT3_IPG_MSTR_CLK			59
-#define IMX_LSIO_LPCG_GPT4_IPG_CLK			60
-#define IMX_LSIO_LPCG_GPT4_IPG_S_CLK			61
-#define IMX_LSIO_LPCG_GPT4_IPG_HF_CLK			62
-#define IMX_LSIO_LPCG_GPT4_IPG_SLV_CLK			63
-#define IMX_LSIO_LPCG_GPT4_IPG_MSTR_CLK			64
-#define IMX_LSIO_LPCG_FSPI0_HCLK			65
-#define IMX_LSIO_LPCG_FSPI0_IPG_CLK			66
-#define IMX_LSIO_LPCG_FSPI0_IPG_S_CLK			67
-#define IMX_LSIO_LPCG_FSPI0_IPG_SFCK			68
-#define IMX_LSIO_LPCG_FSPI1_HCLK			69
-#define IMX_LSIO_LPCG_FSPI1_IPG_CLK			70
-#define IMX_LSIO_LPCG_FSPI1_IPG_S_CLK			71
-#define IMX_LSIO_LPCG_FSPI1_IPG_SFCK			72
+#define IMX_ADMA_EXT_AUD_MCLK0				23
+#define IMX_ADMA_EXT_AUD_MCLK1				24
+#define IMX_ADMA_ESAI0_RX_CLK				25
+#define IMX_ADMA_ESAI0_RX_HF_CLK			26
+#define IMX_ADMA_ESAI0_TX_CLK				27
+#define IMX_ADMA_ESAI0_TX_HF_CLK			28
+#define IMX_ADMA_SPDIF0_RX				29
+#define IMX_ADMA_SAI0_RX_BCLK				30
+#define IMX_ADMA_SAI0_TX_BCLK				31
+#define IMX_ADMA_SAI1_RX_BCLK				32
+#define IMX_ADMA_SAI1_TX_BCLK				33
+#define IMX_ADMA_SAI2_RX_BCLK				34
+#define IMX_ADMA_SAI3_RX_BCLK				35
+#define IMX_ADMA_SAI4_RX_BCLK				36
+#define IMX_ADMA_SAI5_TX_BCLK				37
+#define IMX_ADMA_SAI6_RX_BCLK				38
+#define IMX_ADMA_HDMI_RX_MCLK				39
+#define IMX_ADMA_SPDIF1_RX				41
+#define IMX_ADMA_ESAI1_RX_CLK				42
+#define IMX_ADMA_ESAI1_RX_HF_CLK			43
+#define IMX_ADMA_ESAI1_TX_CLK				44
+#define IMX_ADMA_ESAI1_TX_HF_CLK			45
 
-#define IMX_LSIO_LPCG_CLK_END				73
+#define IMX_ADMA_ACM_ESAI1_MCLK_SEL			46
+#define IMX_ADMA_ACM_SAI6_MCLK_SEL			47
+#define IMX_ADMA_ACM_SAI7_MCLK_SEL			48
+#define IMX_ADMA_ACM_SPDIF1_TX_CLK_SEL			49
 
-/* Connectivity SS LPCG */
-#define IMX_CONN_LPCG_SDHC0_IPG_CLK			0
-#define IMX_CONN_LPCG_SDHC0_PER_CLK			1
-#define IMX_CONN_LPCG_SDHC0_HCLK			2
-#define IMX_CONN_LPCG_SDHC1_IPG_CLK			3
-#define IMX_CONN_LPCG_SDHC1_PER_CLK			4
-#define IMX_CONN_LPCG_SDHC1_HCLK			5
-#define IMX_CONN_LPCG_SDHC2_IPG_CLK			6
-#define IMX_CONN_LPCG_SDHC2_PER_CLK			7
-#define IMX_CONN_LPCG_SDHC2_HCLK			8
-#define IMX_CONN_LPCG_GPMI_APB_CLK			9
-#define IMX_CONN_LPCG_GPMI_BCH_APB_CLK			10
-#define IMX_CONN_LPCG_GPMI_BCH_IO_CLK			11
-#define IMX_CONN_LPCG_GPMI_BCH_CLK			12
-#define IMX_CONN_LPCG_APBHDMA_CLK			13
-#define IMX_CONN_LPCG_ENET0_ROOT_CLK			14
-#define IMX_CONN_LPCG_ENET0_TX_CLK			15
-#define IMX_CONN_LPCG_ENET0_AHB_CLK			16
-#define IMX_CONN_LPCG_ENET0_IPG_S_CLK			17
-#define IMX_CONN_LPCG_ENET0_IPG_CLK			18
-
-#define IMX_CONN_LPCG_ENET1_ROOT_CLK			19
-#define IMX_CONN_LPCG_ENET1_TX_CLK			20
-#define IMX_CONN_LPCG_ENET1_AHB_CLK			21
-#define IMX_CONN_LPCG_ENET1_IPG_S_CLK			22
-#define IMX_CONN_LPCG_ENET1_IPG_CLK			23
-
-#define IMX_CONN_LPCG_CLK_END				24
-
-/* ADMA SS LPCG */
-#define IMX_ADMA_LPCG_UART0_IPG_CLK			0
-#define IMX_ADMA_LPCG_UART0_BAUD_CLK			1
-#define IMX_ADMA_LPCG_UART1_IPG_CLK			2
-#define IMX_ADMA_LPCG_UART1_BAUD_CLK			3
-#define IMX_ADMA_LPCG_UART2_IPG_CLK			4
-#define IMX_ADMA_LPCG_UART2_BAUD_CLK			5
-#define IMX_ADMA_LPCG_UART3_IPG_CLK			6
-#define IMX_ADMA_LPCG_UART3_BAUD_CLK			7
-#define IMX_ADMA_LPCG_SPI0_IPG_CLK			8
-#define IMX_ADMA_LPCG_SPI1_IPG_CLK			9
-#define IMX_ADMA_LPCG_SPI2_IPG_CLK			10
-#define IMX_ADMA_LPCG_SPI3_IPG_CLK			11
-#define IMX_ADMA_LPCG_SPI0_CLK				12
-#define IMX_ADMA_LPCG_SPI1_CLK				13
-#define IMX_ADMA_LPCG_SPI2_CLK				14
-#define IMX_ADMA_LPCG_SPI3_CLK				15
-#define IMX_ADMA_LPCG_CAN0_IPG_CLK			16
-#define IMX_ADMA_LPCG_CAN0_IPG_PE_CLK			17
-#define IMX_ADMA_LPCG_CAN0_IPG_CHI_CLK			18
-#define IMX_ADMA_LPCG_CAN1_IPG_CLK			19
-#define IMX_ADMA_LPCG_CAN1_IPG_PE_CLK			20
-#define IMX_ADMA_LPCG_CAN1_IPG_CHI_CLK			21
-#define IMX_ADMA_LPCG_CAN2_IPG_CLK			22
-#define IMX_ADMA_LPCG_CAN2_IPG_PE_CLK			23
-#define IMX_ADMA_LPCG_CAN2_IPG_CHI_CLK			24
-#define IMX_ADMA_LPCG_I2C0_CLK				25
-#define IMX_ADMA_LPCG_I2C1_CLK				26
-#define IMX_ADMA_LPCG_I2C2_CLK				27
-#define IMX_ADMA_LPCG_I2C3_CLK				28
-#define IMX_ADMA_LPCG_I2C0_IPG_CLK			29
-#define IMX_ADMA_LPCG_I2C1_IPG_CLK			30
-#define IMX_ADMA_LPCG_I2C2_IPG_CLK			31
-#define IMX_ADMA_LPCG_I2C3_IPG_CLK			32
-#define IMX_ADMA_LPCG_FTM0_CLK				33
-#define IMX_ADMA_LPCG_FTM1_CLK				34
-#define IMX_ADMA_LPCG_FTM0_IPG_CLK			35
-#define IMX_ADMA_LPCG_FTM1_IPG_CLK			36
-#define IMX_ADMA_LPCG_PWM_HI_CLK			37
-#define IMX_ADMA_LPCG_PWM_IPG_CLK			38
-#define IMX_ADMA_LPCG_LCD_PIX_CLK			39
-#define IMX_ADMA_LPCG_LCD_APB_CLK			40
-#define IMX_ADMA_LPCG_DSP_ADB_CLK			41
-#define IMX_ADMA_LPCG_DSP_IPG_CLK			42
-#define IMX_ADMA_LPCG_DSP_CORE_CLK			43
-#define IMX_ADMA_LPCG_OCRAM_IPG_CLK			44
-
-#define IMX_ADMA_LPCG_CLK_END				45
+#define IMX_ADMA_ACM_CLK_END				50
 
 #endif /* __DT_BINDINGS_CLOCK_IMX_H */
diff --git a/include/dt-bindings/clock/imx8mp-clock.h b/include/dt-bindings/clock/imx8mp-clock.h
index 43927a1b9..252820008 100644
--- a/include/dt-bindings/clock/imx8mp-clock.h
+++ b/include/dt-bindings/clock/imx8mp-clock.h
@@ -117,7 +117,6 @@
 #define IMX8MP_CLK_AUDIO_AHB			108
 #define IMX8MP_CLK_MIPI_DSI_ESC_RX		109
 #define IMX8MP_CLK_IPG_ROOT			110
-#define IMX8MP_CLK_IPG_AUDIO_ROOT		111
 #define IMX8MP_CLK_DRAM_ALT			112
 #define IMX8MP_CLK_DRAM_APB			113
 #define IMX8MP_CLK_VPU_G1			114
@@ -319,68 +318,144 @@
 #define IMX8MP_CLK_HSIO_AXI			311
 #define IMX8MP_CLK_MEDIA_ISP			312
 
-#define IMX8MP_CLK_END				313
+#define IMX8MP_CLK_MEDIA_DISP2_PIX		313
+#define IMX8MP_CLK_MEDIA_LDB_ROOT		314
+#define IMX8MP_CLK_AUDIO_AHB_ROOT		315
+#define IMX8MP_CLK_AUDIO_AXI_ROOT		316
+#define IMX8MP_CLK_SAI1_ROOT			317
+#define IMX8MP_CLK_SAI2_ROOT			318
+#define IMX8MP_CLK_SAI3_ROOT			319
+#define IMX8MP_CLK_SAI5_ROOT			320
+#define IMX8MP_CLK_SAI6_ROOT			321
+#define IMX8MP_CLK_SAI7_ROOT			322
+#define IMX8MP_CLK_PDM_ROOT			323
 
-#define IMX8MP_CLK_AUDIOMIX_SAI1_IPG		0
-#define IMX8MP_CLK_AUDIOMIX_SAI1_MCLK1		1
-#define IMX8MP_CLK_AUDIOMIX_SAI1_MCLK2		2
-#define IMX8MP_CLK_AUDIOMIX_SAI1_MCLK3		3
-#define IMX8MP_CLK_AUDIOMIX_SAI2_IPG		4
-#define IMX8MP_CLK_AUDIOMIX_SAI2_MCLK1		5
-#define IMX8MP_CLK_AUDIOMIX_SAI2_MCLK2		6
-#define IMX8MP_CLK_AUDIOMIX_SAI2_MCLK3		7
-#define IMX8MP_CLK_AUDIOMIX_SAI3_IPG		8
-#define IMX8MP_CLK_AUDIOMIX_SAI3_MCLK1		9
-#define IMX8MP_CLK_AUDIOMIX_SAI3_MCLK2		10
-#define IMX8MP_CLK_AUDIOMIX_SAI3_MCLK3		11
-#define IMX8MP_CLK_AUDIOMIX_SAI5_IPG		12
-#define IMX8MP_CLK_AUDIOMIX_SAI5_MCLK1		13
-#define IMX8MP_CLK_AUDIOMIX_SAI5_MCLK2		14
-#define IMX8MP_CLK_AUDIOMIX_SAI5_MCLK3		15
-#define IMX8MP_CLK_AUDIOMIX_SAI6_IPG		16
-#define IMX8MP_CLK_AUDIOMIX_SAI6_MCLK1		17
-#define IMX8MP_CLK_AUDIOMIX_SAI6_MCLK2		18
-#define IMX8MP_CLK_AUDIOMIX_SAI6_MCLK3		19
-#define IMX8MP_CLK_AUDIOMIX_SAI7_IPG		20
-#define IMX8MP_CLK_AUDIOMIX_SAI7_MCLK1		21
-#define IMX8MP_CLK_AUDIOMIX_SAI7_MCLK2		22
-#define IMX8MP_CLK_AUDIOMIX_SAI7_MCLK3		23
-#define IMX8MP_CLK_AUDIOMIX_ASRC_IPG		24
-#define IMX8MP_CLK_AUDIOMIX_PDM_IPG		25
-#define IMX8MP_CLK_AUDIOMIX_SDMA2_ROOT		26
-#define IMX8MP_CLK_AUDIOMIX_SDMA3_ROOT		27
-#define IMX8MP_CLK_AUDIOMIX_SPBA2_ROOT		28
-#define IMX8MP_CLK_AUDIOMIX_DSP_ROOT		29
-#define IMX8MP_CLK_AUDIOMIX_DSPDBG_ROOT		30
-#define IMX8MP_CLK_AUDIOMIX_EARC_IPG		31
-#define IMX8MP_CLK_AUDIOMIX_OCRAMA_IPG		32
-#define IMX8MP_CLK_AUDIOMIX_AUD2HTX_IPG		33
-#define IMX8MP_CLK_AUDIOMIX_EDMA_ROOT		34
-#define IMX8MP_CLK_AUDIOMIX_AUDPLL_ROOT		35
-#define IMX8MP_CLK_AUDIOMIX_MU2_ROOT		36
-#define IMX8MP_CLK_AUDIOMIX_MU3_ROOT		37
-#define IMX8MP_CLK_AUDIOMIX_EARC_PHY		38
-#define IMX8MP_CLK_AUDIOMIX_PDM_ROOT		39
-#define IMX8MP_CLK_AUDIOMIX_SAI1_MCLK1_SEL	40
-#define IMX8MP_CLK_AUDIOMIX_SAI1_MCLK2_SEL	41
-#define IMX8MP_CLK_AUDIOMIX_SAI2_MCLK1_SEL	42
-#define IMX8MP_CLK_AUDIOMIX_SAI2_MCLK2_SEL	43
-#define IMX8MP_CLK_AUDIOMIX_SAI3_MCLK1_SEL	44
-#define IMX8MP_CLK_AUDIOMIX_SAI3_MCLK2_SEL	45
-#define IMX8MP_CLK_AUDIOMIX_SAI4_MCLK1_SEL	46
-#define IMX8MP_CLK_AUDIOMIX_SAI4_MCLK2_SEL	47
-#define IMX8MP_CLK_AUDIOMIX_SAI5_MCLK1_SEL	48
-#define IMX8MP_CLK_AUDIOMIX_SAI5_MCLK2_SEL	49
-#define IMX8MP_CLK_AUDIOMIX_SAI6_MCLK1_SEL	50
-#define IMX8MP_CLK_AUDIOMIX_SAI6_MCLK2_SEL	51
-#define IMX8MP_CLK_AUDIOMIX_SAI7_MCLK1_SEL	52
-#define IMX8MP_CLK_AUDIOMIX_SAI7_MCLK2_SEL	53
-#define IMX8MP_CLK_AUDIOMIX_PDM_SEL		54
-#define IMX8MP_CLK_AUDIOMIX_SAI_PLL_REF_SEL	55
-#define IMX8MP_CLK_AUDIOMIX_SAI_PLL		56
-#define IMX8MP_CLK_AUDIOMIX_SAI_PLL_BYPASS	57
-#define IMX8MP_CLK_AUDIOMIX_SAI_PLL_OUT		58
+#define IMX8MP_CLK_END				331
 
-#define IMX8MP_CLK_AUDIOMIX_END			59
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI1_IPG		0
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI1_MCLK1		1
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI1_MCLK2		2
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI1_MCLK3		3
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI2_IPG		4
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI2_MCLK1		5
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI2_MCLK2		6
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI2_MCLK3		7
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI3_IPG		8
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI3_MCLK1		9
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI3_MCLK2		10
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI3_MCLK3		11
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI5_IPG		12
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI5_MCLK1		13
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI5_MCLK2		14
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI5_MCLK3		15
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI6_IPG		16
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI6_MCLK1		17
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI6_MCLK2		18
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI6_MCLK3		19
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI7_IPG		20
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI7_MCLK1		21
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI7_MCLK2		22
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI7_MCLK3		23
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_ASRC_IPG		24
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_PDM_IPG		25
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SDMA3_ROOT		27
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SPBA2_ROOT		28
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_DSP_ROOT		29
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_DSPDBG_ROOT		30
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_EARC_IPG		31
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_OCRAMA_IPG		32
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_AUD2HTX_IPG		33
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_EDMA_ROOT		34
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_AUDPLL_ROOT		35
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_MU2_ROOT		36
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_MU3_ROOT		37
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_EARC_PHY		38
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_PDM_ROOT		39
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI1_MCLK1_SEL	40
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI1_MCLK2_SEL	41
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI2_MCLK1_SEL	42
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI2_MCLK2_SEL	43
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI3_MCLK1_SEL	44
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI3_MCLK2_SEL	45
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI4_MCLK1_SEL	46
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI4_MCLK2_SEL	47
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI5_MCLK1_SEL	48
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI5_MCLK2_SEL	49
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI6_MCLK1_SEL	50
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI6_MCLK2_SEL	51
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI7_MCLK1_SEL	52
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI7_MCLK2_SEL	53
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_PDM_SEL		54
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI_PLL_REF_SEL	55
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI_PLL		56
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI_PLL_BYPASS	57
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI_PLL_OUT		58
+
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_END			59
+
+#define IMX8MP_CLK_HDMI_BLK_CTRL_GLOBAL_APB_CLK		0
+#define IMX8MP_CLK_HDMI_BLK_CTRL_GLOBAL_B_CLK		1
+#define IMX8MP_CLK_HDMI_BLK_CTRL_GLOBAL_REF266M_CLK	2
+#define IMX8MP_CLK_HDMI_BLK_CTRL_GLOBAL_XTAL24M_CLK	3
+#define IMX8MP_CLK_HDMI_BLK_CTRL_GLOBAL_XTAL32K_CLK	4
+#define IMX8MP_CLK_HDMI_BLK_CTRL_GLOBAL_TX_PIX_CLK	5
+#define IMX8MP_CLK_HDMI_BLK_CTRL_IRQS_STEER_CLK		6
+#define IMX8MP_CLK_HDMI_BLK_CTRL_NOC_HDMI_CLK		7
+#define IMX8MP_CLK_HDMI_BLK_CTRL_NOC_HDCP_CLK		8
+#define IMX8MP_CLK_HDMI_BLK_CTRL_LCDIF_APB_CLK		9
+#define IMX8MP_CLK_HDMI_BLK_CTRL_LCDIF_B_CLK		10
+#define IMX8MP_CLK_HDMI_BLK_CTRL_LCDIF_PDI_CLK		11
+#define IMX8MP_CLK_HDMI_BLK_CTRL_LCDIF_PIX_CLK		12
+#define IMX8MP_CLK_HDMI_BLK_CTRL_LCDIF_SPU_CLK		13
+#define IMX8MP_CLK_HDMI_BLK_CTRL_FDCC_REF_CLK		14
+#define IMX8MP_CLK_HDMI_BLK_CTRL_HRV_MWR_APB_CLK	15
+#define IMX8MP_CLK_HDMI_BLK_CTRL_HRV_MWR_B_CLK		16
+#define IMX8MP_CLK_HDMI_BLK_CTRL_HRV_MWR_CEA_CLK	17
+#define IMX8MP_CLK_HDMI_BLK_CTRL_VSFD_CEA_CLK		18
+#define IMX8MP_CLK_HDMI_BLK_CTRL_TX_HPI_CLK		19
+#define IMX8MP_CLK_HDMI_BLK_CTRL_TX_APB_CLK		20
+#define IMX8MP_CLK_HDMI_BLK_CTRL_TX_CEC_CLK		21
+#define IMX8MP_CLK_HDMI_BLK_CTRL_TX_ESM_CLK		22
+#define IMX8MP_CLK_HDMI_BLK_CTRL_TX_GPA_CLK		23
+#define IMX8MP_CLK_HDMI_BLK_CTRL_TX_PIXEL_CLK		24
+#define IMX8MP_CLK_HDMI_BLK_CTRL_TX_SFR_CLK		25
+#define IMX8MP_CLK_HDMI_BLK_CTRL_TX_SKP_CLK		26
+#define IMX8MP_CLK_HDMI_BLK_CTRL_TX_PREP_CLK		27
+#define IMX8MP_CLK_HDMI_BLK_CTRL_TX_PHY_APB_CLK		28
+#define IMX8MP_CLK_HDMI_BLK_CTRL_TX_PHY_INT_CLK		29
+#define IMX8MP_CLK_HDMI_BLK_CTRL_TX_SEC_MEM_CLK		30
+#define IMX8MP_CLK_HDMI_BLK_CTRL_TX_TRNG_SKP_CLK	31
+#define IMX8MP_CLK_HDMI_BLK_CTRL_TX_VID_LINK_PIX_CLK	32
+#define IMX8MP_CLK_HDMI_BLK_CTRL_TX_TRNG_APB_CLK	33
+#define IMX8MP_CLK_HDMI_BLK_CTRL_HTXPHY_CLK_SEL		34
+#define IMX8MP_CLK_HDMI_BLK_CTRL_LCDIF_CLK_SEL		35
+#define IMX8MP_CLK_HDMI_BLK_CTRL_TX_PIPE_CLK_SEL	36
+
+#define IMX8MP_CLK_HDMI_BLK_CTRL_END			37
+
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_MIPI_DSI_PCLK		0
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_MIPI_DSI_CLKREF	1
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_MIPI_CSI_PCLK		2
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_MIPI_CSI_ACLK		3
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_LCDIF_PIXEL		4
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_LCDIF_APB		5
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_ISI_PROC		6
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_ISI_APB		7
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_BUS_BLK		8
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_MIPI_CSI2_PCLK	9
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_MIPI_CSI2_ACLK	10
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_LCDIF2_PIXEL		11
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_LCDIF2_APB		12
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_ISP_COR		16
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_ISP_AXI		17
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_ISP_AHB		18
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_DWE_COR		19
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_DWE_AXI		20
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_DWE_AHB		21
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_MIPI_DSI2		22
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_LCDIF_AXI		23
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_LCDIF2_AXI		24
+
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_END			25
 
 #endif
diff --git a/include/dt-bindings/clock/imx8mq-clock.h b/include/dt-bindings/clock/imx8mq-clock.h
index afa74d7ba..97df21266 100644
--- a/include/dt-bindings/clock/imx8mq-clock.h
+++ b/include/dt-bindings/clock/imx8mq-clock.h
@@ -426,6 +426,7 @@
 #define IMX8MQ_CLK_MON_SEL			301
 #define IMX8MQ_CLK_MON_CLK2_OUT			302
 
-#define IMX8MQ_CLK_END				303
+#define IMX8MQ_CLK_PHY_27MHZ			303
 
+#define IMX8MQ_CLK_END				304
 #endif /* __DT_BINDINGS_CLOCK_IMX8MQ_H */
diff --git a/include/dt-bindings/clock/imx8ulp-clock.h b/include/dt-bindings/clock/imx8ulp-clock.h
new file mode 100644
index 000000000..cb449c991
--- /dev/null
+++ b/include/dt-bindings/clock/imx8ulp-clock.h
@@ -0,0 +1,262 @@
+/* SPDX-License-Identifier: GPL-2.0+ OR MIT */
+/*
+ * Copyright 2021 NXP
+ */
+
+#ifndef __DT_BINDINGS_CLOCK_IMX8ULP_H
+#define __DT_BINDINGS_CLOCK_IMX8ULP_H
+
+#define IMX8ULP_CLK_DUMMY			0
+#define IMX8ULP_CLK_ROSC			1
+#define IMX8ULP_CLK_FROSC			2
+#define IMX8ULP_CLK_LPOSC			3
+#define IMX8ULP_CLK_SOSC			4
+
+/* CGC1 */
+#define IMX8ULP_CLK_SPLL2			5
+#define IMX8ULP_CLK_SPLL3			6
+#define IMX8ULP_CLK_A35_SEL			7
+#define IMX8ULP_CLK_A35_DIV			8
+#define IMX8ULP_CLK_SPLL2_PRE_SEL		9
+#define IMX8ULP_CLK_SPLL3_PRE_SEL		10
+#define IMX8ULP_CLK_SPLL3_PFD0			11
+#define IMX8ULP_CLK_SPLL3_PFD1			12
+#define IMX8ULP_CLK_SPLL3_PFD2			13
+#define IMX8ULP_CLK_SPLL3_PFD3			14
+#define IMX8ULP_CLK_SPLL3_PFD0_DIV1		15
+#define IMX8ULP_CLK_SPLL3_PFD0_DIV2		16
+#define IMX8ULP_CLK_SPLL3_PFD1_DIV1		17
+#define IMX8ULP_CLK_SPLL3_PFD1_DIV2		18
+#define IMX8ULP_CLK_SPLL3_PFD2_DIV1		19
+#define IMX8ULP_CLK_SPLL3_PFD2_DIV2		20
+#define IMX8ULP_CLK_SPLL3_PFD3_DIV1		21
+#define IMX8ULP_CLK_SPLL3_PFD3_DIV2		22
+#define IMX8ULP_CLK_NIC_SEL			23
+#define IMX8ULP_CLK_NIC_AD_DIVPLAT		24
+#define IMX8ULP_CLK_NIC_PER_DIVPLAT		25
+#define IMX8ULP_CLK_XBAR_SEL			26
+#define IMX8ULP_CLK_XBAR_AD_DIVPLAT		27
+#define IMX8ULP_CLK_XBAR_DIVBUS			28
+#define IMX8ULP_CLK_XBAR_AD_SLOW		29
+#define IMX8ULP_CLK_SOSC_DIV1			30
+#define IMX8ULP_CLK_SOSC_DIV2			31
+#define IMX8ULP_CLK_SOSC_DIV3			32
+#define IMX8ULP_CLK_FROSC_DIV1			33
+#define IMX8ULP_CLK_FROSC_DIV2			34
+#define IMX8ULP_CLK_FROSC_DIV3			35
+#define IMX8ULP_CLK_SPLL3_VCODIV		36
+#define IMX8ULP_CLK_SPLL3_PFD0_DIV1_GATE	37
+#define IMX8ULP_CLK_SPLL3_PFD0_DIV2_GATE	38
+#define IMX8ULP_CLK_SPLL3_PFD1_DIV1_GATE	39
+#define IMX8ULP_CLK_SPLL3_PFD1_DIV2_GATE	40
+#define IMX8ULP_CLK_SPLL3_PFD2_DIV1_GATE	41
+#define IMX8ULP_CLK_SPLL3_PFD2_DIV2_GATE	42
+#define IMX8ULP_CLK_SPLL3_PFD3_DIV1_GATE	43
+#define IMX8ULP_CLK_SPLL3_PFD3_DIV2_GATE	44
+#define IMX8ULP_CLK_SOSC_DIV1_GATE		45
+#define IMX8ULP_CLK_SOSC_DIV2_GATE		46
+#define IMX8ULP_CLK_SOSC_DIV3_GATE		47
+#define IMX8ULP_CLK_FROSC_DIV1_GATE		48
+#define IMX8ULP_CLK_FROSC_DIV2_GATE		49
+#define IMX8ULP_CLK_FROSC_DIV3_GATE		50
+#define IMX8ULP_CLK_SAI4_SEL			51
+#define IMX8ULP_CLK_SAI5_SEL			52
+#define IMX8ULP_CLK_AUD_CLK1			53
+#define IMX8ULP_CLK_ARM				54
+#define IMX8ULP_CLK_ENET_TS_SEL			55
+
+#define IMX8ULP_CLK_CGC1_END			56
+
+/* CGC2 */
+#define IMX8ULP_CLK_PLL4_PRE_SEL	0
+#define IMX8ULP_CLK_PLL4		1
+#define IMX8ULP_CLK_PLL4_VCODIV		2
+#define IMX8ULP_CLK_DDR_SEL		3
+#define IMX8ULP_CLK_DDR_DIV		4
+#define IMX8ULP_CLK_LPAV_AXI_SEL	5
+#define IMX8ULP_CLK_LPAV_AXI_DIV	6
+#define IMX8ULP_CLK_LPAV_AHB_DIV	7
+#define IMX8ULP_CLK_LPAV_BUS_DIV	8
+#define IMX8ULP_CLK_PLL4_PFD0		9
+#define IMX8ULP_CLK_PLL4_PFD1		10
+#define IMX8ULP_CLK_PLL4_PFD2		11
+#define IMX8ULP_CLK_PLL4_PFD3		12
+#define IMX8ULP_CLK_PLL4_PFD0_DIV1_GATE	13
+#define IMX8ULP_CLK_PLL4_PFD0_DIV2_GATE	14
+#define IMX8ULP_CLK_PLL4_PFD1_DIV1_GATE	15
+#define IMX8ULP_CLK_PLL4_PFD1_DIV2_GATE	16
+#define IMX8ULP_CLK_PLL4_PFD2_DIV1_GATE	17
+#define IMX8ULP_CLK_PLL4_PFD2_DIV2_GATE	18
+#define IMX8ULP_CLK_PLL4_PFD3_DIV1_GATE	19
+#define IMX8ULP_CLK_PLL4_PFD3_DIV2_GATE	20
+#define IMX8ULP_CLK_PLL4_PFD0_DIV1	21
+#define IMX8ULP_CLK_PLL4_PFD0_DIV2	22
+#define IMX8ULP_CLK_PLL4_PFD1_DIV1	23
+#define IMX8ULP_CLK_PLL4_PFD1_DIV2	24
+#define IMX8ULP_CLK_PLL4_PFD2_DIV1	25
+#define IMX8ULP_CLK_PLL4_PFD2_DIV2	26
+#define IMX8ULP_CLK_PLL4_PFD3_DIV1	27
+#define IMX8ULP_CLK_PLL4_PFD3_DIV2	28
+#define IMX8ULP_CLK_CGC2_SOSC_DIV1_GATE	29
+#define IMX8ULP_CLK_CGC2_SOSC_DIV2_GATE	30
+#define IMX8ULP_CLK_CGC2_SOSC_DIV3_GATE	31
+#define IMX8ULP_CLK_CGC2_SOSC_DIV1	32
+#define IMX8ULP_CLK_CGC2_SOSC_DIV2	33
+#define IMX8ULP_CLK_CGC2_SOSC_DIV3	34
+#define IMX8ULP_CLK_CGC2_FROSC_DIV1_GATE	35
+#define IMX8ULP_CLK_CGC2_FROSC_DIV2_GATE	36
+#define IMX8ULP_CLK_CGC2_FROSC_DIV3_GATE	37
+#define IMX8ULP_CLK_CGC2_FROSC_DIV1	38
+#define IMX8ULP_CLK_CGC2_FROSC_DIV2	39
+#define IMX8ULP_CLK_CGC2_FROSC_DIV3	40
+#define IMX8ULP_CLK_AUD_CLK2		41
+#define IMX8ULP_CLK_SAI6_SEL		42
+#define IMX8ULP_CLK_SAI7_SEL		43
+#define IMX8ULP_CLK_SPDIF_SEL		44
+#define IMX8ULP_CLK_HIFI_SEL		45
+#define IMX8ULP_CLK_HIFI_DIVCORE	46
+#define IMX8ULP_CLK_HIFI_DIVPLAT	47
+#define IMX8ULP_CLK_DSI_PHY_REF		48
+
+#define IMX8ULP_CLK_CGC2_END		49
+
+/* PCC3 */
+#define IMX8ULP_CLK_WDOG3		0
+#define IMX8ULP_CLK_WDOG4		1
+#define IMX8ULP_CLK_LPIT1		2
+#define IMX8ULP_CLK_TPM4		3
+#define IMX8ULP_CLK_TPM5		4
+#define IMX8ULP_CLK_FLEXIO1		5
+#define IMX8ULP_CLK_I3C2		6
+#define IMX8ULP_CLK_LPI2C4		7
+#define IMX8ULP_CLK_LPI2C5		8
+#define IMX8ULP_CLK_LPUART4		9
+#define IMX8ULP_CLK_LPUART5		10
+#define IMX8ULP_CLK_LPSPI4		11
+#define IMX8ULP_CLK_LPSPI5		12
+#define IMX8ULP_CLK_DMA1_MP		13
+#define IMX8ULP_CLK_DMA1_CH0		14
+#define IMX8ULP_CLK_DMA1_CH1		15
+#define IMX8ULP_CLK_DMA1_CH2		16
+#define IMX8ULP_CLK_DMA1_CH3		17
+#define IMX8ULP_CLK_DMA1_CH4		18
+#define IMX8ULP_CLK_DMA1_CH5		19
+#define IMX8ULP_CLK_DMA1_CH6		20
+#define IMX8ULP_CLK_DMA1_CH7		21
+#define IMX8ULP_CLK_DMA1_CH8		22
+#define IMX8ULP_CLK_DMA1_CH9		23
+#define IMX8ULP_CLK_DMA1_CH10		24
+#define IMX8ULP_CLK_DMA1_CH11		25
+#define IMX8ULP_CLK_DMA1_CH12		26
+#define IMX8ULP_CLK_DMA1_CH13		27
+#define IMX8ULP_CLK_DMA1_CH14		28
+#define IMX8ULP_CLK_DMA1_CH15		29
+#define IMX8ULP_CLK_DMA1_CH16		30
+#define IMX8ULP_CLK_DMA1_CH17		31
+#define IMX8ULP_CLK_DMA1_CH18		32
+#define IMX8ULP_CLK_DMA1_CH19		33
+#define IMX8ULP_CLK_DMA1_CH20		34
+#define IMX8ULP_CLK_DMA1_CH21		35
+#define IMX8ULP_CLK_DMA1_CH22		36
+#define IMX8ULP_CLK_DMA1_CH23		37
+#define IMX8ULP_CLK_DMA1_CH24		38
+#define IMX8ULP_CLK_DMA1_CH25		39
+#define IMX8ULP_CLK_DMA1_CH26		40
+#define IMX8ULP_CLK_DMA1_CH27		41
+#define IMX8ULP_CLK_DMA1_CH28		42
+#define IMX8ULP_CLK_DMA1_CH29		43
+#define IMX8ULP_CLK_DMA1_CH30		44
+#define IMX8ULP_CLK_DMA1_CH31		45
+#define IMX8ULP_CLK_MU3_A		46
+#define IMX8ULP_CLK_MU0_B		47
+
+#define IMX8ULP_CLK_PCC3_END		48
+
+/* PCC4 */
+#define IMX8ULP_CLK_FLEXSPI2		0
+#define IMX8ULP_CLK_TPM6		1
+#define IMX8ULP_CLK_TPM7		2
+#define IMX8ULP_CLK_LPI2C6		3
+#define IMX8ULP_CLK_LPI2C7		4
+#define IMX8ULP_CLK_LPUART6		5
+#define IMX8ULP_CLK_LPUART7		6
+#define IMX8ULP_CLK_SAI4		7
+#define IMX8ULP_CLK_SAI5		8
+#define IMX8ULP_CLK_PCTLE		9
+#define IMX8ULP_CLK_PCTLF		10
+#define IMX8ULP_CLK_USDHC0		11
+#define IMX8ULP_CLK_USDHC1		12
+#define IMX8ULP_CLK_USDHC2		13
+#define IMX8ULP_CLK_USB0		14
+#define IMX8ULP_CLK_USB0_PHY		15
+#define IMX8ULP_CLK_USB1		16
+#define IMX8ULP_CLK_USB1_PHY		17
+#define IMX8ULP_CLK_USB_XBAR		18
+#define IMX8ULP_CLK_ENET		19
+#define IMX8ULP_CLK_SFA1		20
+#define IMX8ULP_CLK_RGPIOE		21
+#define IMX8ULP_CLK_RGPIOF		22
+
+#define IMX8ULP_CLK_PCC4_END		23
+
+/* PCC5 */
+#define IMX8ULP_CLK_TPM8		0
+#define IMX8ULP_CLK_SAI6		1
+#define IMX8ULP_CLK_SAI7		2
+#define IMX8ULP_CLK_SPDIF		3
+#define IMX8ULP_CLK_ISI			4
+#define IMX8ULP_CLK_CSI_REGS 		5
+#define IMX8ULP_CLK_PCTLD		6
+#define IMX8ULP_CLK_CSI			7
+#define IMX8ULP_CLK_DSI			8
+#define IMX8ULP_CLK_WDOG5		9
+#define IMX8ULP_CLK_EPDC		10
+#define IMX8ULP_CLK_PXP			11
+#define IMX8ULP_CLK_SFA2		12
+#define IMX8ULP_CLK_GPU2D		13
+#define IMX8ULP_CLK_GPU3D		14
+#define IMX8ULP_CLK_DC_NANO		15
+#define IMX8ULP_CLK_CSI_CLK_UI 		16
+#define IMX8ULP_CLK_CSI_CLK_ESC		17
+#define IMX8ULP_CLK_RGPIOD		18
+#define IMX8ULP_CLK_DMA2_MP		19
+#define IMX8ULP_CLK_DMA2_CH0		20
+#define IMX8ULP_CLK_DMA2_CH1		21
+#define IMX8ULP_CLK_DMA2_CH2		22
+#define IMX8ULP_CLK_DMA2_CH3		23
+#define IMX8ULP_CLK_DMA2_CH4		24
+#define IMX8ULP_CLK_DMA2_CH5		25
+#define IMX8ULP_CLK_DMA2_CH6		26
+#define IMX8ULP_CLK_DMA2_CH7		27
+#define IMX8ULP_CLK_DMA2_CH8		28
+#define IMX8ULP_CLK_DMA2_CH9		29
+#define IMX8ULP_CLK_DMA2_CH10		30
+#define IMX8ULP_CLK_DMA2_CH11		31
+#define IMX8ULP_CLK_DMA2_CH12		32
+#define IMX8ULP_CLK_DMA2_CH13		33
+#define IMX8ULP_CLK_DMA2_CH14		34
+#define IMX8ULP_CLK_DMA2_CH15		35
+#define IMX8ULP_CLK_DMA2_CH16		36
+#define IMX8ULP_CLK_DMA2_CH17		37
+#define IMX8ULP_CLK_DMA2_CH18		38
+#define IMX8ULP_CLK_DMA2_CH19		39
+#define IMX8ULP_CLK_DMA2_CH20		40
+#define IMX8ULP_CLK_DMA2_CH21		41
+#define IMX8ULP_CLK_DMA2_CH22		42
+#define IMX8ULP_CLK_DMA2_CH23		43
+#define IMX8ULP_CLK_DMA2_CH24		44
+#define IMX8ULP_CLK_DMA2_CH25		45
+#define IMX8ULP_CLK_DMA2_CH26		46
+#define IMX8ULP_CLK_DMA2_CH27		47
+#define IMX8ULP_CLK_DMA2_CH28		48
+#define IMX8ULP_CLK_DMA2_CH29		49
+#define IMX8ULP_CLK_DMA2_CH30		50
+#define IMX8ULP_CLK_DMA2_CH31		51
+#define IMX8ULP_CLK_MU2_B		52
+#define IMX8ULP_CLK_MU3_B		53
+#define IMX8ULP_CLK_AVD_SIM		54
+#define IMX8ULP_CLK_DSI_TX_ESC		55
+
+#define IMX8ULP_CLK_PCC5_END		56
+
+#endif
diff --git a/include/dt-bindings/clock/s32v234-clock.h b/include/dt-bindings/clock/s32v234-clock.h
new file mode 100644
index 000000000..1ddfae5c1
--- /dev/null
+++ b/include/dt-bindings/clock/s32v234-clock.h
@@ -0,0 +1,65 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
+ * Copyright (C) 2017 NXP
+ */
+
+#ifndef __DT_BINDINGS_CLOCK_S32V234_H
+#define __DT_BINDINGS_CLOCK_S32V234_H
+
+#define	S32V234_CLK_DUMMY			0
+#define	S32V234_CLK_FXOSC			1
+#define	S32V234_CLK_FIRC			2
+/* PERIPH PLL */
+#define	S32V234_CLK_PERIPHPLL_SRC_SEL		3
+#define	S32V234_CLK_PERIPHPLL_VCO		4
+#define	S32V234_CLK_PERIPHPLL_PHI0		5
+#define	S32V234_CLK_PERIPHPLL_PHI0_DIV3		6
+#define	S32V234_CLK_PERIPHPLL_PHI0_DIV5		7
+#define	S32V234_CLK_PERIPHPLL_PHI1		8
+/* LINFlexD Clock */
+#define	S32V234_CLK_LIN				9
+#define	S32V234_CLK_LIN_SEL			10
+#define	S32V234_CLK_LIN_IPG			11
+/* SDHC Clock */
+#define	S32V234_CLK_SDHC			12
+#define	S32V234_CLK_SDHC_SEL			13
+/* ENET PLL */
+#define	S32V234_CLK_ENETPLL_SRC_SEL		14
+#define	S32V234_CLK_ENETPLL_VCO			15
+#define	S32V234_CLK_ENETPLL_PHI0		16
+#define	S32V234_CLK_ENETPLL_PHI1		17
+#define	S32V234_CLK_ENETPLL_DFS0		18
+#define	S32V234_CLK_ENETPLL_DFS1		19
+#define	S32V234_CLK_ENETPLL_DFS2		20
+#define	S32V234_CLK_ENETPLL_DFS3		21
+/* System Clock */
+#define	S32V234_CLK_SYS_SEL			22
+#define	S32V234_CLK_SYS3			23
+#define	S32V234_CLK_SYS6			24
+#define	S32V234_CLK_SYS6_DIV2			25
+/* ENET Clock */
+#define	S32V234_CLK_ENET_TIME_DIV		26
+#define	S32V234_CLK_ENET_TIME_SEL		27
+#define	S32V234_CLK_ENET_DIV			28
+#define	S32V234_CLK_ENET_SEL			29
+
+#define	S32V234_CLK_ENET			30
+#define	S32V234_CLK_ENET_TIME			31
+
+/* ARM PLL */
+#define	S32V234_CLK_ARMPLL_SRC_SEL		32
+#define	S32V234_CLK_ARMPLL_VCO			33
+#define	S32V234_CLK_ARMPLL_PHI0			34
+#define	S32V234_CLK_ARMPLL_PHI1			35
+#define	S32V234_CLK_ARMPLL_DFS0			35
+#define	S32V234_CLK_ARMPLL_DFS1			36
+#define	S32V234_CLK_ARMPLL_DFS2			37
+
+/* CAN Clock */
+#define S32V234_CLK_CAN				38
+#define S32V234_CLK_CAN_SEL			39
+
+#define	S32V234_CLK_END				40
+
+#endif /* __DT_BINDINGS_CLOCK_S32V234_H */
diff --git a/include/dt-bindings/firmware/imx/rsrc.h b/include/dt-bindings/firmware/imx/rsrc.h
index 438850565..00fceda4b 100644
--- a/include/dt-bindings/firmware/imx/rsrc.h
+++ b/include/dt-bindings/firmware/imx/rsrc.h
@@ -37,10 +37,14 @@
 #define IMX_SC_R_DC_0_BLIT2		21
 #define IMX_SC_R_DC_0_BLIT_OUT		22
 #define IMX_SC_R_PERF			23
+#define IMX_SC_R_USB_1_PHY		24
 #define IMX_SC_R_DC_0_WARP		25
+#define IMX_SC_R_V2X_MU_0		26
+#define IMX_SC_R_V2X_MU_1		27
 #define IMX_SC_R_DC_0_VIDEO0		28
 #define IMX_SC_R_DC_0_VIDEO1		29
 #define IMX_SC_R_DC_0_FRAC0		30
+#define IMX_SC_R_V2X_MU_2		31
 #define IMX_SC_R_DC_0			32
 #define IMX_SC_R_GPU_2_PID0		33
 #define IMX_SC_R_DC_0_PLL_0		34
@@ -49,7 +53,10 @@
 #define IMX_SC_R_DC_1_BLIT1		37
 #define IMX_SC_R_DC_1_BLIT2		38
 #define IMX_SC_R_DC_1_BLIT_OUT		39
+#define IMX_SC_R_V2X_MU_3		40
+#define IMX_SC_R_V2X_MU_4		41
 #define IMX_SC_R_DC_1_WARP		42
+#define IMX_SC_R_SECVIO			44
 #define IMX_SC_R_DC_1_VIDEO0		45
 #define IMX_SC_R_DC_1_VIDEO1		46
 #define IMX_SC_R_DC_1_FRAC0		47
@@ -257,7 +264,6 @@
 #define IMX_SC_R_SDHC_2			250
 #define IMX_SC_R_ENET_0			251
 #define IMX_SC_R_ENET_1			252
-#define IMX_SC_R_MLB_0			253
 #define IMX_SC_R_DMA_2_CH0		254
 #define IMX_SC_R_DMA_2_CH1		255
 #define IMX_SC_R_DMA_2_CH2		256
diff --git a/include/dt-bindings/pinctrl/pads-imx8qxp.h b/include/dt-bindings/pinctrl/pads-imx8qxp.h
index fbfee7ecf..e4abcd6f7 100644
--- a/include/dt-bindings/pinctrl/pads-imx8qxp.h
+++ b/include/dt-bindings/pinctrl/pads-imx8qxp.h
@@ -747,5 +747,30 @@
 #define IMX8QXP_QSPI0B_SS1_B_LSIO_QSPI1A_SS1_B                     IMX8QXP_QSPI0B_SS1_B                  1
 #define IMX8QXP_QSPI0B_SS1_B_LSIO_KPP0_ROW3                        IMX8QXP_QSPI0B_SS1_B                  2
 #define IMX8QXP_QSPI0B_SS1_B_LSIO_GPIO3_IO24                       IMX8QXP_QSPI0B_SS1_B                  4
+#define IMX8QXP_COMP_CTL_GPIO_1V8_3V3_GPIORHB_PAD                  IMX8QXP_COMP_CTL_GPIO_1V8_3V3_GPIORHB 0
+
+/*!
+ * @name Fake Pad Mux Definitions
+ * format: name padid 0
+ */
+/*@{*/
+#define IMX8QXP_COMP_CTL_GPIO_1V8_3V3_PCIESEP_PAD          IMX8QXP_COMP_CTL_GPIO_1V8_3V3_PCIESEP         0
+#define IMX8QXP_COMP_CTL_GPIO_3V3_USB3IO_PAD               IMX8QXP_COMP_CTL_GPIO_3V3_USB3IO              0
+#define IMX8QXP_COMP_CTL_GPIO_1V8_3V3_SD1FIX0_PAD          IMX8QXP_COMP_CTL_GPIO_1V8_3V3_SD1FIX0         0
+#define IMX8QXP_COMP_CTL_GPIO_1V8_3V3_SD1FIX1_PAD          IMX8QXP_COMP_CTL_GPIO_1V8_3V3_SD1FIX1         0
+#define IMX8QXP_COMP_CTL_GPIO_1V8_3V3_VSELSEP_PAD          IMX8QXP_COMP_CTL_GPIO_1V8_3V3_VSELSEP         0
+#define IMX8QXP_COMP_CTL_GPIO_1V8_3V3_VSEL3_PAD            IMX8QXP_COMP_CTL_GPIO_1V8_3V3_VSEL3           0
+#define IMX8QXP_COMP_CTL_GPIO_1V8_3V3_ENET_ENETB0_PAD      IMX8QXP_COMP_CTL_GPIO_1V8_3V3_ENET_ENETB0     0
+#define IMX8QXP_COMP_CTL_GPIO_1V8_3V3_ENET_ENETB1_PAD      IMX8QXP_COMP_CTL_GPIO_1V8_3V3_ENET_ENETB1     0
+#define IMX8QXP_COMP_CTL_GPIO_1V8_3V3_GPIOCT_PAD           IMX8QXP_COMP_CTL_GPIO_1V8_3V3_GPIOCT          0
+#define IMX8QXP_COMP_CTL_GPIO_1V8_3V3_GPIORHB_PAD          IMX8QXP_COMP_CTL_GPIO_1V8_3V3_GPIORHB         0
+#define IMX8QXP_COMP_CTL_GPIO_1V8_3V3_GPIORHK_PAD          IMX8QXP_COMP_CTL_GPIO_1V8_3V3_GPIORHK         0
+#define IMX8QXP_COMP_CTL_GPIO_1V8_3V3_GPIORHT_PAD          IMX8QXP_COMP_CTL_GPIO_1V8_3V3_GPIORHT         0
+#define IMX8QXP_COMP_CTL_GPIO_1V8_3V3_GPIOLH_PAD           IMX8QXP_COMP_CTL_GPIO_1V8_3V3_GPIOLH          0
+#define IMX8QXP_COMP_CTL_GPIO_1V8_3V3_MIPIDSIGPIO_PAD      IMX8QXP_COMP_CTL_GPIO_1V8_3V3_MIPIDSIGPIO     0
+#define IMX8QXP_COMP_CTL_GPIO_1V8_3V3_GPIORHD_PAD          IMX8QXP_COMP_CTL_GPIO_1V8_3V3_GPIORHD         0
+#define IMX8QXP_COMP_CTL_GPIO_1V8_3V3_QSPI0A_PAD           IMX8QXP_COMP_CTL_GPIO_1V8_3V3_QSPI0A          0
+#define IMX8QXP_COMP_CTL_GPIO_1V8_3V3_QSPI0B_PAD           IMX8QXP_COMP_CTL_GPIO_1V8_3V3_QSPI0B          0
+/*@}*/
 
 #endif /* _IMX8QXP_PADS_H */
diff --git a/include/dt-bindings/pinctrl/s32v234-pinctrl.h b/include/dt-bindings/pinctrl/s32v234-pinctrl.h
new file mode 100644
index 000000000..8736d556a
--- /dev/null
+++ b/include/dt-bindings/pinctrl/s32v234-pinctrl.h
@@ -0,0 +1,1173 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright 2015-2016 by Freescale Semiconductor
+ * Copyright 2016-2017, 2019 NXP
+ */
+
+#ifndef __DT_BINDINGS_S32V234_PINCTRL_H__
+#define __DT_BINDINGS_S32V234_PINCTRL_H__
+
+/*
+ * Use to set PAD control
+ */
+#define PAD_CTL_DCYLE_TRIM_OFS      (22)
+#define PAD_CTL_DCYLE_TRIM_NONE     (0 << PAD_CTL_DCYLE_TRIM_OFS)
+#define PAD_CTL_DCYLE_TRIM_LEFT     (1 << PAD_CTL_DCYLE_TRIM_OFS)
+#define PAD_CTL_DCYLE_TRIM_RIGHT    (2 << PAD_CTL_DCYLE_TRIM_OFS)
+
+#define PAD_CTL_OBE         (1 << 21)
+#define PAD_CTL_ODE         (1 << 20)
+#define PAD_CTL_IBE         (1 << 19)
+#define PAD_CTL_HYS         (1 << 18)
+#define PAD_CTL_INV         (1 << 17)
+#define PAD_CTL_PKE         (1 << 16)
+
+#define PAD_CTL_SRE_OFS             (14)
+#define PAD_CTL_SRE_LOW_50HZ        (0 << PAD_CTL_SRE_OFS)
+#define PAD_CTL_SRE_LOW_100MHZ      (1 << PAD_CTL_SRE_OFS)
+/* The manual reports the same value for SRE = 01 and SRE = 10 */
+#define PAD_CTL_SRE_HIGH_100MHZ     (2 << PAD_CTL_SRE_OFS)
+#define PAD_CTL_SRE_HIGH_200MHZ     (3 << PAD_CTL_SRE_OFS)
+
+#define PAD_CTL_PUE             (1 << 13)
+
+#define PAD_CTL_PUS_OFS         (11)
+#define PAD_CTL_PUS_100K_DOWN   (0 << PAD_CTL_PUS_OFS)
+#define PAD_CTL_PUS_50K_UP      (1 << PAD_CTL_PUS_OFS)
+#define PAD_CTL_PUS_100K_UP     (2 << PAD_CTL_PUS_OFS)
+#define PAD_CTL_PUS_33K_UP      (3 << PAD_CTL_PUS_OFS)
+#define PAD_CTL_PUS_MASK        (3 << PAD_CTL_PUS_OFS)
+
+#define PAD_CTL_DSE_OFS         (8)
+#define PAD_CTL_DSE_OUT_DISABLE (0 << PAD_CTL_DSE_OFS)
+#define PAD_CTL_DSE_240         (1 << PAD_CTL_DSE_OFS)
+#define PAD_CTL_DSE_120         (2 << PAD_CTL_DSE_OFS)
+#define PAD_CTL_DSE_80          (3 << PAD_CTL_DSE_OFS)
+#define PAD_CTL_DSE_60          (4 << PAD_CTL_DSE_OFS)
+#define PAD_CTL_DSE_48          (5 << PAD_CTL_DSE_OFS)
+#define PAD_CTL_DSE_40          (6 << PAD_CTL_DSE_OFS)
+#define PAD_CTL_DSE_34          (7 << PAD_CTL_DSE_OFS)
+#define PAD_CTL_DSE_MASK        (7 << PAD_CTL_DSE_OFS)
+
+#define PAD_CTL_CRPOINT_TRIM    (3 << 6)
+
+#define PAD_CTL_SMC             (1 << 5)
+
+#define PAD_CTL_MUX_MODE_ALT0   (0)
+#define PAD_CTL_MUX_MODE_ALT1   (1)
+#define PAD_CTL_MUX_MODE_ALT2   (2)
+#define PAD_CTL_MUX_MODE_ALT3   (3)
+#define PAD_CTL_MUX_MODE_ALT4   (4)
+#define PAD_CTL_MUX_MODE_ALT5   (5)
+#define PAD_CTL_MUX_MODE_ALT6   (6)
+#define PAD_CTL_MUX_MODE_ALT7   (7)
+#define PAD_CTL_MUX_MODE_MASK   (0xF)
+
+/* UART configuration */
+#define PAD_CTL_UART_TX         (PAD_CTL_OBE | PAD_CTL_PUS_100K_UP |\
+				PAD_CTL_DSE_60 | PAD_CTL_SRE_LOW_100MHZ |\
+				PAD_CTL_MUX_MODE_ALT1)
+#define PAD_CTL_UART_RX_MSCR    (PAD_CTL_PUE | PAD_CTL_IBE |\
+				PAD_CTL_DCYLE_TRIM_RIGHT)
+#define PAD_CTL_UART_RX_IMCR    (PAD_CTL_MUX_MODE_ALT2)
+
+/* CAN0 configuration */
+#define PAD_CTL_CAN_FD0_TX      (PAD_CTL_OBE | PAD_CTL_PUS_50K_UP |\
+				PAD_CTL_PUE | PAD_CTL_DSE_34 |\
+				PAD_CTL_MUX_MODE_ALT1)
+#define PAD_CTL_CAN_FD0_RX_MSCR (PAD_CTL_PUE | PAD_CTL_IBE | PAD_CTL_PUS_50K_UP)
+#define PAD_CTL_CAN_FD0_RX_IMCR (PAD_CTL_MUX_MODE_ALT2)
+
+/* CAN1 configuration */
+#define PAD_CTL_CAN_FD1_TX      (PAD_CTL_OBE | PAD_CTL_PUS_50K_UP |\
+				PAD_CTL_PUE | PAD_CTL_DSE_34 |\
+				PAD_CTL_MUX_MODE_ALT1)
+#define PAD_CTL_CAN_FD1_RX_MSCR (PAD_CTL_PUE | PAD_CTL_IBE | PAD_CTL_PUS_50K_UP)
+#define PAD_CTL_CAN_FD1_RX_IMCR (PAD_CTL_MUX_MODE_ALT3)
+
+/* USDHC configuration  */
+#define PAD_CTL_USDHC_BASE      (PAD_CTL_SRE_HIGH_200MHZ | PAD_CTL_OBE | \
+				PAD_CTL_DSE_34 | PAD_CTL_PKE |  \
+				PAD_CTL_IBE | PAD_CTL_PUS_100K_UP | PAD_CTL_PUE)
+#define PAD_CTL_USDHC_CMD       (PAD_CTL_USDHC_BASE | PAD_CTL_MUX_MODE_ALT1)
+#define PAD_CTL_USDHC_CLK       (PAD_CTL_USDHC_BASE | PAD_CTL_MUX_MODE_ALT2)
+#define PAD_CTL_USDHC_DAT0_3    (PAD_CTL_USDHC_BASE | PAD_CTL_MUX_MODE_ALT2)
+#define PAD_CTL_USDHC_DAT4_7    (PAD_CTL_USDHC_BASE | PAD_CTL_MUX_MODE_ALT3)
+
+/* QSPI configuration */
+#define PAD_CTL_QSPI_BASE         (PAD_CTL_SRE_HIGH_200MHZ | PAD_CTL_OBE | \
+				  PAD_CTL_DSE_34 | PAD_CTL_IBE)
+#define PAD_CTL_QSPI_CLK_BASE     (PAD_CTL_SRE_HIGH_200MHZ | PAD_CTL_DSE_34 | \
+				  PAD_CTL_PUS_100K_UP | PAD_CTL_OBE)
+#define PAD_CTL_QSPI_CK2_MUX      PAD_CTL_MUX_MODE_ALT1
+#define PAD_CTL_QSPI_A_SCK_MUX    PAD_CTL_MUX_MODE_ALT1
+#define PAD_CTL_QSPI_B_SCK_MUX    PAD_CTL_MUX_MODE_ALT1
+#define PAD_CTL_QSPI_A_CS0_MUX    PAD_CTL_MUX_MODE_ALT1
+#define PAD_CTL_QSPI_B_CS0_MUX    PAD_CTL_MUX_MODE_ALT1
+#define PAD_CTL_QSPI_A_CS1_MUX    PAD_CTL_MUX_MODE_ALT1
+#define PAD_CTL_QSPI_B_CS1_MUX    PAD_CTL_MUX_MODE_ALT1
+#define PAD_CTL_QSPI_A_DQS        (PAD_CTL_SRE_HIGH_200MHZ | PAD_CTL_IBE | \
+				  PAD_CTL_PUS_100K_DOWN | PAD_CTL_PUE | \
+				  PAD_CTL_PKE)
+#define PAD_CTL_QSPI_A_DATA0_3    (PAD_CTL_QSPI_BASE | PAD_CTL_MUX_MODE_ALT1)
+#define PAD_CTL_QSPI_A_DATA4_7    (PAD_CTL_QSPI_BASE | PAD_CTL_MUX_MODE_ALT2)
+#define PAD_CTL_QSPI_B_DATA0_3    (PAD_CTL_QSPI_BASE | PAD_CTL_MUX_MODE_ALT1)
+
+/* EIRQ configuration */
+#define PAD_CTL_EIRQ              PAD_CTL_MUX_MODE_ALT2
+
+/* I2C0 - Serial Data Input PA15 */
+#define PAD_CTL_I2C0_MSCR_SDA_PA15    (PAD_CTL_MUX_MODE_ALT1 | PAD_CTL_OBE | \
+				      PAD_CTL_IBE | PAD_CTL_ODE | \
+				      PAD_CTL_DSE_34)
+#define PAD_CTL_I2C0_IMCR_SDA_PA15    (PAD_CTL_MUX_MODE_ALT2)
+
+/* I2C0 - Serial Clock Input PB0 */
+#define PAD_CTL_I2C0_MSCR_SCLK_PB0    (PAD_CTL_MUX_MODE_ALT1 | PAD_CTL_OBE | \
+				      PAD_CTL_IBE | PAD_CTL_ODE | \
+				      PAD_CTL_DSE_34)
+#define PAD_CTL_I2C0_IMCR_SCLK_PB0    (PAD_CTL_MUX_MODE_ALT2)
+
+/* I2C0 - Serial Data Input PG3 */
+#define PAD_CTL_I2C0_MSCR_SDA_PG3     (PAD_CTL_MUX_MODE_ALT2 | PAD_CTL_OBE | \
+				      PAD_CTL_IBE | PAD_CTL_ODE | \
+				      PAD_CTL_DSE_34)
+#define PAD_CTL_I2C0_IMCR_SDA_PG3     (PAD_CTL_MUX_MODE_ALT3)
+
+/* I2C0 - Serial Clock Input PG4 */
+#define PAD_CTL_I2C0_MSCR_SCLK_PG4    (PAD_CTL_MUX_MODE_ALT2 | PAD_CTL_OBE | \
+				      PAD_CTL_IBE | PAD_CTL_ODE | \
+				      PAD_CTL_DSE_34)
+#define PAD_CTL_I2C0_IMCR_SCLK_PG4    (PAD_CTL_MUX_MODE_ALT3)
+
+/* I2C1 - Serial Data Input */
+#define  PAD_CTL_I2C1_MSCR_SDA  (PAD_CTL_MUX_MODE_ALT2 | PAD_CTL_OBE | \
+				PAD_CTL_IBE | PAD_CTL_ODE | PAD_CTL_DSE_34)
+#define PAD_CTL_I2C1_IMCR_SDA   (PAD_CTL_MUX_MODE_ALT3)
+
+/* I2C1 - Serial Clock Input */
+#define  PAD_CTL_I2C1_MSCR_SCLK (PAD_CTL_MUX_MODE_ALT2 | PAD_CTL_OBE | \
+				PAD_CTL_IBE | PAD_CTL_ODE | PAD_CTL_DSE_34)
+#define PAD_CTL_I2C1_IMCR_SCLK  (PAD_CTL_MUX_MODE_ALT3)
+
+/* I2C2 - Serial Data Input */
+#define  PAD_CTL_I2C2_MSCR_SDA  (PAD_CTL_MUX_MODE_ALT1 | PAD_CTL_OBE | \
+				PAD_CTL_IBE | PAD_CTL_ODE | PAD_CTL_DSE_34)
+#define PAD_CTL_I2C2_IMCR_SDA   (PAD_CTL_MUX_MODE_ALT2)
+
+/* I2C2 - Serial Clock Input */
+#define  PAD_CTL_I2C2_MSCR_SCLK (PAD_CTL_MUX_MODE_ALT1 | PAD_CTL_OBE | \
+				PAD_CTL_IBE | PAD_CTL_ODE | PAD_CTL_DSE_34)
+#define PAD_CTL_I2C2_IMCR_SCLK  (PAD_CTL_MUX_MODE_ALT2)
+
+/* ENET CFG1 = 0x203701 */
+#define PAD_CTL_ENET_CFG1       (PAD_CTL_DSE_34 | PAD_CTL_PUS_100K_UP | PAD_CTL_PUE | \
+                                PAD_CTL_OBE | PAD_CTL_MUX_MODE_ALT1)
+
+/* ENET CFG2 = 0x20c701 */
+#define PAD_CTL_ENET_CFG2       (PAD_CTL_DSE_34 | PAD_CTL_SRE_HIGH_200MHZ | \
+                                PAD_CTL_OBE | PAD_CTL_MUX_MODE_ALT1)
+
+/* ENET CFG3 = 0x28c701 */
+#define PAD_CTL_ENET_CFG3       (PAD_CTL_DSE_34 | PAD_CTL_SRE_HIGH_200MHZ | \
+                                PAD_CTL_OBE | PAD_CTL_IBE | PAD_CTL_MUX_MODE_ALT1)
+
+/* ENET CFG7 = 0x8c700 */
+#define PAD_CTL_ENET_CFG4       (PAD_CTL_DSE_34 | PAD_CTL_SRE_HIGH_200MHZ | PAD_CTL_IBE)
+
+/* DCU CFG = 0x20C101 */
+#define PAD_CTL_DCU_CFG         (PAD_CTL_DSE_80 | PAD_CTL_SRE_HIGH_200MHZ | \
+				PAD_CTL_OBE | PAD_CTL_IBE | \
+				PAD_CTL_MUX_MODE_ALT1)
+
+#define PAD_CTL_DCU_CLK_CFG_DSE_DISABLE (PAD_CTL_SRE_HIGH_200MHZ | \
+					PAD_CTL_OBE | PAD_CTL_IBE | \
+					PAD_CTL_MUX_MODE_ALT1)
+
+/* VIU IMCR = 0x00000002 */
+#define PAD_CTL_VIU_CFG         (PAD_CTL_MUX_MODE_ALT2)
+
+/* VIU MSCR = 0x00000002 */
+#define PAD_CTL_VIU_IBE         (PAD_CTL_IBE)
+
+/* SPI 0-3 */
+#define PAD_CTL_SPI_MSCR_CSx    (PAD_CTL_OBE | PAD_CTL_PUS_100K_UP | \
+				PAD_CTL_DSE_34 | PAD_CTL_PUE)
+
+#define PAD_CTL_SPI_MSCR_SCK    (PAD_CTL_OBE | PAD_CTL_DSE_34 | \
+				PAD_CTL_MUX_MODE_ALT1)
+
+#define PAD_CTL_SPI_MSCR_SOUT   (PAD_CTL_OBE | PAD_CTL_DSE_34 | \
+				PAD_CTL_MUX_MODE_ALT1)
+
+#define PAD_CTL_SPI_MSCR_SIN    (PAD_CTL_PUE | PAD_CTL_IBE | \
+				PAD_CTL_PUS_50K_UP)
+
+#define PAD_CTL_SPI_IMCR_SIN    (PAD_CTL_MUX_MODE_ALT2)
+
+/* MSCR register numbers associated to port or function */
+#define S32V234_MSCR_PA0        0
+#define S32V234_MSCR_PA1        1
+#define S32V234_MSCR_PA2        2
+#define S32V234_MSCR_PA3        3
+#define S32V234_MSCR_PA4        4
+#define S32V234_MSCR_PA5        5
+#define S32V234_MSCR_PA6        6
+#define S32V234_MSCR_PA7        7
+#define S32V234_MSCR_PA8        8
+#define S32V234_MSCR_PA9        9
+#define S32V234_MSCR_PA10       10
+#define S32V234_MSCR_PA11       11
+#define S32V234_MSCR_PA12       12
+#define S32V234_MSCR_PA13       13
+#define S32V234_MSCR_PA14       14
+#define S32V234_MSCR_PA15       15
+#define S32V234_MSCR_PB0        16
+#define S32V234_MSCR_PB1        17
+#define S32V234_MSCR_PB2        18
+#define S32V234_MSCR_PB3        19
+#define S32V234_MSCR_PB4        20
+#define S32V234_MSCR_PB5        21
+#define S32V234_MSCR_PB6        22
+#define S32V234_MSCR_PB7        23
+#define S32V234_MSCR_PB8        24
+#define S32V234_MSCR_PB9        25
+#define S32V234_MSCR_PB10       26
+#define S32V234_MSCR_PB11       27
+#define S32V234_MSCR_PB12       28
+#define S32V234_MSCR_PB13       29
+#define S32V234_MSCR_PB14       30
+#define S32V234_MSCR_PB15       31
+#define S32V234_MSCR_PC0        32
+#define S32V234_MSCR_PC1        33
+#define S32V234_MSCR_PC2        34
+#define S32V234_MSCR_PC3        35
+#define S32V234_MSCR_PC4        36
+#define S32V234_MSCR_PC5        37
+#define S32V234_MSCR_PC6        38
+#define S32V234_MSCR_PC7        39
+#define S32V234_MSCR_PC8        40
+#define S32V234_MSCR_PC9        41
+#define S32V234_MSCR_PC10       42
+#define S32V234_MSCR_PC11       43
+#define S32V234_MSCR_PC12       44
+#define S32V234_MSCR_PC13       45
+#define S32V234_MSCR_PC14       46
+#define S32V234_MSCR_PC15       47
+#define S32V234_MSCR_PD0        48
+#define S32V234_MSCR_PD1        49
+#define S32V234_MSCR_PD2        50
+#define S32V234_MSCR_PD3        51
+#define S32V234_MSCR_PD4        52
+#define S32V234_MSCR_PD5        53
+#define S32V234_MSCR_PD6        54
+#define S32V234_MSCR_PD7        55
+#define S32V234_MSCR_PD8        56
+#define S32V234_MSCR_PD9        57
+#define S32V234_MSCR_PD10       58
+#define S32V234_MSCR_PD11       59
+#define S32V234_MSCR_PD12       60
+#define S32V234_MSCR_PD13       61
+#define S32V234_MSCR_PD14       62
+#define S32V234_MSCR_PD15       63
+#define S32V234_MSCR_PE0        64
+#define S32V234_MSCR_PE1        65
+#define S32V234_MSCR_PE2        66
+#define S32V234_MSCR_PE3        67
+#define S32V234_MSCR_PE4        68
+#define S32V234_MSCR_PE5        69
+#define S32V234_MSCR_PE6        70
+#define S32V234_MSCR_PE7        71
+#define S32V234_MSCR_PE8        72
+#define S32V234_MSCR_PE9        73
+#define S32V234_MSCR_PE10       74
+#define S32V234_MSCR_PE11       75
+#define S32V234_MSCR_PE12       76
+#define S32V234_MSCR_PE13       77
+#define S32V234_MSCR_PE14       78
+#define S32V234_MSCR_PE15       79
+#define S32V234_MSCR_PF0        80
+#define S32V234_MSCR_PF1        81
+#define S32V234_MSCR_PF2        82
+#define S32V234_MSCR_PF3        83
+#define S32V234_MSCR_PF4        84
+#define S32V234_MSCR_PF5        85
+#define S32V234_MSCR_PF6        86
+#define S32V234_MSCR_PF7        87
+#define S32V234_MSCR_PF8        88
+#define S32V234_MSCR_PF9        89
+#define S32V234_MSCR_PF10       90
+#define S32V234_MSCR_PF11       91
+#define S32V234_MSCR_PF12       92
+#define S32V234_MSCR_PF13       93
+#define S32V234_MSCR_PF14       94
+#define S32V234_MSCR_PF15       95
+#define S32V234_MSCR_PG0        96
+#define S32V234_MSCR_PG1        97
+#define S32V234_MSCR_PG2        98
+#define S32V234_MSCR_PG3        99
+#define S32V234_MSCR_PG4        100
+#define S32V234_MSCR_PG5        101
+#define S32V234_MSCR_PG6        102
+#define S32V234_MSCR_PG7        103
+#define S32V234_MSCR_PG8        104
+#define S32V234_MSCR_PG9        105
+#define S32V234_MSCR_PG10       106
+#define S32V234_MSCR_PG11       107
+#define S32V234_MSCR_PG12       108
+#define S32V234_MSCR_PG13       109
+#define S32V234_MSCR_PG14       110
+#define S32V234_MSCR_PG15       111
+#define S32V234_MSCR_PH0        112
+#define S32V234_MSCR_PH1        113
+#define S32V234_MSCR_PH2        114
+#define S32V234_MSCR_PH3        115
+#define S32V234_MSCR_PH4        116
+#define S32V234_MSCR_PH5        117
+#define S32V234_MSCR_PH6        118
+#define S32V234_MSCR_PH7        119
+#define S32V234_MSCR_PH8        120
+#define S32V234_MSCR_PH9        121
+#define S32V234_MSCR_PH10       122
+#define S32V234_MSCR_PH11       123
+#define S32V234_MSCR_PH12       124
+#define S32V234_MSCR_PH13       125
+#define S32V234_MSCR_PH14       126
+#define S32V234_MSCR_PH15       127
+#define S32V234_MSCR_PJ0        128
+#define S32V234_MSCR_PJ1        129
+#define S32V234_MSCR_PJ2        130
+#define S32V234_MSCR_PJ3        131
+#define S32V234_MSCR_PJ4        132
+#define S32V234_MSCR_PJ5        133
+#define S32V234_MSCR_PJ6        134
+#define S32V234_MSCR_PJ7        135
+#define S32V234_MSCR_PJ8        136
+#define S32V234_MSCR_PJ9        137
+#define S32V234_MSCR_PJ10       138
+#define S32V234_MSCR_PJ11       139
+#define S32V234_MSCR_PJ12       140
+#define S32V234_MSCR_PJ13       141
+#define S32V234_MSCR_PJ14       142
+#define S32V234_MSCR_PJ15       143
+#define S32V234_MSCR_PK0        144
+#define S32V234_MSCR_PK1        145
+#define S32V234_MSCR_PK2        146
+#define S32V234_MSCR_PK3        147
+#define S32V234_MSCR_PK4        148
+#define S32V234_MSCR_PK5        149
+#define S32V234_MSCR_PK6        150
+#define S32V234_MSCR_PK7        151
+#define S32V234_MSCR_PK8        152
+#define S32V234_MSCR_PK9        153
+#define S32V234_MSCR_PK10       154
+#define S32V234_MSCR_PK11       155
+#define S32V234_MSCR_PK12       156
+#define S32V234_MSCR_PK13       157
+#define S32V234_MSCR_PK14       158
+#define S32V234_MSCR_PK15       159
+#define S32V234_MSCR_PL0        160
+#define S32V234_MSCR_PL1        161
+#define S32V234_MSCR_PL2        162
+#define S32V234_MSCR_PL3        163
+#define S32V234_MSCR_PL4        164
+#define S32V234_MSCR_PL5        165
+#define S32V234_MSCR_PL8        166
+
+#define S32V234_IMCR_FlexTimer0_CH0    512
+#define S32V234_IMCR_FlexTimer0_CH1    513
+#define S32V234_IMCR_FlexTimer0_CH2    514
+#define S32V234_IMCR_FlexTimer0_CH3    515
+#define S32V234_IMCR_FlexTimer0_CH4    516
+#define S32V234_IMCR_FlexTimer0_CH5    517
+#define S32V234_IMCR_FlexTimer0_EXTCLK 520
+#define S32V234_IMCR_FlexTimer1_CH0    521
+#define S32V234_IMCR_FlexTimer1_CH1    522
+#define S32V234_IMCR_FlexTimer1_CH2    523
+#define S32V234_IMCR_FlexTimer1_CH3    524
+#define S32V234_IMCR_FlexTimer1_CH4    525
+#define S32V234_IMCR_FlexTimer1_CH5    526
+#define S32V234_IMCR_FlexTimer1_EXTCLK 529
+#define S32V234_IMCR_LFAST_REF_CLK     550
+#define S32V234_IMCR_BOOT_BOOTMOD0     570
+#define S32V234_IMCR_BOOT_BOOTMOD1     571
+#define S32V234_IMCR_SIUL_EIRQ0        590
+#define S32V234_IMCR_SIUL_EIRQ1        591
+#define S32V234_IMCR_SIUL_EIRQ2        592
+#define S32V234_IMCR_SIUL_EIRQ3        593
+#define S32V234_IMCR_SIUL_EIRQ4        594
+#define S32V234_IMCR_SIUL_EIRQ5        595
+#define S32V234_IMCR_SIUL_EIRQ6        596
+#define S32V234_IMCR_SIUL_EIRQ7        597
+#define S32V234_IMCR_SIUL_EIRQ8        598
+#define S32V234_IMCR_SIUL_EIRQ9        599
+#define S32V234_IMCR_SIUL_EIRQ10       600
+#define S32V234_IMCR_SIUL_EIRQ11       601
+#define S32V234_IMCR_SIUL_EIRQ12       602
+#define S32V234_IMCR_SIUL_EIRQ13       603
+#define S32V234_IMCR_SIUL_EIRQ14       604
+#define S32V234_IMCR_SIUL_EIRQ15       605
+#define S32V234_IMCR_SIUL_EIRQ16       606
+#define S32V234_IMCR_SIUL_EIRQ17       607
+#define S32V234_IMCR_SIUL_EIRQ18       608
+#define S32V234_IMCR_SIUL_EIRQ19       609
+#define S32V234_IMCR_SIUL_EIRQ20       610
+#define S32V234_IMCR_SIUL_EIRQ21       611
+#define S32V234_IMCR_SIUL_EIRQ22       612
+#define S32V234_IMCR_SIUL_EIRQ23       613
+#define S32V234_IMCR_SIUL_EIRQ24       614
+#define S32V234_IMCR_SIUL_EIRQ25       615
+#define S32V234_IMCR_SIUL_EIRQ26       616
+#define S32V234_IMCR_SIUL_EIRQ27       617
+#define S32V234_IMCR_SIUL_EIRQ28       618
+#define S32V234_IMCR_SIUL_EIRQ29       619
+#define S32V234_IMCR_SIUL_EIRQ30       620
+#define S32V234_IMCR_SIUL_EIRQ31       621
+#define S32V234_IMCR_VIU0_HSYNC        622
+#define S32V234_IMCR_VIU0_VSYNC        623
+#define S32V234_IMCR_VIU0_PCLK         624
+#define S32V234_IMCR_VIU0_D4           629
+#define S32V234_IMCR_VIU0_D5           630
+#define S32V234_IMCR_VIU0_D6           631
+#define S32V234_IMCR_VIU0_D7           632
+#define S32V234_IMCR_VIU0_D8           633
+#define S32V234_IMCR_VIU0_D9           634
+#define S32V234_IMCR_VIU0_D10          635
+#define S32V234_IMCR_VIU0_D11          636
+#define S32V234_IMCR_VIU0_D12          637
+#define S32V234_IMCR_VIU0_D13          638
+#define S32V234_IMCR_VIU0_D14          639
+#define S32V234_IMCR_VIU0_D15          640
+#define S32V234_IMCR_VIU0_D16          641
+#define S32V234_IMCR_VIU0_D17          642
+#define S32V234_IMCR_VIU0_D18          643
+#define S32V234_IMCR_VIU0_D19          644
+#define S32V234_IMCR_VIU0_D20          645
+#define S32V234_IMCR_VIU0_D21          646
+#define S32V234_IMCR_VIU0_D22          647
+#define S32V234_IMCR_VIU0_D23          648
+#define S32V234_IMCR_VIU1_HSYNC        657
+#define S32V234_IMCR_VIU1_VSYNC        658
+#define S32V234_IMCR_VIU1_PCLK         659
+#define S32V234_IMCR_VIU1_D8           668
+#define S32V234_IMCR_VIU1_D9           669
+#define S32V234_IMCR_VIU1_D10          670
+#define S32V234_IMCR_VIU1_D11          671
+#define S32V234_IMCR_VIU1_D12          672
+#define S32V234_IMCR_VIU1_D13          673
+#define S32V234_IMCR_VIU1_D14          674
+#define S32V234_IMCR_VIU1_D15          675
+#define S32V234_IMCR_VIU1_D16          676
+#define S32V234_IMCR_VIU1_D17          677
+#define S32V234_IMCR_VIU1_D18          678
+#define S32V234_IMCR_VIU1_D19          679
+#define S32V234_IMCR_VIU1_D20          680
+#define S32V234_IMCR_VIU1_D21          681
+#define S32V234_IMCR_VIU1_D22          682
+#define S32V234_IMCR_VIU1_D23          683
+#define S32V234_IMCR_CAN_FD0_RXD       700
+#define S32V234_IMCR_CAN_FD1_RXD       701
+#define S32V234_IMCR_UART0_RXD         712
+#define S32V234_IMCR_UART1_RXD         714
+#define S32V234_IMCR_IIC0_CLK          780
+#define S32V234_IMCR_IIC0_DATA         781
+#define S32V234_IMCR_IIC1_CLK          782
+#define S32V234_IMCR_IIC1_DATA         783
+#define S32V234_IMCR_IIC2_CLK          784
+#define S32V234_IMCR_IIC2_DATA         785
+#define S32V234_IMCR_SPI0_SIN          800
+#define S32V234_IMCR_SPI0_SCK          801
+#define S32V234_IMCR_SPI0_CS0          802
+#define S32V234_IMCR_SPI1_SIN          803
+#define S32V234_IMCR_SPI1_SCK          804
+#define S32V234_IMCR_SPI1_CS0          805
+#define S32V234_IMCR_SPI2_SIN          806
+#define S32V234_IMCR_SPI2_SCK          807
+#define S32V234_IMCR_SPI2_CS0          808
+#define S32V234_IMCR_SPI3_SIN          809
+#define S32V234_IMCR_SPI3_SCK          810
+#define S32V234_IMCR_SPI3_CS0          811
+#define S32V234_IMCR_QSPI_A_DQS        819
+#define S32V234_IMCR_QSPI_A_DATA0      820
+#define S32V234_IMCR_QSPI_A_DATA1      821
+#define S32V234_IMCR_QSPI_A_DATA2      822
+#define S32V234_IMCR_QSPI_A_DATA3      823
+#define S32V234_IMCR_QSPI_A_DATA4      824
+#define S32V234_IMCR_QSPI_A_DATA5      825
+#define S32V234_IMCR_QSPI_A_DATA6      826
+#define S32V234_IMCR_QSPI_A_DATA7      827
+#define S32V234_IMCR_QSPI_B_DQS        828
+#define S32V234_IMCR_QSPI_B_DATA0      829
+#define S32V234_IMCR_QSPI_B_DATA1      830
+#define S32V234_IMCR_QSPI_B_DATA2      831
+#define S32V234_IMCR_QSPI_B_DATA3      832
+#define S32V234_IMCR_USDHC_WP          900
+#define S32V234_IMCR_USDHC_CMD         901
+#define S32V234_IMCR_USDHC_CLK         902
+#define S32V234_IMCR_USDHC_DAT0        903
+#define S32V234_IMCR_USDHC_DAT1        904
+#define S32V234_IMCR_USDHC_DAT2        905
+#define S32V234_IMCR_USDHC_DAT3        906
+#define S32V234_IMCR_USDHC_DAT4        907
+#define S32V234_IMCR_USDHC_DAT5        908
+#define S32V234_IMCR_USDHC_DAT6        909
+#define S32V234_IMCR_USDHC_DAT7        910
+#define S32V234_IMCR_Ethernet_RX_ER    970
+#define S32V234_IMCR_Ethernet_COL      971
+#define S32V234_IMCR_Ethernet_CRS      972
+#define S32V234_IMCR_Ethernet_RX_DV    973
+#define S32V234_IMCR_Ethernet_RX_D0    974
+#define S32V234_IMCR_Ethernet_RX_D1    975
+#define S32V234_IMCR_Ethernet_RX_D2    976
+#define S32V234_IMCR_Ethernet_RX_D3    977
+#define S32V234_IMCR_Ethernet_TX_CLK   978
+#define S32V234_IMCR_Ethernet_RX_CLK   979
+#define S32V234_IMCR_Ethernet_MDIO     981
+#define S32V234_IMCR_Ethernet_TIMER0   982
+#define S32V234_IMCR_Ethernet_TIMER1   983
+#define S32V234_IMCR_Ethernet_TIMER2   984
+#define S32V234_IMCR_FlexRay_CA_RX     1012
+#define S32V234_IMCR_FlexRay_CB_RX     1013
+#define S32V234_IMCR_SSE_IN0           1018
+#define S32V234_IMCR_SSE_IN1           1019
+#define S32V234_IMCR_SSE_IN2           1020
+#define S32V234_IMCR_SSE_IN3           1021
+
+/* Format of pins: MSCR_IDX PAD_CONFIGURATION If you know the IMCR_IDX
+ * instead of MSCR_IDX, add 512 to it as the Reference Manual states.
+ */
+
+/* UART configuration */
+#define S32V234_PAD_PA12__UART0_TXD     S32V234_MSCR_PA12 PAD_CTL_UART_TX
+#define S32V234_PAD_PA11__UART0_RXD_OUT S32V234_MSCR_PA11 PAD_CTL_UART_RX_MSCR
+#define S32V234_PAD_PA11__UART0_RXD_IN  S32V234_IMCR_UART0_RXD \
+					PAD_CTL_UART_RX_IMCR
+
+#define S32V234_PAD_PA14__UART1_TXD     S32V234_MSCR_PA14 PAD_CTL_UART_TX
+#define S32V234_PAD_PA13__UART1_RXD_OUT S32V234_MSCR_PA13 PAD_CTL_UART_RX_MSCR
+#define S32V234_PAD_PA13__UART1_RXD_IN  S32V234_IMCR_UART1_RXD \
+					PAD_CTL_UART_RX_IMCR
+
+/* CAN0 configuration */
+#define S32V234_PAD_PA2__CAN_FD0_TXD     S32V234_MSCR_PA2 PAD_CTL_CAN_FD0_TX
+#define S32V234_PAD_PA3__CAN_FD0_RXD_OUT S32V234_MSCR_PA3 \
+					 PAD_CTL_CAN_FD0_RX_MSCR
+#define S32V234_PAD_PA3__CAN_FD0_RXD_IN  S32V234_IMCR_CAN_FD0_RXD \
+					 PAD_CTL_CAN_FD0_RX_IMCR
+
+/* CAN1 configuration */
+#define S32V234_PAD_PA4__CAN_FD1_TXD     S32V234_MSCR_PA4 PAD_CTL_CAN_FD1_TX
+#define S32V234_PAD_PA5__CAN_FD1_RXD_OUT S32V234_MSCR_PA5 \
+					 PAD_CTL_CAN_FD1_RX_MSCR
+#define S32V234_PAD_PA5__CAN_FD1_RXD_IN  S32V234_IMCR_CAN_FD1_RXD \
+					 PAD_CTL_CAN_FD1_RX_IMCR
+
+/* uSDHC configuration */
+#define S32V234_PAD_PK6__USDHC_CLK_OUT   S32V234_MSCR_PK6 PAD_CTL_USDHC_CLK
+#define S32V234_PAD_PK6__USDHC_CLK_IN    S32V234_IMCR_USDHC_CLK \
+					 PAD_CTL_MUX_MODE_ALT3
+
+#define S32V234_PAD_PK7__USDHC_CMD_OUT   S32V234_MSCR_PK7 PAD_CTL_USDHC_CMD
+#define S32V234_PAD_PK7__USDHC_CMD_IN    S32V234_IMCR_USDHC_CMD \
+					 PAD_CTL_MUX_MODE_ALT3
+
+#define S32V234_PAD_PK8__USDHC_DAT0_OUT  S32V234_MSCR_PK8 PAD_CTL_USDHC_DAT0_3
+#define S32V234_PAD_PK8__USDHC_DAT0_IN   S32V234_IMCR_USDHC_DAT0 \
+					 PAD_CTL_MUX_MODE_ALT3
+
+#define S32V234_PAD_PK9__USDHC_DAT1_OUT  S32V234_MSCR_PK9 PAD_CTL_USDHC_DAT0_3
+#define S32V234_PAD_PK9__USDHC_DAT1_IN   S32V234_IMCR_USDHC_DAT1 \
+					 PAD_CTL_MUX_MODE_ALT3
+
+#define S32V234_PAD_PK10__USDHC_DAT2_OUT S32V234_MSCR_PK10 PAD_CTL_USDHC_DAT0_3
+#define S32V234_PAD_PK10__USDHC_DAT2_IN  S32V234_IMCR_USDHC_DAT2 \
+					 PAD_CTL_MUX_MODE_ALT3
+
+#define S32V234_PAD_PK11__USDHC_DAT3_OUT S32V234_MSCR_PK11 PAD_CTL_USDHC_DAT0_3
+#define S32V234_PAD_PK11__USDHC_DAT3_IN  S32V234_IMCR_USDHC_DAT3 \
+					 PAD_CTL_MUX_MODE_ALT3
+
+#define S32V234_PAD_PK15__USDHC_DAT4_OUT S32V234_MSCR_PK15 PAD_CTL_USDHC_DAT4_7
+#define S32V234_PAD_PK15__USDHC_DAT4_IN  S32V234_IMCR_USDHC_DAT4 \
+					 PAD_CTL_MUX_MODE_ALT3
+
+#define S32V234_PAD_PL0__USDHC_DAT5_OUT  S32V234_MSCR_PL0 PAD_CTL_USDHC_DAT4_7
+#define S32V234_PAD_PL0__USDHC_DAT5_IN   S32V234_IMCR_USDHC_DAT5 \
+					 PAD_CTL_MUX_MODE_ALT3
+
+#define S32V234_PAD_PL1__USDHC_DAT6_OUT  S32V234_MSCR_PL1 PAD_CTL_USDHC_DAT4_7
+#define S32V234_PAD_PL1__USDHC_DAT6_IN   S32V234_IMCR_USDHC_DAT6 \
+					 PAD_CTL_MUX_MODE_ALT3
+
+#define S32V234_PAD_PL2__USDHC_DAT7_OUT  S32V234_MSCR_PL2 PAD_CTL_USDHC_DAT4_7
+#define S32V234_PAD_PL2__USDHC_DAT7_IN   S32V234_IMCR_USDHC_DAT7 \
+					 PAD_CTL_MUX_MODE_ALT3
+
+/* QSPI configuration */
+#define S32V234_PAD_PK7__QSPI_A_DQS        S32V234_IMCR_QSPI_A_DQS \
+					   PAD_CTL_MUX_MODE_ALT2
+#define S32V234_PAD_PK14__QSPI_B_DQS       S32V234_IMCR_QSPI_B_DQS \
+					   PAD_CTL_MUX_MODE_ALT2
+
+#define S32V234_PAD_PK8__QSPI_A_DATA0_IN   S32V234_IMCR_QSPI_A_DATA0 \
+					   PAD_CTL_MUX_MODE_ALT2
+#define S32V234_PAD_PK8__QSPI_A_DATA0_OUT  S32V234_MSCR_PK8 \
+					   PAD_CTL_QSPI_A_DATA0_3
+
+#define S32V234_PAD_PK9__QSPI_A_DATA1_IN   S32V234_IMCR_QSPI_A_DATA1 \
+					   PAD_CTL_MUX_MODE_ALT2
+#define S32V234_PAD_PK9__QSPI_A_DATA1_OUT  S32V234_MSCR_PK9 \
+					   PAD_CTL_QSPI_A_DATA0_3
+
+#define S32V234_PAD_PK10__QSPI_A_DATA2_IN  S32V234_IMCR_QSPI_A_DATA2 \
+					   PAD_CTL_MUX_MODE_ALT2
+#define S32V234_PAD_PK10__QSPI_A_DATA2_OUT S32V234_MSCR_PK10 \
+					   PAD_CTL_QSPI_A_DATA0_3
+
+#define S32V234_PAD_PK11__QSPI_A_DATA3_IN  S32V234_IMCR_QSPI_A_DATA3 \
+					   PAD_CTL_MUX_MODE_ALT2
+#define S32V234_PAD_PK11__QSPI_A_DATA3_OUT S32V234_MSCR_PK11 \
+					   PAD_CTL_QSPI_A_DATA0_3
+
+#define S32V234_PAD_PK15__QSPI_A_DATA4_IN  S32V234_IMCR_QSPI_A_DATA4 \
+					   PAD_CTL_MUX_MODE_ALT2
+#define S32V234_PAD_PK15__QSPI_A_DATA4_OUT S32V234_MSCR_PK15 \
+					   PAD_CTL_QSPI_A_DATA4_7
+
+#define S32V234_PAD_PL0__QSPI_A_DATA5_IN   S32V234_IMCR_QSPI_A_DATA5 \
+					   PAD_CTL_MUX_MODE_ALT2
+#define S32V234_PAD_PL0__QSPI_A_DATA5_OUT  S32V234_MSCR_PL0 \
+					   PAD_CTL_QSPI_A_DATA4_7
+
+#define S32V234_PAD_PL1__QSPI_A_DATA6_IN   S32V234_IMCR_QSPI_A_DATA6 \
+					   PAD_CTL_MUX_MODE_ALT2
+#define S32V234_PAD_PL1__QSPI_A_DATA6_OUT  S32V234_MSCR_PL1 \
+					   PAD_CTL_QSPI_A_DATA4_7
+
+#define S32V234_PAD_PL2__QSPI_A_DATA7_IN   S32V234_IMCR_QSPI_A_DATA7 \
+					   PAD_CTL_MUX_MODE_ALT2
+#define S32V234_PAD_PL2__QSPI_A_DATA7_OUT  S32V234_MSCR_PL2 \
+					   PAD_CTL_QSPI_A_DATA4_7
+
+#define S32V234_PAD_PK15__QSPI_B_DATA0_IN  S32V234_IMCR_QSPI_B_DATA0 \
+					   PAD_CTL_MUX_MODE_ALT2
+#define S32V234_PAD_PK15__QSPI_B_DATA0_OUT S32V234_MSCR_PK15 \
+					   PAD_CTL_QSPI_B_DATA0_3
+
+#define S32V234_PAD_PL0__QSPI_B_DATA1_IN   S32V234_IMCR_QSPI_B_DATA1 \
+					   PAD_CTL_MUX_MODE_ALT2
+#define S32V234_PAD_PL0__QSPI_B_DATA1_OUT  S32V234_MSCR_PL0 \
+					   PAD_CTL_QSPI_B_DATA0_3
+
+#define S32V234_PAD_PL1__QSPI_B_DATA2_IN   S32V234_IMCR_QSPI_B_DATA2 \
+					   PAD_CTL_MUX_MODE_ALT2
+#define S32V234_PAD_PL1__QSPI_B_DATA2_OUT  S32V234_MSCR_PL1 \
+					   PAD_CTL_QSPI_B_DATA0_3
+
+#define S32V234_PAD_PL2__QSPI_B_DATA3_IN   S32V234_IMCR_QSPI_B_DATA3 \
+					   PAD_CTL_MUX_MODE_ALT2
+#define S32V234_PAD_PL2__QSPI_B_DATA3_OUT  S32V234_MSCR_PL2 \
+					   PAD_CTL_QSPI_B_DATA0_3
+
+#define S32V234_PAD_PF12__QSPI_A_CS1       S32V234_MSCR_PF12 \
+					   (PAD_CTL_QSPI_CLK_BASE | \
+					   PAD_CTL_QSPI_A_CS1_MUX)
+#define S32V234_PAD_PF13__QSPI_B_CS1       S32V234_MSCR_PF13 \
+					   (PAD_CTL_QSPI_CLK_BASE | \
+					   PAD_CTL_QSPI_B_CS1_MUX)
+
+#define S32V234_PAD_PK5__QSPI_A_CS0        S32V234_MSCR_PK5 \
+					   (PAD_CTL_QSPI_CLK_BASE | \
+					   PAD_CTL_QSPI_A_CS0_MUX)
+#define S32V234_PAD_PK6__QSPI_A_SCK        S32V234_MSCR_PK6 \
+					   (PAD_CTL_QSPI_CLK_BASE | \
+					   PAD_CTL_QSPI_A_SCK_MUX)
+
+#define S32V234_PAD_PK12__QSPI_B_CS0       S32V234_MSCR_PK12 \
+					   (PAD_CTL_QSPI_CLK_BASE | \
+					   PAD_CTL_QSPI_B_CS0_MUX)
+#define S32V234_PAD_PK13__QSPI_B_SCK       S32V234_MSCR_PK13 \
+					   (PAD_CTL_QSPI_CLK_BASE | \
+					   PAD_CTL_QSPI_B_SCK_MUX)
+
+#define S32V234_PAD_PK13__QSPI_CK2         S32V234_MSCR_PK13 \
+					   (PAD_CTL_QSPI_CLK_BASE | \
+					   PAD_CTL_QSPI_CK2_MUX)
+
+/* I2C configuration */
+#define S32V234_PAD_PA15__I2C0_DATA_OUT S32V234_MSCR_PA15 \
+					PAD_CTL_I2C0_MSCR_SDA_PA15
+#define S32V234_PAD_PA15__I2C0_DATA_IN  S32V234_IMCR_IIC0_DATA \
+					PAD_CTL_I2C0_IMCR_SDA_PA15
+
+#define S32V234_PAD_PB0__I2C0_SCLK_OUT  S32V234_MSCR_PB0 \
+					PAD_CTL_I2C0_MSCR_SCLK_PB0
+#define S32V234_PAD_PB0__I2C0_SCLK_IN   S32V234_IMCR_IIC0_CLK \
+					PAD_CTL_I2C0_IMCR_SCLK_PB0
+
+#define S32V234_PAD_PG3__I2C0_DATA_OUT  S32V234_MSCR_PG3 \
+					PAD_CTL_I2C0_MSCR_SDA_PG3
+#define S32V234_PAD_PG3__I2C0_DATA_IN   S32V234_IMCR_IIC0_DATA \
+					PAD_CTL_I2C0_IMCR_SDA_PG3
+
+#define S32V234_PAD_PG4__I2C0_SCLK_OUT  S32V234_MSCR_PG4 \
+					PAD_CTL_I2C0_MSCR_SCLK_PG4
+#define S32V234_PAD_PG4__I2C0_SCLK_IN   S32V234_IMCR_IIC0_CLK \
+					PAD_CTL_I2C0_IMCR_SCLK_PG4
+
+#define S32V234_PAD_PG5__I2C1_DATA_OUT  S32V234_MSCR_PG5 \
+					PAD_CTL_I2C1_MSCR_SDA
+#define S32V234_PAD_PG5__I2C1_DATA_IN   S32V234_IMCR_IIC1_DATA \
+					PAD_CTL_I2C1_IMCR_SDA
+
+#define S32V234_PAD_PG6__I2C1_SCLK_OUT  S32V234_MSCR_PG6 \
+					PAD_CTL_I2C1_MSCR_SCLK
+#define S32V234_PAD_PG6__I2C1_SCLK_IN   S32V234_IMCR_IIC1_CLK \
+					PAD_CTL_I2C1_IMCR_SCLK
+
+#define S32V234_PAD_PB3__I2C2_DATA_OUT  S32V234_MSCR_PB3 \
+					PAD_CTL_I2C2_MSCR_SDA
+#define S32V234_PAD_PB3__I2C2_DATA_IN   S32V234_IMCR_IIC2_DATA \
+					PAD_CTL_I2C2_IMCR_SDA
+
+#define S32V234_PAD_PB4__I2C2_SCLK_OUT  S32V234_MSCR_PB4 \
+					PAD_CTL_I2C2_MSCR_SCLK
+#define S32V234_PAD_PB4__I2C2_SCLK_IN   S32V234_IMCR_IIC2_CLK \
+					PAD_CTL_I2C2_IMCR_SCLK
+
+/* ENET configuration */
+#define S32V234_PAD_PC13__MDC       S32V234_MSCR_PC13 PAD_CTL_ENET_CFG2
+
+#define S32V234_PAD_PC14__MDIO_OUT  S32V234_MSCR_PC14 PAD_CTL_ENET_CFG3
+#define S32v234_PAD_PC14__MDIO_IN   S32V234_IMCR_Ethernet_MDIO \
+				    PAD_CTL_MUX_MODE_ALT2
+
+#define S32V234_PAD_PC15__TXCLK_OUT S32V234_MSCR_PC15 PAD_CTL_ENET_CFG1
+#define S32V234_PAD_PC15__TXCLK_IN  S32V234_IMCR_Ethernet_TX_CLK \
+				    PAD_CTL_MUX_MODE_ALT2
+
+#define S32V234_PAD_PD0__RXCLK_OUT  S32V234_MSCR_PD0 PAD_CTL_ENET_CFG4
+#define S32V234_PAD_PD0__RXCLK_IN   S32V234_IMCR_Ethernet_RX_CLK \
+				    PAD_CTL_MUX_MODE_ALT2
+
+#define S32V234_PAD_PD1__RX_D0_OUT  S32V234_MSCR_PD1 PAD_CTL_ENET_CFG4
+#define S32V234_PAD_PD1__RX_D0_IN   S32V234_IMCR_Ethernet_RX_D0 \
+				    PAD_CTL_MUX_MODE_ALT2
+
+#define S32V234_PAD_PD2__RX_D1_OUT  S32V234_MSCR_PD2 PAD_CTL_ENET_CFG4
+#define S32V234_PAD_PD2__RX_D1_IN   S32V234_IMCR_Ethernet_RX_D1 \
+				    PAD_CTL_MUX_MODE_ALT2
+
+#define S32V234_PAD_PD3__RX_D2_OUT  S32V234_MSCR_PD3 PAD_CTL_ENET_CFG4
+#define S32V234_PAD_PD3__RX_D2_IN   S32V234_IMCR_Ethernet_RX_D2 \
+				    PAD_CTL_MUX_MODE_ALT2
+
+#define S32V234_PAD_PD4__RX_D3_OUT  S32V234_MSCR_PD4 PAD_CTL_ENET_CFG4
+#define S32V234_PAD_PD4__RX_D3_IN   S32V234_IMCR_Ethernet_RX_D3 \
+				    PAD_CTL_MUX_MODE_ALT2
+
+#define S32V234_PAD_PD4__RX_DV_OUT  S32V234_MSCR_PD5 PAD_CTL_ENET_CFG4
+#define S32V234_PAD_PD4__RX_DV_IN   S32V234_IMCR_Ethernet_RX_DV \
+				    PAD_CTL_MUX_MODE_ALT2
+
+#define S32V234_PAD_PD7__TX_D0_OUT  S32V234_MSCR_PD7  PAD_CTL_ENET_CFG2
+#define S32V234_PAD_PD8__TX_D1_OUT  S32V234_MSCR_PD8  PAD_CTL_ENET_CFG2
+#define S32V234_PAD_PD9__TX_D2_OUT  S32V234_MSCR_PD9  PAD_CTL_ENET_CFG2
+#define S32V234_PAD_PD10__TX_D3_OUT S32V234_MSCR_PD10 PAD_CTL_ENET_CFG2
+#define S32V234_PAD_PD11__TX_EN_OUT S32V234_MSCR_PD11 PAD_CTL_ENET_CFG2
+
+/* 2D ACE DCU */
+#define S32V234_PAD_PH8__DCU_HSYNC_C1 S32V234_MSCR_PH8  PAD_CTL_DCU_CFG
+#define S32V234_PAD_PH9__DCU_VSYNC_C2 S32V234_MSCR_PH9  PAD_CTL_DCU_CFG
+#define S32V234_PAD_PH10__DCU_DE_C3   S32V234_MSCR_PH10 PAD_CTL_DCU_CFG
+
+#define S32V234_PAD_PH12__DCU_PCLK_D1_DSE_DISABLE S32V234_MSCR_PH12 \
+					PAD_CTL_DCU_CLK_CFG_DSE_DISABLE
+#define S32V234_PAD_PH12__DCU_PCLK_D1_DSE_240     S32V234_MSCR_PH12 \
+					(PAD_CTL_DCU_CLK_CFG_DSE_DISABLE | \
+					PAD_CTL_DSE_240)
+#define S32V234_PAD_PH12__DCU_PCLK_D1_DSE_120     S32V234_MSCR_PH12 \
+					(PAD_CTL_DCU_CLK_CFG_DSE_DISABLE | \
+					PAD_CTL_DSE_120)
+#define S32V234_PAD_PH12__DCU_PCLK_D1_DSE_80      S32V234_MSCR_PH12 \
+					(PAD_CTL_DCU_CLK_CFG_DSE_DISABLE | \
+					PAD_CTL_DSE_80)
+#define S32V234_PAD_PH12__DCU_PCLK_D1_DSE_60      S32V234_MSCR_PH12 \
+					(PAD_CTL_DCU_CLK_CFG_DSE_DISABLE | \
+					PAD_CTL_DSE_60)
+#define S32V234_PAD_PH12__DCU_PCLK_D1_DSE_48      S32V234_MSCR_PH12 \
+					(PAD_CTL_DCU_CLK_CFG_DSE_DISABLE | \
+					PAD_CTL_DSE_48)
+#define S32V234_PAD_PH12__DCU_PCLK_D1_DSE_40      S32V234_MSCR_PH12 \
+					(PAD_CTL_DCU_CLK_CFG_DSE_DISABLE | \
+					PAD_CTL_DSE_40)
+#define S32V234_PAD_PH12__DCU_PCLK_D1_DSE_34      S32V234_MSCR_PH12 \
+					(PAD_CTL_DCU_CLK_CFG_DSE_DISABLE | \
+					PAD_CTL_DSE_34)
+
+#define S32V234_PAD_PH13__DCU_R0_D2  S32V234_MSCR_PH13 PAD_CTL_DCU_CFG
+#define S32V234_PAD_PH14__DCU_R1_D3  S32V234_MSCR_PH14 PAD_CTL_DCU_CFG
+#define S32V234_PAD_PH15__DCU_R2_D4  S32V234_MSCR_PH15 PAD_CTL_DCU_CFG
+#define S32V234_PAD_PJ0__DCU_R3_D5   S32V234_MSCR_PJ0  PAD_CTL_DCU_CFG
+#define S32V234_PAD_PJ1__DCU_R4_D6   S32V234_MSCR_PJ1  PAD_CTL_DCU_CFG
+#define S32V234_PAD_PJ2__DCU_R5_D7   S32V234_MSCR_PJ2  PAD_CTL_DCU_CFG
+#define S32V234_PAD_PJ3__DCU_R6_D8   S32V234_MSCR_PJ3  PAD_CTL_DCU_CFG
+#define S32V234_PAD_PJ4__DCU_R7_D9   S32V234_MSCR_PJ4  PAD_CTL_DCU_CFG
+
+#define S32V234_PAD_PJ5__DCU_G0_D10  S32V234_MSCR_PJ5  PAD_CTL_DCU_CFG
+#define S32V234_PAD_PJ6__DCU_G1_D11  S32V234_MSCR_PJ6  PAD_CTL_DCU_CFG
+#define S32V234_PAD_PJ7__DCU_G2_D12  S32V234_MSCR_PJ7  PAD_CTL_DCU_CFG
+#define S32V234_PAD_PJ8__DCU_G3_D13  S32V234_MSCR_PJ8  PAD_CTL_DCU_CFG
+#define S32V234_PAD_PJ9__DCU_G4_D14  S32V234_MSCR_PJ9  PAD_CTL_DCU_CFG
+#define S32V234_PAD_PJ10__DCU_G5_D15 S32V234_MSCR_PJ10 PAD_CTL_DCU_CFG
+#define S32V234_PAD_PJ11__DCU_G6_D16 S32V234_MSCR_PJ11 PAD_CTL_DCU_CFG
+#define S32V234_PAD_PJ12__DCU_G7_D17 S32V234_MSCR_PJ12 PAD_CTL_DCU_CFG
+
+#define S32V234_PAD_PJ13__DCU_B0_D18 S32V234_MSCR_PJ13 PAD_CTL_DCU_CFG
+#define S32V234_PAD_PJ14__DCU_B1_D19 S32V234_MSCR_PJ14 PAD_CTL_DCU_CFG
+#define S32V234_PAD_PJ15__DCU_B2_D20 S32V234_MSCR_PJ15 PAD_CTL_DCU_CFG
+#define S32V234_PAD_PK0__DCU_B3_D21  S32V234_MSCR_PK0  PAD_CTL_DCU_CFG
+#define S32V234_PAD_PK1__DCU_B4_D22  S32V234_MSCR_PK1  PAD_CTL_DCU_CFG
+#define S32V234_PAD_PK2__DCU_B5_D23  S32V234_MSCR_PK2  PAD_CTL_DCU_CFG
+#define S32V234_PAD_PK3__DCU_B6_D24  S32V234_MSCR_PK3  PAD_CTL_DCU_CFG
+#define S32V234_PAD_PK4__DCU_B7_D25  S32V234_MSCR_PK4  PAD_CTL_DCU_CFG
+
+/* VIULite0 */
+#define S32V234_PAD_PD13__VIU0_EN    S32V234_MSCR_PD13       PAD_CTL_VIU_IBE
+#define S32V234_PAD_PD13__VIU0_PCLK  S32V234_IMCR_VIU0_PCLK  PAD_CTL_VIU_CFG
+#define S32V234_PAD_PD14__VIU0_EN    S32V234_MSCR_PD14       PAD_CTL_VIU_IBE
+#define S32V234_PAD_PD14__VIU0_HSYNC S32V234_IMCR_VIU0_HSYNC PAD_CTL_VIU_CFG
+#define S32V234_PAD_PD15__VIU0_EN    S32V234_MSCR_PD15       PAD_CTL_VIU_IBE
+#define S32V234_PAD_PD15__VIU0_VSYNC S32V234_IMCR_VIU0_VSYNC PAD_CTL_VIU_CFG
+
+#define S32V234_PAD_PF3__VIU_EN      S32V234_MSCR_PF3        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PF3__VIU0_D4     S32V234_IMCR_VIU0_D4    PAD_CTL_VIU_CFG
+#define S32V234_PAD_PF4__VIU_EN      S32V234_MSCR_PF4        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PF4__VIU0_D5     S32V234_IMCR_VIU0_D5    PAD_CTL_VIU_CFG
+#define S32V234_PAD_PF5__VIU_EN      S32V234_MSCR_PF5        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PF5__VIU0_D6     S32V234_IMCR_VIU0_D6    PAD_CTL_VIU_CFG
+#define S32V234_PAD_PF6__VIU_EN      S32V234_MSCR_PF6        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PF6__VIU0_D7     S32V234_IMCR_VIU0_D7    PAD_CTL_VIU_CFG
+#define S32V234_PAD_PE0__VIU0_EN     S32V234_MSCR_PE0        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PE0__VIU0_D8     S32V234_IMCR_VIU0_D8    PAD_CTL_VIU_CFG
+#define S32V234_PAD_PE1__VIU0_EN     S32V234_MSCR_PE1        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PE1__VIU0_D9     S32V234_IMCR_VIU0_D9    PAD_CTL_VIU_CFG
+#define S32V234_PAD_PE2__VIU0_EN     S32V234_MSCR_PE2        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PE2__VIU0_D10    S32V234_IMCR_VIU0_D10   PAD_CTL_VIU_CFG
+#define S32V234_PAD_PE3__VIU0_EN     S32V234_MSCR_PE3        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PE3__VIU0_D11    S32V234_IMCR_VIU0_D11   PAD_CTL_VIU_CFG
+#define S32V234_PAD_PE4__VIU0_EN     S32V234_MSCR_PE4        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PE4__VIU0_D12    S32V234_IMCR_VIU0_D12   PAD_CTL_VIU_CFG
+#define S32V234_PAD_PE5__VIU0_EN     S32V234_MSCR_PE5        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PE5__VIU0_D13    S32V234_IMCR_VIU0_D13   PAD_CTL_VIU_CFG
+#define S32V234_PAD_PE6__VIU0_EN     S32V234_MSCR_PE6        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PE6__VIU0_D14    S32V234_IMCR_VIU0_D14   PAD_CTL_VIU_CFG
+#define S32V234_PAD_PE7__VIU0_EN     S32V234_MSCR_PE7        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PE7__VIU0_D15    S32V234_IMCR_VIU0_D15   PAD_CTL_VIU_CFG
+#define S32V234_PAD_PE8__VIU0_EN     S32V234_MSCR_PE8        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PE8__VIU0_D16    S32V234_IMCR_VIU0_D16   PAD_CTL_VIU_CFG
+#define S32V234_PAD_PE9__VIU0_EN     S32V234_MSCR_PE9        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PE9__VIU0_D17    S32V234_IMCR_VIU0_D17   PAD_CTL_VIU_CFG
+#define S32V234_PAD_PE10__VIU0_EN    S32V234_MSCR_PE10       PAD_CTL_VIU_IBE
+#define S32V234_PAD_PE10__VIU0_D18   S32V234_IMCR_VIU0_D18   PAD_CTL_VIU_CFG
+#define S32V234_PAD_PE11__VIU0_EN    S32V234_MSCR_PE11       PAD_CTL_VIU_IBE
+#define S32V234_PAD_PE11__VIU0_D19   S32V234_IMCR_VIU0_D19   PAD_CTL_VIU_CFG
+#define S32V234_PAD_PE12__VIU0_EN    S32V234_MSCR_PE12       PAD_CTL_VIU_IBE
+#define S32V234_PAD_PE12__VIU0_D20   S32V234_IMCR_VIU0_D20   PAD_CTL_VIU_CFG
+#define S32V234_PAD_PE13__VIU0_EN    S32V234_MSCR_PE13       PAD_CTL_VIU_IBE
+#define S32V234_PAD_PE13__VIU0_D21   S32V234_IMCR_VIU0_D21   PAD_CTL_VIU_CFG
+#define S32V234_PAD_PE14__VIU0_EN    S32V234_MSCR_PE14       PAD_CTL_VIU_IBE
+#define S32V234_PAD_PE14__VIU0_D22   S32V234_IMCR_VIU0_D22   PAD_CTL_VIU_CFG
+#define S32V234_PAD_PE15__VIU0_EN    S32V234_MSCR_PE15       PAD_CTL_VIU_IBE
+#define S32V234_PAD_PE15__VIU0_D23   S32V234_IMCR_VIU0_D23   PAD_CTL_VIU_CFG
+
+/* VIULite1 */
+#define S32V234_PAD_PF0__VIU1_EN    S32V234_MSCR_PF0        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PF0__VIU1_PCLK  S32V234_IMCR_VIU1_PCLK  PAD_CTL_VIU_CFG
+#define S32V234_PAD_PF1__VIU1_EN    S32V234_MSCR_PF1        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PF1__VIU1_HSYNC S32V234_IMCR_VIU1_HSYNC PAD_CTL_VIU_CFG
+#define S32V234_PAD_PF2__VIU1_EN    S32V234_MSCR_PF2        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PF2__VIU1_VSYNC S32V234_IMCR_VIU1_VSYNC PAD_CTL_VIU_CFG
+
+#define S32V234_PAD_PF3__VIU_EN     S32V234_MSCR_PF3        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PF3__VIU1_D8    S32V234_IMCR_VIU1_D8    PAD_CTL_VIU_CFG
+#define S32V234_PAD_PF4__VIU_EN     S32V234_MSCR_PF4        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PF4__VIU1_D9    S32V234_IMCR_VIU1_D9    PAD_CTL_VIU_CFG
+#define S32V234_PAD_PF5__VIU_EN     S32V234_MSCR_PF5        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PF5__VIU1_D10   S32V234_IMCR_VIU1_D10   PAD_CTL_VIU_CFG
+#define S32V234_PAD_PF6__VIU_EN     S32V234_MSCR_PF6        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PF6__VIU1_D11   S32V234_IMCR_VIU1_D11   PAD_CTL_VIU_CFG
+#define S32V234_PAD_PF7__VIU1_EN    S32V234_MSCR_PF7        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PF7__VIU1_D12   S32V234_IMCR_VIU1_D12   PAD_CTL_VIU_CFG
+#define S32V234_PAD_PF8__VIU1_EN    S32V234_MSCR_PF8        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PF8__VIU1_D13   S32V234_IMCR_VIU1_D13   PAD_CTL_VIU_CFG
+#define S32V234_PAD_PF9__VIU1_EN    S32V234_MSCR_PF9        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PF9__VIU1_D14   S32V234_IMCR_VIU1_D14   PAD_CTL_VIU_CFG
+#define S32V234_PAD_PF10__VIU1_EN   S32V234_MSCR_PF10       PAD_CTL_VIU_IBE
+#define S32V234_PAD_PF10__VIU1_D15  S32V234_IMCR_VIU1_D15   PAD_CTL_VIU_CFG
+#define S32V234_PAD_PF11__VIU1_EN   S32V234_MSCR_PF11       PAD_CTL_VIU_IBE
+#define S32V234_PAD_PF11__VIU1_D16  S32V234_IMCR_VIU1_D16   PAD_CTL_VIU_CFG
+#define S32V234_PAD_PF12__VIU1_EN   S32V234_MSCR_PF12       PAD_CTL_VIU_IBE
+#define S32V234_PAD_PF12__VIU1_D17  S32V234_IMCR_VIU1_D17   PAD_CTL_VIU_CFG
+#define S32V234_PAD_PF13__VIU1_EN   S32V234_MSCR_PF13       PAD_CTL_VIU_IBE
+#define S32V234_PAD_PF13__VIU1_D18  S32V234_IMCR_VIU1_D18   PAD_CTL_VIU_CFG
+#define S32V234_PAD_PF14__VIU1_EN   S32V234_MSCR_PF14       PAD_CTL_VIU_IBE
+#define S32V234_PAD_PF14__VIU1_D19  S32V234_IMCR_VIU1_D19   PAD_CTL_VIU_CFG
+#define S32V234_PAD_PF15__VIU1_EN   S32V234_MSCR_PF15       PAD_CTL_VIU_IBE
+#define S32V234_PAD_PF15__VIU1_D20  S32V234_IMCR_VIU1_D20   PAD_CTL_VIU_CFG
+#define S32V234_PAD_PG0__VIU1_EN    S32V234_MSCR_PG0        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PG0__VIU1_D21   S32V234_IMCR_VIU1_D21   PAD_CTL_VIU_CFG
+#define S32V234_PAD_PG1__VIU1_EN    S32V234_MSCR_PG1        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PG1__VIU1_D22   S32V234_IMCR_VIU1_D22   PAD_CTL_VIU_CFG
+#define S32V234_PAD_PG2__VIU1_EN    S32V234_MSCR_PG2        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PG2__VIU1_D23   S32V234_IMCR_VIU1_D23   PAD_CTL_VIU_CFG
+
+/* SPI 0-3 */
+#define S32V234_PAD_PB6__SPI0_SOUT_OUT  S32V234_MSCR_PB6 PAD_CTL_SPI_MSCR_SOUT
+#define S32V234_PAD_PB7__SPI0_SIN_OUT   S32V234_MSCR_PB7 PAD_CTL_SPI_MSCR_SIN
+#define S32V234_PAD_PB7__SPI0_SIN_IN    S32V234_IMCR_SPI0_SIN \
+					PAD_CTL_SPI_IMCR_SIN
+#define S32V234_PAD_PB5__SPI0_SCK_OUT   S32V234_MSCR_PB5 PAD_CTL_SPI_MSCR_SCK
+#define S32V234_PAD_PB8__SPI0_CS0_OUT   S32V234_MSCR_PB8 \
+					(PAD_CTL_SPI_MSCR_CSx | \
+					PAD_CTL_MUX_MODE_ALT1)
+#define S32V234_PAD_PC0__SPI0_CS4_OUT   S32V234_MSCR_PC0 \
+					(PAD_CTL_SPI_MSCR_CSx | \
+					PAD_CTL_MUX_MODE_ALT3)
+#define S32V234_PAD_PC1__SPI0_CS5_OUT   S32V234_MSCR_PC1 \
+					(PAD_CTL_SPI_MSCR_CSx | \
+					PAD_CTL_MUX_MODE_ALT3)
+#define S32V234_PAD_PC2__SPI0_CS6_OUT   S32V234_MSCR_PC2 \
+					(PAD_CTL_SPI_MSCR_CSx | \
+					PAD_CTL_MUX_MODE_ALT3)
+#define S32V234_PAD_PC3__SPI0_CS7_OUT   S32V234_MSCR_PC3 \
+					(PAD_CTL_SPI_MSCR_CSx | \
+					PAD_CTL_MUX_MODE_ALT2)
+
+#define S32V234_PAD_PB10__SPI1_SOUT_OUT S32V234_MSCR_PB10 PAD_CTL_SPI_MSCR_SOUT
+#define S32V234_PAD_PB11__SPI1_SIN_OUT  S32V234_MSCR_PB11 PAD_CTL_SPI_MSCR_SIN
+#define S32V234_PAD_PB11__SPI1_SIN_IN   S32V234_IMCR_SPI1_SIN \
+					PAD_CTL_SPI_IMCR_SIN
+#define S32V234_PAD_PB9__SPI1_SCK_OUT   S32V234_MSCR_PB9 PAD_CTL_SPI_MSCR_SCK
+#define S32V234_PAD_PB12__SPI1_CS0_OUT  S32V234_MSCR_PB12 \
+					(PAD_CTL_SPI_MSCR_CSx | \
+					PAD_CTL_MUX_MODE_ALT1)
+
+#define S32V234_PAD_PB14__SPI2_SOUT_OUT S32V234_MSCR_PB14 PAD_CTL_SPI_MSCR_SOUT
+#define S32V234_PAD_PB15__SPI2_SIN_OUT  S32V234_MSCR_PB15 PAD_CTL_SPI_MSCR_SIN
+#define S32V234_PAD_PB15__SPI2_SIN_IN   S32V234_IMCR_SPI2_SIN \
+					PAD_CTL_SPI_IMCR_SIN
+#define S32V234_PAD_P13__SPI2_SCK_OUT   S32V234_MSCR_PB13 PAD_CTL_SPI_MSCR_SCK
+#define S32V234_PAD_PC0__SPI2_CS0_OUT   S32V234_MSCR_PC0 \
+					(PAD_CTL_SPI_MSCR_CSx | \
+					PAD_CTL_MUX_MODE_ALT1)
+
+#define S32V234_PAD_PC2__SPI3_SOUT_OUT  S32V234_MSCR_PC2 PAD_CTL_SPI_MSCR_SOUT
+#define S32V234_PAD_PC3__SPI3_SIN_OUT   S32V234_MSCR_PC3 PAD_CTL_SPI_MSCR_SIN
+#define S32V234_PAD_PC3__SPI3_SIN_IN    S32V234_IMCR_SPI3_SIN \
+					PAD_CTL_SPI_IMCR_SIN
+#define S32V234_PAD_PC1__SPI3_SCK_OUT   S32V234_MSCR_PC1 PAD_CTL_SPI_MSCR_SCK
+#define S32V234_PAD_PC4__SPI3_CS0_OUT   S32V234_MSCR_PC4 \
+					(PAD_CTL_SPI_MSCR_CSx | \
+					PAD_CTL_MUX_MODE_ALT1)
+
+/* SIUL2 GPIOs */
+#define S32V234_PAD_PA0__SIUL_GPIO0    S32V234_MSCR_PA0  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PA1__SIUL_GPIO1    S32V234_MSCR_PA1  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PA2__SIUL_GPIO2    S32V234_MSCR_PA2  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PA3__SIUL_GPIO3    S32V234_MSCR_PA3  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PA4__SIUL_GPIO4    S32V234_MSCR_PA4  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PA5__SIUL_GPIO5    S32V234_MSCR_PA5  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PA6__SIUL_GPIO6    S32V234_MSCR_PA6  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PA7__SIUL_GPIO7    S32V234_MSCR_PA7  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PA8__SIUL_GPIO8    S32V234_MSCR_PA8  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PA9__SIUL_GPIO9    S32V234_MSCR_PA9  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PA10__SIUL_GPIO10  S32V234_MSCR_PA10 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PA11__SIUL_GPIO11  S32V234_MSCR_PA11 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PA12__SIUL_GPIO12  S32V234_MSCR_PA12 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PA13__SIUL_GPIO13  S32V234_MSCR_PA13 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PA14__SIUL_GPIO14  S32V234_MSCR_PA14 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PA15__SIUL_GPIO15  S32V234_MSCR_PA15 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PB0__SIUL_GPIO16   S32V234_MSCR_PB0  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PB1__SIUL_GPIO17   S32V234_MSCR_PB1  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PB2__SIUL_GPIO18   S32V234_MSCR_PB2  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PB3__SIUL_GPIO19   S32V234_MSCR_PB3  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PB4__SIUL_GPIO20   S32V234_MSCR_PB4  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PB5__SIUL_GPIO21   S32V234_MSCR_PB5  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PB6__SIUL_GPIO22   S32V234_MSCR_PB6  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PB7__SIUL_GPIO23   S32V234_MSCR_PB7  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PB8__SIUL_GPIO24   S32V234_MSCR_PB8  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PB9__SIUL_GPIO25   S32V234_MSCR_PB9  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PB10__SIUL_GPIO26  S32V234_MSCR_PB10 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PB11__SIUL_GPIO27  S32V234_MSCR_PB11 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PB12__SIUL_GPIO28  S32V234_MSCR_PB12 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PB13__SIUL_GPIO29  S32V234_MSCR_PB13 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PB14__SIUL_GPIO30  S32V234_MSCR_PB14 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PB15__SIUL_GPIO31  S32V234_MSCR_PB15 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PC0__SIUL_GPIO32   S32V234_MSCR_PC0  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PC1__SIUL_GPIO33   S32V234_MSCR_PC1  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PC2__SIUL_GPIO34   S32V234_MSCR_PC2  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PC3__SIUL_GPIO35   S32V234_MSCR_PC3  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PC4__SIUL_GPIO36   S32V234_MSCR_PC4  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PC5__SIUL_GPIO37   S32V234_MSCR_PC5  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PC6__SIUL_GPIO38   S32V234_MSCR_PC6  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PC7__SIUL_GPIO39   S32V234_MSCR_PC7  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PC8__SIUL_GPIO40   S32V234_MSCR_PC8  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PC9__SIUL_GPIO41   S32V234_MSCR_PC9  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PC10__SIUL_GPIO42  S32V234_MSCR_PC10 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PC11__SIUL_GPIO43  S32V234_MSCR_PC11 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PC12__SIUL_GPIO44  S32V234_MSCR_PC12 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PC13__SIUL_GPIO45  S32V234_MSCR_PC13 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PC14__SIUL_GPIO46  S32V234_MSCR_PC14 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PC15__SIUL_GPIO47  S32V234_MSCR_PC15 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PD0__SIUL_GPIO48   S32V234_MSCR_PD0  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PD1__SIUL_GPIO49   S32V234_MSCR_PD1  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PD2__SIUL_GPIO50   S32V234_MSCR_PD2  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PD3__SIUL_GPIO51   S32V234_MSCR_PD3  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PD4__SIUL_GPIO52   S32V234_MSCR_PD4  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PD5__SIUL_GPIO53   S32V234_MSCR_PD5  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PD6__SIUL_GPIO54   S32V234_MSCR_PD6  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PD7__SIUL_GPIO55   S32V234_MSCR_PD7  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PD8__SIUL_GPIO56   S32V234_MSCR_PD8  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PD9__SIUL_GPIO57   S32V234_MSCR_PD9  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PD10__SIUL_GPIO58  S32V234_MSCR_PD10 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PD11__SIUL_GPIO59  S32V234_MSCR_PD11 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PD12__SIUL_GPIO60  S32V234_MSCR_PD12 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PD13__SIUL_GPIO61  S32V234_MSCR_PD13 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PD14__SIUL_GPIO62  S32V234_MSCR_PD14 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PD15__SIUL_GPIO63  S32V234_MSCR_PD15 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PE0__SIUL_GPIO64   S32V234_MSCR_PE0  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PE1__SIUL_GPIO65   S32V234_MSCR_PE1  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PE2__SIUL_GPIO66   S32V234_MSCR_PE2  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PE3__SIUL_GPIO67   S32V234_MSCR_PE3  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PE4__SIUL_GPIO68   S32V234_MSCR_PE4  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PE5__SIUL_GPIO69   S32V234_MSCR_PE5  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PE6__SIUL_GPIO70   S32V234_MSCR_PE6  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PE7__SIUL_GPIO71   S32V234_MSCR_PE7  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PE8__SIUL_GPIO72   S32V234_MSCR_PE8  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PE9__SIUL_GPIO73   S32V234_MSCR_PE9  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PE10__SIUL_GPIO74  S32V234_MSCR_PE10 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PE11__SIUL_GPIO75  S32V234_MSCR_PE11 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PE12__SIUL_GPIO76  S32V234_MSCR_PE12 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PE13__SIUL_GPIO77  S32V234_MSCR_PE13 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PE14__SIUL_GPIO78  S32V234_MSCR_PE14 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PE15__SIUL_GPIO79  S32V234_MSCR_PE15 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PF0__SIUL_GPIO80   S32V234_MSCR_PF0  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PF1__SIUL_GPIO81   S32V234_MSCR_PF1  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PF2__SIUL_GPIO82   S32V234_MSCR_PF2  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PF3__SIUL_GPIO83   S32V234_MSCR_PF3  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PF4__SIUL_GPIO84   S32V234_MSCR_PF4  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PF5__SIUL_GPIO85   S32V234_MSCR_PF5  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PF6__SIUL_GPIO86   S32V234_MSCR_PF6  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PF7__SIUL_GPIO87   S32V234_MSCR_PF7  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PF8__SIUL_GPIO88   S32V234_MSCR_PF8  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PF9__SIUL_GPIO89   S32V234_MSCR_PF9  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PF10__SIUL_GPIO90  S32V234_MSCR_PF10 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PF11__SIUL_GPIO91  S32V234_MSCR_PF11 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PF12__SIUL_GPIO92  S32V234_MSCR_PF12 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PF13__SIUL_GPIO93  S32V234_MSCR_PF13 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PF14__SIUL_GPIO94  S32V234_MSCR_PF14 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PF15__SIUL_GPIO95  S32V234_MSCR_PF15 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PG0__SIUL_GPIO96   S32V234_MSCR_PG0  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PG1__SIUL_GPIO97   S32V234_MSCR_PG1  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PG2__SIUL_GPIO98   S32V234_MSCR_PG2  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PG3__SIUL_GPIO99   S32V234_MSCR_PG3  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PG4__SIUL_GPIO100  S32V234_MSCR_PG4  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PG5__SIUL_GPIO101  S32V234_MSCR_PG5  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PG6__SIUL_GPIO102  S32V234_MSCR_PG6  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PG7__SIUL_GPIO103  S32V234_MSCR_PG7  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PG8__SIUL_GPIO104  S32V234_MSCR_PG8  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PG9__SIUL_GPIO105  S32V234_MSCR_PG9  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PG10__SIUL_GPIO106 S32V234_MSCR_PG10 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PG11__SIUL_GPIO107 S32V234_MSCR_PG11 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PG12__SIUL_GPIO108 S32V234_MSCR_PG12 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PG13__SIUL_GPIO109 S32V234_MSCR_PG13 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PG14__SIUL_GPIO110 S32V234_MSCR_PG14 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PG15__SIUL_GPIO111 S32V234_MSCR_PG15 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PH0__SIUL_GPIO112  S32V234_MSCR_PH0  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PH1__SIUL_GPIO113  S32V234_MSCR_PH1  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PH2__SIUL_GPIO114  S32V234_MSCR_PH2  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PH3__SIUL_GPIO115  S32V234_MSCR_PH3  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PH4__SIUL_GPIO116  S32V234_MSCR_PH4  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PH5__SIUL_GPIO117  S32V234_MSCR_PH5  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PH6__SIUL_GPIO118  S32V234_MSCR_PH6  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PH7__SIUL_GPIO119  S32V234_MSCR_PH7  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PH8__SIUL_GPIO120  S32V234_MSCR_PH8  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PH9__SIUL_GPIO121  S32V234_MSCR_PH9  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PH10__SIUL_GPIO122 S32V234_MSCR_PH10 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PH11__SIUL_GPIO123 S32V234_MSCR_PH11 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PH12__SIUL_GPIO124 S32V234_MSCR_PH12 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PH13__SIUL_GPIO125 S32V234_MSCR_PH13 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PH14__SIUL_GPIO126 S32V234_MSCR_PH14 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PH15__SIUL_GPIO127 S32V234_MSCR_PH15 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PJ0__SIUL_GPIO128  S32V234_MSCR_PJ0  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PJ1__SIUL_GPIO129  S32V234_MSCR_PJ1  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PJ2__SIUL_GPIO130  S32V234_MSCR_PJ2  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PJ3__SIUL_GPIO131  S32V234_MSCR_PJ3  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PJ4__SIUL_GPIO132  S32V234_MSCR_PJ4  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PJ5__SIUL_GPIO133  S32V234_MSCR_PJ5  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PJ6__SIUL_GPIO134  S32V234_MSCR_PJ6  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PJ7__SIUL_GPIO135  S32V234_MSCR_PJ7  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PJ8__SIUL_GPIO136  S32V234_MSCR_PJ8  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PJ9__SIUL_GPIO137  S32V234_MSCR_PJ9  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PJ10__SIUL_GPIO138 S32V234_MSCR_PJ10 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PJ11__SIUL_GPIO139 S32V234_MSCR_PJ11 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PJ12__SIUL_GPIO140 S32V234_MSCR_PJ12 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PJ13__SIUL_GPIO141 S32V234_MSCR_PJ13 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PJ14__SIUL_GPIO142 S32V234_MSCR_PJ14 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PJ15__SIUL_GPIO143 S32V234_MSCR_PJ15 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PK0__SIUL_GPIO144  S32V234_MSCR_PK0  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PK1__SIUL_GPIO145  S32V234_MSCR_PK1  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PK2__SIUL_GPIO146  S32V234_MSCR_PK2  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PK3__SIUL_GPIO147  S32V234_MSCR_PK3  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PK4__SIUL_GPIO148  S32V234_MSCR_PK4  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PK5__SIUL_GPIO149  S32V234_MSCR_PK5  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PK6__SIUL_GPIO150  S32V234_MSCR_PK6  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PK7__SIUL_GPIO151  S32V234_MSCR_PK7  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PK8__SIUL_GPIO152  S32V234_MSCR_PK8  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PK9__SIUL_GPIO153  S32V234_MSCR_PK9  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PK10__SIUL_GPIO154 S32V234_MSCR_PK10 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PK11__SIUL_GPIO155 S32V234_MSCR_PK11 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PK12__SIUL_GPIO156 S32V234_MSCR_PK12 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PK13__SIUL_GPIO157 S32V234_MSCR_PK13 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PK14__SIUL_GPIO158 S32V234_MSCR_PK14 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PK15__SIUL_GPIO159 S32V234_MSCR_PK15 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PL0__SIUL_GPIO160  S32V234_MSCR_PL0  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PL1__SIUL_GPIO161  S32V234_MSCR_PL1  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PL2__SIUL_GPIO162  S32V234_MSCR_PL2  PAD_CTL_MUX_MODE_ALT0
+
+/* SIUL2 EIRQ pins */
+#define S32V234_PAD_PA0__SIUL_EIRQ0   S32V234_IMCR_SIUL_EIRQ0  PAD_CTL_EIRQ
+#define S32V234_PAD_PA1__SIUL_EIRQ1   S32V234_IMCR_SIUL_EIRQ1  PAD_CTL_EIRQ
+#define S32V234_PAD_PA2__SIUL_EIRQ2   S32V234_IMCR_SIUL_EIRQ2  PAD_CTL_EIRQ
+#define S32V234_PAD_PA3__SIUL_EIRQ3   S32V234_IMCR_SIUL_EIRQ3  PAD_CTL_EIRQ
+#define S32V234_PAD_PA4__SIUL_EIRQ4   S32V234_IMCR_SIUL_EIRQ4  PAD_CTL_EIRQ
+#define S32V234_PAD_PA5__SIUL_EIRQ5   S32V234_IMCR_SIUL_EIRQ5  PAD_CTL_EIRQ
+#define S32V234_PAD_PA6__SIUL_EIRQ6   S32V234_IMCR_SIUL_EIRQ6  PAD_CTL_EIRQ
+#define S32V234_PAD_PA7__SIUL_EIRQ7   S32V234_IMCR_SIUL_EIRQ7  PAD_CTL_EIRQ
+#define S32V234_PAD_PA8__SIUL_EIRQ8   S32V234_IMCR_SIUL_EIRQ8  PAD_CTL_EIRQ
+#define S32V234_PAD_PA9__SIUL_EIRQ9   S32V234_IMCR_SIUL_EIRQ9  PAD_CTL_EIRQ
+#define S32V234_PAD_PA10__SIUL_EIRQ10 S32V234_IMCR_SIUL_EIRQ10 PAD_CTL_EIRQ
+#define S32V234_PAD_PA11__SIUL_EIRQ11 S32V234_IMCR_SIUL_EIRQ11 PAD_CTL_EIRQ
+#define S32V234_PAD_PA12__SIUL_EIRQ12 S32V234_IMCR_SIUL_EIRQ12 PAD_CTL_EIRQ
+#define S32V234_PAD_PA13__SIUL_EIRQ13 S32V234_IMCR_SIUL_EIRQ13 PAD_CTL_EIRQ
+#define S32V234_PAD_PA14__SIUL_EIRQ14 S32V234_IMCR_SIUL_EIRQ14 PAD_CTL_EIRQ
+#define S32V234_PAD_PA15__SIUL_EIRQ15 S32V234_IMCR_SIUL_EIRQ15 PAD_CTL_EIRQ
+#define S32V234_PAD_PB0__SIUL_EIRQ16  S32V234_IMCR_SIUL_EIRQ16 PAD_CTL_EIRQ
+#define S32V234_PAD_PB1__SIUL_EIRQ17  S32V234_IMCR_SIUL_EIRQ17 PAD_CTL_EIRQ
+#define S32V234_PAD_PB2__SIUL_EIRQ18  S32V234_IMCR_SIUL_EIRQ18 PAD_CTL_EIRQ
+#define S32V234_PAD_PB3__SIUL_EIRQ19  S32V234_IMCR_SIUL_EIRQ19 PAD_CTL_EIRQ
+#define S32V234_PAD_PB4__SIUL_EIRQ20  S32V234_IMCR_SIUL_EIRQ20 PAD_CTL_EIRQ
+#define S32V234_PAD_PB5__SIUL_EIRQ21  S32V234_IMCR_SIUL_EIRQ21 PAD_CTL_EIRQ
+#define S32V234_PAD_PB6__SIUL_EIRQ22  S32V234_IMCR_SIUL_EIRQ22 PAD_CTL_EIRQ
+#define S32V234_PAD_PB7__SIUL_EIRQ23  S32V234_IMCR_SIUL_EIRQ23 PAD_CTL_EIRQ
+#define S32V234_PAD_PB8__SIUL_EIRQ24  S32V234_IMCR_SIUL_EIRQ24 PAD_CTL_EIRQ
+#define S32V234_PAD_PB9__SIUL_EIRQ25  S32V234_IMCR_SIUL_EIRQ25 PAD_CTL_EIRQ
+#define S32V234_PAD_PB10__SIUL_EIRQ26 S32V234_IMCR_SIUL_EIRQ26 PAD_CTL_EIRQ
+#define S32V234_PAD_PB11__SIUL_EIRQ27 S32V234_IMCR_SIUL_EIRQ27 PAD_CTL_EIRQ
+#define S32V234_PAD_PB12__SIUL_EIRQ28 S32V234_IMCR_SIUL_EIRQ28 PAD_CTL_EIRQ
+#define S32V234_PAD_PB13__SIUL_EIRQ29 S32V234_IMCR_SIUL_EIRQ29 PAD_CTL_EIRQ
+#define S32V234_PAD_PB14__SIUL_EIRQ30 S32V234_IMCR_SIUL_EIRQ30 PAD_CTL_EIRQ
+#define S32V234_PAD_PB15__SIUL_EIRQ31 S32V234_IMCR_SIUL_EIRQ31 PAD_CTL_EIRQ
+
+#endif /* __DT_BINDINGS_S32V234_PINCTRL_H__ */
diff --git a/include/dt-bindings/power/imx8ulp-power.h b/include/dt-bindings/power/imx8ulp-power.h
new file mode 100644
index 000000000..a556b2e96
--- /dev/null
+++ b/include/dt-bindings/power/imx8ulp-power.h
@@ -0,0 +1,26 @@
+/* SPDX-License-Identifier: (GPL-2.0 OR MIT) */
+/*
+ *  Copyright 2021 NXP
+ */
+
+#ifndef __DT_BINDINGS_IMX8ULP_POWER_H__
+#define __DT_BINDINGS_IMX8ULP_POWER_H__
+
+#define IMX8ULP_PD_DMA1		0
+#define IMX8ULP_PD_FLEXSPI2	1
+#define IMX8ULP_PD_USB0		2
+#define IMX8ULP_PD_USDHC0	3
+#define IMX8ULP_PD_USDHC1	4
+#define IMX8ULP_PD_USDHC2_USB1	5
+#define IMX8ULP_PD_DCNANO	6
+#define IMX8ULP_PD_EPDC		7
+#define IMX8ULP_PD_DMA2		8
+#define IMX8ULP_PD_GPU2D	9
+#define IMX8ULP_PD_GPU3D	10
+#define IMX8ULP_PD_HIFI4	11
+#define IMX8ULP_PD_ISI		12
+#define IMX8ULP_PD_MIPI_CSI	13
+#define IMX8ULP_PD_MIPI_DSI	14
+#define IMX8ULP_PD_PXP		15
+
+#endif
diff --git a/include/dt-bindings/reset/imx8mm-dispmix.h b/include/dt-bindings/reset/imx8mm-dispmix.h
new file mode 100644
index 000000000..3af137b1b
--- /dev/null
+++ b/include/dt-bindings/reset/imx8mm-dispmix.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright 2019 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __IMX8MM_DISPMIX_H__
+#define __IMX8MM_DISPMIX_H__
+
+/* DISPMIX soft reset */
+#define IMX8MM_CSI_BRIDGE_CHIP_RESET			0
+#define IMX8MM_CSI_BRIDGE_IPG_HARD_ASYNC_RESET		1
+#define IMX8MM_CSI_BRIDGE_CSI_HRESET			2
+#define IMX8MM_CAMERA_PIXEL_RESET			3
+#define IMX8MM_MIPI_CSI_I_PRESET			4
+#define IMX8MM_MIPI_DSI_I_PRESET			5
+#define IMX8MM_BUS_RSTN_BLK_SYNC			6
+#define IMX8MM_DISPMIX_SFT_RSTN_NUM			7
+
+/* DISPMIX clock soft enable */
+#define IMX8MM_CSI_BRIDGE_CSI_HCLK_EN			0
+#define IMX8MM_CSI_BRIDGE_SPU_CLK_EN			1
+#define IMX8MM_CSI_BRIDGE_MEM_WRAPPER_CLK_EN		2
+#define IMX8MM_CSI_BRIDGE_IPG_CLK_EN			3
+#define IMX8MM_CSI_BRIDGE_IPG_CLK_S_EN			4
+#define IMX8MM_CSI_BRIDGE_IPG_CLK_S_RAW_EN		5
+#define IMX8MM_LCDIF_APB_CLK_EN				6
+#define IMX8MM_LCDIF_PIXEL_CLK_EN			7
+#define IMX8MM_MIPI_DSI_PCLK_EN				8
+#define IMX8MM_MIPI_DSI_CLKREF_EN			9
+#define IMX8MM_MIPI_CSI_ACLK_EN				10
+#define IMX8MM_MIPI_CSI_PCLK_EN				11
+#define IMX8MM_BUS_BLK_CLK_EN				12
+#define IMX8MM_DISPMIX_CLK_EN_NUM			13
+
+/* MIPI reset */
+#define IMX8MM_MIPI_S_RESET				0
+#define IMX8MM_MIPI_M_RESET				1
+#define IMX8MM_MIPI_RESET_NUM				2
+
+#endif
diff --git a/include/dt-bindings/reset/imx8mn-dispmix.h b/include/dt-bindings/reset/imx8mn-dispmix.h
new file mode 100644
index 000000000..8703ebe7d
--- /dev/null
+++ b/include/dt-bindings/reset/imx8mn-dispmix.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2019 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __IMX8MN_DISPMIX_H__
+#define __IMX8MN_DISPMIX_H__
+
+/* DISPMIX soft reset */
+#define IMX8MN_MIPI_DSI_PCLK_RESET			0
+#define IMX8MN_MIPI_DSI_CLKREF_RESET			1
+#define IMX8MN_MIPI_CSI_PCLK_RESET			2
+#define IMX8MN_MIPI_CSI_ACLK_RESET			3
+#define IMX8MN_LCDIF_PIXEL_CLK_RESET			4
+#define IMX8MN_LCDIF_APB_CLK_RESET			5
+#define IMX8MN_ISI_PROC_CLK_RESET			6
+#define IMX8MN_ISI_APB_CLK_RESET			7
+#define IMX8MN_BUS_BLK_CLK_RESET			8
+#define IMX8MN_DISPMIX_SFT_RSTN_NUM			9
+
+/* DISPMIX clock soft enable */
+#define IMX8MN_MIPI_DSI_PCLK_EN				0
+#define IMX8MN_MIPI_DSI_CLKREF_EN			1
+#define IMX8MN_MIPI_CSI_PCLK_EN				2
+#define IMX8MN_MIPI_CSI_ACLK_EN				3
+#define IMX8MN_LCDIF_PIXEL_CLK_EN			4
+#define IMX8MN_LCDIF_APB_CLK_EN				5
+#define IMX8MN_ISI_PROC_CLK_EN				6
+#define IMX8MN_ISI_APB_CLK_EN				7
+#define IMX8MN_BUS_BLK_CLK_EN				8
+#define IMX8MN_DISPMIX_CLK_EN_NUM			9
+
+/* MIPI reset */
+#define IMX8MN_MIPI_S_RESET				0
+#define IMX8MN_MIPI_M_RESET				1
+#define IMX8MN_MIPI_RESET_NUM				2
+
+#endif
diff --git a/include/dt-bindings/reset/imx8mp-reset.h b/include/dt-bindings/reset/imx8mp-reset.h
index 2e8c9104b..113a9a0e8 100644
--- a/include/dt-bindings/reset/imx8mp-reset.h
+++ b/include/dt-bindings/reset/imx8mp-reset.h
@@ -44,7 +44,53 @@
 #define IMX8MP_RESET_VPU_G2_RESET		35
 #define IMX8MP_RESET_VPUVC8KE_RESET		36
 #define IMX8MP_RESET_NOC_RESET			37
+#define IMX8MP_RESET_PCIE_CTRL_APPS_CLK_REQ	38
+
+#define IMX8MP_RESET_NUM			39
+
+#define IMX8MP_AUDIO_BLK_CTRL_EARC_RESET	0
+#define IMX8MP_AUDIO_BLK_CTRL_EARC_PHY_RESET	1
+
+#define IMX8MP_AUDIO_BLK_CTRL_RESET_NUM		2
+
+#define IMX8MP_MEDIA_BLK_CTRL_RESET_MIPI_DSI_PCLK	0
+#define IMX8MP_MEDIA_BLK_CTRL_RESET_MIPI_DSI_CLKREF	1
+#define IMX8MP_MEDIA_BLK_CTRL_RESET_MIPI_CSI_PCLK	2
+#define IMX8MP_MEDIA_BLK_CTRL_RESET_MIPI_CSI_ACLK	3
+#define IMX8MP_MEDIA_BLK_CTRL_RESET_LCDIF_PIXEL		4
+#define IMX8MP_MEDIA_BLK_CTRL_RESET_LCDIF_APB		5
+#define IMX8MP_MEDIA_BLK_CTRL_RESET_ISI_PROC		6
+#define IMX8MP_MEDIA_BLK_CTRL_RESET_ISI_APB		7
+#define IMX8MP_MEDIA_BLK_CTRL_RESET_BUS_BLK		8
+#define IMX8MP_MEDIA_BLK_CTRL_RESET_MIPI_CSI2_PCLK	9
+#define IMX8MP_MEDIA_BLK_CTRL_RESET_MIPI_CSI2_ACLK	10
+#define IMX8MP_MEDIA_BLK_CTRL_RESET_LCDIF2_PIXEL	11
+#define IMX8MP_MEDIA_BLK_CTRL_RESET_LCDIF2_APB		12
+#define IMX8MP_MEDIA_BLK_CTRL_RESET_ISP1_COR		13
+#define IMX8MP_MEDIA_BLK_CTRL_RESET_ISP1_AXI		14
+#define IMX8MP_MEDIA_BLK_CTRL_RESET_ISP1_AHB		15
+#define IMX8MP_MEDIA_BLK_CTRL_RESET_ISP0_COR		16
+#define IMX8MP_MEDIA_BLK_CTRL_RESET_ISP0_AXI		17
+#define IMX8MP_MEDIA_BLK_CTRL_RESET_ISP0_AHB		18
+#define IMX8MP_MEDIA_BLK_CTRL_RESET_DWE_COR		19
+#define IMX8MP_MEDIA_BLK_CTRL_RESET_DWE_AXI		20
+#define IMX8MP_MEDIA_BLK_CTRL_RESET_DWE_AHB		21
+#define IMX8MP_MEDIA_BLK_CTRL_RESET_MIPI_DSI2		22
+#define IMX8MP_MEDIA_BLK_CTRL_RESET_LCDIF_AXI		23
+#define IMX8MP_MEDIA_BLK_CTRL_RESET_LCDIF2_AXI		24
+
+#define IMX8MP_MEDIA_BLK_CTRL_RESET_NUM			25
+
+#define IMX8MP_HDMI_BLK_CTRL_HDMI_TX_RESET		0
+#define IMX8MP_HDMI_BLK_CTRL_HDMI_PHY_RESET		1
+#define IMX8MP_HDMI_BLK_CTRL_HDMI_PAI_RESET		2
+#define IMX8MP_HDMI_BLK_CTRL_HDMI_PVI_RESET		3
+#define IMX8MP_HDMI_BLK_CTRL_HDMI_TRNG_RESET		4
+#define IMX8MP_HDMI_BLK_CTRL_IRQ_STEER_RESET		5
+#define IMX8MP_HDMI_BLK_CTRL_HDMI_HDCP_RESET		6
+#define IMX8MP_HDMI_BLK_CTRL_LCDIF_RESET		7
+
+#define IMX8MP_HDMI_BLK_CTRL_RESET_NUM			8
 
-#define IMX8MP_RESET_NUM			38
 
 #endif
diff --git a/include/dt-bindings/reset/imx8mq-reset.h b/include/dt-bindings/reset/imx8mq-reset.h
index 705870693..5d201c000 100644
--- a/include/dt-bindings/reset/imx8mq-reset.h
+++ b/include/dt-bindings/reset/imx8mq-reset.h
@@ -61,7 +61,9 @@
 #define IMX8MQ_RESET_SW_M4C_RST			50
 #define IMX8MQ_RESET_SW_M4P_RST			51
 #define IMX8MQ_RESET_M4_ENABLE			52
+#define IMX8MQ_RESET_PCIE_CTRL_APPS_CLK_REQ	53	/* i.MX8M PCIe CTL CLK REQ */
+#define IMX8MQ_RESET_PCIE2_CTRL_APPS_CLK_REQ	54	/* i.MX8M PCIe CTL CLK REQ */
 
-#define IMX8MQ_RESET_NUM			53
+#define IMX8MQ_RESET_NUM			55
 
 #endif
diff --git a/include/dt-bindings/reset/imx8ulp-pcc-reset.h b/include/dt-bindings/reset/imx8ulp-pcc-reset.h
new file mode 100644
index 000000000..e99a4735c
--- /dev/null
+++ b/include/dt-bindings/reset/imx8ulp-pcc-reset.h
@@ -0,0 +1,59 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright 2021 NXP
+ */
+
+#ifndef DT_BINDING_PCC_RESET_IMX8ULP_H
+#define DT_BINDING_PCC_RESET_IMX8ULP_H
+
+/* PCC3 */
+#define PCC3_WDOG3_SWRST	0
+#define PCC3_WDOG4_SWRST	1
+#define PCC3_LPIT1_SWRST	2
+#define PCC3_TPM4_SWRST		3
+#define PCC3_TPM5_SWRST		4
+#define PCC3_FLEXIO1_SWRST	5
+#define PCC3_I3C2_SWRST		6
+#define PCC3_LPI2C4_SWRST	7
+#define PCC3_LPI2C5_SWRST	8
+#define PCC3_LPUART4_SWRST	9
+#define PCC3_LPUART5_SWRST	10
+#define PCC3_LPSPI4_SWRST	11
+#define PCC3_LPSPI5_SWRST	12
+
+/* PCC4 */
+#define PCC4_FLEXSPI2_SWRST	0
+#define PCC4_TPM6_SWRST		1
+#define PCC4_TPM7_SWRST		2
+#define PCC4_LPI2C6_SWRST	3
+#define PCC4_LPI2C7_SWRST	4
+#define PCC4_LPUART6_SWRST	5
+#define PCC4_LPUART7_SWRST	6
+#define PCC4_SAI4_SWRST		7
+#define PCC4_SAI5_SWRST		8
+#define PCC4_USDHC0_SWRST	9
+#define PCC4_USDHC1_SWRST	10
+#define PCC4_USDHC2_SWRST	11
+#define PCC4_USB0_SWRST		12
+#define PCC4_USB0_PHY_SWRST	13
+#define PCC4_USB1_SWRST		14
+#define PCC4_USB1_PHY_SWRST	15
+#define PCC4_ENET_SWRST		16
+
+/* PCC5 */
+#define PCC5_TPM8_SWRST		0
+#define PCC5_SAI6_SWRST		1
+#define PCC5_SAI7_SWRST		2
+#define PCC5_SPDIF_SWRST	3
+#define PCC5_ISI_SWRST		4
+#define PCC5_CSI_REGS_SWRST	5
+#define PCC5_CSI_SWRST		6
+#define PCC5_DSI_SWRST		7
+#define PCC5_WDOG5_SWRST	8
+#define PCC5_EPDC_SWRST		9
+#define PCC5_PXP_SWRST		10
+#define PCC5_GPU2D_SWRST	11
+#define PCC5_GPU3D_SWRST	12
+#define PCC5_DC_NANO_SWRST	13
+
+#endif /*DT_BINDING_RESET_IMX8ULP_H */
diff --git a/include/dt-bindings/reset/imx8ulp-sim-reset.h b/include/dt-bindings/reset/imx8ulp-sim-reset.h
new file mode 100644
index 000000000..b6b752fb1
--- /dev/null
+++ b/include/dt-bindings/reset/imx8ulp-sim-reset.h
@@ -0,0 +1,16 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+
+/*
+ * Copyright 2021 NXP
+ */
+
+#ifndef DT_BINDING_RESET_IMX8ULP_SIM_H
+#define DT_BINDING_RESET_IMX8ULP_SIM_H
+
+#define IMX8ULP_SIM_RESET_MIPI_DSI_RST_DPI_N	0
+#define IMX8ULP_SIM_RESET_MIPI_DSI_RST_ESC_N	1
+#define IMX8ULP_SIM_RESET_MIPI_DSI_RST_BYTE_N	2
+
+#define IMX8ULP_SIM_RESET_NUM			3
+
+#endif
diff --git a/include/dt-bindings/soc/imx8_hsio.h b/include/dt-bindings/soc/imx8_hsio.h
new file mode 100644
index 000000000..3cf1056b6
--- /dev/null
+++ b/include/dt-bindings/soc/imx8_hsio.h
@@ -0,0 +1,31 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright 2019 NXP
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __DT_BINDINGS_IMX8_HSIO_H
+#define __DT_BINDINGS_IMX8_HSIO_H
+
+/*
+ * imx8qm hsio has pciea, pcieb and sata modules, and hsio
+ * can be configured to the following different work modes.
+ * 1 - pciea 2 lanes and one sata ahci port.
+ * 2 - pciea 1 lane, pcieb 1 lane and one sata ahci port.
+ * 3 - pciea 2 lanes, pcieb 1 lane.
+ * Choose one mode, refer to the exact hardware board design.
+ */
+#define		PCIEAX2SATA		1
+#define		PCIEAX1PCIEBX1SATA	2
+#define		PCIEAX2PCIEBX1		3
+
+#endif /* __DT_BINDINGS_IMX8_HSIO_H */
diff --git a/include/linux/busfreq-imx.h b/include/linux/busfreq-imx.h
new file mode 100644
index 000000000..39c71a9f5
--- /dev/null
+++ b/include/linux/busfreq-imx.h
@@ -0,0 +1,77 @@
+/*
+ * Copyright 2012-2016 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_MXC_BUSFREQ_H__
+#define __ASM_ARCH_MXC_BUSFREQ_H__
+
+#include <linux/notifier.h>
+#include <linux/regulator/consumer.h>
+
+/*
+ * This enumerates busfreq low power mode entry and exit.
+ */
+enum busfreq_event {
+	LOW_BUSFREQ_ENTER,
+	LOW_BUSFREQ_EXIT,
+};
+
+/*
+ * This enumerates the system bus and ddr frequencies in various modes.
+ * BUS_FREQ_HIGH - DDR @ 528MHz, AHB @ 132MHz.
+ * BUS_FREQ_MED - DDR @ 400MHz, AHB @ 132MHz
+ * BUS_FREQ_AUDIO - DDR @ 50MHz/100MHz, AHB @ 24MHz.
+ * BUS_FREQ_LOW  - DDR @ 24MHz, AHB @ 24MHz.
+ * BUS_FREQ_ULTRA_LOW - DDR @ 1MHz, AHB - 3MHz.
+ *
+ * Drivers need to request/release the bus/ddr frequencies based on
+ * their performance requirements. Drivers cannot request/release
+ * BUS_FREQ_ULTRA_LOW mode as this mode is automatically entered from
+ * either BUS_FREQ_AUDIO or BUS_FREQ_LOW
+ * modes.
+ */
+enum bus_freq_mode {
+	BUS_FREQ_HIGH,
+	BUS_FREQ_MED,
+	BUS_FREQ_AUDIO,
+	BUS_FREQ_LOW,
+	BUS_FREQ_ULTRA_LOW,
+};
+
+#if defined(CONFIG_HAVE_IMX_BUSFREQ) && !defined(CONFIG_ARM64)
+extern struct regulator *arm_reg;
+extern struct regulator *soc_reg;
+void request_bus_freq(enum bus_freq_mode mode);
+void release_bus_freq(enum bus_freq_mode mode);
+int register_busfreq_notifier(struct notifier_block *nb);
+int unregister_busfreq_notifier(struct notifier_block *nb);
+int get_bus_freq_mode(void);
+#elif defined(CONFIG_HAVE_IMX_BUSFREQ)
+void request_bus_freq(enum bus_freq_mode mode);
+void release_bus_freq(enum bus_freq_mode mode);
+int get_bus_freq_mode(void);
+#else
+static inline void request_bus_freq(enum bus_freq_mode mode)
+{
+}
+static inline void release_bus_freq(enum bus_freq_mode mode)
+{
+}
+static inline int register_busfreq_notifier(struct notifier_block *nb)
+{
+	return 0;
+}
+static inline int unregister_busfreq_notifier(struct notifier_block *nb)
+{
+	return 0;
+}
+static inline int get_bus_freq_mode(void)
+{
+	return BUS_FREQ_HIGH;
+}
+#endif
+#endif
diff --git a/include/linux/clk-provider.h b/include/linux/clk-provider.h
index f59c87527..fa5e4b189 100644
--- a/include/linux/clk-provider.h
+++ b/include/linux/clk-provider.h
@@ -32,6 +32,7 @@
 #define CLK_OPS_PARENT_ENABLE	BIT(12)
 /* duty cycle call may be forwarded to the parent clock */
 #define CLK_DUTY_CYCLE_PARENT	BIT(13)
+#define CLK_SET_PARENT_NOCACHE	BIT(14) /* do not use the cached clk parent */
 
 struct clk;
 struct clk_hw;
diff --git a/include/linux/imx_rpmsg.h b/include/linux/imx_rpmsg.h
new file mode 100644
index 000000000..e0d5e979a
--- /dev/null
+++ b/include/linux/imx_rpmsg.h
@@ -0,0 +1,43 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2019 NXP.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+ * @file linux/imx_rpmsg.h
+ *
+ * @brief Global header file for iMX RPMSG
+ *
+ * @ingroup RPMSG
+ */
+#ifndef __LINUX_IMX_RPMSG_H__
+#define __LINUX_IMX_RPMSG_H__
+
+/* Category define */
+#define IMX_RMPSG_LIFECYCLE	1
+#define IMX_RPMSG_PMIC		2
+#define IMX_RPMSG_AUDIO		3
+#define IMX_RPMSG_KEY		4
+#define IMX_RPMSG_GPIO		5
+#define IMX_RPMSG_RTC		6
+#define IMX_RPMSG_SENSOR	7
+/* rpmsg version */
+#define IMX_RMPSG_MAJOR		1
+#define IMX_RMPSG_MINOR		0
+
+#define CIRC_ADD(idx, size, value)	(((idx) + (value)) & ((size) - 1))
+
+struct imx_rpmsg_head {
+	u8 cate;
+	u8 major;
+	u8 minor;
+	u8 type;
+	u8 cmd;
+	u8 reserved[5];
+} __packed;
+
+#endif /* __LINUX_IMX_RPMSG_H__ */
diff --git a/include/linux/imx_sema4.h b/include/linux/imx_sema4.h
new file mode 100644
index 000000000..19850ae77
--- /dev/null
+++ b/include/linux/imx_sema4.h
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2014-2015 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __LINUX_IMX_SEMA4_H__
+#define __LINUX_IMX_SEMA4_H__
+
+#define SEMA4_NUM_DEVICES	1
+#define SEMA4_NUM_GATES		16
+
+#define SEMA4_UNLOCK	0x00
+#define SEMA4_A9_LOCK	0x01
+#define SEMA4_GATE_MASK	0x03
+
+#define CORE_MUTEX_VALID	(('c'<<24)|('m'<<24)|('t'<<24)|'x')
+
+/*
+ * The enumerates
+ */
+enum {
+	/* sema4 registers offset */
+	SEMA4_CP0INE	= 0x40,
+	SEMA4_CP1INE	= 0x48,
+	SEMA4_CP0NTF	= 0x80,
+	SEMA4_CP1NTF	= 0x88,
+};
+
+static const unsigned int idx_sema4[SEMA4_NUM_GATES] = {
+	1 << 7, 1 << 6, 1 << 5, 1 << 4,
+	1 << 3, 1 << 2, 1 << 1, 1 << 0,
+	1 << 15, 1 << 14, 1 << 13, 1 << 12,
+	1 << 11, 1 << 10, 1 << 9, 1 << 8,
+};
+
+struct imx_sema4_mutex {
+	u32			valid;
+	u32			gate_num;
+	unsigned char		gate_val;
+	wait_queue_head_t       wait_q;
+};
+
+struct imx_sema4_mutex_device {
+	struct device		*dev;
+	u16			cpntf_val;
+	u16			cpine_val;
+	void __iomem		*ioaddr;	/* Mapped address */
+	spinlock_t		lock;		/* Mutex */
+	int			irq;
+
+	u16			alloced;
+	struct imx_sema4_mutex	*mutex_ptr[SEMA4_NUM_GATES];
+};
+
+struct imx_sema4_mutex *
+	imx_sema4_mutex_create(u32 dev_num, u32 mutex_num);
+#ifdef CONFIG_IMX_SEMA4
+int imx_sema4_mutex_destroy(struct imx_sema4_mutex *mutex_ptr);
+int imx_sema4_mutex_trylock(struct imx_sema4_mutex *mutex_ptr);
+int imx_sema4_mutex_lock(struct imx_sema4_mutex *mutex_ptr);
+int imx_sema4_mutex_unlock(struct imx_sema4_mutex *mutex_ptr);
+#else
+static inline int imx_sema4_mutex_destroy(struct imx_sema4_mutex *mutex_ptr)
+{
+	return 0;
+}
+static inline int imx_sema4_mutex_trylock(struct imx_sema4_mutex *mutex_ptr)
+{
+	return 0;
+}
+static inline int imx_sema4_mutex_lock(struct imx_sema4_mutex *mutex_ptr)
+{
+	return 0;
+}
+static inline int imx_sema4_mutex_unlock(struct imx_sema4_mutex *mutex_ptr)
+{
+	return 0;
+}
+#endif
+#endif /* __LINUX_IMX_SEMA4_H__ */
diff --git a/include/linux/imx_vpu.h b/include/linux/imx_vpu.h
new file mode 100644
index 000000000..55fc1b20a
--- /dev/null
+++ b/include/linux/imx_vpu.h
@@ -0,0 +1,19 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright 2018-2020 NXP
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __LINUX_IMX_VPU_H
+#define __LINUX_IMX_VPU_H
+
+#include <uapi/linux/imx_vpu.h>
+
+#endif
diff --git a/include/soc/imx/gpc.h b/include/soc/imx/gpc.h
new file mode 100644
index 000000000..6a976e6aa
--- /dev/null
+++ b/include/soc/imx/gpc.h
@@ -0,0 +1,7 @@
+#ifndef __SOC_IMX_GPC_H
+#define __SOC_IMX_GPC_H
+
+void imx_gpc_hold_m4_in_sleep(void);
+void imx_gpc_release_m4_in_sleep(void);
+
+#endif /* __SOC_IMX_GPC_H */
diff --git a/include/soc/imx/imx-secvio-sc.h b/include/soc/imx/imx-secvio-sc.h
new file mode 100644
index 000000000..2d5f2a015
--- /dev/null
+++ b/include/soc/imx/imx-secvio-sc.h
@@ -0,0 +1,178 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2019 NXP
+ */
+
+#ifndef _MISC_IMX_SECVIO_SC_H_
+#define _MISC_IMX_SECVIO_SC_H_
+
+#include <linux/kernel.h>
+#include <linux/notifier.h>
+
+/* Bitmask of the security violation status bit in the HPSVS register */
+#define HPSVS__LP_SEC_VIO__MASK BIT(31)
+#define HPSVS__SW_LPSV__MASK    BIT(15)
+#define HPSVS__SW_FSV__MASK     BIT(14)
+#define HPSVS__SW_SV__MASK      BIT(13)
+#define HPSVS__SV5__MASK        BIT(5)
+#define HPSVS__SV4__MASK        BIT(4)
+#define HPSVS__SV3__MASK        BIT(3)
+#define HPSVS__SV2__MASK        BIT(2)
+#define HPSVS__SV1__MASK        BIT(1)
+#define HPSVS__SV0__MASK        BIT(0)
+
+/* Bitmask of all security violation status bit in the HPSVS register */
+#define HPSVS__ALL_SV__MASK (HPSVS__LP_SEC_VIO__MASK | \
+			     HPSVS__SW_LPSV__MASK | \
+			     HPSVS__SW_FSV__MASK | \
+			     HPSVS__SW_SV__MASK | \
+			     HPSVS__SV5__MASK | \
+			     HPSVS__SV4__MASK | \
+			     HPSVS__SV3__MASK | \
+			     HPSVS__SV2__MASK | \
+			     HPSVS__SV1__MASK | \
+			     HPSVS__SV0__MASK)
+
+/*
+ * Bitmask of the security violation and tampers status bit in the LPS register
+ */
+#define LPS__ESVD__MASK  BIT(16)
+#define LPS__ET2D__MASK  BIT(10)
+#define LPS__ET1D__MASK  BIT(9)
+#define LPS__WMT2D__MASK BIT(8)
+#define LPS__WMT1D__MASK BIT(7)
+#define LPS__VTD__MASK   BIT(6)
+#define LPS__TTD__MASK   BIT(5)
+#define LPS__CTD__MASK   BIT(4)
+#define LPS__PGD__MASK   BIT(3)
+#define LPS__MCR__MASK   BIT(2)
+#define LPS__SRTCR__MASK BIT(1)
+#define LPS__LPTA__MASK  BIT(0)
+
+/*
+ * Bitmask of all security violation and tampers status bit in the LPS register
+ */
+#define LPS__ALL_TP__MASK (LPS__ESVD__MASK | \
+			   LPS__ET2D__MASK | \
+			   LPS__ET1D__MASK | \
+			   LPS__WMT2D__MASK | \
+			   LPS__WMT1D__MASK | \
+			   LPS__VTD__MASK | \
+			   LPS__TTD__MASK | \
+			   LPS__CTD__MASK | \
+			   LPS__PGD__MASK | \
+			   LPS__MCR__MASK | \
+			   LPS__SRTCR__MASK | \
+			   LPS__LPTA__MASK)
+
+/*
+ * Bitmask of the security violation and tampers status bit in the LPTDS
+ * register
+ */
+#define LPTDS__ET10D__MASK  BIT(7)
+#define LPTDS__ET9D__MASK   BIT(6)
+#define LPTDS__ET8D__MASK   BIT(5)
+#define LPTDS__ET7D__MASK   BIT(4)
+#define LPTDS__ET6D__MASK   BIT(3)
+#define LPTDS__ET5D__MASK   BIT(2)
+#define LPTDS__ET4D__MASK   BIT(1)
+#define LPTDS__ET3D__MASK   BIT(0)
+
+/*
+ * Bitmask of all security violation and tampers status bit in the LPTDS
+ * register
+ */
+#define LPTDS__ALL_TP__MASK (LPTDS__ET10D__MASK | \
+			     LPTDS__ET9D__MASK | \
+			     LPTDS__ET8D__MASK | \
+			     LPTDS__ET7D__MASK | \
+			     LPTDS__ET6D__MASK | \
+			     LPTDS__ET5D__MASK | \
+			     LPTDS__ET4D__MASK | \
+			     LPTDS__ET3D__MASK)
+
+/* Struct for notification */
+/**
+ * struct secvio_sc_notifier_info - Information about the status of the SNVS
+ * @hpsvs:   status from register HPSVS
+ * @lps: status from register LPS
+ * @lptds: status from register LPTDS
+ */
+struct secvio_sc_notifier_info {
+	u32 hpsvs;
+	u32 lps;
+	u32 lptds;
+};
+
+/**
+ * register_imx_secvio_sc_notifier() - Register a notifier
+ *
+ * @nb: The notifier block structure
+ *
+ * Register a function to notify to the imx-secvio-sc module. The function
+ * will be notified when a check of the state of the SNVS happens: called by
+ * a user or triggered by an interruption form the SNVS.
+ *
+ * The struct secvio_sc_notifier_info is passed as data to the notifier.
+ *
+ * Return: 0 in case of success
+ */
+int register_imx_secvio_sc_notifier(struct notifier_block *nb);
+
+/**
+ * unregister_imx_secvio_sc_notifier() - Unregister a notifier
+ *
+ * @nb: The notifier block structure
+ *
+ * Return: 0 in case of success
+ */
+int unregister_imx_secvio_sc_notifier(struct notifier_block *nb);
+
+/**
+ * imx_secvio_sc_get_state() - Get the state of the SNVS
+ *
+ * @info: The structure containing the state of the SNVS
+ *
+ * Return: 0 in case of success
+ */
+int imx_secvio_sc_get_state(struct secvio_sc_notifier_info *info);
+
+/**
+ * imx_secvio_sc_check_state() - Check the state of the SNVS
+ *
+ * If a security violation or a tamper is detected, the list of notifier
+ * (registered using register_imx_secvio_sc_notifier() ) will be called
+ *
+ * Return: 0 in case of success
+ */
+int imx_secvio_sc_check_state(void);
+
+/**
+ * imx_secvio_sc_clear_state() - Clear the state of the SNVS
+ *
+ * @hpsvs: Value to write to HPSVS register
+ * @lps:   Value to write to LPS register
+ * @lptds: Value to write to LPTDSregister
+ *
+ * The function will write the value provided to the corresponding register
+ * which will clear the status of the bits set.
+ *
+ * Return: 0 in case of success
+ */
+int imx_secvio_sc_clear_state(u32 hpsvs, u32 lps, u32 lptds);
+
+/* Commands of the ioctl interface */
+enum ioctl_cmd_t {
+	GET_STATE,
+	CHECK_STATE,
+	CLEAR_STATE,
+};
+
+/* Definition for the ioctl interface */
+#define IMX_SECVIO_SC_GET_STATE   _IOR('S', GET_STATE, \
+				struct secvio_sc_notifier_info)
+#define IMX_SECVIO_SC_CHECK_STATE _IO('S', CHECK_STATE)
+#define IMX_SECVIO_SC_CLEAR_STATE _IOW('S', CLEAR_STATE, \
+				struct secvio_sc_notifier_info)
+
+#endif /* _MISC_IMX_SECVIO_SC_H_ */
diff --git a/include/soc/imx/imx_sip.h b/include/soc/imx/imx_sip.h
new file mode 100644
index 000000000..082a16f7e
--- /dev/null
+++ b/include/soc/imx/imx_sip.h
@@ -0,0 +1,17 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright 2019 NXP
+ */
+
+#ifndef __IMX_SIP_H__
+#define __IMX_SIP_H__
+
+#define IMX_SIP_GPC			0xC2000000
+#define IMX_SIP_CONFIG_GPC_PM_DOMAIN	0x03
+
+#define IMX_SIP_SRC			0xc2000005
+#define IMX_SIP_SRC_M4_START		0x00
+#define IMX_SIP_SRC_M4_STARTED		0x01
+#define IMX_SIP_SRC_M4_STOP		0x02
+
+#endif /* __IMX_SIP_H__ */
diff --git a/include/soc/imx/soc.h b/include/soc/imx/soc.h
new file mode 100644
index 000000000..78e055231
--- /dev/null
+++ b/include/soc/imx/soc.h
@@ -0,0 +1,20 @@
+/*
+ * Copyright 2017 NXP
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __SOC_IMX8_SOC_H__
+#define __SOC_IMX8_SOC_H__
+
+int check_m4_enabled(void);
+
+#endif
diff --git a/include/soc/imx/src.h b/include/soc/imx/src.h
new file mode 100644
index 000000000..c55c34cd2
--- /dev/null
+++ b/include/soc/imx/src.h
@@ -0,0 +1,6 @@
+#ifndef __SOC_IMX_SRC_H
+#define __SOC_IMX_SRC_H
+
+bool imx_src_is_m4_enabled(void);
+
+#endif /* __SOC_IMX_SRC_H */
diff --git a/include/uapi/drm/drm_fourcc.h b/include/uapi/drm/drm_fourcc.h
index 9f4bb4a6f..28c4c4034 100644
--- a/include/uapi/drm/drm_fourcc.h
+++ b/include/uapi/drm/drm_fourcc.h
@@ -368,6 +368,8 @@ extern "C" {
 #define DRM_FORMAT_MOD_VENDOR_ARM     0x08
 #define DRM_FORMAT_MOD_VENDOR_ALLWINNER 0x09
 #define DRM_FORMAT_MOD_VENDOR_AMLOGIC 0x0a
+#define DRM_FORMAT_MOD_VENDOR_AMPHION 0xf0
+#define DRM_FORMAT_MOD_VENDOR_VSI     0xf1
 
 /* add more to the end as needed */
 
@@ -630,6 +632,15 @@ extern "C" {
  */
 #define DRM_FORMAT_MOD_VIVANTE_SPLIT_SUPER_TILED fourcc_mod_code(VIVANTE, 4)
 
+	/*
+ * Vivante 64x64 super-tiling with compression layout
+ *
+ * This is a tiled layout using 64x64 pixel super-tiles, where each super-tile
+ * contains 8x4 groups of 2x4 tiles of 4x4 pixels each, all in row-major layout
+ * with compression.
+ */
+#define DRM_FORMAT_MOD_VIVANTE_SUPER_TILED_FC	fourcc_mod_code(VIVANTE, 5)
+
 /* NVIDIA frame buffer modifiers */
 
 /*
@@ -1358,6 +1369,42 @@ drm_fourcc_canonicalize_nvidia_format_mod(__u64 modifier)
 #define AMD_FMT_MOD_CLEAR(field) \
 	(~((uint64_t)AMD_FMT_MOD_##field##_MASK << AMD_FMT_MOD_##field##_SHIFT))
 
+/* Amphion tiled layout */
+
+/*
+ * Amphion 8x128 tiling layout
+ *
+ * This is a tiled layout using 8x128 pixel vertical strips, where each strip
+ * contains 1x16 groups of 8x8 pixels in a row-major layout.
+ */
+#define DRM_FORMAT_MOD_AMPHION_TILED fourcc_mod_code(AMPHION, 1)
+
+/* Verisilicon framebuffer modifiers */
+
+/*
+ * Verisilicon 8x4 tiling layout
+ *
+ * This is G1 VPU tiled layout using tiles of 8x4 pixels in a row-major
+ * layout.
+ */
+#define DRM_FORMAT_MOD_VSI_G1_TILED fourcc_mod_code(VSI, 1)
+
+/*
+ * Verisilicon 4x4 tiling layout
+ *
+ * This is G2 VPU tiled layout using tiles of 4x4 pixels in a row-major
+ * layout.
+ */
+#define DRM_FORMAT_MOD_VSI_G2_TILED fourcc_mod_code(VSI, 2)
+
+/*
+ * Verisilicon 4x4 tiling with compression layout
+ *
+ * This is G2 VPU tiled layout using tiles of 4x4 pixels in a row-major
+ * layout with compression.
+ */
+#define DRM_FORMAT_MOD_VSI_G2_TILED_COMPRESSED fourcc_mod_code(VSI, 3)
+
 #if defined(__cplusplus)
 }
 #endif
-- 
2.25.1

