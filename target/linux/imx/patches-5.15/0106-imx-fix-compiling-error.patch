From 415414c527b1419dab1488e0de1f26a9ca282961 Mon Sep 17 00:00:00 2001
From: Yuantian Tang <andy.tang@nxp.com>
Date: Wed, 28 Sep 2022 14:12:41 +0800
Subject: [PATCH 106/274] imx: fix compiling error

Signed-off-by: Tang Yuantian <andy.tang@nxp.com>
---
 include/linux/platform_data/dma-imx.h |  41 +++
 include/linux/pxp_device.h            |  66 +++++
 include/linux/pxp_dma.h               |  70 ++++++
 include/uapi/linux/pxp_device.h       |  66 +++++
 include/uapi/linux/pxp_dma.h          | 347 ++++++++++++++++++++++++++
 5 files changed, 590 insertions(+)
 create mode 100644 include/linux/pxp_device.h
 create mode 100644 include/linux/pxp_dma.h
 create mode 100644 include/uapi/linux/pxp_device.h
 create mode 100644 include/uapi/linux/pxp_dma.h

diff --git a/include/linux/platform_data/dma-imx.h b/include/linux/platform_data/dma-imx.h
index 281adbb26..ba4953839 100644
--- a/include/linux/platform_data/dma-imx.h
+++ b/include/linux/platform_data/dma-imx.h
@@ -39,6 +39,9 @@ enum sdma_peripheral_type {
 	IMX_DMATYPE_SSI_DUAL,	/* SSI Dual FIFO */
 	IMX_DMATYPE_ASRC_SP,	/* Shared ASRC */
 	IMX_DMATYPE_SAI,	/* SAI */
+	IMX_DMATYPE_MULTI_SAI,  /* MULTI FIFOs For Audio */
+	IMX_DMATYPE_HDMI,	/* HDMI Audio */
+	IMX_DMATYPE_I2C,	/* I2C */
 };
 
 enum imx_dma_prio {
@@ -47,6 +50,39 @@ enum imx_dma_prio {
 	DMA_PRIO_LOW = 2
 };
 
+/**
+ * struct sdma_audio_config - special sdma config for audio case
+ * @src_fifo_num: source fifo number for mcu_2_sai/sai_2_mcu script
+ *                For example, if there are 4 fifos, sdma will fetch
+ *                fifos one by one and roll back to the first fifo after
+ *                the 4th fifo fetch.
+ * @dst_fifo_num: similar as src_fifo_num, but dest fifo instead.
+ * @src_fifo_off: source fifo offset, 0 means all fifos are continuous, 1
+ *                means 1 word offset between fifos. All offset between
+ *                fifos should be same.
+ * @dst_fifo_off: dst fifo offset, similar as @src_fifo_off.
+ * @words_per_fifo: numbers of words per fifo fetch/fill, 0 means
+ *                  one channel per fifo, 1 means 2 channels per fifo..
+ *                  If 'src_fifo_num =  4' and 'chans_per_fifo = 1', it
+ *                  means the first two words(channels) fetch from fifo1
+ *                  and then jump to fifo2 for next two words, and so on
+ *                  after the last fifo4 fetched, roll back to fifo1.
+ * @sw_done_sel: software done selector, PDM need enable software done feature
+ *               in mcu_2_sai/sai_2_mcu script.
+ *               Bit31: sw_done eanbled or not
+ *               Bit16~Bit0: selector
+ *               For example: 0x80000000 means sw_done enabled for done0
+ *                            sector which is for PDM on i.mx8mm.
+ */
+struct sdma_audio_config {
+	u8 src_fifo_num;
+	u8 dst_fifo_num;
+	u8 src_fifo_off;
+	u8 dst_fifo_off;
+	u8 words_per_fifo;
+	u32 sw_done_sel;
+};
+
 struct imx_dma_data {
 	int dma_request; /* DMA request line */
 	int dma_request2; /* secondary DMA request line */
@@ -59,6 +95,11 @@ static inline int imx_dma_is_ipu(struct dma_chan *chan)
 	return !strcmp(dev_name(chan->device->dev), "ipu-core");
 }
 
+static inline int imx_dma_is_pxp(struct dma_chan *chan)
+{
+        return strstr(dev_name(chan->device->dev), "pxp") != NULL;
+}
+
 static inline int imx_dma_is_general_purpose(struct dma_chan *chan)
 {
 	return !strcmp(chan->device->dev->driver->name, "imx-sdma") ||
diff --git a/include/linux/pxp_device.h b/include/linux/pxp_device.h
new file mode 100644
index 000000000..9946a56ac
--- /dev/null
+++ b/include/linux/pxp_device.h
@@ -0,0 +1,66 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2013-2014 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * Copyright 2019 NXP
+ */
+#ifndef _PXP_DEVICE
+#define _PXP_DEVICE
+
+#include <linux/idr.h>
+#include <linux/hash.h>
+#include <uapi/linux/pxp_device.h>
+
+struct pxp_irq_info {
+	wait_queue_head_t waitq;
+	atomic_t irq_pending;
+	int hist_status;
+};
+
+struct pxp_buffer_hash {
+	struct hlist_head *hash_table;
+	u32 order;
+	spinlock_t hash_lock;
+};
+
+struct pxp_buf_obj {
+	uint32_t handle;
+
+	uint32_t size;
+	uint32_t mem_type;
+
+	unsigned long offset;
+	void *virtual;
+	unsigned long attrs;
+
+	struct hlist_node item;
+
+	struct sg_table *sgt_base;
+	/* DMABUF related */
+	struct dma_buf_attachment *db_attach;
+};
+
+struct pxp_chan_obj {
+	uint32_t handle;
+	struct dma_chan *chan;
+};
+
+/* File private data */
+struct pxp_file {
+	struct file *filp;
+
+	/* record allocated dma buffer */
+	struct idr buffer_idr;
+	spinlock_t buffer_lock;
+
+	/* record allocated dma channel */
+	struct idr channel_idr;
+	spinlock_t channel_lock;
+};
+
+struct pxp_attachment {
+	struct sg_table sgt;
+	enum dma_data_direction dma_dir;
+};
+
+#endif
diff --git a/include/linux/pxp_dma.h b/include/linux/pxp_dma.h
new file mode 100644
index 000000000..f89e36369
--- /dev/null
+++ b/include/linux/pxp_dma.h
@@ -0,0 +1,70 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2010-2015 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * Copyright 2017-2019 NXP
+ */
+#ifndef _PXP_DMA
+#define _PXP_DMA
+
+#include <uapi/linux/pxp_dma.h>
+
+struct pxp_tx_desc {
+	struct dma_async_tx_descriptor txd;
+	struct list_head tx_list;
+	struct list_head list;
+	int len;
+	union {
+		struct pxp_layer_param s0_param;
+		struct pxp_layer_param out_param;
+		struct pxp_layer_param ol_param;
+		struct pxp_layer_param processing_param;
+	} layer_param;
+	struct pxp_proc_data proc_data;
+
+	u32 hist_status;	/* Histogram output status */
+
+	struct pxp_tx_desc *next;
+};
+
+struct pxp_channel {
+	struct dma_chan dma_chan;
+	dma_cookie_t completed;	/* last completed cookie */
+	enum pxp_channel_status status;
+	void *client;		/* Only one client per channel */
+	unsigned int n_tx_desc;
+	struct pxp_tx_desc *desc;	/* allocated tx-descriptors */
+	struct list_head active_list;	/* active tx-descriptors */
+	struct list_head free_list;	/* free tx-descriptors */
+	struct list_head queue;	/* queued tx-descriptors */
+	struct list_head list;	/* track queued channel number */
+	spinlock_t lock;	/* protects sg[0,1], queue */
+	struct mutex chan_mutex;	/* protects status, cookie, free_list */
+	int active_buffer;
+	unsigned int eof_irq;
+	char eof_name[16];	/* EOF IRQ name for request_irq()  */
+};
+
+#define to_tx_desc(tx) container_of(tx, struct pxp_tx_desc, txd)
+#define to_pxp_channel(d) container_of(d, struct pxp_channel, dma_chan)
+
+void pxp_txd_ack(struct dma_async_tx_descriptor *txd,
+		 struct pxp_channel *pxp_chan);
+
+#ifdef CONFIG_MXC_PXP_CLIENT_DEVICE
+int register_pxp_device(void);
+void unregister_pxp_device(void);
+#else
+static int register_pxp_device(void) { return 0; }
+static void unregister_pxp_device(void) {}
+#endif
+void pxp_fill(
+        u32 bpp,
+        u32 value,
+        u32 width,
+        u32 height,
+        u32 output_buffer,
+        u32 output_pitch);
+
+void m4_process(void);
+#endif
diff --git a/include/uapi/linux/pxp_device.h b/include/uapi/linux/pxp_device.h
new file mode 100644
index 000000000..9b56c8c0e
--- /dev/null
+++ b/include/uapi/linux/pxp_device.h
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2013-2014 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+#ifndef _UAPI_PXP_DEVICE
+#define _UAPI_PXP_DEVICE
+
+#include <linux/pxp_dma.h>
+
+struct pxp_chan_handle {
+	unsigned int handle;
+	int hist_status;
+};
+
+struct pxp_mem_desc {
+	unsigned int handle;
+	unsigned int size;
+	dma_addr_t phys_addr;
+	void *virt_uaddr;		/* virtual user space address */
+	unsigned int mtype;
+	__u32 flags;
+	__s32 fd;
+};
+
+struct pxp_mem_flush {
+	unsigned int handle;
+	unsigned int type;
+};
+
+#define PXP_IOC_MAGIC  'P'
+
+#define PXP_IOC_GET_CHAN      _IOR(PXP_IOC_MAGIC, 0, struct pxp_mem_desc)
+#define PXP_IOC_PUT_CHAN      _IOW(PXP_IOC_MAGIC, 1, struct pxp_mem_desc)
+#define PXP_IOC_CONFIG_CHAN   _IOW(PXP_IOC_MAGIC, 2, struct pxp_mem_desc)
+#define PXP_IOC_START_CHAN    _IOW(PXP_IOC_MAGIC, 3, struct pxp_mem_desc)
+#define PXP_IOC_GET_PHYMEM    _IOWR(PXP_IOC_MAGIC, 4, struct pxp_mem_desc)
+#define PXP_IOC_PUT_PHYMEM    _IOW(PXP_IOC_MAGIC, 5, struct pxp_mem_desc)
+#define PXP_IOC_WAIT4CMPLT    _IOWR(PXP_IOC_MAGIC, 6, struct pxp_mem_desc)
+#define PXP_IOC_FLUSH_PHYMEM   _IOR(PXP_IOC_MAGIC, 7, struct pxp_mem_flush)
+#define PXP_IOC_EXPBUF        _IOR(PXP_IOC_MAGIC, 8, struct pxp_mem_desc)
+
+/* Memory types supported*/
+#define MEMORY_TYPE_UNCACHED 0x0
+#define MEMORY_TYPE_WC	     0x1
+#define MEMORY_TYPE_CACHED   0x2
+
+/* Cache flush operations */
+#define CACHE_CLEAN      0x1
+#define CACHE_INVALIDATE 0x2
+#define CACHE_FLUSH      0x4
+
+#endif
diff --git a/include/uapi/linux/pxp_dma.h b/include/uapi/linux/pxp_dma.h
new file mode 100644
index 000000000..2888f44fa
--- /dev/null
+++ b/include/uapi/linux/pxp_dma.h
@@ -0,0 +1,347 @@
+/*
+ * Copyright (C) 2013-2015 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2017 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+#ifndef _UAPI_PXP_DMA
+#define _UAPI_PXP_DMA
+
+#include <linux/posix_types.h>
+#include <linux/types.h>
+
+#ifndef __KERNEL__
+typedef unsigned long dma_addr_t;
+typedef unsigned char bool;
+#endif
+
+/*  PXP Pixel format definitions */
+/*  Four-character-code (FOURCC) */
+#define fourcc(a, b, c, d)\
+	(((__u32)(a)<<0)|((__u32)(b)<<8)|((__u32)(c)<<16)|((__u32)(d)<<24))
+
+/*!
+ * @name PXP Pixel Formats
+ *
+ * Pixel formats are defined with ASCII FOURCC code. The pixel format codes are
+ * the same used by V4L2 API.
+ */
+
+/*! @} */
+/*! @name RGB Formats */
+/*! @{ */
+#define PXP_PIX_FMT_RGB332  fourcc('R', 'G', 'B', '1')	/*!<  8  RGB-3-3-2    */
+#define PXP_PIX_FMT_RGB444  fourcc('R', '4', '4', '4')	/* 16  xxxxrrrr ggggbbbb */
+#define PXP_PIX_FMT_ARGB444 fourcc('A', 'R', '1', '2')	/* 16  aaaarrrr ggggbbbb */
+#define PXP_PIX_FMT_RGBA444 fourcc('R', 'A', '1', '2')	/* 16  rrrrgggg bbbbaaaa */
+#define PXP_PIX_FMT_XRGB444 fourcc('X', 'R', '1', '2')	/* 16  xxxxrrrr ggggbbbb */
+#define PXP_PIX_FMT_RGB555  fourcc('R', 'G', 'B', 'O')	/*!< 16  RGB-5-5-5    */
+#define PXP_PIX_FMT_ARGB555 fourcc('A', 'R', '1', '5')	/*!< 16  ARGB-1-5-5-5 */
+#define PXP_PIX_FMT_RGBA555 fourcc('R', 'A', '1', '5')	/*!< 16  RGBA-5-5-5-1 */
+#define PXP_PIX_FMT_XRGB555 fourcc('X', 'R', '1', '5')	/*!< 16  XRGB-1-5-5-5 */
+#define PXP_PIX_FMT_RGB565  fourcc('R', 'G', 'B', 'P')	/*!< 16  RGB-5-6-5    */
+#define PXP_PIX_FMT_BGR565  fourcc('B', 'G', 'R', 'P')	/*!< 16  BGR-5-6-5    */
+#define PXP_PIX_FMT_RGB666  fourcc('R', 'G', 'B', '6')	/*!< 18  RGB-6-6-6    */
+#define PXP_PIX_FMT_BGR666  fourcc('B', 'G', 'R', '6')	/*!< 18  BGR-6-6-6    */
+#define PXP_PIX_FMT_BGR24   fourcc('B', 'G', 'R', '3')	/*!< 24  BGR-8-8-8    */
+#define PXP_PIX_FMT_RGB24   fourcc('R', 'G', 'B', '3')	/*!< 24  RGB-8-8-8    */
+#define PXP_PIX_FMT_XBGR32  fourcc('X', 'B', 'G', 'R')	/*!< 32  XBGR-8-8-8-8 */
+#define PXP_PIX_FMT_BGRX32  fourcc('B', 'G', 'R', 'X')	/*!< 32  BGRX-8-8-8-8 */
+#define PXP_PIX_FMT_BGRA32  fourcc('B', 'G', 'R', 'A')	/*!< 32  BGRA-8-8-8-8 */
+#define PXP_PIX_FMT_XRGB32  fourcc('X', 'R', 'G', 'B')	/*!< 32  XRGB-8-8-8-8 */
+#define PXP_PIX_FMT_RGBX32  fourcc('R', 'G', 'B', 'X')	/*!< 32  RGBX-8-8-8-8 */
+#define PXP_PIX_FMT_ARGB32  fourcc('A', 'R', 'G', 'B')	/*!< 32  ARGB-8-8-8-8 */
+#define PXP_PIX_FMT_RGBA32  fourcc('R', 'G', 'B', 'A')	/*!< 32  RGBA-8-8-8-8 */
+#define PXP_PIX_FMT_ABGR32  fourcc('A', 'B', 'G', 'R')	/*!< 32  ABGR-8-8-8-8 */
+#define PXP_PIX_FMT_RGB32	PXP_PIX_FMT_XRGB32
+/*! @} */
+/*! @name YUV Interleaved Formats */
+/*! @{ */
+#define PXP_PIX_FMT_YUYV    fourcc('Y', 'U', 'Y', 'V')	/*!< 16 YUV 4:2:2 */
+#define PXP_PIX_FMT_UYVY    fourcc('U', 'Y', 'V', 'Y')	/*!< 16 YUV 4:2:2 */
+#define PXP_PIX_FMT_VYUY    fourcc('V', 'Y', 'U', 'Y')  /*!< 16 YVU 4:2:2 */
+#define PXP_PIX_FMT_YVYU    fourcc('Y', 'V', 'Y', 'U')  /*!< 16 YVU 4:2:2 */
+#define PXP_PIX_FMT_Y41P    fourcc('Y', '4', '1', 'P')	/*!< 12 YUV 4:1:1 */
+#define PXP_PIX_FMT_VUY444  fourcc('V', 'U', 'Y', 'A')	/*!< 32 VUYA 8:8:8 */
+#define PXP_PIX_FMT_YUV444  fourcc('A', 'Y', 'U', 'V') /*!< 32 AYUV 8:8:8 */
+#define PXP_PIX_FMT_YVU444  fourcc('A', 'Y', 'V', 'U') /*!< 32 AYUV 8:8:8 */
+/* two planes -- one Y, one Cb + Cr interleaved  */
+#define PXP_PIX_FMT_NV12    fourcc('N', 'V', '1', '2')	/* 12  Y/CbCr 4:2:0  */
+#define PXP_PIX_FMT_NV21    fourcc('N', 'V', '2', '1')	/* 12  Y/CbCr 4:2:0  */
+#define PXP_PIX_FMT_NV16    fourcc('N', 'V', '1', '6')	/* 12  Y/CbCr 4:2:2  */
+#define PXP_PIX_FMT_NV61    fourcc('N', 'V', '6', '1')	/* 12  Y/CbCr 4:2:2  */
+/*! @} */
+/*! @name YUV Planar Formats */
+/*! @{ */
+#define PXP_PIX_FMT_GREY    fourcc('G', 'R', 'E', 'Y')	/*!< 8  Greyscale */
+#define PXP_PIX_FMT_GY04    fourcc('G', 'Y', '0', '4') /*!< 4  Greyscale */
+#define PXP_PIX_FMT_YVU410P fourcc('Y', 'V', 'U', '9')	/*!< 9  YVU 4:1:0 */
+#define PXP_PIX_FMT_YUV410P fourcc('Y', 'U', 'V', '9')	/*!< 9  YUV 4:1:0 */
+#define PXP_PIX_FMT_YVU420P fourcc('Y', 'V', '1', '2')	/*!< 12 YVU 4:2:0 */
+#define PXP_PIX_FMT_YUV420P fourcc('I', '4', '2', '0')	/*!< 12 YUV 4:2:0 */
+#define PXP_PIX_FMT_YUV420P2 fourcc('Y', 'U', '1', '2')	/*!< 12 YUV 4:2:0 */
+#define PXP_PIX_FMT_YVU422P fourcc('Y', 'V', '1', '6')	/*!< 16 YVU 4:2:2 */
+#define PXP_PIX_FMT_YUV422P fourcc('4', '2', '2', 'P')	/*!< 16 YUV 4:2:2 */
+/*! @} */
+
+#define PXP_LUT_NONE			0x0
+#define PXP_LUT_INVERT			0x1
+#define PXP_LUT_BLACK_WHITE		0x2
+#define PXP_LUT_USE_CMAP		0x4
+
+/* dithering modes enum */
+#define PXP_DITHER_PASS_THROUGH 0
+#define PXP_DITHER_FLOYD	1
+#define PXP_DITHER_ATKINSON	2
+#define PXP_DITHER_ORDERED	3
+#define PXP_DITHER_QUANT_ONLY	4
+
+#define NR_PXP_VIRT_CHANNEL	16
+
+#define PXP_IOC_MAGIC  'P'
+
+#define PXP_IOC_GET_CHAN      _IOR(PXP_IOC_MAGIC, 0, struct pxp_mem_desc)
+#define PXP_IOC_PUT_CHAN      _IOW(PXP_IOC_MAGIC, 1, struct pxp_mem_desc)
+#define PXP_IOC_CONFIG_CHAN   _IOW(PXP_IOC_MAGIC, 2, struct pxp_mem_desc)
+#define PXP_IOC_START_CHAN    _IOW(PXP_IOC_MAGIC, 3, struct pxp_mem_desc)
+#define PXP_IOC_GET_PHYMEM    _IOWR(PXP_IOC_MAGIC, 4, struct pxp_mem_desc)
+#define PXP_IOC_PUT_PHYMEM    _IOW(PXP_IOC_MAGIC, 5, struct pxp_mem_desc)
+#define PXP_IOC_WAIT4CMPLT    _IOWR(PXP_IOC_MAGIC, 6, struct pxp_mem_desc)
+
+#define PXP_IOC_FILL_DATA    _IOWR(PXP_IOC_MAGIC, 7, struct pxp_mem_desc)
+#define PXP_IOC_EXPBUF       _IOR(PXP_IOC_MAGIC, 8, struct pxp_mem_desc)
+
+#define ALPHA_MODE_ROP		0x1
+#define ALPHA_MODE_LEGACY	0x2
+#define ALPHA_MODE_PORTER_DUFF	0x3
+
+#define PXP_DEVICE_LEGACY
+
+/* Order significant! */
+enum pxp_channel_status {
+	PXP_CHANNEL_FREE,
+	PXP_CHANNEL_INITIALIZED,
+	PXP_CHANNEL_READY,
+};
+
+enum pxp_working_mode {
+	PXP_MODE_LEGACY			= 0x1,
+	PXP_MODE_STANDARD		= 0x2,
+	PXP_MODE_ADVANCED		= 0x4,
+};
+
+enum pxp_buffer_flag {
+	PXP_BUF_FLAG_WFE_A_FETCH0	= 0x0001,
+	PXP_BUF_FLAG_WFE_A_FETCH1	= 0x0002,
+	PXP_BUF_FLAG_WFE_A_STORE0	= 0x0004,
+	PXP_BUF_FLAG_WFE_A_STORE1	= 0x0008,
+	PXP_BUF_FLAG_WFE_B_FETCH0	= 0x0010,
+	PXP_BUF_FLAG_WFE_B_FETCH1	= 0x0020,
+	PXP_BUF_FLAG_WFE_B_STORE0	= 0x0040,
+	PXP_BUF_FLAG_WFE_B_STORE1	= 0x0080,
+	PXP_BUF_FLAG_DITHER_FETCH0	= 0x0100,
+	PXP_BUF_FLAG_DITHER_FETCH1	= 0x0200,
+	PXP_BUF_FLAG_DITHER_STORE0	= 0x0400,
+	PXP_BUF_FLAG_DITHER_STORE1	= 0x0800,
+};
+
+enum pxp_engine_ctrl {
+	PXP_ENABLE_ROTATE0		= 0x001,
+	PXP_ENABLE_ROTATE1		= 0x002,
+	PXP_ENABLE_LUT			= 0x004,
+	PXP_ENABLE_CSC2			= 0x008,
+	PXP_ENABLE_ALPHA_B		= 0x010,
+	PXP_ENABLE_INPUT_FETCH_SOTRE	= 0x020,
+	PXP_ENABLE_WFE_B		= 0x040,
+	PXP_ENABLE_WFE_A		= 0x080,
+	PXP_ENABLE_DITHER		= 0x100,
+	PXP_ENABLE_PS_AS_OUT		= 0x200,
+	PXP_ENABLE_COLLISION_DETECT     = 0x400,
+	PXP_ENABLE_HANDSHAKE		= 0x1000,
+	PXP_ENABLE_DITHER_BYPASS	= 0x2000,
+};
+
+enum pxp_op_type {
+	PXP_OP_2D			= 0x001,
+	PXP_OP_DITHER			= 0x002,
+	PXP_OP_WFE_A			= 0x004,
+	PXP_OP_WFE_B			= 0x008,
+};
+
+struct rect {
+	int top;		/* Upper left coordinate of rectangle */
+	int left;
+	int width;
+	int height;
+};
+
+#define ALPHA_MODE_STRAIGHT	0x0
+#define ALPHA_MODE_INVERSED	0x1
+
+#define GLOBAL_ALPHA_MODE_ON	0x0
+#define GLOBAL_ALPHA_MODE_OFF	0x1
+#define GLOBAL_ALPHA_MODE_SCALE	0x2
+
+#define FACTOR_MODE_ONE		0x0
+#define FACTOR_MODE_ZERO	0x1
+#define FACTOR_MODE_STRAIGHT	0x2
+#define FACTOR_MODE_INVERSED	0x3
+
+#define COLOR_MODE_STRAIGHT	0x0
+#define COLOR_MODE_MULTIPLY	0x1
+
+struct pxp_alpha {
+	unsigned int alpha_mode;
+	unsigned int global_alpha_mode;
+	unsigned int global_alpha_value;
+	unsigned int factor_mode;
+	unsigned int color_mode;
+};
+
+struct pxp_layer_param {
+	unsigned short left;
+	unsigned short top;
+	unsigned short width;
+	unsigned short height;
+	unsigned short stride; /* aka pitch */
+	unsigned int pixel_fmt;
+
+	unsigned int flag;
+	/* layers combining parameters
+	 * (these are ignored for S0 and output
+	 * layers, and only apply for OL layer)
+	 */
+	bool combine_enable;
+	unsigned int color_key_enable;
+	unsigned int color_key;
+	bool global_alpha_enable;
+	/* global alpha is either override or multiply */
+	bool global_override;
+	unsigned char global_alpha;
+	bool alpha_invert;
+	bool local_alpha_enable;
+	int comp_mask;
+
+	struct pxp_alpha alpha;
+	struct rect crop;
+
+	dma_addr_t paddr;
+};
+
+struct pxp_collision_info {
+	unsigned int pixel_cnt;
+	unsigned int rect_min_x;
+	unsigned int rect_min_y;
+	unsigned int rect_max_x;
+	unsigned int rect_max_y;
+	unsigned int victim_luts[2];
+};
+
+struct pxp_proc_data {
+	/* S0 Transformation Info */
+	int scaling;
+	int hflip;
+	int vflip;
+	int rotate;
+	int rot_pos;
+	int yuv;
+	unsigned int alpha_mode;
+
+	/* Source rectangle (srect) defines the sub-rectangle
+	 * within S0 to undergo processing.
+	 */
+	struct rect srect;
+	/* Dest rect (drect) defines how to position the processed
+	 * source rectangle (after resizing) within the output frame,
+	 * whose dimensions are defined in pxp->pxp_conf_state.out_param
+	 */
+	struct rect drect;
+
+	/* Current S0 configuration */
+	unsigned int bgcolor;
+	unsigned char fill_en;
+
+	/* Output overlay support */
+	int overlay_state;
+
+	/* LUT transformation on Y data */
+	int lut_transform;
+	unsigned char *lut_map; /* 256 entries */
+	bool lut_map_updated; /* Map recently changed */
+	bool combine_enable;
+
+	enum pxp_op_type op_type;
+
+	/* LUT cleanup */
+	__u64 lut_sels;
+
+	/* the mode pxp's working against */
+	enum pxp_working_mode working_mode;
+	enum pxp_engine_ctrl engine_enable;
+
+	/* wfe */
+/*
+ * partial:
+ *         0 - full update
+ *         1 - partial update
+ * alpha_en:
+ *         0 - upd is {Y4[3:0],4'b0000} format
+ *         1 - upd is {Y4[3:0],3'b000,alpha} format
+ * reagl_en:
+ *         0 - use normal waveform algorithm
+ *         1 - enable reagl/-d waveform algorithm
+ * detection_only:
+ *         0 - write working buffer
+ *         1 - do no write working buffer, detection only
+ * lut:
+ *         valid value 0-63
+ *         set to the lut used for next update
+ */
+	bool partial_update;
+	bool alpha_en;
+	bool lut_update;
+	bool reagl_en;		/* enable reagl/-d */
+	bool reagl_d_en;	/* enable reagl or reagl-d */
+	bool detection_only;
+	bool pxp_legacy;
+	int lut;
+	bool lut_cleanup;
+	unsigned int lut_status_1;
+	unsigned int lut_status_2;
+
+	/* Dithering specific data */
+	int dither_mode;
+	unsigned int quant_bit;
+};
+
+struct pxp_config_data {
+	struct pxp_layer_param s0_param;
+	struct pxp_layer_param ol_param[1];
+	struct pxp_layer_param out_param;
+	struct pxp_layer_param wfe_a_fetch_param[2];
+	struct pxp_layer_param wfe_a_store_param[2];
+	struct pxp_layer_param wfe_b_fetch_param[2];
+	struct pxp_layer_param wfe_b_store_param[2];
+	struct pxp_layer_param dither_fetch_param[2];
+	struct pxp_layer_param dither_store_param[2];
+	struct pxp_proc_data proc_data;
+	int layer_nr;
+
+	/* Users don't touch */
+	int handle;
+};
+
+#endif
-- 
2.25.1

