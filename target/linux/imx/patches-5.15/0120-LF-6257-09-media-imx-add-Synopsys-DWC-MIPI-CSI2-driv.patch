From 1c6be6003ae85274c6f823dcdfdb6a45722134de Mon Sep 17 00:00:00 2001
From: Yuantian Tang <andy.tang@nxp.com>
Date: Wed, 28 Sep 2022 14:24:25 +0800
Subject: [PATCH 120/274] LF-6257-09: media: imx: add Synopsys DWC MIPI CSI2
 driver support for iMX93

Add Synopsys DWC MIPI CSI2 driver support for iMX93 platform

Signed-off-by: Guoniu.zhou <guoniu.zhou@nxp.com>
Reviewed-by: Robby Cai <robby.cai@nxp.com>
---
 drivers/staging/media/imx/Kconfig             |   95 +
 drivers/staging/media/imx/Makefile            |   17 +
 drivers/staging/media/imx/dwc-mipi-csi2.c     | 1478 ++++++++
 drivers/staging/media/imx/gmsl-max9286.c      | 3344 +++++++++++++++++
 drivers/staging/media/imx/hdmirx/Kconfig      |    6 +
 drivers/staging/media/imx/hdmirx/Makefile     |    2 +
 .../media/imx/hdmirx/cdns-hdmirx-audio.c      |  185 +
 .../media/imx/hdmirx/cdns-hdmirx-hdcp.c       |  172 +
 .../staging/media/imx/hdmirx/cdns-hdmirx-hw.c |  984 +++++
 .../media/imx/hdmirx/cdns-hdmirx-phy.c        | 1483 ++++++++
 .../media/imx/hdmirx/cdns-hdmirx-phy.h        |  105 +
 .../staging/media/imx/hdmirx/cdns-hdmirx.c    | 1491 ++++++++
 .../media/imx/hdmirx/cdns-mhdp-hdmirx.c       |  503 +++
 .../media/imx/hdmirx/cdns-mhdp-hdmirx.h       |  436 +++
 drivers/staging/media/imx/imx7-mipi-csis.c    |    6 +-
 drivers/staging/media/imx/imx8-common.h       |  108 +
 drivers/staging/media/imx/imx8-isi-cap.c      | 1868 +++++++++
 drivers/staging/media/imx/imx8-isi-core.h     |  458 +++
 drivers/staging/media/imx/imx8-isi-fmt.c      |   94 +
 drivers/staging/media/imx/imx8-isi-fmt.h      |   12 +
 drivers/staging/media/imx/imx8-isi-hw.c       |  829 ++++
 drivers/staging/media/imx/imx8-isi-hw.h       |  485 +++
 drivers/staging/media/imx/imx8-isi-m2m.c      | 1375 +++++++
 drivers/staging/media/imx/imx8-media-dev.c    | 1176 ++++++
 .../staging/media/imx/imx8-mipi-csi2-sam.c    | 2119 +++++++++++
 drivers/staging/media/imx/imx8-mipi-csi2.c    | 1400 +++++++
 drivers/staging/media/imx/imx8-parallel-csi.c |  837 +++++
 drivers/staging/media/imx/imx8mq-mipi-csi2.c  |   74 +-
 28 files changed, 21093 insertions(+), 49 deletions(-)
 create mode 100644 drivers/staging/media/imx/dwc-mipi-csi2.c
 create mode 100644 drivers/staging/media/imx/gmsl-max9286.c
 create mode 100644 drivers/staging/media/imx/hdmirx/Kconfig
 create mode 100644 drivers/staging/media/imx/hdmirx/Makefile
 create mode 100644 drivers/staging/media/imx/hdmirx/cdns-hdmirx-audio.c
 create mode 100644 drivers/staging/media/imx/hdmirx/cdns-hdmirx-hdcp.c
 create mode 100644 drivers/staging/media/imx/hdmirx/cdns-hdmirx-hw.c
 create mode 100644 drivers/staging/media/imx/hdmirx/cdns-hdmirx-phy.c
 create mode 100644 drivers/staging/media/imx/hdmirx/cdns-hdmirx-phy.h
 create mode 100644 drivers/staging/media/imx/hdmirx/cdns-hdmirx.c
 create mode 100644 drivers/staging/media/imx/hdmirx/cdns-mhdp-hdmirx.c
 create mode 100644 drivers/staging/media/imx/hdmirx/cdns-mhdp-hdmirx.h
 create mode 100644 drivers/staging/media/imx/imx8-common.h
 create mode 100644 drivers/staging/media/imx/imx8-isi-cap.c
 create mode 100644 drivers/staging/media/imx/imx8-isi-core.h
 create mode 100644 drivers/staging/media/imx/imx8-isi-fmt.c
 create mode 100644 drivers/staging/media/imx/imx8-isi-fmt.h
 create mode 100644 drivers/staging/media/imx/imx8-isi-hw.c
 create mode 100644 drivers/staging/media/imx/imx8-isi-hw.h
 create mode 100644 drivers/staging/media/imx/imx8-isi-m2m.c
 create mode 100644 drivers/staging/media/imx/imx8-media-dev.c
 create mode 100644 drivers/staging/media/imx/imx8-mipi-csi2-sam.c
 create mode 100644 drivers/staging/media/imx/imx8-mipi-csi2.c
 create mode 100644 drivers/staging/media/imx/imx8-parallel-csi.c

diff --git a/drivers/staging/media/imx/Kconfig b/drivers/staging/media/imx/Kconfig
index c3bf433ba..9f87438c4 100644
--- a/drivers/staging/media/imx/Kconfig
+++ b/drivers/staging/media/imx/Kconfig
@@ -32,3 +32,98 @@ config VIDEO_IMX7_CSI
 	  i.MX6UL/L, i.MX7 or i.MX8M.
 endmenu
 endif
+
+config VIDEO_IMX_CAPTURE
+	tristate "i.MX V4L2 media core driver"
+	depends on ARCH_MXC || COMPILE_TEST
+	depends on MEDIA_CONTROLLER && VIDEO_V4L2
+	depends on VIDEO_V4L2_SUBDEV_API
+	depends on HAS_DMA
+	select VIDEOBUF2_DMA_CONTIG
+	select V4L2_FWNODE
+	help
+	  Say yes here to enable support for video4linux media controller
+	  driver for the i.MX5/6 SOC.
+
+if VIDEO_IMX_CAPTURE
+menu "i.MX8QXP/QM Camera ISI/MIPI Features support"
+
+config IMX8_MIPI_CSI2
+	tristate "IMX8 MIPI CSI2 Controller"
+	depends on VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	default y
+	help
+	  Enable support for video4linux camera sensor interface driver for
+	  i.MX8QM/QXP platform.
+
+config IMX8_MIPI_CSI2_SAM
+	tristate "IMX8 MIPI CSI2 SAMSUNG Controller"
+	depends on VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	default y
+	help
+	  Enable support for video4linux MIPI CSI2 Samsung driver for
+	  i.MX8MN platform.
+
+config DWC_MIPI_CSI2_HOST
+       tristate "IMX93 MIPI CSI2 DWC Controller"
+       depends on VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+       default y
+       help
+         Enable support for video4linux MIPI CSI2 DWC driver for
+         i.MX93 platform.
+
+config IMX8_ISI_HW
+	tristate "IMX8 Image Sensor Interface hardware driver"
+	depends on VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	default y
+	help
+	  ISI hardware driver is used to export functions to config
+	  ISI registers and it is shared by isi capture and mem2mem
+	  driver
+
+config IMX8_ISI_CORE
+	tristate "IMX8 Image Sensor Interface Core Driver"
+	depends on IMX8_ISI_CAPTURE && IMX8_ISI_M2M
+	default y
+
+config IMX8_ISI_CAPTURE
+	tristate "IMX8 Image Sensor Interface Capture Device Driver"
+	depends on VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	depends on IMX8_ISI_HW
+	select VIDEOBUF2_DMA_CONTIG
+	default y
+
+config IMX8_ISI_M2M
+	tristate "IMX8 Image Sensor Interface Memory to Memory Device Driver"
+	select V4L2_MEM2MEM_DEV
+	depends on IMX8_ISI_HW
+	default y
+
+config GMSL_MAX9286
+	tristate "GMSL MAX8286"
+	depends on VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	default y
+	help
+	  Enable support for video4linux camera sensor driver for GMSL MAX9286
+
+config IMX8_MEDIA_DEVICE
+	tristate "IMX8 Media Device Driver"
+	select V4L2_FWNODE
+	default y
+	help
+	  This media device is a virtual device which used to manage
+	  all modules in image subsystem of imx8qxp/qm platform.
+
+config IMX8_PARALLEL_CSI
+	tristate "IMX8 Parallel Capture Controller"
+	depends on VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	default y
+	help
+	  Enable support for video4linux parallel camera sensor interface
+	  driver for i.MX8QM/QXP platform.
+
+endmenu
+
+source "drivers/staging/media/imx/hdmirx/Kconfig"
+
+endif  #VIDEO_IMX_CAPTURE
diff --git a/drivers/staging/media/imx/Makefile b/drivers/staging/media/imx/Makefile
index 19c2fc54d..c05ec4ba3 100644
--- a/drivers/staging/media/imx/Makefile
+++ b/drivers/staging/media/imx/Makefile
@@ -8,6 +8,10 @@ imx6-media-objs := imx-media-dev.o imx-media-internal-sd.o \
 
 imx6-media-csi-objs := imx-media-csi.o imx-media-fim.o
 
+imx8-capture-objs := imx8-isi-core.o
+
+imx8-isi-capture-objs := imx8-isi-fmt.o imx8-isi-cap.o
+imx8-isi-mem2mem-objs := imx8-isi-fmt.o imx8-isi-m2m.o
 obj-$(CONFIG_VIDEO_IMX_MEDIA) += imx-media-common.o
 
 obj-$(CONFIG_VIDEO_IMX_CSI) += imx6-media.o
@@ -17,3 +21,16 @@ obj-$(CONFIG_VIDEO_IMX_CSI) += imx6-mipi-csi2.o
 obj-$(CONFIG_VIDEO_IMX7_CSI) += imx7-media-csi.o
 obj-$(CONFIG_VIDEO_IMX7_CSI) += imx7-mipi-csis.o
 obj-$(CONFIG_VIDEO_IMX7_CSI) += imx8mq-mipi-csi2.o
+obj-$(CONFIG_IMX8_MIPI_CSI2) 	  += imx8-mipi-csi2.o
+obj-$(CONFIG_IMX8_MIPI_CSI2_SAM)  += imx8-mipi-csi2-sam.o
+obj-$(CONFIG_DWC_MIPI_CSI2_HOST)  += dwc-mipi-csi2.o
+obj-$(CONFIG_IMX8_CAPTURE_DRIVER) += imx8-capture.o
+obj-$(CONFIG_IMX8_ISI_CORE) += imx8-capture.o
+obj-$(CONFIG_IMX8_ISI_CAPTURE) 	  += imx8-isi-capture.o
+obj-$(CONFIG_IMX8_ISI_M2M)	+= imx8-isi-mem2mem.o
+obj-$(CONFIG_IMX8_ISI_HW) 	  += imx8-isi-hw.o
+obj-$(CONFIG_GMSL_MAX9286)	  += gmsl-max9286.o
+obj-$(CONFIG_IMX8_MEDIA_DEVICE)   += imx8-media-dev.o
+obj-$(CONFIG_IMX8_PARALLEL_CSI)	  += imx8-parallel-csi.o
+
+obj-y += hdmirx/
diff --git a/drivers/staging/media/imx/dwc-mipi-csi2.c b/drivers/staging/media/imx/dwc-mipi-csi2.c
new file mode 100644
index 000000000..6497c092b
--- /dev/null
+++ b/drivers/staging/media/imx/dwc-mipi-csi2.c
@@ -0,0 +1,1478 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright 2022 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/kernel.h>
+#include <linux/memory.h>
+#include <linux/module.h>
+#include <linux/mfd/syscon.h>
+#include <linux/of.h>
+#include <linux/of_graph.h>
+#include <linux/pm_domain.h>
+#include <linux/pm_runtime.h>
+#include <linux/regmap.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/videodev2.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-subdev.h>
+
+/*
+ * DWC MIPI CSI2 Host registers
+ */
+#define DWC_MIPI_CSI2_VERSION			0x0
+
+#define DWC_MIPI_CSI2_N_LANES			0x4
+#define DWC_MIPI_CSI2_N_LANES_N_LANES(x)	((x) & 0x7)
+
+#define DWC_MIPI_CSI2_HOST_RESETN		0x8
+#define DWC_MIPI_CSI2_HOST_RESETN_ENABLE	(0x1)
+
+#define DWC_MIPI_CSI2_INT_ST_MAIN		0xC
+
+#define DWC_MIPI_CSI2_DATA_IDS_1		0x10
+#define DWC_MIPI_CSI2_DATA_IDS_1_DI0_DT(x)	(((x) & 0x3f))
+#define DWC_MIPI_CSI2_DATA_IDS_1_DI1_DT(x)	(((x) & 0x3f) << 8)
+#define DWC_MIPI_CSI2_DATA_IDS_1_DI2_DT(x)	(((x) & 0x3f) << 16)
+#define DWC_MIPI_CSI2_DATA_IDS_1_DI3_DT(x)	(((x) & 0x3f) << 24)
+
+#define DWC_MIPI_CSI2_DATA_IDS_2		0x14
+#define DWC_MIPI_CSI2_DATA_IDS_2_DI0_DT(x)	(((x) & 0x3f))
+#define DWC_MIPI_CSI2_DATA_IDS_2_DI1_DT(x)	(((x) & 0x3f) << 8)
+#define DWC_MIPI_CSI2_DATA_IDS_2_DI2_DT(x)	(((x) & 0x3f) << 16)
+#define DWC_MIPI_CSI2_DATA_IDS_2_DI3_DT(x)	(((x) & 0x3f) << 24)
+
+#define DWC_MIPI_CSI2_DPHY_CFG			0x18
+#define DWC_MIPI_CSI2_DPHY_CFG_PPI8		(0x0)
+#define DWC_MIPI_CSI2_DPHY_CFG_PPI16		(0x1)
+
+#define DWC_MIPI_CSI2_DPHY_MODE			0x1C
+#define DWC_MIPI_CSI2_DPHY_MODE_DPHY		(0x0)
+#define DWC_MIPI_CSI2_DPHY_MODE_CPHY		(0x1)
+
+#define DWC_MIPI_CSI2_INT_ST_AP_MAIN		0x2C
+
+#define DWC_MIPI_CSI2_DATA_IDS_VC_1			0x30
+#define DWC_MIPI_CSI2_DATA_IDS_VC_1_DI0_VC(x)		((x & 0x3))
+#define DWC_MIPI_CSI2_DATA_IDS_VC_1_DI0_VC_0_1(x)	((x & 0x3) << 2)
+#define DWC_MIPI_CSI2_DATA_IDS_VC_1_DI0_VC_2		(0x1 << 4)
+#define DWC_MIPI_CSI2_DATA_IDS_VC_1_DI1_VC(x)		((x & 0x3) << 8)
+#define DWC_MIPI_CSI2_DATA_IDS_VC_1_DI1_VC_0_1(x)	((x & 0x3) << 10)
+#define DWC_MIPI_CSI2_DATA_IDS_VC_1_DI1_VC_2		(0x1 << 12)
+#define DWC_MIPI_CSI2_DATA_IDS_VC_1_DI2_VC(x)		((x & 0x3) << 16)
+#define DWC_MIPI_CSI2_DATA_IDS_VC_1_DI2_VC_0_1(x)	((x & 0x3) << 18)
+#define DWC_MIPI_CSI2_DATA_IDS_VC_1_DI2_VC_2		(0x1 << 20)
+#define DWC_MIPI_CSI2_DATA_IDS_VC_1_DI3_VC(x)		((x & 0x3) << 24)
+#define DWC_MIPI_CSI2_DATA_IDS_VC_1_DI3_VC_0_1(x)	((x & 0x3) << 26)
+#define DWC_MIPI_CSI2_DATA_IDS_VC_1_DI3_VC_2		(0x1 << 28)
+
+#define DWC_MIPI_CSI2_DATA_IDS_VC_2			0x34
+#define DWC_MIPI_CSI2_DATA_IDS_VC_2_DI4_VC(x)		((x & 0x3))
+#define DWC_MIPI_CSI2_DATA_IDS_VC_2_DI4_VC_0_1(x)	((x & 0x3) << 2)
+#define DWC_MIPI_CSI2_DATA_IDS_VC_2_DI4_VC_2		(0x1 << 4)
+#define DWC_MIPI_CSI2_DATA_IDS_VC_2_DI5_VC(x)		((x & 0x3) << 8)
+#define DWC_MIPI_CSI2_DATA_IDS_VC_2_DI5_VC_0_1(x)	((x & 0x3) << 10)
+#define DWC_MIPI_CSI2_DATA_IDS_VC_2_DI5_VC_2		(0x1 << 12)
+#define DWC_MIPI_CSI2_DATA_IDS_VC_2_DI6_VC(x)		((x & 0x3) << 16)
+#define DWC_MIPI_CSI2_DATA_IDS_VC_2_DI6_VC_0_1(x)	((x & 0x3) << 18)
+#define DWC_MIPI_CSI2_DATA_IDS_VC_2_DI6_VC_2		(0x1 << 20)
+#define DWC_MIPI_CSI2_DATA_IDS_VC_2_DI7_VC(x)		((x & 0x3) << 24)
+#define DWC_MIPI_CSI2_DATA_IDS_VC_2_DI7_VC_0_1(x)	((x & 0x3) << 26)
+#define DWC_MIPI_CSI2_DATA_IDS_VC_2_DI7_VC_2		(0x1 << 28)
+
+#define DWC_MIPI_CSI2_DPHY_SHUTDOWNZ		0x40
+#define DWC_MIPI_CSI2_DPHY_SHUTDOWNZ_ENABLE	(0x1)
+
+#define DWC_MIPI_CSI2_DPHY_RSTZ			0x44
+#define DWC_MIPI_CSI2_DPHY_RSTZ_ENABLE		(0x1)
+
+#define DWC_MIPI_CSI2_DPHY_RX_STATUS			0x48
+#define DWC_MIPI_CSI2_DPHY_RX_STATUS_CLK_LANE_HS	(0x1 << 17)
+#define DWC_MIPI_CSI2_DPHY_RX_STATUS_CLK_LANE_ULP	(0x1 << 16)
+#define DWC_MIPI_CSI2_DPHY_RX_STATUS_DATA_LANE0_ULP	(0x1)
+#define DWC_MIPI_CSI2_DPHY_RX_STATUS_DATA_LANE1_ULP	(0x1 << 1)
+#define DWC_MIPI_CSI2_DPHY_RX_STATUS_DATA_LANE2_ULP	(0x1 << 2)
+#define DWC_MIPI_CSI2_DPHY_RX_STATUS_DATA_LANE3_ULP	(0x1 << 3)
+#define DWC_MIPI_CSI2_DPHY_RX_STATUS_DATA_LANE4_ULP	(0x1 << 4)
+#define DWC_MIPI_CSI2_DPHY_RX_STATUS_DATA_LANE5_ULP	(0x1 << 5)
+#define DWC_MIPI_CSI2_DPHY_RX_STATUS_DATA_LANE6_ULP	(0x1 << 6)
+#define DWC_MIPI_CSI2_DPHY_RX_STATUS_DATA_LANE7_ULP	(0x1 << 7)
+
+#define DWC_MIPI_CSI2_DPHY_STOPSTATE			0x4C
+#define DWC_MIPI_CSI2_DPHY_STOPSTATE_CLK_LANE		(0x1 << 16)
+#define DWC_MIPI_CSI2_DPHY_STOPSTATE_DATA_LANE0		(0x1)
+#define DWC_MIPI_CSI2_DPHY_STOPSTATE_DATA_LANE1		(0x1 << 1)
+#define DWC_MIPI_CSI2_DPHY_STOPSTATE_DATA_LANE2		(0x1 << 2)
+#define DWC_MIPI_CSI2_DPHY_STOPSTATE_DATA_LANE3		(0x1 << 3)
+#define DWC_MIPI_CSI2_DPHY_STOPSTATE_DATA_LANE4		(0x1 << 4)
+#define DWC_MIPI_CSI2_DPHY_STOPSTATE_DATA_LANE5		(0x1 << 5)
+#define DWC_MIPI_CSI2_DPHY_STOPSTATE_DATA_LANE6		(0x1 << 6)
+#define DWC_MIPI_CSI2_DPHY_STOPSTATE_DATA_LANE7		(0x1 << 7)
+
+#define DWC_MIPI_CSI2_DPHY_TEST_CTRL0			0x50
+#define DWC_MIPI_CSI2_DPHY_TEST_CTRL0_TEST_CLR		(0x1)
+#define DWC_MIPI_CSI2_DPHY_TEST_CTRL0_TEST_CLKEN	(0x1 << 1)
+
+#define DWC_MIPI_CSI2_DPHY_TEST_CTRL1			0x54
+#define DWC_MIPI_CSI2_DPHY_TEST_CTRL1_TEST_DIN(x)	((x) & 0xFF)
+#define DWC_MIPI_CSI2_DPHY_TEST_CTRL1_TEST_DOUT(x)	(((x) & 0xFF) << 8)
+#define DWC_MIPI_CSI2_DPHY_TEST_CTRL1_TEST_EN		(0x1 << 16)
+
+#define DWC_MIPI_CSI2_PPI_PG_PATTERN_VRES		0x60
+#define DWC_MIPI_CSI2_PPI_PG_PATTERN_VRES_VRES(x)	((x) & 0xFFFF)
+
+#define DWC_MIPI_CSI2_PPI_PG_PATTERN_HRES		0x64
+#define DWC_MIPI_CSI2_PPI_PG_PATTERN_HRES_HRES(x)	((x) & 0xFFFF)
+
+#define DWC_MIPI_CSI2_PPI_PG_CONFIG			0x68
+#define DWC_MIPI_CSI2_PPI_PG_CONFIG_DATA_TYPE(x)	(((x) & 0x3F) << 8)
+#define DWC_MIPI_CSI2_PPI_PG_CONFIG_VIR_CHAN(x)		(((x) & 0x3) << 14)
+#define DWC_MIPI_CSI2_PPI_PG_CONFIG_VIR_CHAN_EX(x)	(((x) & 0x3) << 16)
+#define DWC_MIPI_CSI2_PPI_PG_CONFIG_VIR_CHAN_EX_2_EN	(0x1 << 18)
+#define DWC_MIPI_CSI2_PPI_PG_CONFIG_PG_MODE(x)		(x)
+
+#define DWC_MIPI_CSI2_PPI_PG_ENABLE			0x6C
+#define DWC_MIPI_CSI2_PPI_PG_ENABLE_EN			0x1
+
+#define DWC_MIPI_CSI2_PPI_PG_STATUS			0x70
+
+#define DWC_MIPI_CSI2_IPI_MODE				0x80
+#define DWC_MIPI_CSI2_IPI_MODE_CAMERA			0x0
+#define DWC_MIPI_CSI2_IPI_MODE_CONTROLLER		0x1
+#define DWC_MIPI_CSI2_IPI_MODE_COLOR_MODE16		(0x1 << 8)
+#define DWC_MIPI_CSI2_IPI_MODE_COLOR_MODE48		(0x0 << 8)
+#define DWC_MIPI_CSI2_IPI_MODE_CUT_THROUGH		(0x1 << 16)
+#define DWC_MIPI_CSI2_IPI_MODE_ENABLE			(0x1 << 24)
+
+#define DWC_MIPI_CSI2_IPI_VCID				0x84
+#define DWC_MIPI_CSI2_IPI_VCID_VC(x)			((x)  & 0x3)
+#define DWC_MIPI_CSI2_IPI_VCID_VC_0_1(x)		(((x) & 0x3) << 2)
+#define DWC_MIPI_CSI2_IPI_VCID_VC_2			(0x1 << 4)
+
+#define DWC_MIPI_CSI2_IPI_DATA_TYPE			0x88
+#define DWC_MIPI_CSI2_IPI_DATA_TYPE_DT(x)		((x) & 0x3F)
+#define DWC_MIPI_CSI2_IPI_DATA_TYPE_EMB_DATA_EN		(0x1 << 8)
+
+#define DWC_MIPI_CSI2_IPI_MEM_FLUSH			0x8C
+#define DWC_MIPI_CSI2_IPI_MEM_FLUSH_AUTO		(0x1 << 8)
+
+#define DWC_MIPI_CSI2_IPI_HSA_TIME			0x90
+#define DWC_MIPI_CSI2_IPI_HSA_TIME_VAL(x)		((x) & 0xFFF)
+
+#define DWC_MIPI_CSI2_IPI_HBP_TIME			0x94
+#define DWC_MIPI_CSI2_IPI_HBP_TIME_VAL(x)		((x) & 0xFFF)
+
+#define DWC_MIPI_CSI2_IPI_HSD_TIME			0x98
+#define DWC_MIPI_CSI2_IPI_HSD_TIME_VAL(x)		((x) & 0xFFF)
+
+#define DWC_MIPI_CSI2_IPI_HLINE_TIME			0x9C
+#define DWC_MIPI_CSI2_IPI_HLINE_TIME_VAL(x)		((x) & 0x3FFF)
+
+#define DWC_MIPI_CSI2_IPI_SOFTRSTN			0xA0
+#define DWC_MIPI_CSI2_IPI_ADV_FEATURES			0xAC
+
+#define DWC_MIPI_CSI2_IPI_VSA_LINES			0xB0
+#define DWC_MIPI_CSI2_IPI_VSA_LINES_VAL(x)		((x) & 0x3FF)
+
+#define DWC_MIPI_CSI2_IPI_VBP_LINES			0xB4
+#define DWC_MIPI_CSI2_IPI_VBP_LINES_VAL(x)		((x) & 0x3FF)
+
+#define DWC_MIPI_CSI2_IPI_VFP_LINES			0xB8
+#define DWC_MIPI_CSI2_IPI_VFP_LINES_VAL(x)		((x) & 0x3FF)
+
+#define DWC_MIPI_CSI2_IPI_VACTIVE_LINES			0xBC
+#define DWC_MIPI_CSI2_IPI_VACTIVE_LINES_VAL(x)		((x) & 0x3FFF)
+
+#define DWC_MIPI_CSI2_VC_EXTENSION			0xC8
+
+#define DWC_MIPI_CSI2_DPHY_CAL				0xCC
+#define DWC_MIPI_CSI2_INT_ST_DPHY_FATAL			0xE0
+#define DWC_MIPI_CSI2_INT_MSK_DPHY_FATAL		0xE4
+#define DWC_MIPI_CSI2_INT_FORCE_DPHY_FATAL		0xE8
+#define DWC_MIPI_CSI2_INT_ST_PKT_FATAL			0xF0
+#define DWC_MIPI_CSI2_INT_MSK_PKT_FATAL			0xF4
+#define DWC_MIPI_CSI2_INT_FORCE_PKT_FATAL		0xF8
+
+#define DWC_MIPI_CSI2_INT_ST_DPHY			0x110
+#define DWC_MIPI_CSI2_INT_MSK_DPHY			0x114
+#define DWC_MIPI_CSI2_INT_FORCE_DPHY			0x118
+#define DWC_MIPI_CSI2_INT_ST_LINE			0x130
+#define DWC_MIPI_CSI2_INT_MSK_LINE			0x134
+#define DWC_MIPI_CSI2_INT_FORCE_LINE			0x138
+#define DWC_MIPI_CSI2_INT_ST_IPI_FATAL			0x140
+#define DWC_MIPI_CSI2_INT_MSK_IPI_FATAL			0x144
+#define DWC_MIPI_CSI2_INT_FORCE_IPI_FATAL		0x148
+
+#define DWC_MIPI_CSI2_INT_ST_AP_GENERIC			0x180
+#define DWC_MIPI_CSI2_INT_MSK_AP_GENERIC		0x184
+#define DWC_MIPI_CSI2_INT_FORCE_AP_GENERIC		0x188
+#define DWC_MIPI_CSI2_INT_ST_AP_IPI_FATAL		0x190
+#define DWC_MIPI_CSI2_INT_MSK_AP_IPI_FATAL		0x194
+#define DWC_MIPI_CSI2_INT_FORCE_AP_IPI_FATAL		0x198
+
+#define DWC_MIPI_CSI2_INT_ST_BNDRY_FRAME_FATAL		0x280
+#define DWC_MIPI_CSI2_INT_MSK_BNDRY_FRAME_FATAL		0x284
+#define DWC_MIPI_CSI2_INT_FORCE_BNDRY_FRAME_FATAL	0x288
+#define DWC_MIPI_CSI2_INT_ST_SEQ_FRAME_FATAL		0x290
+#define DWC_MIPI_CSI2_INT_MSK_SEQ_FRAME_FATAL		0x294
+#define DWC_MIPI_CSI2_INT_FORCE_SEQ_FRAME_FATAL		0x298
+#define DWC_MIPI_CSI2_INT_ST_CRC_FRAME_FATAL		0x2A0
+#define DWC_MIPI_CSI2_INT_MSK_CRC_FRAME_FATAL		0x2A4
+#define DWC_MIPI_CSI2_INT_FORCE_CRC_FRAME_FATAL		0x2A8
+#define DWC_MIPI_CSI2_INT_ST_PLD_CRC_FATAL		0x2B0
+#define DWC_MIPI_CSI2_INT_MSK_PLD_CRC_FATAL		0x2B4
+#define DWC_MIPI_CSI2_INT_FORCE_PLD_CRC_FATAL		0x2B8
+#define DWC_MIPI_CSI2_INT_ST_DATA_ID			0x2C0
+#define DWC_MIPI_CSI2_INT_MSK_DATA_ID			0x2C4
+#define DWC_MIPI_CSI2_INT_FORCE_DATA_ID			0x2C8
+#define DWC_MIPI_CSI2_INT_ST_ECC_CORRECTED		0x2D0
+#define DWC_MIPI_CSI2_INT_MSK_ECC_CORRECTED		0x2D4
+#define DWC_MIPI_CSI2_INT_FORCE_ECC_CORRECTED		0x2D8
+#define DWC_MIPI_CSI2_IPI_RAM_ERR_LOG_AP		0x2E0
+#define DWC_MIPI_CSI2_IPI_RAM_ERR_ADDR_AP		0x2E4
+
+#define DWC_MIPI_CSI2_SCRAMBLING			0x300
+#define DWC_MIPI_CSI2_SCRAMBLING_SEED1			0x304
+#define DWC_MIPI_CSI2_SCRAMBLING_SEED2			0x308
+
+/* mediamix_GPR register */
+#define DISP_MIX_CAMERA_MUX				0x30
+#define DISP_MIX_CAMERA_MUX_DATA_TYPE(x)		(((x) & 0x3f) << 3)
+#define DISP_MIX_CAMERA_MUX_GASKET_ENABLE		(1 << 16)
+
+#define DISP_MIX_CSI_REG				0x48
+#define DISP_MIX_CSI_REG_CFGFREQRANGE(x)		((x)  & 0x3f)
+#define DISP_MIX_CSI_REG_HSFREQRANGE(x)			(((x) & 0x7f) << 8)
+
+#define dwc_mipi_csi2h_write(__csi2h, __r, __v) writel(__v, __csi2h->base_regs + __r)
+#define dwc_mipi_csi2h_read(__csi2h, __r) readl(__csi2h->base_regs + __r)
+
+#define DWC_MIPI_CSI2_HOST_DRIVER_NAME		"dwc-mipi-csi2-host"
+#define DWC_MIPI_CSI2_SUBDEV_NAME		"mxc-mipi-csi2"
+#define DWC_MIPI_CSI2_IPI_NUM			8
+
+#define DWC_MIPI_CSI2_VC0_PAD_SINK	0
+#define DWC_MIPI_CSI2_VC1_PAD_SINK	1
+#define DWC_MIPI_CSI2_VC2_PAD_SINK	2
+#define DWC_MIPI_CSI2_VC3_PAD_SINK	3
+#define DWC_MIPI_CSI2_VC0_PAD_SOURCE	4
+#define DWC_MIPI_CSI2_VC1_PAD_SOURCE	5
+#define DWC_MIPI_CSI2_VC2_PAD_SOURCE	6
+#define DWC_MIPI_CSI2_VC3_PAD_SOURCE	7
+#define DWC_MIPI_CSI2_VCX_PADS_NUM	8
+
+#define DEF_WIDTH	1920
+#define DEF_HEIGHT	1080
+
+enum data_type {
+	DT_YUV420_8	= 0x18,
+	DT_YUV420_10	= 0x19,
+	DT_YUV422_8	= 0x1E,
+	DT_YUV422_10	= 0x1F,
+	DT_RGB565	= 0x22,
+	DT_RGB888	= 0x24,
+	DT_RAW8		= 0x2A,
+	DT_RAW10	= 0x2B,
+	DT_RAW12	= 0x2C,
+};
+
+enum pg_mode {
+	DWC_VERTICAL_PATTERN,
+	DWC_HORIZONTIAL_APTTERN,
+};
+
+enum ipi_mode {
+	CAMERA_MODE,
+	CONTROLLER_MODE,
+};
+
+struct dwc_pg_config {
+	enum pg_mode mode;
+	u32 data_type;
+	u32 virtual_ch;
+	u16 virtual_ch_ex;
+	u16 virtual_ch_ex_2;
+};
+
+struct dphy_config {
+	u16 addr;
+	u16 data;
+	u16 out;
+};
+
+struct ipi_config {
+	u8 data_type;
+	u8 vir_chan;
+	u8 vir_ext;
+	u8 vir_ext_extra;
+
+	// IPI horizontal frame information
+	u16 hsa_time;
+	u16 hbp_time;
+	u16 hsd_time;
+	u16 hline_time;
+
+	// IPI vertical frame information
+	u16 vsa_lines;
+	u16 vbp_lines;
+	u16 vfp_lines;
+	u16 vactive_lines;
+
+	// IPI mode control
+	u8 controller_mode;
+	u8 color_mode_16;
+	u8 embeded_data;
+};
+
+struct csi2h_pix_format {
+	u32 code;
+	u32 fmt_reg;
+};
+
+struct dwc_mipi_csi2_host {
+	struct v4l2_subdev    sd;
+	struct v4l2_device    v4l2_dev;
+	struct v4l2_subdev    *sensor_sd;
+	struct media_pad      pads[8];
+
+	struct platform_device *pdev;
+	struct dwc_pg_config   pg_config;
+	struct dphy_config     dphy_cfg;
+	struct ipi_config      ipi_cfg[DWC_MIPI_CSI2_IPI_NUM];
+
+	const struct csi2h_pix_format *csi2h_fmt;
+
+	struct clk *csi_apb;
+	struct clk *csi_pixel;
+	struct clk *phy_cfg;
+
+	struct v4l2_mbus_framefmt format;
+
+	struct mutex lock;
+
+	struct regmap *gasket;
+
+	u32 num_lanes;
+	u32 lane_state;
+	u32 interlace_mode;
+	u32 yuv420_line_sel;
+	u32 cfgclkfreqrange;
+	u32 hsclkfreqrange;
+
+	bool ppi_pg_enable;
+	bool ppi_bus_width_ppi8;
+
+	void __iomem *base_regs;
+};
+
+static const struct csi2h_pix_format dwc_csi2h_formats[] = {
+	{
+		.code = MEDIA_BUS_FMT_YUYV8_2X8,
+		.fmt_reg = 0x18,
+	}, {
+		.code = MEDIA_BUS_FMT_RGB888_1X24,
+		.fmt_reg = 0x24,
+	}, {
+		.code = MEDIA_BUS_FMT_RGB565_1X16,
+		.fmt_reg = 0x22,
+	}, {
+		.code = MEDIA_BUS_FMT_SBGGR8_1X8,
+		.fmt_reg = 0x2A,
+	}, {
+		.code = MEDIA_BUS_FMT_SBGGR10_1X10,
+		.fmt_reg = 0x2B,
+	}, {
+		.code = MEDIA_BUS_FMT_SBGGR12_1X12,
+		.fmt_reg = 0x2C,
+	}, {
+		/* sentinel */
+	}
+};
+
+static void dwc_mipi_csi2_dump(struct dwc_mipi_csi2_host *csi2h)
+{
+	struct device *dev = &csi2h->pdev->dev;
+
+	dev_dbg(dev, "DWC CSI2 Version: %#x\n", dwc_mipi_csi2h_read(csi2h, DWC_MIPI_CSI2_VERSION));
+	dev_dbg(dev, "DWC CSI2 lanes: %#x\n",   dwc_mipi_csi2h_read(csi2h, DWC_MIPI_CSI2_N_LANES));
+	dev_dbg(dev, "DWC CSI2 HOST RESETN: %#x\n",   dwc_mipi_csi2h_read(csi2h, DWC_MIPI_CSI2_HOST_RESETN));
+	dev_dbg(dev, "DWC CSI2 INT STATUS MAIN: %#x\n",   dwc_mipi_csi2h_read(csi2h, DWC_MIPI_CSI2_INT_ST_MAIN));
+	dev_dbg(dev, "DWC CSI2 DATA IDS1: %#x\n",   dwc_mipi_csi2h_read(csi2h, DWC_MIPI_CSI2_DATA_IDS_1));
+	dev_dbg(dev, "DWC CSI2 DATA IDS2: %#x\n",   dwc_mipi_csi2h_read(csi2h, DWC_MIPI_CSI2_DATA_IDS_2));
+	dev_dbg(dev, "DWC CSI2 DPHY CFG: %#x\n",   dwc_mipi_csi2h_read(csi2h, DWC_MIPI_CSI2_DPHY_CFG));
+	dev_dbg(dev, "DWC CSI2 DPHY MODE: %#x\n",   dwc_mipi_csi2h_read(csi2h, DWC_MIPI_CSI2_DPHY_MODE));
+	dev_dbg(dev, "DWC CSI2 INT STATUS AP MAIN: %#x\n",   dwc_mipi_csi2h_read(csi2h, DWC_MIPI_CSI2_INT_ST_AP_MAIN));
+	dev_dbg(dev, "DWC CSI2 DATA IDS VC1: %#x\n",   dwc_mipi_csi2h_read(csi2h, DWC_MIPI_CSI2_DATA_IDS_VC_1));
+	dev_dbg(dev, "DWC CSI2 DATA IDS VC2: %#x\n",   dwc_mipi_csi2h_read(csi2h, DWC_MIPI_CSI2_DATA_IDS_VC_2));
+	dev_dbg(dev, "DWC CSI2 DPHY SHUTDOWN: %#x\n",   dwc_mipi_csi2h_read(csi2h, DWC_MIPI_CSI2_DPHY_SHUTDOWNZ));
+	dev_dbg(dev, "DWC CSI2 DPHY RESET: %#x\n",   dwc_mipi_csi2h_read(csi2h, DWC_MIPI_CSI2_DPHY_RSTZ));
+	dev_dbg(dev, "DWC CSI2 DPHY RX STATUS: %#x\n",   dwc_mipi_csi2h_read(csi2h, DWC_MIPI_CSI2_DPHY_RX_STATUS));
+	dev_dbg(dev, "DWC CSI2 DPHY STOP STATUS: %#x\n",   dwc_mipi_csi2h_read(csi2h, DWC_MIPI_CSI2_DPHY_STOPSTATE));
+	dev_dbg(dev, "DWC CSI2 DPHY TEST CTRL0: %#x\n",   dwc_mipi_csi2h_read(csi2h, DWC_MIPI_CSI2_DPHY_TEST_CTRL0));
+	dev_dbg(dev, "DWC CSI2 DPHY TEST CTRL1: %#x\n",   dwc_mipi_csi2h_read(csi2h, DWC_MIPI_CSI2_DPHY_TEST_CTRL1));
+	dev_dbg(dev, "DWC CSI2 PPI PG PATTERN HIGH: %#x\n",   dwc_mipi_csi2h_read(csi2h, DWC_MIPI_CSI2_PPI_PG_PATTERN_VRES));
+	dev_dbg(dev, "DWC CSI2 PPI PG PATTERN WIDTH: %#x\n",   dwc_mipi_csi2h_read(csi2h, DWC_MIPI_CSI2_PPI_PG_PATTERN_HRES));
+	dev_dbg(dev, "DWC CSI2 PPI PG CONFIG: %#x\n",   dwc_mipi_csi2h_read(csi2h, DWC_MIPI_CSI2_PPI_PG_CONFIG));
+	dev_dbg(dev, "DWC CSI2 PPI PG ENABLE: %#x\n",   dwc_mipi_csi2h_read(csi2h, DWC_MIPI_CSI2_PPI_PG_ENABLE));
+	dev_dbg(dev, "DWC CSI2 PPI PG STATUS: %#x\n",   dwc_mipi_csi2h_read(csi2h, DWC_MIPI_CSI2_PPI_PG_STATUS));
+	dev_dbg(dev, "DWC CSI2 IPI MODE: %#x\n",   dwc_mipi_csi2h_read(csi2h, DWC_MIPI_CSI2_IPI_MODE));
+	dev_dbg(dev, "DWC CSI2 IPI VCID: %#x\n",   dwc_mipi_csi2h_read(csi2h, DWC_MIPI_CSI2_IPI_VCID));
+	dev_dbg(dev, "DWC CSI2 IPI DATA TYPE: %#x\n",   dwc_mipi_csi2h_read(csi2h, DWC_MIPI_CSI2_IPI_DATA_TYPE));
+	dev_dbg(dev, "DWC CSI2 IPI SOFT RESET: %#x\n",   dwc_mipi_csi2h_read(csi2h, DWC_MIPI_CSI2_IPI_SOFTRSTN));
+	dev_dbg(dev, "DWC CSI2 IPI ADV FEATURE: %#x\n",   dwc_mipi_csi2h_read(csi2h, DWC_MIPI_CSI2_IPI_ADV_FEATURES));
+	dev_dbg(dev, "DWC CSI2 INT_MSK_PHY_FATAL: %#x\n", dwc_mipi_csi2h_read(csi2h, 0xE4));
+	dev_dbg(dev, "DWC CSI2 INT_MSK_PKT_FATAL: %#x\n", dwc_mipi_csi2h_read(csi2h, 0xF4));
+	dev_dbg(dev, "DWC CSI2 INT_MSK_PHY: %#x\n", dwc_mipi_csi2h_read(csi2h, 0x114));
+	dev_dbg(dev, "DWC CSI2 INT_MSK_IPI_FATAL: %#x\n", dwc_mipi_csi2h_read(csi2h, 0x144));
+	dev_dbg(dev, "DWC CSI2 INT_MSK_BNDRY_FRAME_FATAL: %#x\n", dwc_mipi_csi2h_read(csi2h, 0x284));
+	dev_dbg(dev, "DWC CSI2 INT_MSK_SEQ_FRAME_FATAL: %#x\n", dwc_mipi_csi2h_read(csi2h, 0x294));
+	dev_dbg(dev, "DWC CSI2 INT_MSK_DATA_ID: %#x\n", dwc_mipi_csi2h_read(csi2h, 0x2c4));
+}
+
+static void gasket_dump(struct dwc_mipi_csi2_host *csi2h)
+{
+	struct device *dev = &csi2h->pdev->dev;
+	struct regmap *gasket = csi2h->gasket;
+	u32 val;
+
+	regmap_read(gasket, DISP_MIX_CAMERA_MUX, &val);
+	dev_dbg(dev, "gasket: CAMERA MUX: %#x\n", val);
+
+	regmap_read(gasket, DISP_MIX_CSI_REG, &val);
+	dev_dbg(dev, "gasket: CSI REG: %#x\n", val);
+
+	regmap_read(gasket, 0x3C, &val);
+	dev_dbg(dev, "gasket: MIPI -> ISI pixel ctrl: %#x\n", val);
+
+	regmap_read(gasket, 0x40, &val);
+	dev_dbg(dev, "gasket: MIPI -> ISI pixel cnt: %#x\n", val);
+
+	regmap_read(gasket, 0x44, &val);
+	dev_dbg(dev, "gasket: MIPI -> ISI line cnt: %#x\n", val);
+}
+
+static inline struct dwc_mipi_csi2_host *sd_to_dwc_mipi_csi2h(
+						struct v4l2_subdev *sdev)
+{
+	return container_of(sdev, struct dwc_mipi_csi2_host, sd);
+}
+
+static inline u32 get_csi2_version(struct dwc_mipi_csi2_host *csi2h)
+{
+	return dwc_mipi_csi2h_read(csi2h, DWC_MIPI_CSI2_VERSION);
+}
+
+static const struct csi2h_pix_format *find_csi2h_format(u32 code)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(dwc_csi2h_formats); i++)
+		if (code == dwc_csi2h_formats[i].code)
+			return &dwc_csi2h_formats[i];
+	return NULL;
+}
+
+
+static ssize_t dwc_ppi_pg_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct dwc_mipi_csi2_host *csi2h = dev_get_drvdata(dev);
+	char temp[32];
+
+	if (csi2h->ppi_pg_enable)
+		strcpy(temp, "enabled");
+	else
+		strcpy(temp, "disabled");
+	return sprintf(buf, "%s\n", temp);
+}
+
+static ssize_t dwc_ppi_pg_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	struct dwc_mipi_csi2_host *csi2h = dev_get_drvdata(dev);
+	char temp[32];
+
+	if (sscanf(buf, "%s", temp) > 0) {
+		if (!strcmp(temp, "enabled"))
+			csi2h->ppi_pg_enable = true;
+		else
+			csi2h->ppi_pg_enable = false;
+		return count;
+	}
+	return -EINVAL;
+}
+static DEVICE_ATTR(ppi_pg_enable, 0644, dwc_ppi_pg_show, dwc_ppi_pg_store);
+
+static bool is_ppi_pg_active(struct dwc_mipi_csi2_host *csi2h)
+{
+	u32 val;
+
+	val = dwc_mipi_csi2h_read(csi2h, DWC_MIPI_CSI2_PPI_PG_STATUS);
+
+	return (val) ? true : false;
+}
+
+static void dwc_pattern_generate(struct dwc_mipi_csi2_host *csi2h)
+{
+	struct dwc_pg_config *pg_config = &csi2h->pg_config; 
+	struct v4l2_mbus_framefmt *mf = &csi2h->format;
+	struct device *dev = &csi2h->pdev->dev;
+	u32 val;
+
+	/*configure resolution for pattern generator*/
+	val = DWC_MIPI_CSI2_PPI_PG_PATTERN_HRES_HRES(mf->width);
+	dwc_mipi_csi2h_write(csi2h, DWC_MIPI_CSI2_PPI_PG_PATTERN_HRES, val);
+
+	val = DWC_MIPI_CSI2_PPI_PG_PATTERN_VRES_VRES(mf->height);
+	dwc_mipi_csi2h_write(csi2h, DWC_MIPI_CSI2_PPI_PG_PATTERN_VRES, val);
+
+	/*pattern generator configuration*/
+	val  = DWC_MIPI_CSI2_PPI_PG_CONFIG_DATA_TYPE(pg_config->data_type);
+	val |= DWC_MIPI_CSI2_PPI_PG_CONFIG_VIR_CHAN(pg_config->virtual_ch);
+	val |= DWC_MIPI_CSI2_PPI_PG_CONFIG_VIR_CHAN_EX(pg_config->virtual_ch_ex);
+	val |= DWC_MIPI_CSI2_PPI_PG_CONFIG_PG_MODE(pg_config->mode);
+
+	if (pg_config->virtual_ch_ex_2)
+		val |= DWC_MIPI_CSI2_PPI_PG_CONFIG_VIR_CHAN_EX_2_EN;
+
+	dwc_mipi_csi2h_write(csi2h, DWC_MIPI_CSI2_PPI_PG_CONFIG, val);
+
+	/*Enable ppi pattern generator*/
+	val = (csi2h->ppi_pg_enable) ? DWC_MIPI_CSI2_PPI_PG_ENABLE_EN : 0;
+	dwc_mipi_csi2h_write(csi2h, DWC_MIPI_CSI2_PPI_PG_ENABLE, val);
+
+	dev_dbg(dev, "enable DWC MIPI CSI2 pattern generator\n");
+}
+
+static void dwc_mipi_csi2_dphy_reset(struct dwc_mipi_csi2_host *csi2h)
+{
+	dwc_mipi_csi2h_write(csi2h, DWC_MIPI_CSI2_DPHY_RSTZ, 0x0);
+	dwc_mipi_csi2h_write(csi2h, DWC_MIPI_CSI2_DPHY_SHUTDOWNZ, 0x0);
+	udelay(50);
+
+	dwc_mipi_csi2h_write(csi2h, DWC_MIPI_CSI2_DPHY_SHUTDOWNZ, 0x1);
+	udelay(50);
+	dwc_mipi_csi2h_write(csi2h, DWC_MIPI_CSI2_DPHY_RSTZ, 0x1);
+}
+
+static void dwc_mipi_csi2_test_code_reset(struct dwc_mipi_csi2_host *csi2h)
+{
+	u32 val;
+
+	/*set PHY_TST_CTRL0, bit[0]*/
+	val = dwc_mipi_csi2h_read(csi2h, DWC_MIPI_CSI2_DPHY_TEST_CTRL0);
+	val |= DWC_MIPI_CSI2_DPHY_TEST_CTRL0_TEST_CLR;
+	dwc_mipi_csi2h_write(csi2h, DWC_MIPI_CSI2_DPHY_TEST_CTRL0, val);
+
+	/*clear PHY_TST_CTRL0, bit[0]*/
+	val = dwc_mipi_csi2h_read(csi2h, DWC_MIPI_CSI2_DPHY_TEST_CTRL0);
+	val &= ~DWC_MIPI_CSI2_DPHY_TEST_CTRL0_TEST_CLR;
+	dwc_mipi_csi2h_write(csi2h, DWC_MIPI_CSI2_DPHY_TEST_CTRL0, val);
+}
+
+static void dwc_mipi_csi2_host_reset(struct dwc_mipi_csi2_host *csi2h)
+{
+	u32 val;
+
+	/*reset mipi csi host, active low*/
+	val = 0;
+	dwc_mipi_csi2h_write(csi2h, DWC_MIPI_CSI2_HOST_RESETN, val);
+
+	val = DWC_MIPI_CSI2_HOST_RESETN_ENABLE;
+	dwc_mipi_csi2h_write(csi2h, DWC_MIPI_CSI2_HOST_RESETN, val);
+}
+
+static void dwc_mipi_csi2_ipi_config_htiming(struct dwc_mipi_csi2_host *csi2h)
+{
+	struct device *dev = &csi2h->pdev->dev;
+	struct ipi_config *ipi_cfg = &csi2h->ipi_cfg[0];
+	u32 val;
+
+	val = DWC_MIPI_CSI2_IPI_HSA_TIME_VAL(ipi_cfg->hsa_time);
+	dwc_mipi_csi2h_write(csi2h, DWC_MIPI_CSI2_IPI_HSA_TIME, val);
+
+	val = DWC_MIPI_CSI2_IPI_HBP_TIME_VAL(ipi_cfg->hbp_time);
+	dwc_mipi_csi2h_write(csi2h, DWC_MIPI_CSI2_IPI_HBP_TIME, val);
+
+	val = DWC_MIPI_CSI2_IPI_HSD_TIME_VAL(ipi_cfg->hsd_time);
+	dwc_mipi_csi2h_write(csi2h, DWC_MIPI_CSI2_IPI_HSD_TIME, val);
+
+	val = DWC_MIPI_CSI2_IPI_HLINE_TIME_VAL(ipi_cfg->hline_time);
+	dwc_mipi_csi2h_write(csi2h, DWC_MIPI_CSI2_IPI_HLINE_TIME, val);
+
+	dev_dbg(dev, "hsa_time=%d, hbp_time=%d, hsd_time=%d, hline_time=%d\n",
+		ipi_cfg->hsa_time, ipi_cfg->hbp_time,
+		ipi_cfg->hsd_time, ipi_cfg->hline_time);
+}
+
+static void dwc_mipi_csi2_ipi_config_vtiming(struct dwc_mipi_csi2_host *csi2h)
+{
+	struct device *dev = &csi2h->pdev->dev;
+	struct ipi_config *ipi_cfg = &csi2h->ipi_cfg[0];
+	u32 val;
+
+	val = DWC_MIPI_CSI2_IPI_VSA_LINES_VAL(ipi_cfg->vsa_lines);
+	dwc_mipi_csi2h_write(csi2h, DWC_MIPI_CSI2_IPI_VSA_LINES, val);
+
+	val = DWC_MIPI_CSI2_IPI_VBP_LINES_VAL(ipi_cfg->vbp_lines);
+	dwc_mipi_csi2h_write(csi2h, DWC_MIPI_CSI2_IPI_VBP_LINES, val);
+
+	val = DWC_MIPI_CSI2_IPI_VFP_LINES_VAL(ipi_cfg->vfp_lines);
+	dwc_mipi_csi2h_write(csi2h, DWC_MIPI_CSI2_IPI_VFP_LINES, val);
+
+	val = DWC_MIPI_CSI2_IPI_VACTIVE_LINES_VAL(ipi_cfg->vactive_lines);
+	dwc_mipi_csi2h_write(csi2h, DWC_MIPI_CSI2_IPI_VACTIVE_LINES, val);
+
+	dev_dbg(dev, "vsa_lines=%d, vbp_lines=%d, vsd_lines=%d, active_lines=%d\n",
+		ipi_cfg->vsa_lines, ipi_cfg->vbp_lines,
+		ipi_cfg->vfp_lines, ipi_cfg->vactive_lines);
+}
+
+static void dwc_mipi_csi2_ipi_enable(struct dwc_mipi_csi2_host *csi2h)
+{
+	u32 val;
+
+	/*enable ipi*/
+	val = dwc_mipi_csi2h_read(csi2h, DWC_MIPI_CSI2_IPI_MODE);
+	val |= DWC_MIPI_CSI2_IPI_MODE_ENABLE;
+	dwc_mipi_csi2h_write(csi2h, DWC_MIPI_CSI2_IPI_MODE, val);
+}
+
+static void dwc_mipi_csi2_ipi_disable(struct dwc_mipi_csi2_host *csi2h)
+{
+	u32 val;
+
+	/*disable ipi*/
+	val = dwc_mipi_csi2h_read(csi2h, DWC_MIPI_CSI2_IPI_MODE);
+	val &= ~DWC_MIPI_CSI2_IPI_MODE_ENABLE;
+	dwc_mipi_csi2h_write(csi2h, DWC_MIPI_CSI2_IPI_MODE, val);
+}
+
+/*
+ * function: Start up DWC_mipi_csi2_host
+ */
+static void dwc_mipi_csi2_host_startup(struct dwc_mipi_csi2_host *csi2h)
+{
+	/* Release DWC_mipi_csi2_host from reset */
+	dwc_mipi_csi2_host_reset(csi2h);
+
+	// Apply PHY Reset
+	dwc_mipi_csi2_dphy_reset(csi2h);
+
+	// Release PHY test codes from reset
+	dwc_mipi_csi2_test_code_reset(csi2h);
+}
+
+static void disp_mix_gasket_config(struct dwc_mipi_csi2_host *csi2h)
+{
+	struct device *dev = &csi2h->pdev->dev;
+	struct regmap *gasket = csi2h->gasket;
+	struct v4l2_mbus_framefmt *mf = &csi2h->format;
+	s32 fmt_val = -EINVAL;
+	u32 val;
+
+
+	switch (mf->code) {
+	case MEDIA_BUS_FMT_RGB888_1X24:
+		fmt_val = DT_RGB888;
+		break;
+	case MEDIA_BUS_FMT_YUYV8_2X8:
+	case MEDIA_BUS_FMT_YVYU8_2X8:
+	case MEDIA_BUS_FMT_UYVY8_2X8:
+	case MEDIA_BUS_FMT_VYUY8_2X8:
+		fmt_val = DT_YUV422_8;
+		break;
+	case MEDIA_BUS_FMT_SBGGR8_1X8:
+		fmt_val = DT_RAW8;
+		break;
+	case MEDIA_BUS_FMT_SBGGR10_1X10:
+	case MEDIA_BUS_FMT_SGBRG10_1X10:
+	case MEDIA_BUS_FMT_SGRBG10_1X10:
+	case MEDIA_BUS_FMT_SRGGB10_1X10:
+		fmt_val = DT_RAW10;
+		break;
+	case MEDIA_BUS_FMT_SBGGR12_1X12:
+	case MEDIA_BUS_FMT_SGBRG12_1X12:
+	case MEDIA_BUS_FMT_SGRBG12_1X12:
+	case MEDIA_BUS_FMT_SRGGB12_1X12:
+		fmt_val = DT_RAW12;
+		break;
+	default:
+		pr_err("gasket not support format %d\n", mf->code);
+		return;
+	}
+
+	if (csi2h->ppi_pg_enable)
+		fmt_val = DT_RGB888;
+
+	regmap_write(gasket, DISP_MIX_CAMERA_MUX, 0x0);
+
+	regmap_read(gasket, DISP_MIX_CAMERA_MUX, &val);
+	val |= DISP_MIX_CAMERA_MUX_DATA_TYPE(fmt_val);
+	val |= csi2h->ipi_cfg[0].vir_chan << 11;
+	val |= csi2h->interlace_mode << 9;
+	val |= csi2h->yuv420_line_sel << 13;
+	regmap_write(gasket, DISP_MIX_CAMERA_MUX, val);
+
+	dev_dbg(dev, "format: %#x, w/h=(%d, %d)\n", mf->code, mf->width, mf->height);
+	if (WARN_ON(!mf->width || !mf->height)) {
+		pr_err("Invaid width/height\n");
+		return;
+	}
+
+	/*Configure the PHY frequency range*/
+	val = DISP_MIX_CSI_REG_CFGFREQRANGE(csi2h->cfgclkfreqrange);
+	val |= DISP_MIX_CSI_REG_HSFREQRANGE(csi2h->hsclkfreqrange);
+	regmap_write(gasket, DISP_MIX_CSI_REG, val);
+
+	/*enable gasket*/
+	regmap_read(gasket, DISP_MIX_CAMERA_MUX, &val);
+	val |= DISP_MIX_CAMERA_MUX_GASKET_ENABLE;
+	regmap_write(gasket, DISP_MIX_CAMERA_MUX, val);
+}
+
+/*
+ * function: Initialize DWC_mipi_csi2_host
+ */
+static int dwc_mipi_csi2_host_init(struct dwc_mipi_csi2_host *csi2h)
+{
+	struct device *dev = &csi2h->pdev->dev;
+	struct regmap *gasket = csi2h->gasket;
+	struct ipi_config *ipi_cfg = &csi2h->ipi_cfg[0];
+	u32 val, ret;
+
+	/* Release Synopsys DPHY test codes from reset */
+	dwc_mipi_csi2h_write(csi2h, DWC_MIPI_CSI2_DPHY_RSTZ, 0x0);
+	dwc_mipi_csi2h_write(csi2h, DWC_MIPI_CSI2_DPHY_SHUTDOWNZ, 0x0);
+	dwc_mipi_csi2h_write(csi2h, DWC_MIPI_CSI2_HOST_RESETN, 0);
+
+	/*Set testclr=1'b1*/
+	val = dwc_mipi_csi2h_read(csi2h, DWC_MIPI_CSI2_DPHY_TEST_CTRL0);
+	val |= DWC_MIPI_CSI2_DPHY_TEST_CTRL0_TEST_CLR;
+	dwc_mipi_csi2h_write(csi2h, DWC_MIPI_CSI2_DPHY_TEST_CTRL0, val);
+
+	/* Wait for at least 15ns */
+	udelay(1);
+
+	/*Set testclr=1'b0*/
+	val = dwc_mipi_csi2h_read(csi2h, DWC_MIPI_CSI2_DPHY_TEST_CTRL0);
+	val &= ~DWC_MIPI_CSI2_DPHY_TEST_CTRL0_TEST_CLR;
+	dwc_mipi_csi2h_write(csi2h, DWC_MIPI_CSI2_DPHY_TEST_CTRL0, val);
+
+	/*config PHY frequency ranage*/
+	val = DISP_MIX_CSI_REG_CFGFREQRANGE(csi2h->cfgclkfreqrange);
+	val |= DISP_MIX_CSI_REG_HSFREQRANGE(csi2h->hsclkfreqrange);
+	regmap_write(gasket, DISP_MIX_CSI_REG, val);
+
+	/*config the number of active lanes*/
+	val = DWC_MIPI_CSI2_N_LANES_N_LANES(csi2h->num_lanes - 1);
+	dwc_mipi_csi2h_write(csi2h, DWC_MIPI_CSI2_N_LANES, val);
+
+	/*config PHY_CFG[1:0], PPI8 or PPI16(default)*/
+	val = csi2h->ppi_bus_width_ppi8 ? DWC_MIPI_CSI2_DPHY_CFG_PPI8 :
+	                                  DWC_MIPI_CSI2_DPHY_CFG_PPI16;
+	dwc_mipi_csi2h_write(csi2h, DWC_MIPI_CSI2_DPHY_CFG, val);
+
+	/*release PHY from reset*/
+	dwc_mipi_csi2h_write(csi2h, DWC_MIPI_CSI2_DPHY_SHUTDOWNZ, 0x1);
+	dwc_mipi_csi2h_write(csi2h, DWC_MIPI_CSI2_DPHY_RSTZ, 0x1);
+	dwc_mipi_csi2h_write(csi2h, DWC_MIPI_CSI2_HOST_RESETN, 0x1);
+
+	/*Define errors to be masked*/
+	dwc_mipi_csi2h_write(csi2h, DWC_MIPI_CSI2_INT_MSK_DPHY_FATAL, 0xffff);
+	dwc_mipi_csi2h_write(csi2h, DWC_MIPI_CSI2_INT_MSK_PKT_FATAL,  0xffff);
+	dwc_mipi_csi2h_write(csi2h, DWC_MIPI_CSI2_INT_MSK_IPI_FATAL,  0xffff);
+	dwc_mipi_csi2h_write(csi2h, DWC_MIPI_CSI2_INT_MSK_AP_GENERIC, 0xffff);
+	dwc_mipi_csi2h_write(csi2h, DWC_MIPI_CSI2_INT_MSK_DPHY,  0xffff);
+	dwc_mipi_csi2h_write(csi2h, DWC_MIPI_CSI2_INT_MSK_LINE,  0xffff);
+
+	/*add IDI DT config*/
+	val  = DWC_MIPI_CSI2_DATA_IDS_1_DI0_DT(ipi_cfg->data_type);
+	dwc_mipi_csi2h_write(csi2h, DWC_MIPI_CSI2_DATA_IDS_1, val);
+
+	/*add IDI VC config*/
+	val  = DWC_MIPI_CSI2_DATA_IDS_VC_1_DI0_VC(ipi_cfg->vir_chan);
+	dwc_mipi_csi2h_write(csi2h, DWC_MIPI_CSI2_DATA_IDS_VC_1, val);
+
+	/* Check that data lanes are in stop state, active 0 or 1? */
+	ret = readl_poll_timeout(csi2h->base_regs + DWC_MIPI_CSI2_DPHY_STOPSTATE,
+			   val, val != 0x10003, 10, 10000);
+	if (ret) {
+		dev_err(dev, "dwc data lane not in stop state, state=%#x\n", val);
+		return ret;
+	}
+
+	return 0;
+}
+
+/*
+ * function: Configure IPI
+ */
+static int dwc_mipi_csi2_host_ipi_config(struct dwc_mipi_csi2_host *csi2h)
+{
+	struct device *dev = &csi2h->pdev->dev;
+	struct ipi_config *ipi_cfg = &csi2h->ipi_cfg[0];
+	u32 val;
+
+	/*do IPI soft reset*/
+	dwc_mipi_csi2h_write(csi2h, DWC_MIPI_CSI2_IPI_SOFTRSTN, 0x0);
+	dwc_mipi_csi2h_write(csi2h, DWC_MIPI_CSI2_IPI_SOFTRSTN, 0xfffff);
+
+	/*Select virtual channel and data type to be processed by IPI*/
+	val = DWC_MIPI_CSI2_IPI_DATA_TYPE_DT(ipi_cfg->data_type);
+	if (ipi_cfg->embeded_data)
+		val |= DWC_MIPI_CSI2_IPI_DATA_TYPE_EMB_DATA_EN;
+	dwc_mipi_csi2h_write(csi2h, DWC_MIPI_CSI2_IPI_DATA_TYPE, val);
+
+	val  = DWC_MIPI_CSI2_IPI_VCID_VC(ipi_cfg->vir_chan);
+	val |= DWC_MIPI_CSI2_IPI_VCID_VC_0_1(ipi_cfg->vir_ext);
+	if (ipi_cfg->vir_ext_extra)
+		val |= DWC_MIPI_CSI2_IPI_VCID_VC_2;
+	else
+		val &= ~DWC_MIPI_CSI2_IPI_VCID_VC_2;
+	dwc_mipi_csi2h_write(csi2h, DWC_MIPI_CSI2_IPI_VCID, val);
+
+	dev_dbg(dev, "data_type:0x%x, virtual chan: %d\n",
+		ipi_cfg->data_type, ipi_cfg->vir_chan);
+
+	/* 1. Select the IPI mode, camera timing by default
+	 * 2. PPI color mode, mode16/18: 16 bits interface by default
+	 */
+	val  = dwc_mipi_csi2h_read(csi2h, DWC_MIPI_CSI2_IPI_MODE);
+	val |= ipi_cfg->controller_mode ? DWC_MIPI_CSI2_IPI_MODE_CONTROLLER :
+					  DWC_MIPI_CSI2_IPI_MODE_CAMERA;
+	val |= ipi_cfg->color_mode_16 ? DWC_MIPI_CSI2_IPI_MODE_COLOR_MODE16 :
+					DWC_MIPI_CSI2_IPI_MODE_COLOR_MODE48;
+	dwc_mipi_csi2h_write(csi2h, DWC_MIPI_CSI2_IPI_MODE, val);
+
+	/* Enable ipi_cut_through */
+	val  = dwc_mipi_csi2h_read(csi2h, DWC_MIPI_CSI2_IPI_MODE);
+	val |= DWC_MIPI_CSI2_IPI_MODE_CUT_THROUGH;
+	dwc_mipi_csi2h_write(csi2h, DWC_MIPI_CSI2_IPI_MODE, val);
+
+	/* Configure the IPI horizontal frame information */
+	dwc_mipi_csi2_ipi_config_htiming(csi2h);
+
+	if (csi2h->ppi_pg_enable)
+		dwc_mipi_csi2h_write(csi2h, DWC_MIPI_CSI2_IPI_ADV_FEATURES,
+				     0x01050000);
+
+	/* Configure the IPI vertical frame information for controller mode */
+	if (ipi_cfg->controller_mode || csi2h->ppi_pg_enable)
+		dwc_mipi_csi2_ipi_config_vtiming(csi2h);
+
+	dev_dbg(dev, "ipi mode: %s, color_mode: %s\n",
+		ipi_cfg->controller_mode ? "controller" : "camera",
+		ipi_cfg->color_mode_16   ? "color mode 16" : "color mode 48");
+
+	return 0;
+}
+
+/*
+ * function: Start the High Speed Reception Mode
+ */
+static int dwc_mipi_csi2_host_hs_rx_start(struct dwc_mipi_csi2_host *csi2h)
+{
+	u32 val;
+
+	/* Memory is automatically flushed at each Frame Start */
+	val = DWC_MIPI_CSI2_IPI_MEM_FLUSH_AUTO;
+	dwc_mipi_csi2h_write(csi2h, DWC_MIPI_CSI2_IPI_MEM_FLUSH, val);
+
+	/*Check if user enable PPI pattern generator*/
+	if (csi2h->ppi_pg_enable && !is_ppi_pg_active(csi2h))
+		dwc_pattern_generate(csi2h);
+
+	/* Enable IPI */
+	dwc_mipi_csi2_ipi_enable(csi2h);
+
+	return 0;
+}
+
+/*
+ * function: Stop the High Speed Reception Mode
+ */
+static int dwc_mipi_csi2_host_hs_rx_stop(struct dwc_mipi_csi2_host *csi2h)
+{
+	struct device *dev = &csi2h->pdev->dev;
+	u32 val;
+
+	dwc_mipi_csi2_ipi_disable(csi2h);
+	dwc_mipi_csi2_dphy_reset(csi2h);
+
+	// Check clock lane is not in High Speed Mode
+	val = dwc_mipi_csi2h_read(csi2h, DWC_MIPI_CSI2_DPHY_RX_STATUS);
+	if (val & DWC_MIPI_CSI2_DPHY_RX_STATUS_CLK_LANE_HS) {
+		dev_err(dev, "DWC MIPI CSI clock lanes still in HS mode\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static struct media_pad *dwc_csi2_get_remote_sensor_pad(struct dwc_mipi_csi2_host *csi2h)
+{
+	struct v4l2_subdev *subdev = &csi2h->sd;
+	struct media_pad *sink_pad, *source_pad;
+	int i;
+
+	while (1) {
+		source_pad = NULL;
+		for (i = 0; i < subdev->entity.num_pads; i++) {
+			sink_pad = &subdev->entity.pads[i];
+
+			if (sink_pad->flags & MEDIA_PAD_FL_SINK) {
+				source_pad = media_entity_remote_pad(sink_pad);
+				if (source_pad)
+					break;
+			}
+		}
+		/* return first pad point in the loop  */
+		return source_pad;
+	}
+
+	if (i == subdev->entity.num_pads)
+		v4l2_err(&csi2h->sd, "%s, No remote pad found!\n", __func__);
+
+	return NULL;
+}
+
+static struct v4l2_subdev *dwc_get_remote_subdev(struct dwc_mipi_csi2_host *csi2h,
+						 const char * const label)
+{
+	struct media_pad *source_pad;
+	struct v4l2_subdev *sen_sd;
+
+	/* Get remote source pad */
+	source_pad = dwc_csi2_get_remote_sensor_pad(csi2h);
+	if (!source_pad) {
+		v4l2_err(&csi2h->sd, "%s, No remote pad found!\n", label);
+		return NULL;
+	}
+
+	/* Get remote source pad subdev */
+	sen_sd = media_entity_to_v4l2_subdev(source_pad->entity);
+	if (!sen_sd) {
+		v4l2_err(&csi2h->sd, "%s, No remote subdev found!\n", label);
+		return NULL;
+	}
+
+	return sen_sd;
+}
+
+static int dwc_mipi_csi2_param_init(struct dwc_mipi_csi2_host *csi2h)
+{
+	struct device *dev = &csi2h->pdev->dev;
+	struct device_node *node = dev->of_node;
+	struct dwc_pg_config *pg_config = &csi2h->pg_config;
+	struct ipi_config *ipi_cfg;
+	int i;
+
+	/*Disable pattern generator by default*/
+	csi2h->ppi_pg_enable = false;
+
+	memset(pg_config, 0x0, sizeof(*pg_config));
+
+	pg_config->virtual_ch = 0;
+	pg_config->data_type  = DT_RGB888;
+	pg_config->mode       = DWC_VERTICAL_PATTERN;
+
+	for (i = 0; i < DWC_MIPI_CSI2_IPI_NUM; i++) {
+		ipi_cfg = &csi2h->ipi_cfg[i];
+		memset(ipi_cfg, 0x0, sizeof(*ipi_cfg));
+
+		if (csi2h->ppi_pg_enable) {
+			ipi_cfg->data_type  = DT_RGB888;
+			ipi_cfg->vir_chan   = 0;
+			ipi_cfg->hsa_time   = 3;
+			ipi_cfg->hbp_time   = 2;
+			ipi_cfg->hsd_time   = 0x10;
+			ipi_cfg->hline_time = 2500;
+			ipi_cfg->vsa_lines  = 1;
+			ipi_cfg->vbp_lines  = 1;
+			ipi_cfg->vfp_lines  = 0xf;
+			ipi_cfg->vactive_lines   = 1080;
+			ipi_cfg->controller_mode = 0;
+			ipi_cfg->color_mode_16   = 0;
+			ipi_cfg->embeded_data    = 0;
+		} else {
+			ipi_cfg->data_type  = DT_YUV422_8;
+			ipi_cfg->vir_chan   = 0;
+			ipi_cfg->hsa_time   = 0;
+			ipi_cfg->hbp_time   = 0;
+			ipi_cfg->hsd_time   = 0;
+			ipi_cfg->hline_time = 0x500;
+			ipi_cfg->vsa_lines  = 0;
+			ipi_cfg->vbp_lines  = 0;
+			ipi_cfg->vfp_lines  = 0;
+			ipi_cfg->vactive_lines   = 0x320;
+			ipi_cfg->controller_mode = 0;
+			ipi_cfg->color_mode_16   = 0;
+			ipi_cfg->embeded_data    = 0;
+		}
+	}
+
+	csi2h->format.width  = DEF_WIDTH;
+	csi2h->format.height = DEF_HEIGHT;
+	csi2h->format.code   = dwc_csi2h_formats[0].code;
+	csi2h->csi2h_fmt     = &dwc_csi2h_formats[0];
+
+	node = of_graph_get_next_endpoint(node, NULL);
+	if (!node) {
+		dev_err(dev, "No port node\n");
+		return -EINVAL;
+	}
+	of_property_read_u32(node, "data-lanes", &csi2h->num_lanes);
+	of_property_read_u32(node, "cfg-clk-range", &csi2h->cfgclkfreqrange);
+	of_property_read_u32(node, "hs-clk-range", &csi2h->hsclkfreqrange);
+
+	dev_dbg(dev, "cfgclkfreqrange=%d, hsfreqrange=%d\n",
+		 csi2h->cfgclkfreqrange, csi2h->hsclkfreqrange);
+	return 0;
+}
+
+static int dwc_mipi_csi2_enum_framesizes(struct v4l2_subdev *sd,
+				     struct v4l2_subdev_state *cfg,
+				     struct v4l2_subdev_frame_size_enum *fse)
+{
+	struct dwc_mipi_csi2_host *csi2h = sd_to_dwc_mipi_csi2h(sd);
+	struct v4l2_subdev *sen_sd;
+
+	sen_sd = dwc_get_remote_subdev(csi2h, __func__);
+	if (!sen_sd)
+		return -EINVAL;
+
+	return v4l2_subdev_call(sen_sd, pad, enum_frame_size, NULL, fse);
+}
+
+static int dwc_mipi_csi2_enum_frame_interval(struct v4l2_subdev *sd,
+					 struct v4l2_subdev_state *cfg,
+					 struct v4l2_subdev_frame_interval_enum *fie)
+{
+	struct dwc_mipi_csi2_host *csi2h = sd_to_dwc_mipi_csi2h(sd);
+	struct v4l2_subdev *sen_sd;
+
+	sen_sd = dwc_get_remote_subdev(csi2h, __func__);
+	if (!sen_sd)
+		return -EINVAL;
+
+	return v4l2_subdev_call(sen_sd, pad, enum_frame_interval, NULL, fie);
+}
+
+static int dwc_mipi_csi2_get_fmt(struct v4l2_subdev *sd,
+			     struct v4l2_subdev_state *cfg,
+			     struct v4l2_subdev_format *format)
+{
+	struct dwc_mipi_csi2_host *csi2h = sd_to_dwc_mipi_csi2h(sd);
+	struct v4l2_mbus_framefmt *mf = &csi2h->format;
+	struct media_pad *source_pad;
+	struct v4l2_subdev *sen_sd;
+	int ret;
+
+	/* Get remote source pad */
+	source_pad = dwc_csi2_get_remote_sensor_pad(csi2h);
+	if (!source_pad) {
+		v4l2_err(&csi2h->sd, "%s, No remote pad found!\n", __func__);
+		return -EINVAL;
+	}
+
+	/* Get remote source pad subdev */
+	sen_sd = dwc_get_remote_subdev(csi2h, __func__);
+	if (!sen_sd) {
+		v4l2_err(&csi2h->sd, "%s, No remote subdev found!\n", __func__);
+		return -EINVAL;
+	}
+
+	format->pad = source_pad->index;
+	ret = v4l2_subdev_call(sen_sd, pad, get_fmt, NULL, format);
+	if (ret < 0) {
+		v4l2_err(&csi2h->sd, "%s, call get_fmt of subdev failed!\n", __func__);
+		return ret;
+	}
+
+	memcpy(mf, &format->format, sizeof(struct v4l2_mbus_framefmt));
+	return 0;
+}
+
+static int dwc_mipi_csi2_set_fmt(struct v4l2_subdev *sd,
+			     struct v4l2_subdev_state *cfg,
+			     struct v4l2_subdev_format *format)
+{
+	struct dwc_mipi_csi2_host *csi2h = sd_to_dwc_mipi_csi2h(sd);
+	struct v4l2_mbus_framefmt *mf = &format->format;
+	struct csi2h_pix_format const *csi2h_fmt;
+	struct media_pad *source_pad;
+	struct v4l2_subdev *sen_sd;
+	int ret;
+
+	/* Get remote source pad */
+	source_pad = dwc_csi2_get_remote_sensor_pad(csi2h);
+	if (!source_pad) {
+		v4l2_err(&csi2h->sd, "%s, No remote pad found!\n", __func__);
+		return -EINVAL;
+	}
+
+	/* Get remote source pad subdev */
+	sen_sd = dwc_get_remote_subdev(csi2h, __func__);
+	if (!sen_sd) {
+		v4l2_err(&csi2h->sd, "%s, No remote subdev found!\n", __func__);
+		return -EINVAL;
+	}
+
+	format->pad = source_pad->index;
+	ret = v4l2_subdev_call(sen_sd, pad, set_fmt, NULL, format);
+	if (ret < 0) {
+		v4l2_err(&csi2h->sd, "%s, set sensor format fail\n", __func__);
+		return -EINVAL;
+	}
+
+	csi2h_fmt = find_csi2h_format(mf->code);
+	if (!csi2h_fmt) {
+		csi2h_fmt = &dwc_csi2h_formats[0];
+		mf->code = csi2h_fmt->code;
+	}
+
+	v4l2_info(&csi2h->sd, "format: %#x\n", mf->code);
+
+	return 0;
+}
+
+static int dwc_mipi_csi2_s_power(struct v4l2_subdev *sd, int on)
+{
+	struct dwc_mipi_csi2_host *csi2h = sd_to_dwc_mipi_csi2h(sd);
+	struct v4l2_subdev *sen_sd;
+
+	sen_sd = dwc_get_remote_subdev(csi2h, __func__);
+	if (!sen_sd)
+		return -EINVAL;
+
+	return v4l2_subdev_call(sen_sd, core, s_power, on);
+}
+
+static int dwc_mipi_csi2_g_frame_interval(struct v4l2_subdev *sd,
+				struct v4l2_subdev_frame_interval *interval)
+{
+	struct dwc_mipi_csi2_host *csi2h = sd_to_dwc_mipi_csi2h(sd);
+	struct v4l2_subdev *sen_sd;
+
+	sen_sd = dwc_get_remote_subdev(csi2h, __func__);
+	if (!sen_sd)
+		return -EINVAL;
+
+	return v4l2_subdev_call(sen_sd, video, g_frame_interval, interval);
+}
+
+static int dwc_mipi_csi2_s_frame_interval(struct v4l2_subdev *sd,
+				struct v4l2_subdev_frame_interval *interval)
+{
+	struct dwc_mipi_csi2_host *csi2h = sd_to_dwc_mipi_csi2h(sd);
+	struct v4l2_subdev *sen_sd;
+
+	sen_sd = dwc_get_remote_subdev(csi2h, __func__);
+	if (!sen_sd)
+		return -EINVAL;
+
+	return v4l2_subdev_call(sen_sd, video, s_frame_interval, interval);
+}
+
+static int dwc_mipi_csi2_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct dwc_mipi_csi2_host *csi2h = sd_to_dwc_mipi_csi2h(sd);
+	struct device *dev = &csi2h->pdev->dev;
+	int ret = 0;
+
+	dev_info(&csi2h->pdev->dev, "enter enable=%d\n", enable);
+
+	if (enable) {
+		pm_runtime_get_sync(dev);
+		dwc_mipi_csi2_host_startup(csi2h);
+		dwc_mipi_csi2_host_init(csi2h);
+		dwc_mipi_csi2_host_ipi_config(csi2h);
+		dwc_mipi_csi2_host_hs_rx_start(csi2h);
+		disp_mix_gasket_config(csi2h);
+		dwc_mipi_csi2_dump(csi2h);
+		gasket_dump(csi2h);
+	} else {
+		dwc_mipi_csi2_host_hs_rx_stop(csi2h);
+		pm_runtime_put(dev);
+	}
+
+	return ret;
+}
+static struct v4l2_subdev_pad_ops dwc_mipi_csi2_pad_ops = {
+	.enum_frame_size     = dwc_mipi_csi2_enum_framesizes,
+	.enum_frame_interval = dwc_mipi_csi2_enum_frame_interval,
+	.get_fmt             = dwc_mipi_csi2_get_fmt,
+	.set_fmt             = dwc_mipi_csi2_set_fmt,
+};
+
+static struct v4l2_subdev_core_ops dwc_mipi_csi2_core_ops = {
+	.s_power = dwc_mipi_csi2_s_power,
+};
+
+static struct v4l2_subdev_video_ops dwc_mipi_csi2_video_ops = {
+	.g_frame_interval = dwc_mipi_csi2_g_frame_interval,
+	.s_frame_interval = dwc_mipi_csi2_s_frame_interval,
+	.s_stream	  = dwc_mipi_csi2_s_stream,
+};
+
+static struct v4l2_subdev_ops dwc_mipi_csi2_subdev_ops = {
+	.core  = &dwc_mipi_csi2_core_ops,
+	.video = &dwc_mipi_csi2_video_ops,
+	.pad   = &dwc_mipi_csi2_pad_ops,
+};
+
+static int dwc_mipi_csi2_link_setup(struct media_entity *entity,
+				    const struct media_pad *local,
+				    const struct media_pad *remote, u32 flags)
+{
+	return 0;
+}
+
+static const struct media_entity_operations dwc_mipi_csi2_sd_media_ops = {
+	.link_setup = dwc_mipi_csi2_link_setup,
+};
+
+static int dwc_mipi_csi2_clk_init(struct dwc_mipi_csi2_host *csi2h)
+{
+	struct device *dev = &csi2h->pdev->dev;
+
+	csi2h->csi_apb = devm_clk_get(dev, "clk_core");
+	if (IS_ERR(csi2h->csi_apb)) {
+		if (PTR_ERR(csi2h->csi_apb) != -EPROBE_DEFER)
+			dev_err(dev, "Failed to get media csi apb clock\n");
+		return PTR_ERR(csi2h->csi_apb);
+	}
+
+	csi2h->csi_pixel = devm_clk_get(dev, "clk_pixel");
+	if (IS_ERR(csi2h->csi_pixel)) {
+		if (PTR_ERR(csi2h->csi_pixel) != -EPROBE_DEFER)
+			dev_err(dev, "Failed to get media csi pixel clock\n");
+		return PTR_ERR(csi2h->csi_pixel);
+	}
+
+	csi2h->phy_cfg = devm_clk_get(dev, "phy_cfg");
+	if (IS_ERR(csi2h->phy_cfg)) {
+		if (PTR_ERR(csi2h->phy_cfg) != -EPROBE_DEFER)
+			dev_err(dev, "Failed to get csi phy cfg clock\n");
+		return PTR_ERR(csi2h->phy_cfg);
+	}
+
+	return 0;
+}
+
+static int dwc_mipi_csi2_clk_enable(struct dwc_mipi_csi2_host *csi2h)
+{
+	struct device *dev = &csi2h->pdev->dev;
+	int ret;
+
+	ret = clk_prepare_enable(csi2h->csi_apb);
+	if (ret) {
+		dev_err(dev, "enable csi apb clock failed!\n");
+		return ret;
+	}
+
+	ret = clk_prepare_enable(csi2h->csi_pixel);
+	if (ret) {
+		dev_err(dev, "enable csi pixel clock failed!\n");
+		return ret;
+	}
+
+	ret = clk_prepare_enable(csi2h->phy_cfg);
+	if (ret) {
+		dev_err(dev, "enable csi phy cfg clock failed!\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static void dwc_mipi_csi2_clk_disable(struct dwc_mipi_csi2_host *csi2h)
+{
+	clk_disable_unprepare(csi2h->phy_cfg);
+	clk_disable_unprepare(csi2h->csi_apb);
+	clk_disable_unprepare(csi2h->csi_pixel);
+}
+
+static int dwc_mipi_csi2_parse_dt(struct dwc_mipi_csi2_host *csi2h)
+{
+	return 0;
+}
+
+static int dwc_mipi_csis_system_suspend(struct device *dev)
+{
+	return pm_runtime_force_suspend(dev);;
+}
+
+static int dwc_mipi_csis_system_resume(struct device *dev)
+{
+	int ret;
+
+	ret = pm_runtime_force_resume(dev);
+	if (ret < 0) {
+		dev_err(dev, "force resume %s failed!\n", dev_name(dev));
+		return ret;
+	}
+
+	return 0;
+}
+
+static int dwc_mipi_csis_runtime_suspend(struct device *dev)
+{
+	struct dwc_mipi_csi2_host *csi2h = dev_get_drvdata(dev);
+
+	dwc_mipi_csi2_clk_disable(csi2h);
+
+	return 0;
+}
+
+static int dwc_mipi_csis_runtime_resume(struct device *dev)
+{
+	struct dwc_mipi_csi2_host *csi2h = dev_get_drvdata(dev);
+	int ret;
+
+	ret = dwc_mipi_csi2_clk_enable(csi2h);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+static const struct dev_pm_ops dwc_mipi_csi2_host_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(dwc_mipi_csis_system_suspend,
+				dwc_mipi_csis_system_resume)
+	SET_RUNTIME_PM_OPS(dwc_mipi_csis_runtime_suspend,
+			   dwc_mipi_csis_runtime_resume,
+			   NULL)
+};
+
+static int dwc_mipi_csi2_host_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct dwc_mipi_csi2_host *csi2h;
+	struct resource *mem_res;
+	struct regmap *gasket;
+	int ret;
+
+	csi2h = devm_kzalloc(dev, sizeof(*csi2h), GFP_KERNEL);
+	if (!csi2h)
+		return -ENOMEM;
+
+	csi2h->pdev = pdev;
+	mutex_init(&csi2h->lock);
+
+	ret = dwc_mipi_csi2_parse_dt(csi2h);
+	if (ret < 0) {
+		dev_err(dev, "fail to parse DWC property\n");
+		return ret;
+	}
+
+	mem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	csi2h->base_regs = devm_ioremap_resource(dev, mem_res);
+	if (IS_ERR(csi2h->base_regs)) {
+		dev_err(dev, "Failed to get mipi csi2 register\n");
+		return PTR_ERR(csi2h->base_regs);
+	}
+
+	gasket = syscon_regmap_lookup_by_phandle(pdev->dev.of_node, "gasket");
+	if (IS_ERR(gasket)) {
+		dev_err(dev, "fail to get csi gasket\n");
+		return PTR_ERR(gasket);
+	}
+	csi2h->gasket = gasket;
+
+	ret = dwc_mipi_csi2_clk_init(csi2h);
+	if (ret < 0) {
+		dev_err(dev, "Failed to init DWC mipi csi clocks\n");
+		return ret;
+	}
+
+	ret = dwc_mipi_csi2_param_init(csi2h);
+	if (ret < 0)
+		return ret;
+	v4l2_subdev_init(&csi2h->sd, &dwc_mipi_csi2_subdev_ops);
+
+	csi2h->sd.owner = THIS_MODULE;
+	snprintf(csi2h->sd.name, sizeof(csi2h->sd.name), "%s.0",
+		 DWC_MIPI_CSI2_SUBDEV_NAME);
+
+	csi2h->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	csi2h->sd.entity.function = MEDIA_ENT_F_IO_V4L;
+	csi2h->sd.dev = dev;
+
+	csi2h->pads[DWC_MIPI_CSI2_VC0_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+	csi2h->pads[DWC_MIPI_CSI2_VC1_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+	csi2h->pads[DWC_MIPI_CSI2_VC2_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+	csi2h->pads[DWC_MIPI_CSI2_VC3_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+
+	csi2h->pads[DWC_MIPI_CSI2_VC0_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	csi2h->pads[DWC_MIPI_CSI2_VC1_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	csi2h->pads[DWC_MIPI_CSI2_VC2_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	csi2h->pads[DWC_MIPI_CSI2_VC3_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	ret = media_entity_pads_init(&csi2h->sd.entity,
+				     DWC_MIPI_CSI2_VCX_PADS_NUM, csi2h->pads);
+	if (ret < 0) {
+		dev_err(dev, "DWC MIPI CSI entity pads init fail\n");
+		return ret;
+	}
+
+	csi2h->sd.entity.ops = &dwc_mipi_csi2_sd_media_ops;
+
+	v4l2_set_subdevdata(&csi2h->sd, pdev);
+	platform_set_drvdata(pdev, csi2h);
+
+	ret = device_create_file(&pdev->dev, &dev_attr_ppi_pg_enable);
+	if (ret) {
+		dev_err(&pdev->dev, "Fail to create ppi_pg_enable property\n");
+		return ret;
+	}
+	pm_runtime_enable(dev);
+
+	dev_info(&pdev->dev, "lanes: %d, name: %s\n", csi2h->num_lanes, csi2h->sd.name);
+	return 0;
+}
+
+static int dwc_mipi_csi2_host_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static const struct of_device_id dwc_mipi_csi2_host_of_match[] = {
+	{ .compatible = "fsl,dwc-mipi-csi2-host", },
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, mipi_csi2_of_match);
+
+static struct platform_driver dwc_mipi_csi2_host_driver = {
+	.driver = {
+		.owner          = THIS_MODULE,
+		.name           = DWC_MIPI_CSI2_HOST_DRIVER_NAME,
+		.of_match_table = dwc_mipi_csi2_host_of_match,
+		.pm             = &dwc_mipi_csi2_host_pm_ops,
+	},
+	.probe  = dwc_mipi_csi2_host_probe,
+	.remove = dwc_mipi_csi2_host_remove,
+};
+
+module_platform_driver(dwc_mipi_csi2_host_driver);
+
+MODULE_DESCRIPTION("DWC MIPI CSI2 Host driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" DWC_MIPI_CSI2_HOST_DRIVER_NAME);
diff --git a/drivers/staging/media/imx/gmsl-max9286.c b/drivers/staging/media/imx/gmsl-max9286.c
new file mode 100644
index 000000000..dda6e2f32
--- /dev/null
+++ b/drivers/staging/media/imx/gmsl-max9286.c
@@ -0,0 +1,3344 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright 2019-2021 NXP
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/ctype.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/of_device.h>
+#include <linux/i2c.h>
+#include <linux/v4l2-mediabus.h>
+#include <linux/of_gpio.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/regulator/consumer.h>
+#include <media/v4l2-subdev.h>
+
+#define MAX9271_MAX_SENSOR_NUM	4
+#define CAMERA_USES_15HZ
+
+#define ADDR_MAX9286		0x6A
+#define ADDR_MAX9271		0x40
+#define ADDR_MAX9271_ALL	(ADDR_MAX9271 + 5)  /* Broadcast address */
+
+#define MIPI_CSI2_SENS_VC0_PAD_SOURCE	0
+#define MIPI_CSI2_SENS_VC1_PAD_SOURCE	1
+#define MIPI_CSI2_SENS_VC2_PAD_SOURCE	2
+#define MIPI_CSI2_SENS_VC3_PAD_SOURCE	3
+#define MIPI_CSI2_SENS_VCX_PADS_NUM		4
+
+#define MAX_FPS		30
+#define MIN_FPS		15
+#define DEFAULT_FPS		30
+
+#define ADDR_OV_SENSOR	0x30
+#define ADDR_AP_SENSOR	0x5D
+
+/*!
+ * Maintains the information on the current state of the sesor.
+ */
+struct imxdpu_videomode {
+	char name[64];		/* may not be needed */
+
+	u32 pixelclock;	/* Hz */
+
+	/* htotal (pixels) = hlen + hfp + hsync + hbp */
+	u32 hlen;
+	u32 hfp;
+	u32 hbp;
+	u32 hsync;
+
+	/* field0 - vtotal (lines) = vlen + vfp + vsync + vbp */
+	u32 vlen;
+	u32 vfp;
+	u32 vbp;
+	u32 vsync;
+
+	/* field1  */
+	u32 vlen1;
+	u32 vfp1;
+	u32 vbp1;
+	u32 vsync1;
+
+	u32 flags;
+
+	u32 format;
+	u32 dest_format; /*buffer format for capture*/
+
+	s16 clip_top;
+	s16 clip_left;
+	u16 clip_width;
+	u16 clip_height;
+};
+
+enum ov10635_mode {
+	ov10635_mode_MIN = 0,
+	ov10635_mode_WXGA_1280_800 = 0,
+	ov10635_mode_720P_1280_720 = 1,
+	ov10635_mode_WVGA_752_480 = 2,
+	ov10635_mode_VGA_640_480 = 3,
+	ov10635_mode_CIF_352_288 = 4,
+	ov10635_mode_QVGA_320_240 = 5,
+	ov10635_mode_MAX = 5,
+};
+
+enum ov10635_frame_rate {
+	OV10635_15_FPS = 0,
+	OV10635_30_FPS,
+};
+
+struct sensor_data {
+	struct v4l2_subdev	subdev;
+	struct media_pad pads[MIPI_CSI2_SENS_VCX_PADS_NUM];
+	struct i2c_client *i2c_client;
+	struct v4l2_mbus_framefmt format;
+	enum ov10635_frame_rate current_fr;
+	enum ov10635_mode current_mode;
+	struct v4l2_fract frame_interval;
+
+	/* lock to protect shared members */
+	struct mutex lock;
+	char running;
+
+	/* control settings */
+	int brightness;
+	int hue;
+	int contrast;
+	int saturation;
+	int red;
+	int green;
+	int blue;
+	int ae_mode;
+
+	u32 mclk;
+	u8 mclk_source;
+	struct clk *sensor_clk;
+	int v_channel;
+	bool is_mipi;
+	struct imxdpu_videomode cap_mode;
+
+	unsigned int sensor_num;       /* sensor num connect max9271 */
+	unsigned char sensor_is_there; /* Bit 0~3 for 4 cameras
+					* 0b1= is there;
+					* 0b0 = is not there
+					*/
+	struct gpio_desc *pwn_gpio;
+};
+
+#define OV10635_REG_PID		0x300A
+#define OV10635_REG_VER		0x300B
+
+struct reg_value {
+	unsigned short reg_addr;
+	unsigned char val;
+	unsigned int delay_ms;
+};
+
+static int ov10635_framerates[] = {
+	[OV10635_15_FPS] = 15,
+	[OV10635_30_FPS] = 30,
+};
+
+static struct reg_value ov10635_init_data[] = {
+	{ 0x0103, 0x01, 0 },
+	{ 0x300c, 0x61, 0 },
+	{ 0x300c, 0x61, 0 },
+	{ 0x300c, 0x61, 0 },
+	{ 0x300c, 0x61, 0 },
+	{ 0x300c, 0x61, 0 },
+	{ 0x300c, 0x61, 0 },
+	{ 0x300c, 0x61, 0 },
+	{ 0x300c, 0x61, 0 },
+	{ 0x300c, 0x61, 0 },
+	{ 0x300c, 0x61, 0 },
+	{ 0x300c, 0x61, 0 },
+	{ 0x300c, 0x61, 0 },
+	{ 0x300c, 0x61, 0 },
+	{ 0x300c, 0x61, 0 },
+	{ 0x300c, 0x61, 0 },
+	{ 0x300c, 0x61, 0 },
+	{ 0x300c, 0x61, 0 },
+	{ 0x300c, 0x61, 0 },
+	{ 0x300c, 0x61, 0 },
+	{ 0x300c, 0x61, 0 },
+	{ 0x300c, 0x61, 0 },
+	{ 0x300c, 0x61, 0 },
+	{ 0x300c, 0x61, 0 },
+	{ 0x301b, 0xff, 0 },
+	{ 0x301c, 0xff, 0 },
+	{ 0x301a, 0xff, 0 },
+	{ 0x3011, 0x42, 0 },
+	{ 0x6900, 0x0c, 0 },
+	{ 0x6901, 0x11, 0 },
+	{ 0x3503, 0x10, 0 },
+	{ 0x3025, 0x03, 0 },
+	{ 0x3003, 0x20, 0 },
+	{ 0x3004, 0x21, 0 },
+	{ 0x3005, 0x20, 0 },
+	{ 0x3006, 0x91, 0 },
+	{ 0x3600, 0x74, 0 },
+	{ 0x3601, 0x2b, 0 },
+	{ 0x3612, 0x00, 0 },
+	{ 0x3611, 0x67, 0 },
+	{ 0x3633, 0xca, 0 },
+	{ 0x3602, 0x2f, 0 },
+	{ 0x3603, 0x00, 0 },
+	{ 0x3630, 0x28, 0 },
+	{ 0x3631, 0x16, 0 },
+	{ 0x3714, 0x10, 0 },
+	{ 0x371d, 0x01, 0 },
+	{ 0x4300, 0x38, 0 },
+	{ 0x3007, 0x01, 0 },
+	{ 0x3024, 0x01, 0 },
+	{ 0x3020, 0x0b, 0 },
+	{ 0x3702, 0x20, 0 },
+	{ 0x3703, 0x48, 0 },
+	{ 0x3704, 0x32, 0 },
+	{ 0x3709, 0xa8, 0 },
+	{ 0x3709, 0xa8, 0 },
+	{ 0x370c, 0xc7, 0 },
+	{ 0x370d, 0x80, 0 },
+	{ 0x3712, 0x00, 0 },
+	{ 0x3713, 0x20, 0 },
+	{ 0x3715, 0x04, 0 },
+	{ 0x381d, 0x40, 0 },
+	{ 0x381c, 0x00, 0 },
+	{ 0x3822, 0x50, 0 },
+	{ 0x3824, 0x50, 0 },
+	{ 0x3815, 0x8c, 0 },
+	{ 0x3804, 0x05, 0 },
+	{ 0x3805, 0x1f, 0 },
+	{ 0x3800, 0x00, 0 },
+	{ 0x3801, 0x00, 0 },
+	{ 0x3806, 0x03, 0 },
+	{ 0x3807, 0x29, 0 },
+	{ 0x3802, 0x00, 0 },
+	{ 0x3803, 0x04, 0 },
+	{ 0x3808, 0x05, 0 },
+	{ 0x3809, 0x00, 0 },
+	{ 0x380a, 0x03, 0 },
+	{ 0x380b, 0x20, 0 },
+	{ 0x380c, 0x07, 0 },
+	{ 0x380d, 0x71, 0 },
+	{ 0x6e42, 0x03, 0 },
+	{ 0x6e43, 0x48, 0 },
+	{ 0x380e, 0x03, 0 },
+	{ 0x380f, 0x48, 0 },
+	{ 0x3813, 0x02, 0 },
+	{ 0x3811, 0x10, 0 },
+	{ 0x381f, 0x0c, 0 },
+	{ 0x3828, 0x03, 0 },
+	{ 0x3829, 0x10, 0 },
+	{ 0x382a, 0x10, 0 },
+	{ 0x382b, 0x10, 0 },
+	{ 0x3621, 0x64, 0 },
+	{ 0x5005, 0x08, 0 },
+	{ 0x56d5, 0x00, 0 },
+	{ 0x56d6, 0x80, 0 },
+	{ 0x56d7, 0x00, 0 },
+	{ 0x56d8, 0x00, 0 },
+	{ 0x56d9, 0x00, 0 },
+	{ 0x56da, 0x80, 0 },
+	{ 0x56db, 0x00, 0 },
+	{ 0x56dc, 0x00, 0 },
+	{ 0x56e8, 0x00, 0 },
+	{ 0x56e9, 0x7f, 0 },
+	{ 0x56ea, 0x00, 0 },
+	{ 0x56eb, 0x7f, 0 },
+	{ 0x5100, 0x00, 0 },
+	{ 0x5101, 0x80, 0 },
+	{ 0x5102, 0x00, 0 },
+	{ 0x5103, 0x80, 0 },
+	{ 0x5104, 0x00, 0 },
+	{ 0x5105, 0x80, 0 },
+	{ 0x5106, 0x00, 0 },
+	{ 0x5107, 0x80, 0 },
+	{ 0x5108, 0x00, 0 },
+	{ 0x5109, 0x00, 0 },
+	{ 0x510a, 0x00, 0 },
+	{ 0x510b, 0x00, 0 },
+	{ 0x510c, 0x00, 0 },
+	{ 0x510d, 0x00, 0 },
+	{ 0x510e, 0x00, 0 },
+	{ 0x510f, 0x00, 0 },
+	{ 0x5110, 0x00, 0 },
+	{ 0x5111, 0x80, 0 },
+	{ 0x5112, 0x00, 0 },
+	{ 0x5113, 0x80, 0 },
+	{ 0x5114, 0x00, 0 },
+	{ 0x5115, 0x80, 0 },
+	{ 0x5116, 0x00, 0 },
+	{ 0x5117, 0x80, 0 },
+	{ 0x5118, 0x00, 0 },
+	{ 0x5119, 0x00, 0 },
+	{ 0x511a, 0x00, 0 },
+	{ 0x511b, 0x00, 0 },
+	{ 0x511c, 0x00, 0 },
+	{ 0x511d, 0x00, 0 },
+	{ 0x511e, 0x00, 0 },
+	{ 0x511f, 0x00, 0 },
+	{ 0x56d0, 0x00, 0 },
+	{ 0x5006, 0x24, 0 },
+	{ 0x5608, 0x0d, 0 },
+	{ 0x52d7, 0x06, 0 },
+	{ 0x528d, 0x08, 0 },
+	{ 0x5293, 0x12, 0 },
+	{ 0x52d3, 0x12, 0 },
+	{ 0x5288, 0x06, 0 },
+	{ 0x5289, 0x20, 0 },
+	{ 0x52c8, 0x06, 0 },
+	{ 0x52c9, 0x20, 0 },
+	{ 0x52cd, 0x04, 0 },
+	{ 0x5381, 0x00, 0 },
+	{ 0x5382, 0xff, 0 },
+	{ 0x5589, 0x76, 0 },
+	{ 0x558a, 0x47, 0 },
+	{ 0x558b, 0xef, 0 },
+	{ 0x558c, 0xc9, 0 },
+	{ 0x558d, 0x49, 0 },
+	{ 0x558e, 0x30, 0 },
+	{ 0x558f, 0x67, 0 },
+	{ 0x5590, 0x3f, 0 },
+	{ 0x5591, 0xf0, 0 },
+	{ 0x5592, 0x10, 0 },
+	{ 0x55a2, 0x6d, 0 },
+	{ 0x55a3, 0x55, 0 },
+	{ 0x55a4, 0xc3, 0 },
+	{ 0x55a5, 0xb5, 0 },
+	{ 0x55a6, 0x43, 0 },
+	{ 0x55a7, 0x38, 0 },
+	{ 0x55a8, 0x5f, 0 },
+	{ 0x55a9, 0x4b, 0 },
+	{ 0x55aa, 0xf0, 0 },
+	{ 0x55ab, 0x10, 0 },
+	{ 0x5581, 0x52, 0 },
+	{ 0x5300, 0x01, 0 },
+	{ 0x5301, 0x00, 0 },
+	{ 0x5302, 0x00, 0 },
+	{ 0x5303, 0x0e, 0 },
+	{ 0x5304, 0x00, 0 },
+	{ 0x5305, 0x0e, 0 },
+	{ 0x5306, 0x00, 0 },
+	{ 0x5307, 0x36, 0 },
+	{ 0x5308, 0x00, 0 },
+	{ 0x5309, 0xd9, 0 },
+	{ 0x530a, 0x00, 0 },
+	{ 0x530b, 0x0f, 0 },
+	{ 0x530c, 0x00, 0 },
+	{ 0x530d, 0x2c, 0 },
+	{ 0x530e, 0x00, 0 },
+	{ 0x530f, 0x59, 0 },
+	{ 0x5310, 0x00, 0 },
+	{ 0x5311, 0x7b, 0 },
+	{ 0x5312, 0x00, 0 },
+	{ 0x5313, 0x22, 0 },
+	{ 0x5314, 0x00, 0 },
+	{ 0x5315, 0xd5, 0 },
+	{ 0x5316, 0x00, 0 },
+	{ 0x5317, 0x13, 0 },
+	{ 0x5318, 0x00, 0 },
+	{ 0x5319, 0x18, 0 },
+	{ 0x531a, 0x00, 0 },
+	{ 0x531b, 0x26, 0 },
+	{ 0x531c, 0x00, 0 },
+	{ 0x531d, 0xdc, 0 },
+	{ 0x531e, 0x00, 0 },
+	{ 0x531f, 0x02, 0 },
+	{ 0x5320, 0x00, 0 },
+	{ 0x5321, 0x24, 0 },
+	{ 0x5322, 0x00, 0 },
+	{ 0x5323, 0x56, 0 },
+	{ 0x5324, 0x00, 0 },
+	{ 0x5325, 0x85, 0 },
+	{ 0x5326, 0x00, 0 },
+	{ 0x5327, 0x20, 0 },
+	{ 0x5609, 0x01, 0 },
+	{ 0x560a, 0x40, 0 },
+	{ 0x560b, 0x01, 0 },
+	{ 0x560c, 0x40, 0 },
+	{ 0x560d, 0x00, 0 },
+	{ 0x560e, 0xfa, 0 },
+	{ 0x560f, 0x00, 0 },
+	{ 0x5610, 0xfa, 0 },
+	{ 0x5611, 0x02, 0 },
+	{ 0x5612, 0x80, 0 },
+	{ 0x5613, 0x02, 0 },
+	{ 0x5614, 0x80, 0 },
+	{ 0x5615, 0x01, 0 },
+	{ 0x5616, 0x2c, 0 },
+	{ 0x5617, 0x01, 0 },
+	{ 0x5618, 0x2c, 0 },
+	{ 0x563b, 0x01, 0 },
+	{ 0x563c, 0x01, 0 },
+	{ 0x563d, 0x01, 0 },
+	{ 0x563e, 0x01, 0 },
+	{ 0x563f, 0x03, 0 },
+	{ 0x5640, 0x03, 0 },
+	{ 0x5641, 0x03, 0 },
+	{ 0x5642, 0x05, 0 },
+	{ 0x5643, 0x09, 0 },
+	{ 0x5644, 0x05, 0 },
+	{ 0x5645, 0x05, 0 },
+	{ 0x5646, 0x05, 0 },
+	{ 0x5647, 0x05, 0 },
+	{ 0x5651, 0x00, 0 },
+	{ 0x5652, 0x80, 0 },
+	{ 0x521a, 0x01, 0 },
+	{ 0x521b, 0x03, 0 },
+	{ 0x521c, 0x06, 0 },
+	{ 0x521d, 0x0a, 0 },
+	{ 0x521e, 0x0e, 0 },
+	{ 0x521f, 0x12, 0 },
+	{ 0x5220, 0x16, 0 },
+	{ 0x5223, 0x02, 0 },
+	{ 0x5225, 0x04, 0 },
+	{ 0x5227, 0x08, 0 },
+	{ 0x5229, 0x0c, 0 },
+	{ 0x522b, 0x12, 0 },
+	{ 0x522d, 0x18, 0 },
+	{ 0x522f, 0x1e, 0 },
+	{ 0x5241, 0x04, 0 },
+	{ 0x5242, 0x01, 0 },
+	{ 0x5243, 0x03, 0 },
+	{ 0x5244, 0x06, 0 },
+	{ 0x5245, 0x0a, 0 },
+	{ 0x5246, 0x0e, 0 },
+	{ 0x5247, 0x12, 0 },
+	{ 0x5248, 0x16, 0 },
+	{ 0x524a, 0x03, 0 },
+	{ 0x524c, 0x04, 0 },
+	{ 0x524e, 0x08, 0 },
+	{ 0x5250, 0x0c, 0 },
+	{ 0x5252, 0x12, 0 },
+	{ 0x5254, 0x18, 0 },
+	{ 0x5256, 0x1e, 0 },
+	{ 0x4606, 0x07, 0 },
+	{ 0x4607, 0x71, 0 },
+	{ 0x460a, 0x02, 0 },
+	{ 0x460b, 0x70, 0 },
+	{ 0x460c, 0x00, 0 },
+	{ 0x4620, 0x0e, 0 },
+	{ 0x4700, 0x04, 0 },
+	{ 0x4701, 0x00, 0 },
+	{ 0x4702, 0x01, 0 },
+	{ 0x4004, 0x04, 0 },
+	{ 0x4005, 0x18, 0 },
+	{ 0x4001, 0x06, 0 },
+	{ 0x4050, 0x22, 0 },
+	{ 0x4051, 0x24, 0 },
+	{ 0x4052, 0x02, 0 },
+	{ 0x4057, 0x9c, 0 },
+	{ 0x405a, 0x00, 0 },
+	{ 0x4202, 0x02, 0 },
+	{ 0x3023, 0x10, 0 },
+	{ 0x0100, 0x0f, 0 },
+	{ 0x0100, 0x0f, 0 },
+	{ 0x6f10, 0x07, 0 },
+	{ 0x6f11, 0x82, 0 },
+	{ 0x6f12, 0x04, 0 },
+	{ 0x6f13, 0x00, 0 },
+	{ 0x6f14, 0x1f, 0 },
+	{ 0x6f15, 0xdd, 0 },
+	{ 0x6f16, 0x04, 0 },
+	{ 0x6f17, 0x04, 0 },
+	{ 0x6f18, 0x36, 0 },
+	{ 0x6f19, 0x66, 0 },
+	{ 0x6f1a, 0x04, 0 },
+	{ 0x6f1b, 0x08, 0 },
+	{ 0x6f1c, 0x0c, 0 },
+	{ 0x6f1d, 0xe7, 0 },
+	{ 0x6f1e, 0x04, 0 },
+	{ 0x6f1f, 0x0c, 0 },
+	{ 0xd000, 0x19, 0 },
+	{ 0xd001, 0xa0, 0 },
+	{ 0xd002, 0x00, 0 },
+	{ 0xd003, 0x01, 0 },
+	{ 0xd004, 0xa9, 0 },
+	{ 0xd005, 0xad, 0 },
+	{ 0xd006, 0x10, 0 },
+	{ 0xd007, 0x40, 0 },
+	{ 0xd008, 0x44, 0 },
+	{ 0xd009, 0x00, 0 },
+	{ 0xd00a, 0x68, 0 },
+	{ 0xd00b, 0x00, 0 },
+	{ 0xd00c, 0x15, 0 },
+	{ 0xd00d, 0x00, 0 },
+	{ 0xd00e, 0x00, 0 },
+	{ 0xd00f, 0x00, 0 },
+	{ 0xd010, 0x19, 0 },
+	{ 0xd011, 0xa0, 0 },
+	{ 0xd012, 0x00, 0 },
+	{ 0xd013, 0x01, 0 },
+	{ 0xd014, 0xa9, 0 },
+	{ 0xd015, 0xad, 0 },
+	{ 0xd016, 0x13, 0 },
+	{ 0xd017, 0xd0, 0 },
+	{ 0xd018, 0x44, 0 },
+	{ 0xd019, 0x00, 0 },
+	{ 0xd01a, 0x68, 0 },
+	{ 0xd01b, 0x00, 0 },
+	{ 0xd01c, 0x15, 0 },
+	{ 0xd01d, 0x00, 0 },
+	{ 0xd01e, 0x00, 0 },
+	{ 0xd01f, 0x00, 0 },
+	{ 0xd020, 0x19, 0 },
+	{ 0xd021, 0xa0, 0 },
+	{ 0xd022, 0x00, 0 },
+	{ 0xd023, 0x01, 0 },
+	{ 0xd024, 0xa9, 0 },
+	{ 0xd025, 0xad, 0 },
+	{ 0xd026, 0x14, 0 },
+	{ 0xd027, 0xb8, 0 },
+	{ 0xd028, 0x44, 0 },
+	{ 0xd029, 0x00, 0 },
+	{ 0xd02a, 0x68, 0 },
+	{ 0xd02b, 0x00, 0 },
+	{ 0xd02c, 0x15, 0 },
+	{ 0xd02d, 0x00, 0 },
+	{ 0xd02e, 0x00, 0 },
+	{ 0xd02f, 0x00, 0 },
+	{ 0xd030, 0x19, 0 },
+	{ 0xd031, 0xa0, 0 },
+	{ 0xd032, 0x00, 0 },
+	{ 0xd033, 0x01, 0 },
+	{ 0xd034, 0xa9, 0 },
+	{ 0xd035, 0xad, 0 },
+	{ 0xd036, 0x14, 0 },
+	{ 0xd037, 0xdc, 0 },
+	{ 0xd038, 0x44, 0 },
+	{ 0xd039, 0x00, 0 },
+	{ 0xd03a, 0x68, 0 },
+	{ 0xd03b, 0x00, 0 },
+	{ 0xd03c, 0x15, 0 },
+	{ 0xd03d, 0x00, 0 },
+	{ 0xd03e, 0x00, 0 },
+	{ 0xd03f, 0x00, 0 },
+	{ 0xd040, 0x9c, 0 },
+	{ 0xd041, 0x21, 0 },
+	{ 0xd042, 0xff, 0 },
+	{ 0xd043, 0xe4, 0 },
+	{ 0xd044, 0xd4, 0 },
+	{ 0xd045, 0x01, 0 },
+	{ 0xd046, 0x48, 0 },
+	{ 0xd047, 0x00, 0 },
+	{ 0xd048, 0xd4, 0 },
+	{ 0xd049, 0x01, 0 },
+	{ 0xd04a, 0x50, 0 },
+	{ 0xd04b, 0x04, 0 },
+	{ 0xd04c, 0xd4, 0 },
+	{ 0xd04d, 0x01, 0 },
+	{ 0xd04e, 0x60, 0 },
+	{ 0xd04f, 0x08, 0 },
+	{ 0xd050, 0xd4, 0 },
+	{ 0xd051, 0x01, 0 },
+	{ 0xd052, 0x70, 0 },
+	{ 0xd053, 0x0c, 0 },
+	{ 0xd054, 0xd4, 0 },
+	{ 0xd055, 0x01, 0 },
+	{ 0xd056, 0x80, 0 },
+	{ 0xd057, 0x10, 0 },
+	{ 0xd058, 0x19, 0 },
+	{ 0xd059, 0xc0, 0 },
+	{ 0xd05a, 0x00, 0 },
+	{ 0xd05b, 0x01, 0 },
+	{ 0xd05c, 0xa9, 0 },
+	{ 0xd05d, 0xce, 0 },
+	{ 0xd05e, 0x02, 0 },
+	{ 0xd05f, 0xa4, 0 },
+	{ 0xd060, 0x9c, 0 },
+	{ 0xd061, 0xa0, 0 },
+	{ 0xd062, 0x00, 0 },
+	{ 0xd063, 0x00, 0 },
+	{ 0xd064, 0x84, 0 },
+	{ 0xd065, 0x6e, 0 },
+	{ 0xd066, 0x00, 0 },
+	{ 0xd067, 0x00, 0 },
+	{ 0xd068, 0xd8, 0 },
+	{ 0xd069, 0x03, 0 },
+	{ 0xd06a, 0x28, 0 },
+	{ 0xd06b, 0x76, 0 },
+	{ 0xd06c, 0x1a, 0 },
+	{ 0xd06d, 0x00, 0 },
+	{ 0xd06e, 0x00, 0 },
+	{ 0xd06f, 0x01, 0 },
+	{ 0xd070, 0xaa, 0 },
+	{ 0xd071, 0x10, 0 },
+	{ 0xd072, 0x03, 0 },
+	{ 0xd073, 0xf0, 0 },
+	{ 0xd074, 0x18, 0 },
+	{ 0xd075, 0x60, 0 },
+	{ 0xd076, 0x00, 0 },
+	{ 0xd077, 0x01, 0 },
+	{ 0xd078, 0xa8, 0 },
+	{ 0xd079, 0x63, 0 },
+	{ 0xd07a, 0x07, 0 },
+	{ 0xd07b, 0x80, 0 },
+	{ 0xd07c, 0xe0, 0 },
+	{ 0xd07d, 0xa0, 0 },
+	{ 0xd07e, 0x00, 0 },
+	{ 0xd07f, 0x04, 0 },
+	{ 0xd080, 0x18, 0 },
+	{ 0xd081, 0xc0, 0 },
+	{ 0xd082, 0x00, 0 },
+	{ 0xd083, 0x00, 0 },
+	{ 0xd084, 0xa8, 0 },
+	{ 0xd085, 0xc6, 0 },
+	{ 0xd086, 0x00, 0 },
+	{ 0xd087, 0x00, 0 },
+	{ 0xd088, 0x8c, 0 },
+	{ 0xd089, 0x63, 0 },
+	{ 0xd08a, 0x00, 0 },
+	{ 0xd08b, 0x00, 0 },
+	{ 0xd08c, 0xd4, 0 },
+	{ 0xd08d, 0x01, 0 },
+	{ 0xd08e, 0x28, 0 },
+	{ 0xd08f, 0x14, 0 },
+	{ 0xd090, 0xd4, 0 },
+	{ 0xd091, 0x01, 0 },
+	{ 0xd092, 0x30, 0 },
+	{ 0xd093, 0x18, 0 },
+	{ 0xd094, 0x07, 0 },
+	{ 0xd095, 0xff, 0 },
+	{ 0xd096, 0xf8, 0 },
+	{ 0xd097, 0xfd, 0 },
+	{ 0xd098, 0x9c, 0 },
+	{ 0xd099, 0x80, 0 },
+	{ 0xd09a, 0x00, 0 },
+	{ 0xd09b, 0x03, 0 },
+	{ 0xd09c, 0xa5, 0 },
+	{ 0xd09d, 0x6b, 0 },
+	{ 0xd09e, 0x00, 0 },
+	{ 0xd09f, 0xff, 0 },
+	{ 0xd0a0, 0x18, 0 },
+	{ 0xd0a1, 0xc0, 0 },
+	{ 0xd0a2, 0x00, 0 },
+	{ 0xd0a3, 0x01, 0 },
+	{ 0xd0a4, 0xa8, 0 },
+	{ 0xd0a5, 0xc6, 0 },
+	{ 0xd0a6, 0x01, 0 },
+	{ 0xd0a7, 0x02, 0 },
+	{ 0xd0a8, 0xe1, 0 },
+	{ 0xd0a9, 0x6b, 0 },
+	{ 0xd0aa, 0x58, 0 },
+	{ 0xd0ab, 0x00, 0 },
+	{ 0xd0ac, 0x84, 0 },
+	{ 0xd0ad, 0x8e, 0 },
+	{ 0xd0ae, 0x00, 0 },
+	{ 0xd0af, 0x00, 0 },
+	{ 0xd0b0, 0xe1, 0 },
+	{ 0xd0b1, 0x6b, 0 },
+	{ 0xd0b2, 0x30, 0 },
+	{ 0xd0b3, 0x00, 0 },
+	{ 0xd0b4, 0x98, 0 },
+	{ 0xd0b5, 0xb0, 0 },
+	{ 0xd0b6, 0x00, 0 },
+	{ 0xd0b7, 0x00, 0 },
+	{ 0xd0b8, 0x8c, 0 },
+	{ 0xd0b9, 0x64, 0 },
+	{ 0xd0ba, 0x00, 0 },
+	{ 0xd0bb, 0x6e, 0 },
+	{ 0xd0bc, 0xe5, 0 },
+	{ 0xd0bd, 0xa5, 0 },
+	{ 0xd0be, 0x18, 0 },
+	{ 0xd0bf, 0x00, 0 },
+	{ 0xd0c0, 0x10, 0 },
+	{ 0xd0c1, 0x00, 0 },
+	{ 0xd0c2, 0x00, 0 },
+	{ 0xd0c3, 0x06, 0 },
+	{ 0xd0c4, 0x95, 0 },
+	{ 0xd0c5, 0x8b, 0 },
+	{ 0xd0c6, 0x00, 0 },
+	{ 0xd0c7, 0x00, 0 },
+	{ 0xd0c8, 0x94, 0 },
+	{ 0xd0c9, 0xa4, 0 },
+	{ 0xd0ca, 0x00, 0 },
+	{ 0xd0cb, 0x70, 0 },
+	{ 0xd0cc, 0xe5, 0 },
+	{ 0xd0cd, 0x65, 0 },
+	{ 0xd0ce, 0x60, 0 },
+	{ 0xd0cf, 0x00, 0 },
+	{ 0xd0d0, 0x0c, 0 },
+	{ 0xd0d1, 0x00, 0 },
+	{ 0xd0d2, 0x00, 0 },
+	{ 0xd0d3, 0x62, 0 },
+	{ 0xd0d4, 0x15, 0 },
+	{ 0xd0d5, 0x00, 0 },
+	{ 0xd0d6, 0x00, 0 },
+	{ 0xd0d7, 0x00, 0 },
+	{ 0xd0d8, 0x18, 0 },
+	{ 0xd0d9, 0x60, 0 },
+	{ 0xd0da, 0x80, 0 },
+	{ 0xd0db, 0x06, 0 },
+	{ 0xd0dc, 0xa8, 0 },
+	{ 0xd0dd, 0x83, 0 },
+	{ 0xd0de, 0x38, 0 },
+	{ 0xd0df, 0x29, 0 },
+	{ 0xd0e0, 0xa8, 0 },
+	{ 0xd0e1, 0xe3, 0 },
+	{ 0xd0e2, 0x40, 0 },
+	{ 0xd0e3, 0x08, 0 },
+	{ 0xd0e4, 0x8c, 0 },
+	{ 0xd0e5, 0x84, 0 },
+	{ 0xd0e6, 0x00, 0 },
+	{ 0xd0e7, 0x00, 0 },
+	{ 0xd0e8, 0xa8, 0 },
+	{ 0xd0e9, 0xa3, 0 },
+	{ 0xd0ea, 0x40, 0 },
+	{ 0xd0eb, 0x09, 0 },
+	{ 0xd0ec, 0xa8, 0 },
+	{ 0xd0ed, 0xc3, 0 },
+	{ 0xd0ee, 0x38, 0 },
+	{ 0xd0ef, 0x2a, 0 },
+	{ 0xd0f0, 0xd8, 0 },
+	{ 0xd0f1, 0x07, 0 },
+	{ 0xd0f2, 0x20, 0 },
+	{ 0xd0f3, 0x00, 0 },
+	{ 0xd0f4, 0x8c, 0 },
+	{ 0xd0f5, 0x66, 0 },
+	{ 0xd0f6, 0x00, 0 },
+	{ 0xd0f7, 0x00, 0 },
+	{ 0xd0f8, 0xd8, 0 },
+	{ 0xd0f9, 0x05, 0 },
+	{ 0xd0fa, 0x18, 0 },
+	{ 0xd0fb, 0x00, 0 },
+	{ 0xd0fc, 0x18, 0 },
+	{ 0xd0fd, 0x60, 0 },
+	{ 0xd0fe, 0x00, 0 },
+	{ 0xd0ff, 0x01, 0 },
+	{ 0xd100, 0x98, 0 },
+	{ 0xd101, 0x90, 0 },
+	{ 0xd102, 0x00, 0 },
+	{ 0xd103, 0x00, 0 },
+	{ 0xd104, 0x84, 0 },
+	{ 0xd105, 0xae, 0 },
+	{ 0xd106, 0x00, 0 },
+	{ 0xd107, 0x00, 0 },
+	{ 0xd108, 0xa8, 0 },
+	{ 0xd109, 0x63, 0 },
+	{ 0xd10a, 0x06, 0 },
+	{ 0xd10b, 0x4c, 0 },
+	{ 0xd10c, 0x9c, 0 },
+	{ 0xd10d, 0xc0, 0 },
+	{ 0xd10e, 0x00, 0 },
+	{ 0xd10f, 0x00, 0 },
+	{ 0xd110, 0xd8, 0 },
+	{ 0xd111, 0x03, 0 },
+	{ 0xd112, 0x30, 0 },
+	{ 0xd113, 0x00, 0 },
+	{ 0xd114, 0x8c, 0 },
+	{ 0xd115, 0x65, 0 },
+	{ 0xd116, 0x00, 0 },
+	{ 0xd117, 0x6e, 0 },
+	{ 0xd118, 0xe5, 0 },
+	{ 0xd119, 0x84, 0 },
+	{ 0xd11a, 0x18, 0 },
+	{ 0xd11b, 0x00, 0 },
+	{ 0xd11c, 0x10, 0 },
+	{ 0xd11d, 0x00, 0 },
+	{ 0xd11e, 0x00, 0 },
+	{ 0xd11f, 0x07, 0 },
+	{ 0xd120, 0x18, 0 },
+	{ 0xd121, 0x80, 0 },
+	{ 0xd122, 0x80, 0 },
+	{ 0xd123, 0x06, 0 },
+	{ 0xd124, 0x94, 0 },
+	{ 0xd125, 0x65, 0 },
+	{ 0xd126, 0x00, 0 },
+	{ 0xd127, 0x70, 0 },
+	{ 0xd128, 0xe5, 0 },
+	{ 0xd129, 0x43, 0 },
+	{ 0xd12a, 0x60, 0 },
+	{ 0xd12b, 0x00, 0 },
+	{ 0xd12c, 0x0c, 0 },
+	{ 0xd12d, 0x00, 0 },
+	{ 0xd12e, 0x00, 0 },
+	{ 0xd12f, 0x3e, 0 },
+	{ 0xd130, 0xa8, 0 },
+	{ 0xd131, 0x64, 0 },
+	{ 0xd132, 0x38, 0 },
+	{ 0xd133, 0x24, 0 },
+	{ 0xd134, 0x18, 0 },
+	{ 0xd135, 0x80, 0 },
+	{ 0xd136, 0x80, 0 },
+	{ 0xd137, 0x06, 0 },
+	{ 0xd138, 0xa8, 0 },
+	{ 0xd139, 0x64, 0 },
+	{ 0xd13a, 0x38, 0 },
+	{ 0xd13b, 0x24, 0 },
+	{ 0xd13c, 0x8c, 0 },
+	{ 0xd13d, 0x63, 0 },
+	{ 0xd13e, 0x00, 0 },
+	{ 0xd13f, 0x00, 0 },
+	{ 0xd140, 0xa4, 0 },
+	{ 0xd141, 0x63, 0 },
+	{ 0xd142, 0x00, 0 },
+	{ 0xd143, 0x40, 0 },
+	{ 0xd144, 0xbc, 0 },
+	{ 0xd145, 0x23, 0 },
+	{ 0xd146, 0x00, 0 },
+	{ 0xd147, 0x00, 0 },
+	{ 0xd148, 0x0c, 0 },
+	{ 0xd149, 0x00, 0 },
+	{ 0xd14a, 0x00, 0 },
+	{ 0xd14b, 0x2a, 0 },
+	{ 0xd14c, 0xa8, 0 },
+	{ 0xd14d, 0x64, 0 },
+	{ 0xd14e, 0x6e, 0 },
+	{ 0xd14f, 0x44, 0 },
+	{ 0xd150, 0x19, 0 },
+	{ 0xd151, 0x00, 0 },
+	{ 0xd152, 0x80, 0 },
+	{ 0xd153, 0x06, 0 },
+	{ 0xd154, 0xa8, 0 },
+	{ 0xd155, 0xe8, 0 },
+	{ 0xd156, 0x3d, 0 },
+	{ 0xd157, 0x05, 0 },
+	{ 0xd158, 0x8c, 0 },
+	{ 0xd159, 0x67, 0 },
+	{ 0xd15a, 0x00, 0 },
+	{ 0xd15b, 0x00, 0 },
+	{ 0xd15c, 0xb8, 0 },
+	{ 0xd15d, 0x63, 0 },
+	{ 0xd15e, 0x00, 0 },
+	{ 0xd15f, 0x18, 0 },
+	{ 0xd160, 0xb8, 0 },
+	{ 0xd161, 0x63, 0 },
+	{ 0xd162, 0x00, 0 },
+	{ 0xd163, 0x98, 0 },
+	{ 0xd164, 0xbc, 0 },
+	{ 0xd165, 0x03, 0 },
+	{ 0xd166, 0x00, 0 },
+	{ 0xd167, 0x00, 0 },
+	{ 0xd168, 0x10, 0 },
+	{ 0xd169, 0x00, 0 },
+	{ 0xd16a, 0x00, 0 },
+	{ 0xd16b, 0x10, 0 },
+	{ 0xd16c, 0xa9, 0 },
+	{ 0xd16d, 0x48, 0 },
+	{ 0xd16e, 0x67, 0 },
+	{ 0xd16f, 0x02, 0 },
+	{ 0xd170, 0xb8, 0 },
+	{ 0xd171, 0xa3, 0 },
+	{ 0xd172, 0x00, 0 },
+	{ 0xd173, 0x19, 0 },
+	{ 0xd174, 0x8c, 0 },
+	{ 0xd175, 0x8a, 0 },
+	{ 0xd176, 0x00, 0 },
+	{ 0xd177, 0x00, 0 },
+	{ 0xd178, 0xa9, 0 },
+	{ 0xd179, 0x68, 0 },
+	{ 0xd17a, 0x67, 0 },
+	{ 0xd17b, 0x03, 0 },
+	{ 0xd17c, 0xb8, 0 },
+	{ 0xd17d, 0xc4, 0 },
+	{ 0xd17e, 0x00, 0 },
+	{ 0xd17f, 0x08, 0 },
+	{ 0xd180, 0x8c, 0 },
+	{ 0xd181, 0x6b, 0 },
+	{ 0xd182, 0x00, 0 },
+	{ 0xd183, 0x00, 0 },
+	{ 0xd184, 0xb8, 0 },
+	{ 0xd185, 0x85, 0 },
+	{ 0xd186, 0x00, 0 },
+	{ 0xd187, 0x98, 0 },
+	{ 0xd188, 0xe0, 0 },
+	{ 0xd189, 0x63, 0 },
+	{ 0xd18a, 0x30, 0 },
+	{ 0xd18b, 0x04, 0 },
+	{ 0xd18c, 0xe0, 0 },
+	{ 0xd18d, 0x64, 0 },
+	{ 0xd18e, 0x18, 0 },
+	{ 0xd18f, 0x00, 0 },
+	{ 0xd190, 0xa4, 0 },
+	{ 0xd191, 0x83, 0 },
+	{ 0xd192, 0xff, 0 },
+	{ 0xd193, 0xff, 0 },
+	{ 0xd194, 0xb8, 0 },
+	{ 0xd195, 0x64, 0 },
+	{ 0xd196, 0x00, 0 },
+	{ 0xd197, 0x48, 0 },
+	{ 0xd198, 0xd8, 0 },
+	{ 0xd199, 0x0a, 0 },
+	{ 0xd19a, 0x18, 0 },
+	{ 0xd19b, 0x00, 0 },
+	{ 0xd19c, 0xd8, 0 },
+	{ 0xd19d, 0x0b, 0 },
+	{ 0xd19e, 0x20, 0 },
+	{ 0xd19f, 0x00, 0 },
+	{ 0xd1a0, 0x9c, 0 },
+	{ 0xd1a1, 0x60, 0 },
+	{ 0xd1a2, 0x00, 0 },
+	{ 0xd1a3, 0x00, 0 },
+	{ 0xd1a4, 0xd8, 0 },
+	{ 0xd1a5, 0x07, 0 },
+	{ 0xd1a6, 0x18, 0 },
+	{ 0xd1a7, 0x00, 0 },
+	{ 0xd1a8, 0xa8, 0 },
+	{ 0xd1a9, 0x68, 0 },
+	{ 0xd1aa, 0x38, 0 },
+	{ 0xd1ab, 0x22, 0 },
+	{ 0xd1ac, 0x9c, 0 },
+	{ 0xd1ad, 0x80, 0 },
+	{ 0xd1ae, 0x00, 0 },
+	{ 0xd1af, 0x70, 0 },
+	{ 0xd1b0, 0xa8, 0 },
+	{ 0xd1b1, 0xe8, 0 },
+	{ 0xd1b2, 0x38, 0 },
+	{ 0xd1b3, 0x43, 0 },
+	{ 0xd1b4, 0xd8, 0 },
+	{ 0xd1b5, 0x03, 0 },
+	{ 0xd1b6, 0x20, 0 },
+	{ 0xd1b7, 0x00, 0 },
+	{ 0xd1b8, 0x9c, 0 },
+	{ 0xd1b9, 0xa0, 0 },
+	{ 0xd1ba, 0x00, 0 },
+	{ 0xd1bb, 0x00, 0 },
+	{ 0xd1bc, 0xa8, 0 },
+	{ 0xd1bd, 0xc8, 0 },
+	{ 0xd1be, 0x38, 0 },
+	{ 0xd1bf, 0x42, 0 },
+	{ 0xd1c0, 0x8c, 0 },
+	{ 0xd1c1, 0x66, 0 },
+	{ 0xd1c2, 0x00, 0 },
+	{ 0xd1c3, 0x00, 0 },
+	{ 0xd1c4, 0x9c, 0 },
+	{ 0xd1c5, 0xa5, 0 },
+	{ 0xd1c6, 0x00, 0 },
+	{ 0xd1c7, 0x01, 0 },
+	{ 0xd1c8, 0xb8, 0 },
+	{ 0xd1c9, 0x83, 0 },
+	{ 0xd1ca, 0x00, 0 },
+	{ 0xd1cb, 0x08, 0 },
+	{ 0xd1cc, 0xa4, 0 },
+	{ 0xd1cd, 0xa5, 0 },
+	{ 0xd1ce, 0x00, 0 },
+	{ 0xd1cf, 0xff, 0 },
+	{ 0xd1d0, 0x8c, 0 },
+	{ 0xd1d1, 0x67, 0 },
+	{ 0xd1d2, 0x00, 0 },
+	{ 0xd1d3, 0x00, 0 },
+	{ 0xd1d4, 0xe0, 0 },
+	{ 0xd1d5, 0x63, 0 },
+	{ 0xd1d6, 0x20, 0 },
+	{ 0xd1d7, 0x00, 0 },
+	{ 0xd1d8, 0xa4, 0 },
+	{ 0xd1d9, 0x63, 0 },
+	{ 0xd1da, 0xff, 0 },
+	{ 0xd1db, 0xff, 0 },
+	{ 0xd1dc, 0xbc, 0 },
+	{ 0xd1dd, 0x43, 0 },
+	{ 0xd1de, 0x00, 0 },
+	{ 0xd1df, 0x07, 0 },
+	{ 0xd1e0, 0x0c, 0 },
+	{ 0xd1e1, 0x00, 0 },
+	{ 0xd1e2, 0x00, 0 },
+	{ 0xd1e3, 0x5b, 0 },
+	{ 0xd1e4, 0xbc, 0 },
+	{ 0xd1e5, 0x05, 0 },
+	{ 0xd1e6, 0x00, 0 },
+	{ 0xd1e7, 0x02, 0 },
+	{ 0xd1e8, 0x03, 0 },
+	{ 0xd1e9, 0xff, 0 },
+	{ 0xd1ea, 0xff, 0 },
+	{ 0xd1eb, 0xf6, 0 },
+	{ 0xd1ec, 0x9c, 0 },
+	{ 0xd1ed, 0xa0, 0 },
+	{ 0xd1ee, 0x00, 0 },
+	{ 0xd1ef, 0x00, 0 },
+	{ 0xd1f0, 0xa8, 0 },
+	{ 0xd1f1, 0xa4, 0 },
+	{ 0xd1f2, 0x55, 0 },
+	{ 0xd1f3, 0x86, 0 },
+	{ 0xd1f4, 0x8c, 0 },
+	{ 0xd1f5, 0x63, 0 },
+	{ 0xd1f6, 0x00, 0 },
+	{ 0xd1f7, 0x00, 0 },
+	{ 0xd1f8, 0xa8, 0 },
+	{ 0xd1f9, 0xc4, 0 },
+	{ 0xd1fa, 0x6e, 0 },
+	{ 0xd1fb, 0x45, 0 },
+	{ 0xd1fc, 0xa8, 0 },
+	{ 0xd1fd, 0xe4, 0 },
+	{ 0xd1fe, 0x55, 0 },
+	{ 0xd1ff, 0x87, 0 },
+	{ 0xd200, 0xd8, 0 },
+	{ 0xd201, 0x05, 0 },
+	{ 0xd202, 0x18, 0 },
+	{ 0xd203, 0x00, 0 },
+	{ 0xd204, 0x8c, 0 },
+	{ 0xd205, 0x66, 0 },
+	{ 0xd206, 0x00, 0 },
+	{ 0xd207, 0x00, 0 },
+	{ 0xd208, 0xa8, 0 },
+	{ 0xd209, 0xa4, 0 },
+	{ 0xd20a, 0x6e, 0 },
+	{ 0xd20b, 0x46, 0 },
+	{ 0xd20c, 0xd8, 0 },
+	{ 0xd20d, 0x07, 0 },
+	{ 0xd20e, 0x18, 0 },
+	{ 0xd20f, 0x00, 0 },
+	{ 0xd210, 0xa8, 0 },
+	{ 0xd211, 0x84, 0 },
+	{ 0xd212, 0x55, 0 },
+	{ 0xd213, 0x88, 0 },
+	{ 0xd214, 0x8c, 0 },
+	{ 0xd215, 0x65, 0 },
+	{ 0xd216, 0x00, 0 },
+	{ 0xd217, 0x00, 0 },
+	{ 0xd218, 0xd8, 0 },
+	{ 0xd219, 0x04, 0 },
+	{ 0xd21a, 0x18, 0 },
+	{ 0xd21b, 0x00, 0 },
+	{ 0xd21c, 0x03, 0 },
+	{ 0xd21d, 0xff, 0 },
+	{ 0xd21e, 0xff, 0 },
+	{ 0xd21f, 0xce, 0 },
+	{ 0xd220, 0x19, 0 },
+	{ 0xd221, 0x00, 0 },
+	{ 0xd222, 0x80, 0 },
+	{ 0xd223, 0x06, 0 },
+	{ 0xd224, 0x8c, 0 },
+	{ 0xd225, 0x63, 0 },
+	{ 0xd226, 0x00, 0 },
+	{ 0xd227, 0x00, 0 },
+	{ 0xd228, 0xa4, 0 },
+	{ 0xd229, 0x63, 0 },
+	{ 0xd22a, 0x00, 0 },
+	{ 0xd22b, 0x40, 0 },
+	{ 0xd22c, 0xbc, 0 },
+	{ 0xd22d, 0x23, 0 },
+	{ 0xd22e, 0x00, 0 },
+	{ 0xd22f, 0x00, 0 },
+	{ 0xd230, 0x13, 0 },
+	{ 0xd231, 0xff, 0 },
+	{ 0xd232, 0xff, 0 },
+	{ 0xd233, 0xc8, 0 },
+	{ 0xd234, 0x9d, 0 },
+	{ 0xd235, 0x00, 0 },
+	{ 0xd236, 0x00, 0 },
+	{ 0xd237, 0x40, 0 },
+	{ 0xd238, 0xa8, 0 },
+	{ 0xd239, 0x64, 0 },
+	{ 0xd23a, 0x55, 0 },
+	{ 0xd23b, 0x86, 0 },
+	{ 0xd23c, 0xa8, 0 },
+	{ 0xd23d, 0xa4, 0 },
+	{ 0xd23e, 0x55, 0 },
+	{ 0xd23f, 0x87, 0 },
+	{ 0xd240, 0xd8, 0 },
+	{ 0xd241, 0x03, 0 },
+	{ 0xd242, 0x40, 0 },
+	{ 0xd243, 0x00, 0 },
+	{ 0xd244, 0xa8, 0 },
+	{ 0xd245, 0x64, 0 },
+	{ 0xd246, 0x55, 0 },
+	{ 0xd247, 0x88, 0 },
+	{ 0xd248, 0xd8, 0 },
+	{ 0xd249, 0x05, 0 },
+	{ 0xd24a, 0x40, 0 },
+	{ 0xd24b, 0x00, 0 },
+	{ 0xd24c, 0xd8, 0 },
+	{ 0xd24d, 0x03, 0 },
+	{ 0xd24e, 0x40, 0 },
+	{ 0xd24f, 0x00, 0 },
+	{ 0xd250, 0x03, 0 },
+	{ 0xd251, 0xff, 0 },
+	{ 0xd252, 0xff, 0 },
+	{ 0xd253, 0xc1, 0 },
+	{ 0xd254, 0x19, 0 },
+	{ 0xd255, 0x00, 0 },
+	{ 0xd256, 0x80, 0 },
+	{ 0xd257, 0x06, 0 },
+	{ 0xd258, 0x94, 0 },
+	{ 0xd259, 0x84, 0 },
+	{ 0xd25a, 0x00, 0 },
+	{ 0xd25b, 0x72, 0 },
+	{ 0xd25c, 0xe5, 0 },
+	{ 0xd25d, 0xa4, 0 },
+	{ 0xd25e, 0x60, 0 },
+	{ 0xd25f, 0x00, 0 },
+	{ 0xd260, 0x0c, 0 },
+	{ 0xd261, 0x00, 0 },
+	{ 0xd262, 0x00, 0 },
+	{ 0xd263, 0x3f, 0 },
+	{ 0xd264, 0x9d, 0 },
+	{ 0xd265, 0x60, 0 },
+	{ 0xd266, 0x01, 0 },
+	{ 0xd267, 0x00, 0 },
+	{ 0xd268, 0x85, 0 },
+	{ 0xd269, 0x4e, 0 },
+	{ 0xd26a, 0x00, 0 },
+	{ 0xd26b, 0x00, 0 },
+	{ 0xd26c, 0x98, 0 },
+	{ 0xd26d, 0x70, 0 },
+	{ 0xd26e, 0x00, 0 },
+	{ 0xd26f, 0x00, 0 },
+	{ 0xd270, 0x8c, 0 },
+	{ 0xd271, 0x8a, 0 },
+	{ 0xd272, 0x00, 0 },
+	{ 0xd273, 0x6f, 0 },
+	{ 0xd274, 0xe5, 0 },
+	{ 0xd275, 0x63, 0 },
+	{ 0xd276, 0x20, 0 },
+	{ 0xd277, 0x00, 0 },
+	{ 0xd278, 0x10, 0 },
+	{ 0xd279, 0x00, 0 },
+	{ 0xd27a, 0x00, 0 },
+	{ 0xd27b, 0x07, 0 },
+	{ 0xd27c, 0x15, 0 },
+	{ 0xd27d, 0x00, 0 },
+	{ 0xd27e, 0x00, 0 },
+	{ 0xd27f, 0x00, 0 },
+	{ 0xd280, 0x8c, 0 },
+	{ 0xd281, 0xaa, 0 },
+	{ 0xd282, 0x00, 0 },
+	{ 0xd283, 0x6e, 0 },
+	{ 0xd284, 0xe0, 0 },
+	{ 0xd285, 0x63, 0 },
+	{ 0xd286, 0x28, 0 },
+	{ 0xd287, 0x02, 0 },
+	{ 0xd288, 0xe0, 0 },
+	{ 0xd289, 0x84, 0 },
+	{ 0xd28a, 0x28, 0 },
+	{ 0xd28b, 0x02, 0 },
+	{ 0xd28c, 0x07, 0 },
+	{ 0xd28d, 0xff, 0 },
+	{ 0xd28e, 0xf8, 0 },
+	{ 0xd28f, 0x66, 0 },
+	{ 0xd290, 0xe0, 0 },
+	{ 0xd291, 0x63, 0 },
+	{ 0xd292, 0x5b, 0 },
+	{ 0xd293, 0x06, 0 },
+	{ 0xd294, 0x8c, 0 },
+	{ 0xd295, 0x6a, 0 },
+	{ 0xd296, 0x00, 0 },
+	{ 0xd297, 0x77, 0 },
+	{ 0xd298, 0xe0, 0 },
+	{ 0xd299, 0x63, 0 },
+	{ 0xd29a, 0x5b, 0 },
+	{ 0xd29b, 0x06, 0 },
+	{ 0xd29c, 0xbd, 0 },
+	{ 0xd29d, 0x63, 0 },
+	{ 0xd29e, 0x00, 0 },
+	{ 0xd29f, 0x00, 0 },
+	{ 0xd2a0, 0x0c, 0 },
+	{ 0xd2a1, 0x00, 0 },
+	{ 0xd2a2, 0x00, 0 },
+	{ 0xd2a3, 0x3c, 0 },
+	{ 0xd2a4, 0x15, 0 },
+	{ 0xd2a5, 0x00, 0 },
+	{ 0xd2a6, 0x00, 0 },
+	{ 0xd2a7, 0x00, 0 },
+	{ 0xd2a8, 0x8c, 0 },
+	{ 0xd2a9, 0x8a, 0 },
+	{ 0xd2aa, 0x00, 0 },
+	{ 0xd2ab, 0x78, 0 },
+	{ 0xd2ac, 0xb8, 0 },
+	{ 0xd2ad, 0x63, 0 },
+	{ 0xd2ae, 0x00, 0 },
+	{ 0xd2af, 0x88, 0 },
+	{ 0xd2b0, 0xe1, 0 },
+	{ 0xd2b1, 0x64, 0 },
+	{ 0xd2b2, 0x5b, 0 },
+	{ 0xd2b3, 0x06, 0 },
+	{ 0xd2b4, 0xbd, 0 },
+	{ 0xd2b5, 0x6b, 0 },
+	{ 0xd2b6, 0x00, 0 },
+	{ 0xd2b7, 0x00, 0 },
+	{ 0xd2b8, 0x0c, 0 },
+	{ 0xd2b9, 0x00, 0 },
+	{ 0xd2ba, 0x00, 0 },
+	{ 0xd2bb, 0x34, 0 },
+	{ 0xd2bc, 0xd4, 0 },
+	{ 0xd2bd, 0x01, 0 },
+	{ 0xd2be, 0x18, 0 },
+	{ 0xd2bf, 0x14, 0 },
+	{ 0xd2c0, 0xb9, 0 },
+	{ 0xd2c1, 0x6b, 0 },
+	{ 0xd2c2, 0x00, 0 },
+	{ 0xd2c3, 0x88, 0 },
+	{ 0xd2c4, 0x85, 0 },
+	{ 0xd2c5, 0x01, 0 },
+	{ 0xd2c6, 0x00, 0 },
+	{ 0xd2c7, 0x14, 0 },
+	{ 0xd2c8, 0xbd, 0 },
+	{ 0xd2c9, 0x68, 0 },
+	{ 0xd2ca, 0x00, 0 },
+	{ 0xd2cb, 0x00, 0 },
+	{ 0xd2cc, 0x0c, 0 },
+	{ 0xd2cd, 0x00, 0 },
+	{ 0xd2ce, 0x00, 0 },
+	{ 0xd2cf, 0x2c, 0 },
+	{ 0xd2d0, 0xd4, 0 },
+	{ 0xd2d1, 0x01, 0 },
+	{ 0xd2d2, 0x58, 0 },
+	{ 0xd2d3, 0x18, 0 },
+	{ 0xd2d4, 0x84, 0 },
+	{ 0xd2d5, 0x81, 0 },
+	{ 0xd2d6, 0x00, 0 },
+	{ 0xd2d7, 0x14, 0 },
+	{ 0xd2d8, 0xbd, 0 },
+	{ 0xd2d9, 0xa4, 0 },
+	{ 0xd2da, 0x01, 0 },
+	{ 0xd2db, 0x00, 0 },
+	{ 0xd2dc, 0x10, 0 },
+	{ 0xd2dd, 0x00, 0 },
+	{ 0xd2de, 0x00, 0 },
+	{ 0xd2df, 0x05, 0 },
+	{ 0xd2e0, 0x84, 0 },
+	{ 0xd2e1, 0xc1, 0 },
+	{ 0xd2e2, 0x00, 0 },
+	{ 0xd2e3, 0x18, 0 },
+	{ 0xd2e4, 0x9c, 0 },
+	{ 0xd2e5, 0xa0, 0 },
+	{ 0xd2e6, 0x01, 0 },
+	{ 0xd2e7, 0x00, 0 },
+	{ 0xd2e8, 0xd4, 0 },
+	{ 0xd2e9, 0x01, 0 },
+	{ 0xd2ea, 0x28, 0 },
+	{ 0xd2eb, 0x14, 0 },
+	{ 0xd2ec, 0x84, 0 },
+	{ 0xd2ed, 0xc1, 0 },
+	{ 0xd2ee, 0x00, 0 },
+	{ 0xd2ef, 0x18, 0 },
+	{ 0xd2f0, 0xbd, 0 },
+	{ 0xd2f1, 0x66, 0 },
+	{ 0xd2f2, 0x00, 0 },
+	{ 0xd2f3, 0x00, 0 },
+	{ 0xd2f4, 0x0c, 0 },
+	{ 0xd2f5, 0x00, 0 },
+	{ 0xd2f6, 0x00, 0 },
+	{ 0xd2f7, 0x20, 0 },
+	{ 0xd2f8, 0x9d, 0 },
+	{ 0xd2f9, 0x00, 0 },
+	{ 0xd2fa, 0x00, 0 },
+	{ 0xd2fb, 0x00, 0 },
+	{ 0xd2fc, 0x84, 0 },
+	{ 0xd2fd, 0x61, 0 },
+	{ 0xd2fe, 0x00, 0 },
+	{ 0xd2ff, 0x18, 0 },
+	{ 0xd300, 0xbd, 0 },
+	{ 0xd301, 0xa3, 0 },
+	{ 0xd302, 0x01, 0 },
+	{ 0xd303, 0x00, 0 },
+	{ 0xd304, 0x10, 0 },
+	{ 0xd305, 0x00, 0 },
+	{ 0xd306, 0x00, 0 },
+	{ 0xd307, 0x03, 0 },
+	{ 0xd308, 0x9c, 0 },
+	{ 0xd309, 0x80, 0 },
+	{ 0xd30a, 0x01, 0 },
+	{ 0xd30b, 0x00, 0 },
+	{ 0xd30c, 0xd4, 0 },
+	{ 0xd30d, 0x01, 0 },
+	{ 0xd30e, 0x20, 0 },
+	{ 0xd30f, 0x18, 0 },
+	{ 0xd310, 0x18, 0 },
+	{ 0xd311, 0x60, 0 },
+	{ 0xd312, 0x80, 0 },
+	{ 0xd313, 0x06, 0 },
+	{ 0xd314, 0x85, 0 },
+	{ 0xd315, 0x01, 0 },
+	{ 0xd316, 0x00, 0 },
+	{ 0xd317, 0x14, 0 },
+	{ 0xd318, 0xa8, 0 },
+	{ 0xd319, 0x83, 0 },
+	{ 0xd31a, 0x38, 0 },
+	{ 0xd31b, 0x29, 0 },
+	{ 0xd31c, 0xa8, 0 },
+	{ 0xd31d, 0xc3, 0 },
+	{ 0xd31e, 0x40, 0 },
+	{ 0xd31f, 0x08, 0 },
+	{ 0xd320, 0x8c, 0 },
+	{ 0xd321, 0x84, 0 },
+	{ 0xd322, 0x00, 0 },
+	{ 0xd323, 0x00, 0 },
+	{ 0xd324, 0xa8, 0 },
+	{ 0xd325, 0xa3, 0 },
+	{ 0xd326, 0x38, 0 },
+	{ 0xd327, 0x2a, 0 },
+	{ 0xd328, 0xa8, 0 },
+	{ 0xd329, 0xe3, 0 },
+	{ 0xd32a, 0x40, 0 },
+	{ 0xd32b, 0x09, 0 },
+	{ 0xd32c, 0xe0, 0 },
+	{ 0xd32d, 0x64, 0 },
+	{ 0xd32e, 0x40, 0 },
+	{ 0xd32f, 0x00, 0 },
+	{ 0xd330, 0xd8, 0 },
+	{ 0xd331, 0x06, 0 },
+	{ 0xd332, 0x18, 0 },
+	{ 0xd333, 0x00, 0 },
+	{ 0xd334, 0x8c, 0 },
+	{ 0xd335, 0x65, 0 },
+	{ 0xd336, 0x00, 0 },
+	{ 0xd337, 0x00, 0 },
+	{ 0xd338, 0x84, 0 },
+	{ 0xd339, 0x81, 0 },
+	{ 0xd33a, 0x00, 0 },
+	{ 0xd33b, 0x18, 0 },
+	{ 0xd33c, 0xe3, 0 },
+	{ 0xd33d, 0xe3, 0 },
+	{ 0xd33e, 0x20, 0 },
+	{ 0xd33f, 0x00, 0 },
+	{ 0xd340, 0xd8, 0 },
+	{ 0xd341, 0x07, 0 },
+	{ 0xd342, 0xf8, 0 },
+	{ 0xd343, 0x00, 0 },
+	{ 0xd344, 0x03, 0 },
+	{ 0xd345, 0xff, 0 },
+	{ 0xd346, 0xff, 0 },
+	{ 0xd347, 0x6f, 0 },
+	{ 0xd348, 0x18, 0 },
+	{ 0xd349, 0x60, 0 },
+	{ 0xd34a, 0x00, 0 },
+	{ 0xd34b, 0x01, 0 },
+	{ 0xd34c, 0x0f, 0 },
+	{ 0xd34d, 0xff, 0 },
+	{ 0xd34e, 0xff, 0 },
+	{ 0xd34f, 0x9d, 0 },
+	{ 0xd350, 0x18, 0 },
+	{ 0xd351, 0x60, 0 },
+	{ 0xd352, 0x80, 0 },
+	{ 0xd353, 0x06, 0 },
+	{ 0xd354, 0x00, 0 },
+	{ 0xd355, 0x00, 0 },
+	{ 0xd356, 0x00, 0 },
+	{ 0xd357, 0x11, 0 },
+	{ 0xd358, 0xa8, 0 },
+	{ 0xd359, 0x83, 0 },
+	{ 0xd35a, 0x6e, 0 },
+	{ 0xd35b, 0x43, 0 },
+	{ 0xd35c, 0xe0, 0 },
+	{ 0xd35d, 0x6c, 0 },
+	{ 0xd35e, 0x28, 0 },
+	{ 0xd35f, 0x02, 0 },
+	{ 0xd360, 0xe0, 0 },
+	{ 0xd361, 0x84, 0 },
+	{ 0xd362, 0x28, 0 },
+	{ 0xd363, 0x02, 0 },
+	{ 0xd364, 0x07, 0 },
+	{ 0xd365, 0xff, 0 },
+	{ 0xd366, 0xf8, 0 },
+	{ 0xd367, 0x30, 0 },
+	{ 0xd368, 0xb8, 0 },
+	{ 0xd369, 0x63, 0 },
+	{ 0xd36a, 0x00, 0 },
+	{ 0xd36b, 0x08, 0 },
+	{ 0xd36c, 0x03, 0 },
+	{ 0xd36d, 0xff, 0 },
+	{ 0xd36e, 0xff, 0 },
+	{ 0xd36f, 0xc0, 0 },
+	{ 0xd370, 0x85, 0 },
+	{ 0xd371, 0x4e, 0 },
+	{ 0xd372, 0x00, 0 },
+	{ 0xd373, 0x00, 0 },
+	{ 0xd374, 0x03, 0 },
+	{ 0xd375, 0xff, 0 },
+	{ 0xd376, 0xff, 0 },
+	{ 0xd377, 0xe7, 0 },
+	{ 0xd378, 0xd4, 0 },
+	{ 0xd379, 0x01, 0 },
+	{ 0xd37a, 0x40, 0 },
+	{ 0xd37b, 0x18, 0 },
+	{ 0xd37c, 0x9c, 0 },
+	{ 0xd37d, 0x60, 0 },
+	{ 0xd37e, 0x00, 0 },
+	{ 0xd37f, 0x00, 0 },
+	{ 0xd380, 0x03, 0 },
+	{ 0xd381, 0xff, 0 },
+	{ 0xd382, 0xff, 0 },
+	{ 0xd383, 0xdb, 0 },
+	{ 0xd384, 0xd4, 0 },
+	{ 0xd385, 0x01, 0 },
+	{ 0xd386, 0x18, 0 },
+	{ 0xd387, 0x14, 0 },
+	{ 0xd388, 0x03, 0 },
+	{ 0xd389, 0xff, 0 },
+	{ 0xd38a, 0xff, 0 },
+	{ 0xd38b, 0xce, 0 },
+	{ 0xd38c, 0x9d, 0 },
+	{ 0xd38d, 0x6b, 0 },
+	{ 0xd38e, 0x00, 0 },
+	{ 0xd38f, 0xff, 0 },
+	{ 0xd390, 0x03, 0 },
+	{ 0xd391, 0xff, 0 },
+	{ 0xd392, 0xff, 0 },
+	{ 0xd393, 0xc6, 0 },
+	{ 0xd394, 0x9c, 0 },
+	{ 0xd395, 0x63, 0 },
+	{ 0xd396, 0x00, 0 },
+	{ 0xd397, 0xff, 0 },
+	{ 0xd398, 0xa8, 0 },
+	{ 0xd399, 0xe3, 0 },
+	{ 0xd39a, 0x38, 0 },
+	{ 0xd39b, 0x0f, 0 },
+	{ 0xd39c, 0x8c, 0 },
+	{ 0xd39d, 0x84, 0 },
+	{ 0xd39e, 0x00, 0 },
+	{ 0xd39f, 0x00, 0 },
+	{ 0xd3a0, 0xa8, 0 },
+	{ 0xd3a1, 0xa3, 0 },
+	{ 0xd3a2, 0x38, 0 },
+	{ 0xd3a3, 0x0e, 0 },
+	{ 0xd3a4, 0xa8, 0 },
+	{ 0xd3a5, 0xc3, 0 },
+	{ 0xd3a6, 0x6e, 0 },
+	{ 0xd3a7, 0x42, 0 },
+	{ 0xd3a8, 0xd8, 0 },
+	{ 0xd3a9, 0x07, 0 },
+	{ 0xd3aa, 0x20, 0 },
+	{ 0xd3ab, 0x00, 0 },
+	{ 0xd3ac, 0x8c, 0 },
+	{ 0xd3ad, 0x66, 0 },
+	{ 0xd3ae, 0x00, 0 },
+	{ 0xd3af, 0x00, 0 },
+	{ 0xd3b0, 0xd8, 0 },
+	{ 0xd3b1, 0x05, 0 },
+	{ 0xd3b2, 0x18, 0 },
+	{ 0xd3b3, 0x00, 0 },
+	{ 0xd3b4, 0x85, 0 },
+	{ 0xd3b5, 0x21, 0 },
+	{ 0xd3b6, 0x00, 0 },
+	{ 0xd3b7, 0x00, 0 },
+	{ 0xd3b8, 0x85, 0 },
+	{ 0xd3b9, 0x41, 0 },
+	{ 0xd3ba, 0x00, 0 },
+	{ 0xd3bb, 0x04, 0 },
+	{ 0xd3bc, 0x85, 0 },
+	{ 0xd3bd, 0x81, 0 },
+	{ 0xd3be, 0x00, 0 },
+	{ 0xd3bf, 0x08, 0 },
+	{ 0xd3c0, 0x85, 0 },
+	{ 0xd3c1, 0xc1, 0 },
+	{ 0xd3c2, 0x00, 0 },
+	{ 0xd3c3, 0x0c, 0 },
+	{ 0xd3c4, 0x86, 0 },
+	{ 0xd3c5, 0x01, 0 },
+	{ 0xd3c6, 0x00, 0 },
+	{ 0xd3c7, 0x10, 0 },
+	{ 0xd3c8, 0x44, 0 },
+	{ 0xd3c9, 0x00, 0 },
+	{ 0xd3ca, 0x48, 0 },
+	{ 0xd3cb, 0x00, 0 },
+	{ 0xd3cc, 0x9c, 0 },
+	{ 0xd3cd, 0x21, 0 },
+	{ 0xd3ce, 0x00, 0 },
+	{ 0xd3cf, 0x1c, 0 },
+	{ 0xd3d0, 0x9c, 0 },
+	{ 0xd3d1, 0x21, 0 },
+	{ 0xd3d2, 0xff, 0 },
+	{ 0xd3d3, 0xfc, 0 },
+	{ 0xd3d4, 0xd4, 0 },
+	{ 0xd3d5, 0x01, 0 },
+	{ 0xd3d6, 0x48, 0 },
+	{ 0xd3d7, 0x00, 0 },
+	{ 0xd3d8, 0x18, 0 },
+	{ 0xd3d9, 0x60, 0 },
+	{ 0xd3da, 0x00, 0 },
+	{ 0xd3db, 0x01, 0 },
+	{ 0xd3dc, 0xa8, 0 },
+	{ 0xd3dd, 0x63, 0 },
+	{ 0xd3de, 0x07, 0 },
+	{ 0xd3df, 0x80, 0 },
+	{ 0xd3e0, 0x8c, 0 },
+	{ 0xd3e1, 0x63, 0 },
+	{ 0xd3e2, 0x00, 0 },
+	{ 0xd3e3, 0x68, 0 },
+	{ 0xd3e4, 0xbc, 0 },
+	{ 0xd3e5, 0x03, 0 },
+	{ 0xd3e6, 0x00, 0 },
+	{ 0xd3e7, 0x00, 0 },
+	{ 0xd3e8, 0x10, 0 },
+	{ 0xd3e9, 0x00, 0 },
+	{ 0xd3ea, 0x00, 0 },
+	{ 0xd3eb, 0x0c, 0 },
+	{ 0xd3ec, 0x15, 0 },
+	{ 0xd3ed, 0x00, 0 },
+	{ 0xd3ee, 0x00, 0 },
+	{ 0xd3ef, 0x00, 0 },
+	{ 0xd3f0, 0x07, 0 },
+	{ 0xd3f1, 0xff, 0 },
+	{ 0xd3f2, 0xd9, 0 },
+	{ 0xd3f3, 0x98, 0 },
+	{ 0xd3f4, 0x15, 0 },
+	{ 0xd3f5, 0x00, 0 },
+	{ 0xd3f6, 0x00, 0 },
+	{ 0xd3f7, 0x00, 0 },
+	{ 0xd3f8, 0x18, 0 },
+	{ 0xd3f9, 0x60, 0 },
+	{ 0xd3fa, 0x80, 0 },
+	{ 0xd3fb, 0x06, 0 },
+	{ 0xd3fc, 0xa8, 0 },
+	{ 0xd3fd, 0x63, 0 },
+	{ 0xd3fe, 0xc4, 0 },
+	{ 0xd3ff, 0xb8, 0 },
+	{ 0xd400, 0x8c, 0 },
+	{ 0xd401, 0x63, 0 },
+	{ 0xd402, 0x00, 0 },
+	{ 0xd403, 0x00, 0 },
+	{ 0xd404, 0xbc, 0 },
+	{ 0xd405, 0x23, 0 },
+	{ 0xd406, 0x00, 0 },
+	{ 0xd407, 0x01, 0 },
+	{ 0xd408, 0x10, 0 },
+	{ 0xd409, 0x00, 0 },
+	{ 0xd40a, 0x00, 0 },
+	{ 0xd40b, 0x25, 0 },
+	{ 0xd40c, 0x9d, 0 },
+	{ 0xd40d, 0x00, 0 },
+	{ 0xd40e, 0x00, 0 },
+	{ 0xd40f, 0x00, 0 },
+	{ 0xd410, 0x00, 0 },
+	{ 0xd411, 0x00, 0 },
+	{ 0xd412, 0x00, 0 },
+	{ 0xd413, 0x0b, 0 },
+	{ 0xd414, 0xb8, 0 },
+	{ 0xd415, 0xe8, 0 },
+	{ 0xd416, 0x00, 0 },
+	{ 0xd417, 0x02, 0 },
+	{ 0xd418, 0x07, 0 },
+	{ 0xd419, 0xff, 0 },
+	{ 0xd41a, 0xd6, 0 },
+	{ 0xd41b, 0x24, 0 },
+	{ 0xd41c, 0x15, 0 },
+	{ 0xd41d, 0x00, 0 },
+	{ 0xd41e, 0x00, 0 },
+	{ 0xd41f, 0x00, 0 },
+	{ 0xd420, 0x18, 0 },
+	{ 0xd421, 0x60, 0 },
+	{ 0xd422, 0x80, 0 },
+	{ 0xd423, 0x06, 0 },
+	{ 0xd424, 0xa8, 0 },
+	{ 0xd425, 0x63, 0 },
+	{ 0xd426, 0xc4, 0 },
+	{ 0xd427, 0xb8, 0 },
+	{ 0xd428, 0x8c, 0 },
+	{ 0xd429, 0x63, 0 },
+	{ 0xd42a, 0x00, 0 },
+	{ 0xd42b, 0x00, 0 },
+	{ 0xd42c, 0xbc, 0 },
+	{ 0xd42d, 0x23, 0 },
+	{ 0xd42e, 0x00, 0 },
+	{ 0xd42f, 0x01, 0 },
+	{ 0xd430, 0x10, 0 },
+	{ 0xd431, 0x00, 0 },
+	{ 0xd432, 0x00, 0 },
+	{ 0xd433, 0x1b, 0 },
+	{ 0xd434, 0x9d, 0 },
+	{ 0xd435, 0x00, 0 },
+	{ 0xd436, 0x00, 0 },
+	{ 0xd437, 0x00, 0 },
+	{ 0xd438, 0xb8, 0 },
+	{ 0xd439, 0xe8, 0 },
+	{ 0xd43a, 0x00, 0 },
+	{ 0xd43b, 0x02, 0 },
+	{ 0xd43c, 0x9c, 0 },
+	{ 0xd43d, 0xc0, 0 },
+	{ 0xd43e, 0x00, 0 },
+	{ 0xd43f, 0x00, 0 },
+	{ 0xd440, 0x18, 0 },
+	{ 0xd441, 0xa0, 0 },
+	{ 0xd442, 0x80, 0 },
+	{ 0xd443, 0x06, 0 },
+	{ 0xd444, 0xe0, 0 },
+	{ 0xd445, 0x67, 0 },
+	{ 0xd446, 0x30, 0 },
+	{ 0xd447, 0x00, 0 },
+	{ 0xd448, 0xa8, 0 },
+	{ 0xd449, 0xa5, 0 },
+	{ 0xd44a, 0xce, 0 },
+	{ 0xd44b, 0xb0, 0 },
+	{ 0xd44c, 0x19, 0 },
+	{ 0xd44d, 0x60, 0 },
+	{ 0xd44e, 0x00, 0 },
+	{ 0xd44f, 0x01, 0 },
+	{ 0xd450, 0xa9, 0 },
+	{ 0xd451, 0x6b, 0 },
+	{ 0xd452, 0x06, 0 },
+	{ 0xd453, 0x14, 0 },
+	{ 0xd454, 0xe0, 0 },
+	{ 0xd455, 0x83, 0 },
+	{ 0xd456, 0x28, 0 },
+	{ 0xd457, 0x00, 0 },
+	{ 0xd458, 0x9c, 0 },
+	{ 0xd459, 0xc6, 0 },
+	{ 0xd45a, 0x00, 0 },
+	{ 0xd45b, 0x01, 0 },
+	{ 0xd45c, 0xe0, 0 },
+	{ 0xd45d, 0x63, 0 },
+	{ 0xd45e, 0x18, 0 },
+	{ 0xd45f, 0x00, 0 },
+	{ 0xd460, 0x8c, 0 },
+	{ 0xd461, 0x84, 0 },
+	{ 0xd462, 0x00, 0 },
+	{ 0xd463, 0x00, 0 },
+	{ 0xd464, 0xe0, 0 },
+	{ 0xd465, 0xa3, 0 },
+	{ 0xd466, 0x58, 0 },
+	{ 0xd467, 0x00, 0 },
+	{ 0xd468, 0xa4, 0 },
+	{ 0xd469, 0xc6, 0 },
+	{ 0xd46a, 0x00, 0 },
+	{ 0xd46b, 0xff, 0 },
+	{ 0xd46c, 0xb8, 0 },
+	{ 0xd46d, 0x64, 0 },
+	{ 0xd46e, 0x00, 0 },
+	{ 0xd46f, 0x18, 0 },
+	{ 0xd470, 0xbc, 0 },
+	{ 0xd471, 0x46, 0 },
+	{ 0xd472, 0x00, 0 },
+	{ 0xd473, 0x03, 0 },
+	{ 0xd474, 0x94, 0 },
+	{ 0xd475, 0x85, 0 },
+	{ 0xd476, 0x00, 0 },
+	{ 0xd477, 0x00, 0 },
+	{ 0xd478, 0xb8, 0 },
+	{ 0xd479, 0x63, 0 },
+	{ 0xd47a, 0x00, 0 },
+	{ 0xd47b, 0x98, 0 },
+	{ 0xd47c, 0xe0, 0 },
+	{ 0xd47d, 0x64, 0 },
+	{ 0xd47e, 0x18, 0 },
+	{ 0xd47f, 0x00, 0 },
+	{ 0xd480, 0x0f, 0 },
+	{ 0xd481, 0xff, 0 },
+	{ 0xd482, 0xff, 0 },
+	{ 0xd483, 0xf0, 0 },
+	{ 0xd484, 0xdc, 0 },
+	{ 0xd485, 0x05, 0 },
+	{ 0xd486, 0x18, 0 },
+	{ 0xd487, 0x00, 0 },
+	{ 0xd488, 0x9c, 0 },
+	{ 0xd489, 0x68, 0 },
+	{ 0xd48a, 0x00, 0 },
+	{ 0xd48b, 0x01, 0 },
+	{ 0xd48c, 0xa5, 0 },
+	{ 0xd48d, 0x03, 0 },
+	{ 0xd48e, 0x00, 0 },
+	{ 0xd48f, 0xff, 0 },
+	{ 0xd490, 0xbc, 0 },
+	{ 0xd491, 0x48, 0 },
+	{ 0xd492, 0x00, 0 },
+	{ 0xd493, 0x01, 0 },
+	{ 0xd494, 0x0f, 0 },
+	{ 0xd495, 0xff, 0 },
+	{ 0xd496, 0xff, 0 },
+	{ 0xd497, 0xea, 0 },
+	{ 0xd498, 0xb8, 0 },
+	{ 0xd499, 0xe8, 0 },
+	{ 0xd49a, 0x00, 0 },
+	{ 0xd49b, 0x02, 0 },
+	{ 0xd49c, 0x18, 0 },
+	{ 0xd49d, 0x60, 0 },
+	{ 0xd49e, 0x00, 0 },
+	{ 0xd49f, 0x01, 0 },
+	{ 0xd4a0, 0xa8, 0 },
+	{ 0xd4a1, 0x63, 0 },
+	{ 0xd4a2, 0x06, 0 },
+	{ 0xd4a3, 0x14, 0 },
+	{ 0xd4a4, 0x07, 0 },
+	{ 0xd4a5, 0xff, 0 },
+	{ 0xd4a6, 0xe4, 0 },
+	{ 0xd4a7, 0x05, 0 },
+	{ 0xd4a8, 0x9c, 0 },
+	{ 0xd4a9, 0x83, 0 },
+	{ 0xd4aa, 0x00, 0 },
+	{ 0xd4ab, 0x10, 0 },
+	{ 0xd4ac, 0x85, 0 },
+	{ 0xd4ad, 0x21, 0 },
+	{ 0xd4ae, 0x00, 0 },
+	{ 0xd4af, 0x00, 0 },
+	{ 0xd4b0, 0x44, 0 },
+	{ 0xd4b1, 0x00, 0 },
+	{ 0xd4b2, 0x48, 0 },
+	{ 0xd4b3, 0x00, 0 },
+	{ 0xd4b4, 0x9c, 0 },
+	{ 0xd4b5, 0x21, 0 },
+	{ 0xd4b6, 0x00, 0 },
+	{ 0xd4b7, 0x04, 0 },
+	{ 0xd4b8, 0x18, 0 },
+	{ 0xd4b9, 0x60, 0 },
+	{ 0xd4ba, 0x00, 0 },
+	{ 0xd4bb, 0x01, 0 },
+	{ 0xd4bc, 0x9c, 0 },
+	{ 0xd4bd, 0x80, 0 },
+	{ 0xd4be, 0xff, 0 },
+	{ 0xd4bf, 0xff, 0 },
+	{ 0xd4c0, 0xa8, 0 },
+	{ 0xd4c1, 0x63, 0 },
+	{ 0xd4c2, 0x09, 0 },
+	{ 0xd4c3, 0xef, 0 },
+	{ 0xd4c4, 0xd8, 0 },
+	{ 0xd4c5, 0x03, 0 },
+	{ 0xd4c6, 0x20, 0 },
+	{ 0xd4c7, 0x00, 0 },
+	{ 0xd4c8, 0x18, 0 },
+	{ 0xd4c9, 0x60, 0 },
+	{ 0xd4ca, 0x80, 0 },
+	{ 0xd4cb, 0x06, 0 },
+	{ 0xd4cc, 0xa8, 0 },
+	{ 0xd4cd, 0x63, 0 },
+	{ 0xd4ce, 0xc9, 0 },
+	{ 0xd4cf, 0xef, 0 },
+	{ 0xd4d0, 0xd8, 0 },
+	{ 0xd4d1, 0x03, 0 },
+	{ 0xd4d2, 0x20, 0 },
+	{ 0xd4d3, 0x00, 0 },
+	{ 0xd4d4, 0x44, 0 },
+	{ 0xd4d5, 0x00, 0 },
+	{ 0xd4d6, 0x48, 0 },
+	{ 0xd4d7, 0x00, 0 },
+	{ 0xd4d8, 0x15, 0 },
+	{ 0xd4d9, 0x00, 0 },
+	{ 0xd4da, 0x00, 0 },
+	{ 0xd4db, 0x00, 0 },
+	{ 0xd4dc, 0x18, 0 },
+	{ 0xd4dd, 0x80, 0 },
+	{ 0xd4de, 0x00, 0 },
+	{ 0xd4df, 0x01, 0 },
+	{ 0xd4e0, 0xa8, 0 },
+	{ 0xd4e1, 0x84, 0 },
+	{ 0xd4e2, 0x0a, 0 },
+	{ 0xd4e3, 0x12, 0 },
+	{ 0xd4e4, 0x8c, 0 },
+	{ 0xd4e5, 0x64, 0 },
+	{ 0xd4e6, 0x00, 0 },
+	{ 0xd4e7, 0x00, 0 },
+	{ 0xd4e8, 0xbc, 0 },
+	{ 0xd4e9, 0x03, 0 },
+	{ 0xd4ea, 0x00, 0 },
+	{ 0xd4eb, 0x00, 0 },
+	{ 0xd4ec, 0x13, 0 },
+	{ 0xd4ed, 0xff, 0 },
+	{ 0xd4ee, 0xff, 0 },
+	{ 0xd4ef, 0xfe, 0 },
+	{ 0xd4f0, 0x15, 0 },
+	{ 0xd4f1, 0x00, 0 },
+	{ 0xd4f2, 0x00, 0 },
+	{ 0xd4f3, 0x00, 0 },
+	{ 0xd4f4, 0x44, 0 },
+	{ 0xd4f5, 0x00, 0 },
+	{ 0xd4f6, 0x48, 0 },
+	{ 0xd4f7, 0x00, 0 },
+	{ 0xd4f8, 0x15, 0 },
+	{ 0xd4f9, 0x00, 0 },
+	{ 0xd4fa, 0x00, 0 },
+	{ 0xd4fb, 0x00, 0 },
+	{ 0xd4fc, 0x00, 0 },
+	{ 0xd4fd, 0x00, 0 },
+	{ 0xd4fe, 0x00, 0 },
+	{ 0xd4ff, 0x00, 0 },
+	{ 0xd500, 0x00, 0 },
+	{ 0xd501, 0x00, 0 },
+	{ 0xd502, 0x00, 0 },
+	{ 0xd503, 0x00, 0 },
+	{ 0x6f0e, 0x33, 0 },
+	{ 0x6f0f, 0x33, 0 },
+	{ 0x460e, 0x08, 0 },
+	{ 0x460f, 0x01, 0 },
+	{ 0x4610, 0x00, 0 },
+	{ 0x4611, 0x01, 0 },
+	{ 0x4612, 0x00, 0 },
+	{ 0x4613, 0x01, 0 },
+	{ 0x4605, 0x08, 0 },
+	{ 0x4608, 0x00, 0 },
+	{ 0x4609, 0x08, 0 },
+	{ 0x6804, 0x00, 0 },
+	{ 0x6805, 0x06, 0 },
+	{ 0x6806, 0x00, 0 },
+	{ 0x5120, 0x00, 0 },
+	{ 0x3510, 0x00, 0 },
+	{ 0x3504, 0x00, 0 },
+	{ 0x6800, 0x00, 0 },
+	{ 0x6f0d, 0x0f, 0 },
+	{ 0x5000, 0xff, 0 },
+	{ 0x5001, 0xbf, 0 },
+	{ 0x5002, 0x7e, 0 },
+	{ 0x5003, 0x0c, 0 },
+	{ 0x503d, 0x00, 0 },
+	{ 0xc450, 0x01, 0 },
+	{ 0xc452, 0x04, 0 },
+	{ 0xc453, 0x00, 0 },
+	{ 0xc454, 0x00, 0 },
+	{ 0xc455, 0x00, 0 },
+	{ 0xc456, 0x00, 0 },
+	{ 0xc457, 0x00, 0 },
+	{ 0xc458, 0x00, 0 },
+	{ 0xc459, 0x00, 0 },
+	{ 0xc45b, 0x00, 0 },
+	{ 0xc45c, 0x00, 0 },
+	{ 0xc45d, 0x00, 0 },
+	{ 0xc45e, 0x00, 0 },
+	{ 0xc45f, 0x00, 0 },
+	{ 0xc460, 0x00, 0 },
+	{ 0xc461, 0x01, 0 },
+	{ 0xc462, 0x01, 0 },
+	{ 0xc464, 0x88, 0 },
+	{ 0xc465, 0x00, 0 },
+	{ 0xc466, 0x8a, 0 },
+	{ 0xc467, 0x00, 0 },
+	{ 0xc468, 0x86, 0 },
+	{ 0xc469, 0x00, 0 },
+	{ 0xc46a, 0x40, 0 },
+	{ 0xc46b, 0x50, 0 },
+	{ 0xc46c, 0x30, 0 },
+	{ 0xc46d, 0x28, 0 },
+	{ 0xc46e, 0x60, 0 },
+	{ 0xc46f, 0x40, 0 },
+	{ 0xc47c, 0x01, 0 },
+	{ 0xc47d, 0x38, 0 },
+	{ 0xc47e, 0x00, 0 },
+	{ 0xc47f, 0x00, 0 },
+	{ 0xc480, 0x00, 0 },
+	{ 0xc481, 0xff, 0 },
+	{ 0xc482, 0x00, 0 },
+	{ 0xc483, 0x40, 0 },
+	{ 0xc484, 0x00, 0 },
+	{ 0xc485, 0x18, 0 },
+	{ 0xc486, 0x00, 0 },
+	{ 0xc487, 0x18, 0 },
+	{ 0xc488, 0x34, 0 },
+	{ 0xc489, 0x00, 0 },
+	{ 0xc48a, 0x34, 0 },
+	{ 0xc48b, 0x00, 0 },
+	{ 0xc48c, 0x00, 0 },
+	{ 0xc48d, 0x04, 0 },
+	{ 0xc48e, 0x00, 0 },
+	{ 0xc48f, 0x04, 0 },
+	{ 0xc490, 0x07, 0 },
+	{ 0xc492, 0x20, 0 },
+	{ 0xc493, 0x08, 0 },
+	{ 0xc498, 0x02, 0 },
+	{ 0xc499, 0x00, 0 },
+	{ 0xc49a, 0x02, 0 },
+	{ 0xc49b, 0x00, 0 },
+	{ 0xc49c, 0x02, 0 },
+	{ 0xc49d, 0x00, 0 },
+	{ 0xc49e, 0x02, 0 },
+	{ 0xc49f, 0x60, 0 },
+	{ 0xc4a0, 0x03, 0 },
+	{ 0xc4a1, 0x00, 0 },
+	{ 0xc4a2, 0x04, 0 },
+	{ 0xc4a3, 0x00, 0 },
+	{ 0xc4a4, 0x00, 0 },
+	{ 0xc4a5, 0x10, 0 },
+	{ 0xc4a6, 0x00, 0 },
+	{ 0xc4a7, 0x40, 0 },
+	{ 0xc4a8, 0x00, 0 },
+	{ 0xc4a9, 0x80, 0 },
+	{ 0xc4aa, 0x0d, 0 },
+	{ 0xc4ab, 0x00, 0 },
+	{ 0xc4ac, 0x0f, 0 },
+	{ 0xc4ad, 0xc0, 0 },
+	{ 0xc4b4, 0x01, 0 },
+	{ 0xc4b5, 0x01, 0 },
+	{ 0xc4b6, 0x00, 0 },
+	{ 0xc4b7, 0x01, 0 },
+	{ 0xc4b8, 0x00, 0 },
+	{ 0xc4b9, 0x01, 0 },
+	{ 0xc4ba, 0x01, 0 },
+	{ 0xc4bb, 0x00, 0 },
+	{ 0xc4bc, 0x01, 0 },
+	{ 0xc4bd, 0x60, 0 },
+	{ 0xc4be, 0x02, 0 },
+	{ 0xc4bf, 0x33, 0 },
+	{ 0xc4c8, 0x03, 0 },
+	{ 0xc4c9, 0xd0, 0 },
+	{ 0xc4ca, 0x0e, 0 },
+	{ 0xc4cb, 0x00, 0 },
+	{ 0xc4cc, 0x10, 0 },
+	{ 0xc4cd, 0x18, 0 },
+	{ 0xc4ce, 0x10, 0 },
+	{ 0xc4cf, 0x18, 0 },
+	{ 0xc4d0, 0x04, 0 },
+	{ 0xc4d1, 0x80, 0 },
+	{ 0xc4e0, 0x04, 0 },
+	{ 0xc4e1, 0x02, 0 },
+	{ 0xc4e2, 0x01, 0 },
+	{ 0xc4e4, 0x10, 0 },
+	{ 0xc4e5, 0x20, 0 },
+	{ 0xc4e6, 0x30, 0 },
+	{ 0xc4e7, 0x40, 0 },
+	{ 0xc4e8, 0x50, 0 },
+	{ 0xc4e9, 0x60, 0 },
+	{ 0xc4ea, 0x70, 0 },
+	{ 0xc4eb, 0x80, 0 },
+	{ 0xc4ec, 0x90, 0 },
+	{ 0xc4ed, 0xa0, 0 },
+	{ 0xc4ee, 0xb0, 0 },
+	{ 0xc4ef, 0xc0, 0 },
+	{ 0xc4f0, 0xd0, 0 },
+	{ 0xc4f1, 0xe0, 0 },
+	{ 0xc4f2, 0xf0, 0 },
+	{ 0xc4f3, 0x80, 0 },
+	{ 0xc4f4, 0x00, 0 },
+	{ 0xc4f5, 0x20, 0 },
+	{ 0xc4f6, 0x02, 0 },
+	{ 0xc4f7, 0x00, 0 },
+	{ 0xc4f8, 0x04, 0 },
+	{ 0xc4f9, 0x0b, 0 },
+	{ 0xc4fa, 0x00, 0 },
+	{ 0xc4fb, 0x00, 0 },
+	{ 0xc4fc, 0x01, 0 },
+	{ 0xc4fd, 0x00, 0 },
+	{ 0xc4fe, 0x04, 0 },
+	{ 0xc4ff, 0x02, 0 },
+	{ 0xc500, 0x48, 0 },
+	{ 0xc501, 0x74, 0 },
+	{ 0xc502, 0x58, 0 },
+	{ 0xc503, 0x80, 0 },
+	{ 0xc504, 0x05, 0 },
+	{ 0xc505, 0x80, 0 },
+	{ 0xc506, 0x03, 0 },
+	{ 0xc507, 0x80, 0 },
+	{ 0xc508, 0x01, 0 },
+	{ 0xc509, 0xc0, 0 },
+	{ 0xc50a, 0x01, 0 },
+	{ 0xc50b, 0xa0, 0 },
+	{ 0xc50c, 0x01, 0 },
+	{ 0xc50d, 0x2c, 0 },
+	{ 0xc50e, 0x01, 0 },
+	{ 0xc50f, 0x0a, 0 },
+	{ 0xc510, 0x00, 0 },
+	{ 0xc511, 0x01, 0 },
+	{ 0xc512, 0x01, 0 },
+	{ 0xc513, 0x80, 0 },
+	{ 0xc514, 0x04, 0 },
+	{ 0xc515, 0x00, 0 },
+	{ 0xc518, 0x03, 0 },
+	{ 0xc519, 0x48, 0 },
+	{ 0xc51a, 0x07, 0 },
+	{ 0xc51b, 0x70, 0 },
+	{ 0xc2e0, 0x00, 0 },
+	{ 0xc2e1, 0x51, 0 },
+	{ 0xc2e2, 0x00, 0 },
+	{ 0xc2e3, 0xd6, 0 },
+	{ 0xc2e4, 0x01, 0 },
+	{ 0xc2e5, 0x5e, 0 },
+	{ 0xc2e9, 0x01, 0 },
+	{ 0xc2ea, 0x7a, 0 },
+	{ 0xc2eb, 0x90, 0 },
+	{ 0xc2ed, 0x00, 0 },
+	{ 0xc2ee, 0x7a, 0 },
+	{ 0xc2ef, 0x64, 0 },
+	{ 0xc308, 0x00, 0 },
+	{ 0xc309, 0x00, 0 },
+	{ 0xc30a, 0x00, 0 },
+	{ 0xc30c, 0x00, 0 },
+	{ 0xc30d, 0x01, 0 },
+	{ 0xc30e, 0x00, 0 },
+	{ 0xc30f, 0x00, 0 },
+	{ 0xc310, 0x01, 0 },
+	{ 0xc311, 0x60, 0 },
+	{ 0xc312, 0xff, 0 },
+	{ 0xc313, 0x08, 0 },
+	{ 0xc314, 0x01, 0 },
+	{ 0xc315, 0x7f, 0 },
+	{ 0xc316, 0xff, 0 },
+	{ 0xc317, 0x0b, 0 },
+	{ 0xc318, 0x00, 0 },
+	{ 0xc319, 0x0c, 0 },
+	{ 0xc31a, 0x00, 0 },
+	{ 0xc31b, 0xe0, 0 },
+	{ 0xc31c, 0x00, 0 },
+	{ 0xc31d, 0x14, 0 },
+	{ 0xc31e, 0x00, 0 },
+	{ 0xc31f, 0xc5, 0 },
+	{ 0xc320, 0xff, 0 },
+	{ 0xc321, 0x4b, 0 },
+	{ 0xc322, 0xff, 0 },
+	{ 0xc323, 0xf0, 0 },
+	{ 0xc324, 0xff, 0 },
+	{ 0xc325, 0xe8, 0 },
+	{ 0xc326, 0x00, 0 },
+	{ 0xc327, 0x46, 0 },
+	{ 0xc328, 0xff, 0 },
+	{ 0xc329, 0xd2, 0 },
+	{ 0xc32a, 0xff, 0 },
+	{ 0xc32b, 0xe4, 0 },
+	{ 0xc32c, 0xff, 0 },
+	{ 0xc32d, 0xbb, 0 },
+	{ 0xc32e, 0x00, 0 },
+	{ 0xc32f, 0x61, 0 },
+	{ 0xc330, 0xff, 0 },
+	{ 0xc331, 0xf9, 0 },
+	{ 0xc332, 0x00, 0 },
+	{ 0xc333, 0xd9, 0 },
+	{ 0xc334, 0x00, 0 },
+	{ 0xc335, 0x2e, 0 },
+	{ 0xc336, 0x00, 0 },
+	{ 0xc337, 0xb1, 0 },
+	{ 0xc338, 0xff, 0 },
+	{ 0xc339, 0x64, 0 },
+	{ 0xc33a, 0xff, 0 },
+	{ 0xc33b, 0xeb, 0 },
+	{ 0xc33c, 0xff, 0 },
+	{ 0xc33d, 0xe8, 0 },
+	{ 0xc33e, 0x00, 0 },
+	{ 0xc33f, 0x48, 0 },
+	{ 0xc340, 0xff, 0 },
+	{ 0xc341, 0xd0, 0 },
+	{ 0xc342, 0xff, 0 },
+	{ 0xc343, 0xed, 0 },
+	{ 0xc344, 0xff, 0 },
+	{ 0xc345, 0xad, 0 },
+	{ 0xc346, 0x00, 0 },
+	{ 0xc347, 0x66, 0 },
+	{ 0xc348, 0x01, 0 },
+	{ 0xc349, 0x00, 0 },
+	{ 0x6700, 0x04, 0 },
+	{ 0x6701, 0x7b, 0 },
+	{ 0x6702, 0xfd, 0 },
+	{ 0x6703, 0xf9, 0 },
+	{ 0x6704, 0x3d, 0 },
+	{ 0x6705, 0x71, 0 },
+	{ 0x6706, 0x78, 0 },
+	{ 0x6708, 0x05, 0 },
+	{ 0x6f06, 0x6f, 0 },
+	{ 0x6f07, 0x00, 0 },
+	{ 0x6f0a, 0x6f, 0 },
+	{ 0x6f0b, 0x00, 0 },
+	{ 0x6f00, 0x03, 0 },
+	{ 0xc34c, 0x01, 0 },
+	{ 0xc34d, 0x00, 0 },
+	{ 0xc34e, 0x46, 0 },
+	{ 0xc34f, 0x55, 0 },
+	{ 0xc350, 0x00, 0 },
+	{ 0xc351, 0x40, 0 },
+	{ 0xc352, 0x00, 0 },
+	{ 0xc353, 0xff, 0 },
+	{ 0xc354, 0x04, 0 },
+	{ 0xc355, 0x08, 0 },
+	{ 0xc356, 0x01, 0 },
+	{ 0xc357, 0xef, 0 },
+	{ 0xc358, 0x30, 0 },
+	{ 0xc359, 0x01, 0 },
+	{ 0xc35a, 0x64, 0 },
+	{ 0xc35b, 0x46, 0 },
+	{ 0xc35c, 0x00, 0 },
+	{ 0x3042, 0xf0, 0 },
+	{ 0x3042, 0xf0, 0 },
+	{ 0x3042, 0xf0, 0 },
+	{ 0x3042, 0xf0, 0 },
+	{ 0x3042, 0xf0, 0 },
+	{ 0x3042, 0xf0, 0 },
+	{ 0x3042, 0xf0, 0 },
+	{ 0x3042, 0xf0, 0 },
+	{ 0x3042, 0xf0, 0 },
+	{ 0x3042, 0xf0, 0 },
+	{ 0x3042, 0xf0, 0 },
+	{ 0x3042, 0xf0, 0 },
+	{ 0x3042, 0xf0, 0 },
+	{ 0x3042, 0xf0, 0 },
+	{ 0x3042, 0xf0, 0 },
+	{ 0x3042, 0xf0, 0 },
+	{ 0x3042, 0xf0, 0 },
+	{ 0x3042, 0xf0, 0 },
+	{ 0x3042, 0xf0, 0 },
+	{ 0x3042, 0xf0, 0 },
+	{ 0x3042, 0xf0, 0 },
+	{ 0x3042, 0xf0, 0 },
+	{ 0x3042, 0xf0, 0 },
+	{ 0x3042, 0xf0, 0 },
+	{ 0x3042, 0xf0, 0 },
+	{ 0x3042, 0xf0, 0 },
+	{ 0x301b, 0xf0, 0 },
+	{ 0x301c, 0xf0, 0 },
+	{ 0x301a, 0xf0, 0 },
+	{ 0xceb0, 0x00, 0 },
+	{ 0xceb1, 0x00, 0 },
+	{ 0xceb2, 0x00, 0 },
+	{ 0xceb3, 0x00, 0 },
+	{ 0xceb4, 0x00, 0 },
+	{ 0xceb5, 0x00, 0 },
+	{ 0xceb6, 0x00, 0 },
+	{ 0xceb7, 0x00, 0 },
+	{ 0xc4bc, 0x01, 0 },
+	{ 0xc4bd, 0x60, 0 },
+
+	{ 0x4709, 0x10, 0 },/* dvp swap */
+	{ 0x4300, 0x3a, 0 },/* YUV order UYVY */
+	{ 0x3832, 0x01, 0 },/* fsin */
+	{ 0x3833, 0x1A, 0 },
+	{ 0x3834, 0x03, 0 },
+	{ 0x3835, 0x48, 0 },
+	{ 0x302E, 0x01, 0 },
+};
+
+struct ov10635_mode_info {
+	enum ov10635_mode mode;
+	u32 width;
+	u32 height;
+	struct reg_value *init_data_ptr;
+	u32 init_data_size;
+};
+
+static struct reg_value  ov10635_setting_30fps_WXGA_1280_800[] = {
+	{ 0x3024, 0x01, 0 },
+	{ 0x3003, 0x20, 0 },
+	{ 0x3004, 0x21, 0 },
+	{ 0x3005, 0x20, 0 },
+	{ 0x3006, 0x91, 0 },
+	/* 1280x800 */
+	{ 0x3808, 0x05, 0 },
+	{ 0x3809, 0x00, 0 },
+	{ 0x380a, 0x03, 0 },
+	{ 0x380b, 0x20, 0 },
+};
+
+static struct reg_value  ov10635_setting_30fps_720P_1280_720[] = {
+	{ 0x3024, 0x01, 0 },
+	{ 0x3003, 0x20, 0 },
+	{ 0x3004, 0x21, 0 },
+	{ 0x3005, 0x20, 0 },
+	{ 0x3006, 0x91, 0 },
+	/* 1280x720 */
+	{ 0x3808, 0x05, 0 },
+	{ 0x3809, 0x00, 0 },
+	{ 0x380a, 0x02, 0 },
+	{ 0x380b, 0xD0, 0 },
+};
+
+static struct reg_value  ov10635_setting_30fps_WVGA_752_480[] = {
+	{ 0x3024, 0x01, 0 },
+	{ 0x3003, 0x20, 0 },
+	{ 0x3004, 0x21, 0 },
+	{ 0x3005, 0x20, 0 },
+	{ 0x3006, 0x91, 0 },
+	/* 752x480 */
+	{ 0x3808, 0x02, 0 },
+	{ 0x3809, 0xF0, 0 },
+	{ 0x380a, 0x01, 0 },
+	{ 0x380b, 0xE0, 0 },
+};
+
+static struct reg_value  ov10635_setting_30fps_VGA_640_480[] = {
+	{ 0x3024, 0x01, 0 },
+	{ 0x3003, 0x20, 0 },
+	{ 0x3004, 0x21, 0 },
+	{ 0x3005, 0x20, 0 },
+	{ 0x3006, 0x91, 0 },
+	/* 640x480 */
+	{ 0x3808, 0x02, 0 },
+	{ 0x3809, 0x80, 0 },
+	{ 0x380a, 0x01, 0 },
+	{ 0x380b, 0xE0, 0 },
+};
+
+static struct reg_value  ov10635_setting_30fps_CIF_352_288[] = {
+	{ 0x3024, 0x01, 0 },
+	{ 0x3003, 0x20, 0 },
+	{ 0x3004, 0x21, 0 },
+	{ 0x3005, 0x20, 0 },
+	{ 0x3006, 0x91, 0 },
+	/* 352x288 */
+	{ 0x3808, 0x01, 0 },
+	{ 0x3809, 0x60, 0 },
+	{ 0x380a, 0x01, 0 },
+	{ 0x380b, 0x20, 0 },
+};
+
+static struct reg_value  ov10635_setting_30fps_QVGA_320_240[] = {
+	{ 0x3024, 0x01, 0 },
+	{ 0x3003, 0x20, 0 },
+	{ 0x3004, 0x21, 0 },
+	{ 0x3005, 0x20, 0 },
+	{ 0x3006, 0x91, 0 },
+	/* 320x240 */
+	{ 0x3808, 0x01, 0 },
+	{ 0x3809, 0x40, 0 },
+	{ 0x380a, 0x00, 0 },
+	{ 0x380b, 0xF0, 0 },
+};
+
+static struct ov10635_mode_info ov10635_mode_info_data[2][ov10635_mode_MAX + 1] = {
+	/* 15fps not support */
+	{
+		{ ov10635_mode_WXGA_1280_800, 0, 0, NULL, 0 },
+		{ ov10635_mode_720P_1280_720, 0, 0, NULL, 0 },
+		{ ov10635_mode_WVGA_752_480, 0, 0, NULL, 0 },
+		{ ov10635_mode_VGA_640_480, 0, 0, NULL, 0 },
+		{ ov10635_mode_CIF_352_288, 0, 0, NULL, 0},
+		{ ov10635_mode_QVGA_320_240, 0, 0, NULL, 0},
+	},
+	/* 30fps */
+	{
+		{ ov10635_mode_WXGA_1280_800, 1280, 800,
+		  ov10635_setting_30fps_WXGA_1280_800,
+		  ARRAY_SIZE(ov10635_setting_30fps_WXGA_1280_800)
+		},
+		{ ov10635_mode_720P_1280_720, 1280, 720,
+		  ov10635_setting_30fps_720P_1280_720,
+		  ARRAY_SIZE(ov10635_setting_30fps_720P_1280_720)
+		},
+		{ ov10635_mode_WVGA_752_480, 752, 480,
+		  ov10635_setting_30fps_WVGA_752_480,
+		  ARRAY_SIZE(ov10635_setting_30fps_WVGA_752_480)
+		},
+		{ ov10635_mode_VGA_640_480, 640, 480,
+		  ov10635_setting_30fps_VGA_640_480,
+		  ARRAY_SIZE(ov10635_setting_30fps_VGA_640_480)
+		},
+		{ ov10635_mode_CIF_352_288, 352, 288,
+		  ov10635_setting_30fps_CIF_352_288,
+		  ARRAY_SIZE(ov10635_setting_30fps_CIF_352_288)
+		},
+		{ ov10635_mode_QVGA_320_240, 320, 240,
+		  ov10635_setting_30fps_QVGA_320_240,
+		  ARRAY_SIZE(ov10635_setting_30fps_QVGA_320_240)
+		},
+	}
+};
+
+static inline struct sensor_data *subdev_to_sensor_data(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct sensor_data, subdev);
+}
+
+static enum ov10635_frame_rate to_ov10635_frame_rate(struct v4l2_fract *timeperframe)
+{
+	enum ov10635_frame_rate rate;
+	u32 tgt_fps;	/* target frames per secound */
+
+	tgt_fps = timeperframe->denominator / timeperframe->numerator;
+
+	if (tgt_fps == 30)
+		rate = OV10635_30_FPS;
+	else if (tgt_fps == 15)
+		rate = OV10635_15_FPS;
+	else
+		rate = -EINVAL;
+
+	return rate;
+}
+
+static inline int ov10635_read_reg(struct sensor_data *max9286_data, int index,
+				   unsigned short reg, unsigned char *val)
+{
+	struct i2c_client *client = max9286_data->i2c_client;
+	struct device *dev = &client->dev;
+	unsigned char u8_buf[2] = { 0 };
+	unsigned int buf_len = 2;
+	int retry, timeout = 10;
+	unsigned char u8_val = 0;
+
+	u8_buf[0] = (reg >> 8) & 0xFF;
+	u8_buf[1] = reg & 0xFF;
+
+	client->addr = ADDR_OV_SENSOR + index;
+
+	for (retry = 0; retry < timeout; retry++) {
+		if (i2c_master_send(client, u8_buf, buf_len) < 0) {
+			dev_dbg(dev, "%s:read reg error on send: reg=0x%x, retry = %d.\n", __func__, reg, retry);
+			msleep(5);
+			continue;
+		}
+		if (i2c_master_recv(client, &u8_val, 1) != 1) {
+			dev_dbg(dev, "%s:read reg error on recv: reg=0x%x, retry = %d.\n", __func__, reg, retry);
+			msleep(5);
+			continue;
+		}
+		break;
+	}
+
+	if (retry >= timeout) {
+		dev_info(dev, "%s:read reg error: reg=0x%x.\n", __func__, reg);
+		return -1;
+	}
+
+	*val = u8_val;
+
+	return u8_val;
+}
+
+static inline int ov10635_write_reg(struct sensor_data *max9286_data, int index,
+				    unsigned short reg, unsigned char val)
+{
+	struct i2c_client *client = max9286_data->i2c_client;
+	struct device *dev = &client->dev;
+	unsigned char u8_buf[3] = { 0 };
+	unsigned int buf_len = 3;
+	int retry, timeout = 10;
+
+	u8_buf[0] = (reg >> 8) & 0xFF;
+	u8_buf[1] = reg & 0xFF;
+	u8_buf[2] = val;
+
+	client->addr = ADDR_OV_SENSOR + index;
+	for (retry = 0; retry < timeout; retry++) {
+		if (i2c_master_send(client, u8_buf, buf_len) < 0) {
+			dev_dbg(dev, "%s:write reg error: reg=0x%x, val=0x%x, retry = %d.\n", __func__, reg, val, retry);
+			msleep(5);
+			continue;
+		}
+		break;
+	}
+
+	if (retry >= timeout) {
+		dev_info(dev, "%s:write reg error: reg=0x%x, val=0x%x.\n",
+			 __func__, reg, val);
+		return -1;
+	}
+
+	return 0;
+}
+
+static int ov10635_check_device(struct sensor_data *max9286_data, int index)
+{
+	struct i2c_client *client = max9286_data->i2c_client;
+	struct device *dev = &client->dev;
+	unsigned char reg = 0;
+
+	ov10635_read_reg(max9286_data, index, OV10635_REG_PID, &reg);
+	if (reg != 0xA6) {
+		dev_err(dev, "%s: OV10635 hasn't been found, reg[0x%x] = 0x%x., index=%d\n",
+			__func__, OV10635_REG_PID, reg, index);
+		return -1;
+	}
+	ov10635_read_reg(max9286_data, index, OV10635_REG_VER, &reg);
+	if (reg != 0x35) {
+		dev_err(dev, "%s: OV10635 hasn't been found, reg[0x%x] = 0x%x.\n",
+			__func__, OV10635_REG_VER, reg);
+		return -1;
+	}
+	dev_info(dev, "%s: OV10635 index=%d was found.\n", __func__, index);
+
+	return 0;
+}
+
+static int ov10635_download_firmware(struct sensor_data *max9286_data, int index,
+				     struct reg_value *reg_setting, s32 arysize)
+{
+	register u32 delay_ms = 0;
+	register u16 reg_addr = 0;
+	register u8 val = 0;
+	int i, retval = 0;
+
+	for (i = 0; i < arysize; ++i, ++reg_setting) {
+		delay_ms = reg_setting->delay_ms;
+		reg_addr = reg_setting->reg_addr;
+		val = reg_setting->val;
+
+		retval = ov10635_write_reg(max9286_data, index, reg_addr, val);
+		if (retval < 0)
+			goto err;
+
+		if (delay_ms)
+			msleep(delay_ms);
+	}
+err:
+	return retval;
+}
+
+static int ov10635_initialize(struct sensor_data *max9286_data, int index)
+{
+	struct device *dev = &max9286_data->i2c_client->dev; int i, array_size;
+	int retval;
+
+	dev_info(dev, "%s: index = %d.\n", __func__, index);
+	array_size = ARRAY_SIZE(ov10635_init_data);
+	for (i = 0; i < array_size; i++) {
+		retval = ov10635_write_reg(max9286_data, index,
+					   ov10635_init_data[i].reg_addr,
+					   ov10635_init_data[i].val);
+		if (retval < 0)
+			break;
+		if (ov10635_init_data[i].delay_ms != 0)
+			msleep(ov10635_init_data[i].delay_ms);
+	}
+
+	return 0;
+}
+
+static inline int max9271_read_reg(struct sensor_data *max9286_data, int index, u8 reg)
+{
+	struct device *dev = &max9286_data->i2c_client->dev;
+	int val;
+	int retry, timeout = 10;
+
+	max9286_data->i2c_client->addr = ADDR_MAX9271 + index;
+	for (retry = 0; retry < timeout; retry++) {
+		val = i2c_smbus_read_byte_data(max9286_data->i2c_client, reg);
+		if (val < 0)
+			msleep(5);
+		else
+			break;
+	}
+
+	if (retry >= timeout) {
+		dev_info(dev, "%s:read reg error: reg=%2x\n", __func__, reg);
+		return -1;
+	}
+
+	return val;
+}
+
+static int max9271_write_reg(struct sensor_data *max9286_data, int index, u8 reg, u8 val)
+{
+	struct i2c_client *client = max9286_data->i2c_client;
+	struct device *dev = &client->dev;
+	s32 ret;
+	int retry, timeout = 10;
+
+	max9286_data->i2c_client->addr = ADDR_MAX9271 + index;
+	for (retry = 0; retry < timeout; retry++) {
+		ret = i2c_smbus_write_byte_data(client, reg, val);
+		if (ret < 0)
+			msleep(5);
+		else
+			break;
+	}
+	dev_dbg(dev, "%s: addr %02x reg %02x val %02x\n", __func__, client->addr, reg, val);
+
+	if (retry >= timeout) {
+		dev_info(dev, "%s:write reg error:reg=%2x,val=%2x\n", __func__, reg, val);
+		return -1;
+	}
+
+	return 0;
+}
+
+/*  Read one register from a MAX9286 i2c slave device.
+ *
+ *  @param *reg: register in the device we wish to access.
+ *
+ *  @return 0 if success, an error code otherwise.
+ */
+static inline int max9286_read_reg(struct sensor_data *max9286_data, u8 reg)
+{
+	int val;
+
+	max9286_data->i2c_client->addr = ADDR_MAX9286;
+	val = i2c_smbus_read_byte_data(max9286_data->i2c_client, reg);
+	if (val < 0) {
+		dev_info(&max9286_data->i2c_client->dev,
+			 "%s:read reg error: reg=%2x\n", __func__, reg);
+		return -1;
+	}
+	return val;
+}
+
+/*  Write one register of a MAX9286 i2c slave device.
+ *
+ *  @param *reg: register in the device we wish to access.
+ *
+ *  @return 0 if success, an error code otherwise.
+ */
+static int max9286_write_reg(struct sensor_data *max9286_data, u8 reg, u8 val)
+{
+	struct i2c_client *client = max9286_data->i2c_client;
+	struct device *dev = &client->dev;
+	s32 ret;
+
+	client->addr = ADDR_MAX9286;
+	ret = i2c_smbus_write_byte_data(client, reg, val);
+
+	dev_dbg(dev, "addr %02x reg %02x val %02x\n", client->addr, reg, val);
+
+	if (ret < 0) {
+		dev_info(dev, "write reg error:reg=%2x,val=%2x\n", reg, val);
+		return -1;
+	}
+	return 0;
+}
+
+#ifdef debug
+static void max9271_dump_registers(struct sensor_data *max9286_data, int index)
+{
+	unsigned char i;
+
+	pr_info("max9271_dump_registers: index = %d.\r\n", index);
+	for (i = 0; i < 0x20; i++)
+		pr_info("MAX9271 Reg 0x%02x = 0x%x.\r\n",
+			i, max9271_read_reg(max9286_data, index, i));
+}
+
+static void max9286_dump_registers(struct sensor_data *max9286_data)
+{
+	unsigned char i;
+
+	pr_info("Dump MAX9286 registers:\r\n");
+	for (i = 0; i < 0x72; i++)
+		pr_info("MAX9286 Reg 0x%02x = 0x%x.\r\n",
+			i, max9286_read_reg(max9286_data, i));
+}
+#else
+static void max9271_dump_registers(struct sensor_data *max9286_data, int index)
+{
+}
+#endif
+
+static void max9286_hw_reset(struct sensor_data *max9286_data)
+{
+	gpiod_set_value_cansleep(max9286_data->pwn_gpio, 0);
+	udelay(200);
+	gpiod_set_value_cansleep(max9286_data->pwn_gpio, 1);
+	msleep(1);
+}
+
+static int max9286_hardware_preinit(struct sensor_data *max9286_data)
+{
+	u8 reg;
+
+	dev_info(&max9286_data->i2c_client->dev, "In %s()\n", __func__);
+
+	/* Disable CSI Output */
+	max9286_write_reg(max9286_data, 0x15, 0x03);
+
+	/* Enable PRBS test */
+	max9286_write_reg(max9286_data, 0x0E, 0x5F);
+	msleep(10);
+
+	/* Enable Custom Reverse Channel & First Pulse Length  STEP 1 */
+	max9286_write_reg(max9286_data, 0x3F, 0x4F);
+	msleep(2); /* STEP 2 */
+
+	/* Reverse Channel Amplitude to mid level and transition time */
+	max9286_write_reg(max9286_data, 0x3B, 0x1E); /* STEP 3 */
+	msleep(2); /* STEP 4 */
+
+	/* Enable MAX9271 Configuration Link */
+	max9271_write_reg(max9286_data, 0, 0x04, 0x43);  /* STEP 5 */
+	msleep(2);  /* STEP 6 */
+
+	/* Increase serializer reverse channel input thresholds */
+	max9271_write_reg(max9286_data, 0, 0x08, 0x01);  /* STEP 7 */
+	msleep(2);  /* STEP 8 */
+
+	/* Reverse Channel Amplitude level */
+	max9286_write_reg(max9286_data, 0x3B, 0x19);  /* STEP 9 */
+	msleep(5);  /* STEP 10 */
+
+	/* Set YUV422 8 bits mode, Double Data Rate, 4 data lane */
+	max9286_write_reg(max9286_data, 0x12, 0xF3); /* STEP 12 */
+
+	max9286_write_reg(max9286_data, 0x01, 0x02); /* STEP 13 */
+	/* Enable All Link 0-3  */
+	max9286_write_reg(max9286_data, 0x00, 0xef); /* STEP 14 */
+
+	/* Frame Sync */
+	/* Automatic Mode */
+	max9286_write_reg(max9286_data, 0x01, 0x02);/* STEP 13 */
+	msleep(200);
+	/* Detect link */
+	max9286_data->sensor_num = 0;
+	reg = max9286_read_reg(max9286_data, 0x49);
+	max9286_data->sensor_is_there = ((reg >> 4) & 0xF) | (reg & 0xF);
+	if (max9286_data->sensor_is_there & (0x1 << 0))
+		max9286_data->sensor_num += 1;
+	if (max9286_data->sensor_is_there & (0x1 << 1))
+		max9286_data->sensor_num += 1;
+	if (max9286_data->sensor_is_there & (0x1 << 2))
+		max9286_data->sensor_num += 1;
+	if (max9286_data->sensor_is_there & (0x1 << 3))
+		max9286_data->sensor_num += 1;
+	pr_info("max9286_mipi: reg = 0x%02x.\n", reg);
+	pr_info("max9286_mipi: sensor number = %d.\n", max9286_data->sensor_num);
+
+	if (max9286_data->sensor_num == 0) {
+		pr_err("%s: no camera connected.\n", __func__);
+		return -1;
+	}
+
+	return 0;
+}
+
+static void max9286_camera_reorder(struct sensor_data *max9286_data)
+{
+	u8 reg;
+
+	reg = 0xE4;
+	if (max9286_data->sensor_num == 1) {
+		switch (max9286_data->sensor_is_there) {
+		case 0x8:
+			reg = 0x27;
+			break;
+		case 0x4:
+			reg = 0xC6;
+			break;
+		case 0x2:
+			reg = 0xE1;
+			break;
+		case 0x1:
+		default:
+			reg = 0xE4;
+			break;
+		}
+	} else if (max9286_data->sensor_num == 2) {
+		switch (max9286_data->sensor_is_there) {
+		case 0xC:
+			reg = 0x4E;
+			break;
+		case 0xA:
+			reg = 0x72;
+			break;
+		case 0x9:
+			reg = 0x78;
+			break;
+		case 0x6:
+			reg = 0xD2;
+			break;
+		case 0x5:
+			reg = 0xD8;
+			break;
+		case 0x3:
+		default:
+			reg = 0xE4;
+			break;
+		}
+	} else if (max9286_data->sensor_num == 3) {
+		switch (max9286_data->sensor_is_there) {
+		case 0xE:
+			reg = 0x93;
+			break;
+		case 0xD:
+			reg = 0x9C;
+			break;
+		case 0xB:
+			reg = 0xB4;
+			break;
+		case 0x7:
+		default:
+			reg = 0xE4;
+			break;
+		}
+	}
+	max9286_write_reg(max9286_data, 0x0B, reg);
+}
+
+static int max9286_hardware_init(struct sensor_data *max9286_data)
+{
+	int retval = 0;
+	int i;
+	u8 reg, sensor_addr = 0;
+
+	dev_info(&max9286_data->i2c_client->dev, "In %s()\n", __func__);
+
+	/* Disable PRBS test */
+	max9286_write_reg(max9286_data, 0x0E, 0x50);
+
+	/* reorder camera */
+	max9286_camera_reorder(max9286_data);
+
+	/* Enable all links */
+	reg = 0xE0 | max9286_data->sensor_is_there;
+	max9286_write_reg(max9286_data, 0x00, reg);
+
+	/* Set up links */
+	sensor_addr = ADDR_OV_SENSOR;
+	max9271_write_reg(max9286_data, 0, 0x07, 0x84);
+	/* STEP 15-46 */
+	reg = 0;
+	for (i = 1; i <= MAX9271_MAX_SENSOR_NUM; i++) {
+		if (((0x1 << (i - 1)) & max9286_data->sensor_is_there) == 0)
+			continue;
+
+		/* Enable Link control channel */
+		reg |= (0x11 << (i - 1));
+		max9286_write_reg(max9286_data, 0x0A, reg);/* STEP 15 */
+
+		/* Set MAX9271 new address for link 0 */
+		max9271_write_reg(max9286_data, 0, 0x00, (ADDR_MAX9271 + i) << 1);
+		msleep(2);
+
+		max9271_write_reg(max9286_data, i, 0x01, ADDR_MAX9286 << 1);
+		max9271_write_reg(max9286_data, i, 0x09, (sensor_addr + i) << 1);
+		max9271_write_reg(max9286_data, i, 0x0A, sensor_addr << 1);
+		max9271_write_reg(max9286_data, i, 0x0B, ADDR_MAX9271_ALL << 1);
+		max9271_write_reg(max9286_data, i, 0x0C, (ADDR_MAX9271 + i) << 1);
+
+		msleep(1);
+		pr_info("max9286_mipi: initialized sensor  = 0x%02x.\n", i);
+		max9271_dump_registers(max9286_data, i);
+	}
+	max9286_write_reg(max9286_data, 0x0A, reg);
+	max9286_write_reg(max9286_data, 0x0A, reg);
+
+	/* Disable Local Auto I2C ACK */
+	max9286_write_reg(max9286_data, 0x34, 0x36); /* STEP 48 */
+
+	/* Initialize Camera Sensor */
+	/* STEP 49 */
+	if (max9286_data->sensor_is_there & (0x1 << 0)) {
+		retval = ov10635_check_device(max9286_data, 1);
+		if (retval < 0)
+			return retval;
+		ov10635_initialize(max9286_data, 0);
+	}
+
+	if (max9286_data->sensor_is_there & (0x1 << 1)) {
+		retval = ov10635_check_device(max9286_data, 2);
+		if (retval < 0)
+			return retval;
+		ov10635_initialize(max9286_data, 1);
+	}
+
+	if (max9286_data->sensor_is_there & (0x1 << 2)) {
+		retval = ov10635_check_device(max9286_data, 3);
+		if (retval < 0)
+			return retval;
+		ov10635_initialize(max9286_data, 2);
+	}
+
+	if (max9286_data->sensor_is_there & (0x1 << 3)) {
+		retval = ov10635_check_device(max9286_data, 4);
+		if (retval < 0)
+			return retval;
+		ov10635_initialize(max9286_data, 3);
+	}
+
+	/* Enable Local Auto I2C ACK */
+	max9286_write_reg(max9286_data, 0x34, 0xB6); /* STEP 50 */
+
+	/* MAX9271: Enable Serial Links and Disable Configuration Link */
+	max9271_write_reg(max9286_data, ADDR_MAX9271_ALL - ADDR_MAX9271, 0x04, 0x83); /* STEP 51 */
+	/* Wait for more than 2 frame time */
+	msleep(1000); /* STEP 52 */
+
+	/* Enable CSI output, set virtual channel according to the link number */
+	max9286_write_reg(max9286_data, 0x15, 0x9B); /* STEP 52 */
+	msleep(10);
+	return retval;
+}
+
+static int ov10635_change_mode(struct sensor_data *max9286_data)
+{
+	struct reg_value *reg_setting = NULL;
+	enum ov10635_mode mode = max9286_data->current_mode;
+	enum ov10635_frame_rate rate =
+				to_ov10635_frame_rate(&max9286_data->frame_interval);
+	int arysize = 0, retval = 0;
+
+	if (mode > ov10635_mode_MAX || mode < ov10635_mode_MIN) {
+		pr_err("Wrong ov10635 mode detected!\n");
+		return -1;
+	}
+
+	reg_setting = ov10635_mode_info_data[rate][mode].init_data_ptr;
+	arysize = ov10635_mode_info_data[rate][mode].init_data_size;
+
+	max9286_data->format.width = ov10635_mode_info_data[rate][mode].width;
+	max9286_data->format.height = ov10635_mode_info_data[rate][mode].height;
+
+	if (max9286_data->format.width == 0 ||
+	    max9286_data->format.height == 0 ||
+	    !reg_setting || arysize == 0) {
+		pr_err("Not support mode=%d %s\n", mode,
+		       (rate == 0) ? "15(fps)" : "30(fps)");
+		return -EINVAL;
+	}
+
+	retval = ov10635_download_firmware(max9286_data, 0, reg_setting, arysize);
+
+	return retval;
+}
+
+static int max9286_enum_mbus_code(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_state *sd_state,
+				  struct v4l2_subdev_mbus_code_enum *code)
+{
+	struct sensor_data *max9286_data = subdev_to_sensor_data(sd);
+
+	code->code = max9286_data->format.code;
+	return 0;
+}
+
+/*
+ * max9286_enum_framesizes - V4L2 sensor interface handler for
+ *			     VIDIOC_ENUM_FRAMESIZES ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @fsize: standard V4L2 VIDIOC_ENUM_FRAMESIZES ioctl structure
+ *
+ * Return 0 if successful, otherwise -EINVAL.
+ */
+static int max9286_enum_framesizes(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_state *sd_state,
+				   struct v4l2_subdev_frame_size_enum *fse)
+{
+	if (fse->index > ov10635_mode_MAX)
+		return -EINVAL;
+
+	fse->max_width = max(ov10635_mode_info_data[0][fse->index].width,
+			     ov10635_mode_info_data[1][fse->index].width);
+	fse->min_width = fse->max_width;
+
+	fse->max_height = max(ov10635_mode_info_data[0][fse->index].height,
+			      ov10635_mode_info_data[1][fse->index].height);
+	fse->min_height = fse->max_height;
+
+	return 0;
+}
+
+static int max9286_enum_frame_interval(struct v4l2_subdev *sd,
+				       struct v4l2_subdev_state *sd_state,
+				       struct v4l2_subdev_frame_interval_enum *fie)
+{
+	int i, j, count;
+
+	if (fie->index > ov10635_mode_MAX)
+		return -EINVAL;
+
+	if (fie->width == 0 || fie->height == 0 || fie->code == 0) {
+		pr_warn("Please assign pixel format, width and height.\n");
+		return -EINVAL;
+	}
+
+	fie->interval.numerator = 1;
+
+	 /* TODO Reserved to extension */
+	count = 0;
+	for (i = 0; i < ARRAY_SIZE(ov10635_framerates); i++) {
+		for (j = 0; j < (ov10635_mode_MAX + 1); j++) {
+			if (fie->width == ov10635_mode_info_data[i][j].width &&
+			    fie->height == ov10635_mode_info_data[i][j].height &&
+			    ov10635_mode_info_data[i][j].init_data_ptr)
+				count++;
+
+			if (fie->index == (count - 1)) {
+				fie->interval.denominator = ov10635_framerates[i];
+				return 0;
+			}
+		}
+	}
+
+	return -EINVAL;
+}
+
+static int max9286_get_fmt(struct v4l2_subdev *sd,
+			   struct v4l2_subdev_state *sd_state,
+			   struct v4l2_subdev_format *fmt)
+{
+	struct sensor_data *max9286_data = subdev_to_sensor_data(sd);
+	struct v4l2_mbus_framefmt *mf = &fmt->format;
+
+	if (fmt->pad)
+		return -EINVAL;
+
+	mf->code        = max9286_data->format.code;
+	mf->width       = max9286_data->format.width;
+	mf->height      = max9286_data->format.height;
+	mf->colorspace  = max9286_data->format.colorspace;
+	mf->field       = max9286_data->format.field;
+	mf->reserved[0] = max9286_data->format.reserved[0];
+
+	return 0;
+}
+
+static struct ov10635_mode_info *get_max_resolution(enum ov10635_frame_rate rate)
+{
+	u32 max_width;
+	enum ov10635_mode mode;
+	int i;
+
+	mode = 0;
+	max_width  = ov10635_mode_info_data[rate][0].width;
+
+	for (i = 0; i < (ov10635_mode_MAX + 1); i++) {
+		if (ov10635_mode_info_data[rate][i].width > max_width) {
+			max_width = ov10635_mode_info_data[rate][i].width;
+			mode = i;
+		}
+	}
+	return &ov10635_mode_info_data[rate][mode];
+}
+
+static struct ov10635_mode_info *match(struct v4l2_mbus_framefmt *fmt,
+				       enum ov10635_frame_rate rate)
+{
+	struct ov10635_mode_info *info;
+	int i;
+
+	for (i = 0; i < (ov10635_mode_MAX + 1); i++) {
+		if (fmt->width == ov10635_mode_info_data[rate][i].width &&
+		    fmt->height == ov10635_mode_info_data[rate][i].height) {
+			info = &ov10635_mode_info_data[rate][i];
+			break;
+		}
+	}
+	if (i == ov10635_mode_MAX + 1)
+		info = NULL;
+
+	return info;
+}
+
+static bool try_to_find_resolution(struct sensor_data *sensor,
+				   const enum ov10635_frame_rate fr,
+				   struct v4l2_mbus_framefmt *mf)
+{
+	enum ov10635_mode mode = sensor->current_mode;
+	enum ov10635_frame_rate frame_rate = fr;
+	struct device *dev = &sensor->i2c_client->dev;
+	struct ov10635_mode_info *info;
+	bool found = false;
+
+	if ((mf->width == ov10635_mode_info_data[frame_rate][mode].width) &&
+	    (mf->height == ov10635_mode_info_data[frame_rate][mode].height)) {
+			info = &ov10635_mode_info_data[frame_rate][mode];
+			found = true;
+	} else {
+		/* get mode info according to frame user's width and height */
+		info = match(mf, frame_rate);
+		if (!info) {
+			frame_rate ^= 0x1;
+			info = match(mf, frame_rate);
+			if (info) {
+				sensor->current_mode = -1;
+				dev_err(dev, "%s %dx%d only support %s(fps)\n",
+					__func__,
+					info->width, info->height,
+					(frame_rate == 0) ? "15fps" : "30fps");
+				return false;
+			}
+			goto max_resolution;
+		}
+		found = true;
+	}
+
+	/* get max resolution to resize */
+max_resolution:
+	if (!found) {
+		frame_rate ^= 0x1;
+		info = get_max_resolution(frame_rate);
+	}
+
+	sensor->current_mode = info->mode;
+	sensor->frame_interval.denominator = (frame_rate) ? 30 : 15;
+	sensor->format.width  = info->width;
+	sensor->format.height = info->height;
+
+	return found;
+}
+
+static int max9286_set_fmt(struct v4l2_subdev *sd,
+			   struct v4l2_subdev_state *sd_state,
+			   struct v4l2_subdev_format *fmt)
+{
+	struct sensor_data *max9286_data = subdev_to_sensor_data(sd);
+	struct v4l2_mbus_framefmt *mf = &fmt->format;
+	enum ov10635_frame_rate frame_rate = max9286_data->current_fr;
+	int ret;
+
+	if (fmt->pad)
+		return -EINVAL;
+
+	mf->code       = max9286_data->format.code;
+	mf->colorspace = max9286_data->format.colorspace;
+	mf->field      = V4L2_FIELD_NONE;
+
+	try_to_find_resolution(max9286_data, frame_rate, mf);
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY)
+		return 0;
+
+	ret = ov10635_change_mode(max9286_data);
+
+	return ret;
+}
+
+static int max9286_get_frame_desc(struct v4l2_subdev *sd, unsigned int pad,
+				  struct v4l2_mbus_frame_desc *fd)
+{
+	return 0;
+}
+
+static int max9286_set_frame_desc(struct v4l2_subdev *sd,
+				  unsigned int pad,
+				  struct v4l2_mbus_frame_desc *fd)
+{
+	return 0;
+}
+
+static int max9286_set_power(struct v4l2_subdev *sd, int on)
+{
+	return 0;
+}
+
+static int ov10635_try_frame_interval(struct sensor_data *sensor,
+				      struct v4l2_fract *fi,
+				      u32 width, u32 height)
+{
+	enum ov10635_frame_rate rate = OV10635_15_FPS;
+	int minfps, maxfps, best_fps, fps;
+	int i;
+
+	minfps = ov10635_framerates[OV10635_15_FPS];
+	maxfps = ov10635_framerates[OV10635_30_FPS];
+
+	if (fi->numerator == 0) {
+		fi->denominator = ov10635_framerates[OV10635_30_FPS];
+		fi->numerator = 1;
+		rate = OV10635_30_FPS;
+		goto out;
+	}
+
+	fps = clamp_val(DIV_ROUND_CLOSEST(fi->denominator, fi->numerator),
+			minfps, maxfps);
+
+	best_fps = minfps;
+	for (i = 0; i < ARRAY_SIZE(ov10635_framerates); i++) {
+		int curr_fps = ov10635_framerates[i];
+
+		if (abs(curr_fps - fps) < abs(best_fps - fps)) {
+			best_fps = curr_fps;
+			rate = i;
+		}
+	}
+
+	fi->numerator = 1;
+	fi->denominator = best_fps;
+
+out:
+	return rate;
+}
+
+static int max9286_g_frame_interval(struct v4l2_subdev *sd,
+				    struct v4l2_subdev_frame_interval *fi)
+{
+	struct sensor_data *max9286_data = subdev_to_sensor_data(sd);
+
+	mutex_lock(&max9286_data->lock);
+	fi->interval = max9286_data->frame_interval;
+	mutex_unlock(&max9286_data->lock);
+
+	return 0;
+}
+
+static int max9286_s_frame_interval(struct v4l2_subdev *sd,
+				    struct v4l2_subdev_frame_interval *fi)
+{
+	struct sensor_data *max9286_data = subdev_to_sensor_data(sd);
+	enum ov10635_mode mode = max9286_data->current_mode;
+	enum ov10635_frame_rate fr = max9286_data->current_fr;
+	struct v4l2_mbus_framefmt mf;
+	bool found = false;
+	int frame_rate, ret = 0;
+
+	if (fi->pad != 0)
+		return -EINVAL;
+
+	mutex_lock(&max9286_data->lock);
+
+	memset(&mf, 0, sizeof(mf));
+	mf.width  = ov10635_mode_info_data[fr][mode].width;
+	mf.height = ov10635_mode_info_data[fr][mode].height;
+	frame_rate = ov10635_try_frame_interval(max9286_data, &fi->interval,
+						mf.width, mf.height);
+	if (frame_rate < 0) {
+		fi->interval = max9286_data->frame_interval;
+		goto out;
+	}
+
+	mf.width  = ov10635_mode_info_data[frame_rate][mode].width;
+	mf.height = ov10635_mode_info_data[frame_rate][mode].height;
+	found = try_to_find_resolution(max9286_data, frame_rate, &mf);
+	if (!found) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	max9286_data->current_fr = frame_rate;
+	max9286_data->frame_interval = fi->interval;
+
+out:
+	mutex_unlock(&max9286_data->lock);
+	return ret;
+}
+
+static int max9286_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct sensor_data *max9286_data = subdev_to_sensor_data(sd);
+
+	dev_dbg(sd->dev, "%s\n", __func__);
+	if (enable) {
+		if (!max9286_data->running++) {
+			/*
+			 * Enable CSI output, set virtual channel
+			 * according to the link number
+			 */
+			max9286_write_reg(max9286_data, 0x15, 0x9B);
+		}
+
+	} else {
+
+		if (!--max9286_data->running) {
+			/* Disable CSI Output */
+			max9286_write_reg(max9286_data, 0x15, 0x03);
+		}
+	}
+
+	return 0;
+}
+
+static int max9286_link_setup(struct media_entity *entity,
+			      const struct media_pad *local,
+			      const struct media_pad *remote,
+			      u32 flags)
+{
+	return 0;
+}
+
+static const struct v4l2_subdev_pad_ops max9286_pad_ops = {
+	.enum_mbus_code		= max9286_enum_mbus_code,
+	.enum_frame_size	= max9286_enum_framesizes,
+	.enum_frame_interval	= max9286_enum_frame_interval,
+	.get_fmt		= max9286_get_fmt,
+	.set_fmt		= max9286_set_fmt,
+	.get_frame_desc		= max9286_get_frame_desc,
+	.set_frame_desc		= max9286_set_frame_desc,
+};
+
+static const struct v4l2_subdev_core_ops max9286_core_ops = {
+	.s_power	= max9286_set_power,
+};
+
+static const struct v4l2_subdev_video_ops max9286_video_ops = {
+	.g_frame_interval = max9286_g_frame_interval,
+	.s_frame_interval = max9286_s_frame_interval,
+	.s_stream	  = max9286_s_stream,
+};
+
+static const struct v4l2_subdev_ops max9286_subdev_ops = {
+	.core	= &max9286_core_ops,
+	.pad	= &max9286_pad_ops,
+	.video	= &max9286_video_ops,
+};
+
+static const struct media_entity_operations max9286_sd_media_ops = {
+	.link_setup = max9286_link_setup,
+};
+
+ssize_t analog_test_pattern_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct v4l2_subdev *sd = dev_get_drvdata(dev);
+	struct sensor_data *max9286_data = subdev_to_sensor_data(sd);
+	u8 val = 0;
+
+	ov10635_read_reg(max9286_data, 0, 0x370A, &val);
+	return sprintf(buf, "%s\n", (val & 0x4) ? "enabled" : "disabled");
+}
+
+static ssize_t analog_test_pattern_store(struct device *dev,
+					 struct device_attribute *attr,
+					 const char *buf, size_t count)
+{
+	struct v4l2_subdev *sd = dev_get_drvdata(dev);
+	struct sensor_data *max9286_data = subdev_to_sensor_data(sd);
+	char enabled[32];
+
+	if (sscanf(buf, "%s", enabled) > 0) {
+		if (strcmp(enabled, "enable") == 0)
+			ov10635_write_reg(max9286_data, 0, 0x370A, 0x4);
+		else
+			ov10635_write_reg(max9286_data, 0, 0x370A, 0x0);
+		return count;
+	}
+	return -EINVAL;
+}
+
+static DEVICE_ATTR_RW(analog_test_pattern);
+
+/*!
+ * max9286 I2C probe function
+ *
+ * @param adapter            struct i2c_adapter *
+ * @return  Error code indicating success or failure
+ */
+static int max9286_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct device *dev = &client->dev;
+	struct sensor_data *max9286_data;
+	struct v4l2_subdev *sd;
+	int retval;
+
+	max9286_data = devm_kzalloc(dev, sizeof(*max9286_data), GFP_KERNEL);
+	if (!max9286_data)
+		return -ENOMEM;
+
+	/* Set initial values for the sensor struct. */
+	max9286_data->sensor_clk = devm_clk_get(dev, "capture_mclk");
+	if (IS_ERR(max9286_data->sensor_clk)) {
+		/* assuming clock enabled by default */
+		dev_err(dev, "clock-frequency missing or invalid\n");
+		return PTR_ERR(max9286_data->sensor_clk);
+	}
+
+	retval = of_property_read_u32(dev->of_node, "mclk", &max9286_data->mclk);
+	if (retval) {
+		dev_err(dev, "mclk missing or invalid\n");
+		return retval;
+	}
+
+	retval = of_property_read_u32(dev->of_node, "mclk_source", (u32 *)&max9286_data->mclk_source);
+	if (retval) {
+		dev_err(dev, "mclk_source missing or invalid\n");
+		return retval;
+	}
+
+	/* request power down pin */
+	max9286_data->pwn_gpio = devm_gpiod_get_optional(dev, "pwn-gpios",
+							GPIOD_OUT_HIGH);
+	if (IS_ERR(max9286_data->pwn_gpio))
+		return PTR_ERR(max9286_data->pwn_gpio);
+
+	max9286_hw_reset(max9286_data);
+
+	clk_prepare_enable(max9286_data->sensor_clk);
+
+	mutex_init(&max9286_data->lock);
+
+	max9286_data->i2c_client        = client;
+	max9286_data->format.code       = MEDIA_BUS_FMT_YUYV8_1X16;
+	max9286_data->format.width      = ov10635_mode_info_data[1][0].width;
+	max9286_data->format.height     = ov10635_mode_info_data[1][0].height;
+	max9286_data->format.colorspace = V4L2_COLORSPACE_JPEG;
+
+	/*
+	 * Pass mipi phy clock rate Mbps
+	 * fcsi2 = PCLk * WIDTH * CHANNELS / LANES
+	 * fsci2 = 72MPCLK * 8 bit * 4 channels / 4 lanes
+	 */
+	max9286_data->format.reserved[0] = 72 * 8;
+	max9286_data->format.field = V4L2_FIELD_NONE;
+	max9286_data->current_mode = 0;
+	max9286_data->frame_interval.denominator = 30;
+	max9286_data->frame_interval.numerator = 1;
+	max9286_data->is_mipi = 1;
+
+	retval = max9286_read_reg(max9286_data, 0x1e);
+	if (retval != 0x40) {
+		pr_warn("max9286 is not found, chip id reg 0x1e = 0x(%x)\n", retval);
+		clk_disable_unprepare(max9286_data->sensor_clk);
+		return -ENODEV;
+	}
+
+	max9286_hardware_preinit(max9286_data);
+
+	if  (max9286_data->sensor_num == 0) {
+		pr_warn("cameras are not found,\n");
+		clk_disable_unprepare(max9286_data->sensor_clk);
+		return -ENODEV;
+	}
+
+	max9286_data->frame_interval.denominator = 30;
+	max9286_data->frame_interval.numerator   = 1;
+	max9286_data->v_channel = 0;
+	max9286_data->cap_mode.clip_top  = 0;
+	max9286_data->cap_mode.clip_left = 0;
+
+	max9286_data->cap_mode.clip_height = 800;
+	max9286_data->cap_mode.clip_width  = 1280;
+
+	max9286_data->cap_mode.hlen = max9286_data->cap_mode.clip_width;
+
+	max9286_data->cap_mode.hfp   = 0;
+	max9286_data->cap_mode.hbp   = 0;
+	max9286_data->cap_mode.hsync = 625;
+	max9286_data->cap_mode.vlen  = 800;
+	max9286_data->cap_mode.vfp   = 0;
+	max9286_data->cap_mode.vbp   = 0;
+	max9286_data->cap_mode.vsync = 40;
+	max9286_data->cap_mode.vlen1 = 0;
+	max9286_data->cap_mode.vfp1  = 0;
+	max9286_data->cap_mode.vbp1  = 0;
+	max9286_data->cap_mode.vsync1 = 0;
+	max9286_data->cap_mode.pixelclock = 27000000;
+
+	sd = &max9286_data->subdev;
+	v4l2_i2c_subdev_init(sd, client, &max9286_subdev_ops);
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	sd->entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	max9286_data->pads[MIPI_CSI2_SENS_VC0_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	max9286_data->pads[MIPI_CSI2_SENS_VC1_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	max9286_data->pads[MIPI_CSI2_SENS_VC2_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	max9286_data->pads[MIPI_CSI2_SENS_VC3_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	retval = media_entity_pads_init(&sd->entity, MIPI_CSI2_SENS_VCX_PADS_NUM,
+					max9286_data->pads);
+	if (retval < 0)
+		return retval;
+
+	max9286_data->subdev.entity.ops = &max9286_sd_media_ops;
+	retval = v4l2_async_register_subdev(&max9286_data->subdev);
+	if (retval < 0) {
+		dev_err(dev, "Async register failed, ret=(%d)\n", retval);
+		media_entity_cleanup(&sd->entity);
+	}
+
+	retval = max9286_hardware_init(max9286_data);
+	if (retval < 0) {
+		dev_err(dev, "camera init failed\n");
+		clk_disable_unprepare(max9286_data->sensor_clk);
+		media_entity_cleanup(&sd->entity);
+		v4l2_async_unregister_subdev(sd);
+		return retval;
+	}
+
+	max9286_data->running = 0;
+
+	/* Disable CSI Output */
+	max9286_write_reg(max9286_data, 0x15, 0x03);
+
+	/*Create device attr in sys */
+	retval = device_create_file(&client->dev, &dev_attr_analog_test_pattern);
+	if (retval < 0) {
+		dev_err(dev, "%s: create device file fail\n", __func__);
+		return retval;
+	}
+
+	dev_info(dev, "max9286_mipi is found, name %s\n", sd->name);
+	return retval;
+}
+
+/*!
+ * max9286 I2C detach function
+ *
+ * @param client            struct i2c_client *
+ * @return  Error code indicating success or failure
+ */
+static int max9286_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct sensor_data *max9286_data = subdev_to_sensor_data(sd);
+
+	clk_disable_unprepare(max9286_data->sensor_clk);
+	device_remove_file(&client->dev, &dev_attr_analog_test_pattern);
+	media_entity_cleanup(&sd->entity);
+	v4l2_async_unregister_subdev(sd);
+
+	return 0;
+}
+
+static const struct i2c_device_id max9286_id[] = {
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, max9286_id);
+
+static const struct of_device_id max9286_of_match[] = {
+	{ .compatible = "maxim,max9286_mipi" },
+	{ /* sentinel */ }
+};
+
+static struct i2c_driver max9286_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name   = "max9286_mipi",
+		.of_match_table	= of_match_ptr(max9286_of_match),
+	},
+	.probe  = max9286_probe,
+	.remove = max9286_remove,
+	.id_table = max9286_id,
+};
+
+module_i2c_driver(max9286_i2c_driver);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("MAX9286 GSML Deserializer Driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1.0");
+MODULE_ALIAS("CSI");
diff --git a/drivers/staging/media/imx/hdmirx/Kconfig b/drivers/staging/media/imx/hdmirx/Kconfig
new file mode 100644
index 000000000..f36250388
--- /dev/null
+++ b/drivers/staging/media/imx/hdmirx/Kconfig
@@ -0,0 +1,6 @@
+config MHDP_HDMIRX
+	tristate "Cadence MHDP HDMIRX Controller"
+
+config MHDP_HDMIRX_CEC
+	tristate "Cadence MHDP HDMIRX CEC"
+	select DRM_CDNS_HDMI_CEC
diff --git a/drivers/staging/media/imx/hdmirx/Makefile b/drivers/staging/media/imx/hdmirx/Makefile
new file mode 100644
index 000000000..cf85cdc01
--- /dev/null
+++ b/drivers/staging/media/imx/hdmirx/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_MHDP_HDMIRX) += cdns-mhdp-hdmirx.o cdns-hdmirx-hdcp.o cdns-hdmirx-hw.o \
+			cdns-hdmirx-phy.o cdns-hdmirx-audio.o cdns-hdmirx.o
diff --git a/drivers/staging/media/imx/hdmirx/cdns-hdmirx-audio.c b/drivers/staging/media/imx/hdmirx/cdns-hdmirx-audio.c
new file mode 100644
index 000000000..e4c7f0b64
--- /dev/null
+++ b/drivers/staging/media/imx/hdmirx/cdns-hdmirx-audio.c
@@ -0,0 +1,185 @@
+/*
+ * Copyright 2020 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/kthread.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/component.h>
+#include <linux/mfd/syscon.h>
+#include <linux/of.h>
+#include <linux/irq.h>
+#include <linux/of_device.h>
+#include <linux/hdmi.h>
+#include <sound/hdmi-codec.h>
+
+#include "cdns-mhdp-hdmirx.h"
+
+static int get_audio_infoframe(struct cdns_hdmirx_device *hdmirx, unsigned int *chan,
+			       u16 timeout_ms)
+{
+	u8 buffer[32];
+	int ret;
+
+	ret = infoframe_poll(hdmirx, HDMI_INFOFRAME_TYPE_AUDIO,
+			     buffer, timeout_ms);
+	if (ret == 0)
+		*chan = (buffer[HDMI_INFOFRAME_HEADER_SIZE+1] & 0x07) + 1;
+
+	pr_info("AUDIOIF: ch:%d\n", *chan);
+
+	return ret;
+}
+
+static u32 TMDS_rate_table[7] = {
+25200, 27000, 54000, 74250, 148500, 297000, 594000,
+};
+
+static u32 N_table_32k[8] = {
+/*25200, 27000, 54000, 74250, 148500, 297000, 594000,*/
+4096, 4096, 4096, 4096, 4096, 3072, 3072, 4096,
+};
+
+static u32 N_table_44k[8] = {
+6272, 6272, 6272, 6272, 6272, 4704, 9408, 6272,
+};
+
+static u32 N_table_48k[8] = {
+6144, 6144, 6144, 6144, 6144, 5120, 6144, 6144,
+};
+
+static int select_rate(u32 pclk, u32 N)
+{
+	int i = 0;
+	int rate = 0;
+
+	for (i = 0; i < 7; i++) {
+		if (pclk == TMDS_rate_table[i])
+			break;
+	}
+
+	if (i == 7)
+		DRM_WARN("pclkc %d is not supported!\n", pclk);
+
+	if (N_table_32k[i] == N)
+		rate = 32000;
+
+	if (N_table_44k[i] == N)
+		rate = 44100;
+
+	if (N_table_44k[i] * 2 == N)
+		rate = 44100 * 2;
+
+	if (N_table_44k[i] * 4 == N)
+		rate = 44100 * 4;
+
+	if (N_table_48k[i] == N)
+		rate = 48000;
+
+	if (N_table_48k[i] * 2 == N)
+		rate = 48000 * 2;
+
+	if (N_table_48k[i] * 4 == N)
+		rate = 48000 * 4;
+
+	return rate;
+}
+
+static int hdmirx_audio(struct cdns_hdmirx_device *hdmirx)
+{
+	u32 regread;
+	u32 rate;
+	u32 chan = 2;
+	int status;
+	int ret;
+
+	if (hdmirx->initialized != true)
+		return -EINVAL;
+
+	ret = get_audio_infoframe(hdmirx, &chan, 100);
+	if (ret)
+		return ret;
+
+	status = cdns_hdmirx_audioautoconfig(hdmirx, chan, chan/2, 0, 32, 32);
+	if (status)
+		return -EINVAL;
+
+	regread = cdns_hdmirx_bus_read(hdmirx, AIF_ACR_N_ST);
+
+	rate = select_rate(hdmirx->timings->timings.bt.pixelclock/1000, regread);
+
+	hdmirx->channels = chan;
+	hdmirx->sample_rate = rate;
+
+	return 0;
+}
+
+/*
+ * HDMI audio codec callbacks
+ */
+static int hdmirx_audio_hw_params(struct device *dev, void *data,
+				    struct hdmi_codec_daifmt *daifmt,
+				    struct hdmi_codec_params *params)
+{
+	return 0;
+}
+
+static void hdmirx_audio_shutdown(struct device *dev, void *data)
+{
+	pm_runtime_put_sync(dev);
+}
+
+static int hdmirx_audio_startup(struct device *dev, void *data)
+{
+	struct cdns_hdmirx_device *hdmirx = dev_get_drvdata(dev);
+	int ret;
+
+	pm_runtime_get_sync(dev);
+	ret = hdmirx_audio(hdmirx);
+	return ret;
+}
+
+static int hdmirx_audio_get_eld(struct device *dev, void *data, uint8_t *buf, size_t len)
+{
+	struct cdns_hdmirx_device *hdmirx = dev_get_drvdata(dev);
+
+	if (len < 8)
+		return -EINVAL;
+
+	memcpy(buf, &hdmirx->sample_rate, 4);
+	memcpy(buf + 4, &hdmirx->channels, 4);
+
+	return 0;
+}
+
+static const struct hdmi_codec_ops hdmirx_audio_codec_ops = {
+	.hw_params = hdmirx_audio_hw_params,
+	.audio_shutdown = hdmirx_audio_shutdown,
+	.audio_startup = hdmirx_audio_startup,
+	.get_eld = hdmirx_audio_get_eld,
+};
+
+void cdns_hdmirx_register_audio_driver(struct device *dev)
+{
+	struct hdmi_codec_pdata codec_data = {
+		.ops = &hdmirx_audio_codec_ops,
+		.max_i2s_channels = 8,
+		.i2s = 1,
+	};
+	struct platform_device *pdev;
+
+	pdev = platform_device_register_data(dev, HDMI_CODEC_DRV_NAME,
+					     2, &codec_data,
+					     sizeof(codec_data));
+	if (IS_ERR(pdev))
+		return;
+
+	dev_err(dev, "%s driver bound to HDMI\n", HDMI_CODEC_DRV_NAME);
+}
diff --git a/drivers/staging/media/imx/hdmirx/cdns-hdmirx-hdcp.c b/drivers/staging/media/imx/hdmirx/cdns-hdmirx-hdcp.c
new file mode 100644
index 000000000..0c29ecaba
--- /dev/null
+++ b/drivers/staging/media/imx/hdmirx/cdns-hdmirx-hdcp.c
@@ -0,0 +1,172 @@
+/*
+ * Copyright 2020 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+#include "cdns-mhdp-hdmirx.h"
+
+static int hdcprx_setconfig(struct cdns_hdmirx_device *hdmirx,
+			 struct hdcprx_config *cfg)
+{
+	u8 msg[3];
+
+	msg[0] = cfg->activate;
+	msg[0] |= cfg->version << 1;
+	msg[0] |= cfg->repeater << 3;
+	msg[0] |= cfg->use_secondary_link << 4;
+	msg[0] |= cfg->use_km_key << 5;
+	msg[1] = cfg->bcaps;
+	msg[2] = cfg->bstatus;
+
+	return cdns_hdmirx_mailbox_send(hdmirx, MB_MODULE_ID_HDCP_RX,
+				      HDCP_RX_SET_CONFIG, 3, msg);
+}
+
+static int hdcprx_getstatus(struct cdns_hdmirx_device *hdmirx,
+			 struct hdcprx_status *status)
+{
+	int ret;
+
+	ret = cdns_hdmirx_mailbox_send(hdmirx, MB_MODULE_ID_HDCP_RX,
+				      HDCP_RX_GET_STATUS, 0, NULL);
+	if (ret)
+		goto err_get_sts;
+
+	ret = cdns_hdmirx_mailbox_validate_receive(hdmirx, MB_MODULE_ID_HDCP_RX,
+						 HDCP_RX_GET_STATUS, sizeof(struct hdcprx_status));
+	if (ret)
+		goto err_get_sts;
+
+	ret = cdns_hdmirx_mailbox_read_receive(hdmirx, (u8 *)status, sizeof(struct hdcprx_status));
+	if (ret)
+		goto err_get_sts;
+
+err_get_sts:
+	if (ret)
+		dev_err(&hdmirx->pdev->dev, "hdcp rx status req failed: %d\n", ret);
+	return ret;
+}
+
+static int hdcprx_notsync(struct cdns_hdmirx_device *hdmirx)
+{
+	return cdns_hdmirx_mailbox_send(hdmirx, MB_MODULE_ID_HDCP_RX,
+				      HDCP_RX_NOT_SYNC, 0, NULL);
+}
+
+void cdns_hdcprx_enable(struct cdns_hdmirx_device *hdmirx)
+{
+    int ret;
+	int version = HDCPRX_VERSION_2;
+	struct hdcprx_config config = { 0 };
+
+	config.activate = 1;
+	config.version = version;
+	config.repeater = 0;
+	config.use_secondary_link = 0;
+	config.use_km_key = 1;
+	config.bcaps = 0x80;
+	config.bstatus = 0x1000; /* HDMI mode */
+
+	/* This was handled by the SECO */
+	ret = hdcprx_setconfig(hdmirx, &config);
+	if (ret)
+		dev_warn(&hdmirx->pdev->dev, "%s(), could not enable the HDCP\n", __func__);
+}
+
+void cdns_hdcprx_disable(struct cdns_hdmirx_device *hdmirx)
+{
+	int ret;
+	int version = HDCPRX_VERSION_2;
+	struct hdcprx_config config = { 0 };
+
+	config.activate = 0;
+	config.version = version;
+	config.repeater = 0;
+	config.use_secondary_link = 0;
+	config.use_km_key = 0;
+	config.bcaps = 0x00;
+	config.bstatus = 0x1000; /* HDMI mode */
+
+	/* This was handled by the SECO */
+	ret = hdcprx_setconfig(hdmirx, &config);
+	if (ret)
+		dev_warn(&hdmirx->pdev->dev, "%s(), could not disable the HDCP\n", __func__);
+}
+
+int cdns_hdcprx_get_status(struct cdns_hdmirx_device *hdmirx,
+			   struct hdcprx_status *status)
+{
+	/* TODO: implement HDCP status checking if needed */
+	memset(status, 0, sizeof(struct hdcprx_status));
+
+	return hdcprx_getstatus(hdmirx, status);
+}
+
+int cdns_hdcprx_wait_auth_complete(struct cdns_hdmirx_device *hdmirx, u16 timeout_ms)
+{
+	struct hdcprx_status status;
+	u8 key_arrived;
+	ktime_t timeout = ktime_timeout_ms(timeout_ms);
+
+	dev_dbg(&hdmirx->pdev->dev, "Wait for HDCP authentication to complete\n");
+	do {
+		if (!cdns_hdcprx_get_status(hdmirx, &status)) {
+			dev_dbg(&hdmirx->pdev->dev, "Failed to get HDCP status\n");
+			return -1;
+		}
+		if (ktime_after(ktime_get(), timeout)) {
+			dev_dbg(&hdmirx->pdev->dev, "Timed out waiting for HDCP authentication to complete\n");
+			return -1;
+		}
+		key_arrived = status.flags & 0x1;
+		msleep(10);
+	} while (key_arrived == 0);
+
+    /* Clear out error register */
+	cdns_hdmirx_reg_read(hdmirx, PKT_ERR_CNT_HEADER);
+
+    return 0;
+}
+
+static int hdmirx_hdcp_print_status(struct cdns_hdmirx_device *hdmirx)
+{
+	struct hdcprx_status status;
+	int ret;
+
+	ret = cdns_hdcprx_get_status(hdmirx, &status);
+	if (!ret) {
+	    dev_info(&hdmirx->pdev->dev, "HCDP key_arrived 0x%02x\n", status.flags & 1);
+	    dev_info(&hdmirx->pdev->dev, "HCDP hdcp_ver    0x%02x\n", (status.flags >> 1) & 0x3);
+	    dev_info(&hdmirx->pdev->dev, "HCDP error       0x%02x\n", (status.flags >> 4) & 0xF);
+	    dev_info(&hdmirx->pdev->dev, "HCDP aksv[] 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x\n",
+		    status.aksv[0],
+		    status.aksv[1],
+		    status.aksv[2],
+		    status.aksv[3],
+		    status.aksv[4]);
+	    dev_info(&hdmirx->pdev->dev, "HCDP ainfo      0x%02x\n", status.ainfo);
+	}
+
+	return ret;
+}
+
+/* As above but wait for completion */
+int cdns_hdcprx_reauth_req_wait(struct cdns_hdmirx_device *hdmirx, u16 timeout_ms)
+{
+	int ret;
+
+	ret = hdcprx_notsync(hdmirx);
+	if (ret) {
+		dev_info(&hdmirx->pdev->dev, "%s(), could not request reauthentication for the HDCP\n", __func__);
+		return ret;
+	} else
+		dev_info(&hdmirx->pdev->dev, "%s(), requested HDCP re-authentication\n", __func__);
+	cdns_hdcprx_wait_auth_complete(hdmirx, timeout_ms);
+	ret = hdmirx_hdcp_print_status(hdmirx);
+
+    return ret;
+}
diff --git a/drivers/staging/media/imx/hdmirx/cdns-hdmirx-hw.c b/drivers/staging/media/imx/hdmirx/cdns-hdmirx-hw.c
new file mode 100644
index 000000000..c2150b22a
--- /dev/null
+++ b/drivers/staging/media/imx/hdmirx/cdns-hdmirx-hw.c
@@ -0,0 +1,984 @@
+/*
+ * Copyright 2018-2020 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#include "cdns-mhdp-hdmirx.h"
+#include "cdns-hdmirx-phy.h"
+
+#include <asm/unaligned.h>
+#include <linux/firmware.h>
+#include <linux/ktime.h>
+
+u8 block0[128] = {
+	0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00,
+	0x3B, 0x10, 0x01, 0x00, 0x9B, 0x5F, 0x02, 0x00,
+	0x19, 0x1C, 0x01, 0x03, 0x81, 0x3C, 0x22, 0x78,
+	0x9F, 0x30, 0x35, 0xA7, 0x55, 0x4E, 0xA3, 0x26,
+	0x0F, 0x50, 0x54, 0x20, 0x00, 0x00, 0x01, 0x01,
+	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x3A,
+	0x80, 0x18, 0x71, 0x38, 0x2D, 0x40, 0x58, 0x2C,
+	0x45, 0x00, 0x20, 0xC2, 0x31, 0x00, 0x00, 0x1E,
+	0x04, 0x74, 0x00, 0x30, 0xF2, 0x70, 0x5A, 0x80,
+	0xB0, 0x58, 0x8A, 0x00, 0x20, 0xC2, 0x31, 0x00,
+	0x00, 0x1E, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x18,
+	0x3D, 0x19, 0x87, 0x1E, 0x00, 0x0A, 0x20, 0x20,
+	0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFC,
+	0x00, 0x4E, 0x58, 0x50, 0x20, 0x69, 0x4D, 0x58,
+	0x38, 0x51, 0x4D, 0x0A, 0x20, 0x20, 0x01, 0x8E,
+};
+
+u8 block1[128] = {
+
+	0x02, 0x03, 0x21, 0x71, 0x46, 0x91, 0x04, 0x03,
+	0x13, 0x1F, 0x10, 0x23, 0x09, 0x07, 0x07, 0x6D,
+	0x03, 0x0C, 0x00, 0x10, 0x00, 0x00, 0x3C, 0x20,
+	0x00, 0x60, 0x01, 0x02, 0x03, 0x83, 0x01, 0x00,
+	0x00, 0x04, 0x74, 0x00, 0x30, 0xF2, 0x70, 0x5A,
+	0x80, 0xB0, 0x58, 0x8A, 0x00, 0x20, 0xC2, 0x31,
+	0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x96,
+};
+
+struct S_HDMI_SCDC_SET_MSG scdcexampledata = {
+	.sink_ver = 1,
+	.manufacturer_oui_1 = 0x1,
+	.manufacturer_oui_2 = 0x2,
+	.manufacturer_oui_3 = 0x3,
+	.devId = {1, 2, 3, 4, 5, 6, 7, 8},
+	.hardware_major_rev = 12,
+	.hardware_minor_rev = 13,
+	.software_major_rev = 0xAB,
+	.software_minor_rev = 0XBC,
+	.manufacturerSpecific = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
+	     20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34}
+};
+
+#define FW_IRAM_OFFSET		0x2000
+#define FW_IRAM_SIZE		0x10000
+#define FW_DRAM_SIZE		0x8000
+
+int infoframe_poll(struct cdns_hdmirx_device *hdmirx, u8 type, u8 *buf, u16 timeout_ms)
+{
+	ktime_t timeout;
+
+	u32 reg;
+	int ret = -1;
+	u8 i, cs;
+
+	mutex_lock(&hdmirx->pif_mutex);
+
+	timeout = ktime_timeout_ms(timeout_ms);
+
+	/* Packet type to wait for so we don't get anything unexpected
+	 * while we are invalidating packets.
+	 * We only use one infoframe check location, but we keep TYPE1
+	 * to mop up some strange behaviour of some sources with 0x00
+	 * types...
+	 */
+	cdns_hdmirx_bus_write(F_INFO_TYPE1(0x00) | F_INFO_TYPE2(0x00),
+					hdmirx, PKT_INFO_TYPE_CFG1);
+
+	/* Enable masking of invalid packets */
+	cdns_hdmirx_bus_write(1, hdmirx, PKT_TRANS_CTRL);
+
+	/*
+	 * Unmask interrupts for TYPE2 packet reception
+	 * and packet transfer PKT transfer complete
+	 */
+	cdns_hdmirx_bus_write(~0x10002, hdmirx, PKT_INT_MASK);
+
+	/* Read to clear any existing interrupts, don't care about these */
+	reg = cdns_hdmirx_bus_read(hdmirx, PKT_INT_STATUS);
+
+	/* Check cleared */
+	reg = cdns_hdmirx_bus_read(hdmirx, PKT_INT_STATUS);
+	if (reg > 0) {
+		dev_dbg(&hdmirx->pdev->dev, "Unexpected PKT_INT_STATUS 0,\
+					should be cleared after read, got 0x%08X\n", reg);
+		goto exit;
+	}
+
+	/* Invalidate existing packet data by setting all locations to 0xdeaddead*/
+	for (i = 0; i < 2; ++i)
+		cdns_hdmirx_bus_write(0xdeaddead, hdmirx, (PKT_INFO_HEADER + i * 4));
+
+	/* Trigger writing of above data into memory. */
+	cdns_hdmirx_bus_write(F_PACKET_RDN_WR(0x1) | F_PACKET_NUM(0x1), hdmirx, PKT_INFO_CTRL);
+
+	/* Wait for indication of process completion */
+	do {
+		reg = cdns_hdmirx_bus_read(hdmirx, PKT_INT_STATUS);
+		if (ktime_after(ktime_get(), timeout)) {
+			dev_dbg(&hdmirx->pdev->dev, "Infoframe poll failed to invalidate existing packet data\n");
+			goto exit;
+		}
+	} while (!(reg & (1 << 16)));
+	/* Check cleared */
+	reg = cdns_hdmirx_bus_read(hdmirx, PKT_INT_STATUS);
+	if (reg > 0) {
+		dev_dbg(&hdmirx->pdev->dev, "Unexpected PKT_INT_STATUS 1, should be cleared after read, got 0x%08X\n", reg);
+		goto exit;
+	}
+
+	/* Double check what we told controller to write,
+	 * this should be reflecting what we
+	 * wrote above and not the memory data yet...
+	*/
+	for (i = 0; i < 2; ++i) {
+		reg = cdns_hdmirx_bus_read(hdmirx, (PKT_INFO_HEADER + i * 4));
+		if (reg != 0xdeaddead)
+			dev_dbg(&hdmirx->pdev->dev, "Readback reg check for infoframe invalidation failed, got 0x%08X on word %d\n", reg, i);
+	}
+
+	/* Now do a readback check just to make sure the writes happened properly, this uses
+	 * the same process as above except we have RDN_WR set to 0 to indicate read*/
+	cdns_hdmirx_bus_write(F_PACKET_RDN_WR(0x0) | F_PACKET_NUM(0x1), hdmirx, PKT_INFO_CTRL);
+	/* Wait for indication of process completion */
+	do {
+		reg = cdns_hdmirx_bus_read(hdmirx, PKT_INT_STATUS);
+		if (ktime_after(ktime_get(), timeout)) {
+			dev_dbg(&hdmirx->pdev->dev, "Infoframe poll failed to readback packet data\n");
+			goto exit;
+		}
+	} while (!(reg & (1 << 16)));
+
+	/* Compare values */
+	for (i = 0; i < 2; ++i) {
+		reg = cdns_hdmirx_bus_read(hdmirx, (PKT_INFO_HEADER + i*4));
+		if (reg != 0xdeaddead)
+			dev_dbg(&hdmirx->pdev->dev, "Readback mem check for infoframe invalidation failed, got 0x%08X on word %d\n", reg, i);
+	}
+	/* Check cleared */
+	reg = cdns_hdmirx_bus_read(hdmirx, PKT_INT_STATUS);
+	if (reg > 0) {
+		dev_dbg(&hdmirx->pdev->dev, "Unexpected PKT_INT_STATUS 2, should be cleared after read, got 0x%08X\n", reg);
+		goto exit;
+	}
+
+	/* Set packet type to wait for */
+	cdns_hdmirx_bus_write(F_INFO_TYPE2(type), hdmirx, PKT_INFO_TYPE_CFG1);
+
+	/* Wait for Infoframe of TYPE2 type */
+	do {
+		reg = cdns_hdmirx_bus_read(hdmirx, PKT_INT_STATUS);
+		if (ktime_after(ktime_get(), timeout)) {
+			dev_dbg(&hdmirx->pdev->dev, "Infoframe poll did not see requested infoframe type 0x%02X\n", type);
+			goto exit;
+		}
+	} while (!(reg & (1 << 1)));
+
+	/* Check cleared */
+	reg = cdns_hdmirx_bus_read(hdmirx, PKT_INT_STATUS);
+	if (reg > 0) {
+		dev_dbg(&hdmirx->pdev->dev, "Unexpected PKT_INT_STATUS 3, should be cleared after read, got 0x%08X\n", reg);
+		goto exit;
+	}
+
+	/* Load Infoframe contents to registers */
+	cdns_hdmirx_bus_write(F_PACKET_RDN_WR(0x0) | F_PACKET_NUM(0x1), hdmirx, PKT_INFO_CTRL);
+	do {
+		reg = cdns_hdmirx_bus_read(hdmirx, PKT_INT_STATUS);
+		if (ktime_after(ktime_get(), timeout)) {
+			dev_dbg(&hdmirx->pdev->dev, "Infoframe poll failed to load packet data\n");
+			goto exit;
+		}
+	} while (!(reg & (1 << 16)));
+
+	/* Check cleared */
+	reg = cdns_hdmirx_bus_read(hdmirx, PKT_INT_STATUS);
+	if (reg > 0) {
+		dev_dbg(&hdmirx->pdev->dev, "Unexpected PKT_INT_STATUS 4, should be cleared after read, got 0x%08X\n", reg);
+		goto exit;
+	}
+
+	/* Read data */
+	for (i = 0; i < 8; ++i) {
+		reg = cdns_hdmirx_bus_read(hdmirx, PKT_INFO_HEADER + i * 4);
+		put_unaligned_le32(reg, buf + i * 4);
+	}
+
+	if (buf[0] != type)
+		dev_dbg(&hdmirx->pdev->dev, "Infoframe buf[0] read did not match type 0x%02X got 0x%02X\n", type, buf[0]);
+
+	/* Check if InfoFrame size is within maximum range */
+	if (buf[2] > 31) {
+		dev_dbg(&hdmirx->pdev->dev, "Infoframe poll size exceeds maximum range\n");
+		goto exit;
+	}
+	/* Veryfy checksum */
+	for (cs = 0, i = 0; i < 5 + buf[2]; ++i)
+		cs += buf[i];
+	if (cs) {
+		dev_dbg(&hdmirx->pdev->dev, "Infoframe poll checksum check failed\n");
+		goto exit;
+	}
+
+	ret = 0;
+
+exit:
+	/* Disable and clear interrupts */
+	cdns_hdmirx_bus_write(~0x00000, hdmirx, PKT_INT_MASK);
+	/* Disable detection of Infoframes */
+	cdns_hdmirx_bus_write(F_INFO_TYPE1(0x00) | F_INFO_TYPE2(0x00), hdmirx, PKT_INFO_TYPE_CFG1);
+	reg = cdns_hdmirx_bus_read(hdmirx, PKT_INT_STATUS);
+
+	mutex_unlock(&hdmirx->pif_mutex);
+
+	return ret;
+}
+
+/*
+ * Exemplary code to configure the controller for the AVI_InfoFrame reception.
+ * Returns -1 on error, 0 if AVI did not change, 1 if AVI changed.
+ */
+int cdns_hdmirx_get_avi_infoframe(struct cdns_hdmirx_device *hdmirx, u16 timeout_ms)
+{
+	int ret;
+	u8 buf[32];
+	/* AVI Data Byte 1 is at offset 5 */
+	u8 *avi = &buf[5];
+
+	/* Try to receive AVI */
+	ret = infoframe_poll(hdmirx, HDMI_INFOFRAME_TYPE_AVI, buf, timeout_ms);
+	if (ret < 0)
+		return -1;
+
+	/* Check if header is valid (version 2 only) */
+	if (buf[0] != 0x82 || buf[1] != 0x02 || buf[2] != 0x0D || buf[3] != 0) {
+		dev_dbg(&hdmirx->pdev->dev, "AVI Infoframe header is not valid, got %.2X %.2X %.2X %.2X\n",
+				buf[0], buf[1], buf[2], buf[3]);
+		dev_dbg(&hdmirx->pdev->dev, "--- Got: %.2X %.2X %.2X %.2X %.2X %.2X %.2X %.2X %.2X %.2X %.2X %.2X %.2X %.2X %.2X %.2X %.2X %.2X\n",
+			buf[0], buf[1], buf[2], buf[3], buf[4],
+			buf[5], buf[6], buf[7], buf[8], buf[9], buf[10], buf[11],
+			buf[12], buf[13], buf[14], buf[15], buf[16], buf[17]);
+		return -1;
+	}
+
+	/*
+	 * Check if received AVI differs from previous one.
+	 * Compare only data bytes 1-5.
+	 */
+	if (!memcmp(hdmirx->avi, avi, 5))
+		return 0;
+
+	dev_dbg(&hdmirx->pdev->dev, "--- avi infoframe new: %.2X %.2X %.2X %.2X %.2X %.2X %.2X %.2X %.2X %.2X %.2X %.2X %.2X %.2X %.2X %.2X %.2X %.2X\n",
+		buf[0], buf[1], buf[2], buf[3], buf[4],
+		buf[5], buf[6], buf[7], buf[8], buf[9], buf[10], buf[11],
+		buf[12], buf[13], buf[14], buf[15], buf[16], buf[17]);
+	dev_dbg(&hdmirx->pdev->dev, "--- avi infoframe old:                %.2X %.2X %.2X %.2X %.2X %.2X %.2X %.2X %.2X %.2X %.2X %.2X %.2X\n",
+		hdmirx->avi[0], hdmirx->avi[1], hdmirx->avi[2],
+		hdmirx->avi[3], hdmirx->avi[4], hdmirx->avi[5],
+		hdmirx->avi[6], hdmirx->avi[7], hdmirx->avi[8],
+		hdmirx->avi[9], hdmirx->avi[10], hdmirx->avi[11],
+		hdmirx->avi[12]);
+
+	memcpy(hdmirx->avi, avi, sizeof(hdmirx->avi));
+
+	hdmirx->vic_code = avi[3] & 0x7F; /* VIC value */
+	hdmirx->pixel_encoding = avi[0] >> 5 & 3; /* Y value */
+
+	return 1;
+}
+
+int cdns_hdmirx_get_vendor_infoframe(struct cdns_hdmirx_device *hdmirx, u16 timeout_ms)
+{
+	u32 ieee_oui;
+	int ret;
+	u8 buf[32];
+
+	dev_dbg(&hdmirx->pdev->dev, "%s\n", __func__);
+
+	/* Try to receive AVI */
+	ret = infoframe_poll(hdmirx, HDMI_INFOFRAME_TYPE_VENDOR, buf, timeout_ms);
+	if (ret < 0)
+		return -1;
+
+	/* Check if header is valid (version 1 only) */
+	if (buf[0] != 0x81 || buf[1] != 0x01) {
+		dev_dbg(&hdmirx->pdev->dev, "Vendor Infoframe header is not valid, got %.2X %.2X\n", buf[0], buf[1]);
+		return -1;
+	}
+
+	/*
+	 * Check if received Vnd differs from previous one.
+	 * Compare only data bytes 1-10.
+	 */
+	if (!memcmp(hdmirx->vnd, buf, 10))
+		return 0;
+
+	dev_dbg(&hdmirx->pdev->dev, "--- Vendor infoframe: %.2X %.2X %.2X %.2X %.2X %.2X %.2X %.2X %.2X %.2X %.2X %.2X %.2X %.2X %.2X %.2X",
+		buf[0], buf[1], buf[2], buf[3], buf[4],
+		buf[5], buf[6], buf[7], buf[8], buf[9], buf[10], buf[11],
+		buf[12], buf[13], buf[14], buf[15]);
+
+	dev_dbg(&hdmirx->pdev->dev, "---                 : %.2X %.2X %.2X %.2X %.2X %.2X %.2X %.2X %.2X %.2X %.2X %.2X %.2X %.2X %.2X %.2X",
+		buf[16], buf[16], buf[18], buf[19], buf[20],
+		buf[21], buf[22], buf[23], buf[24], buf[25], buf[26], buf[27],
+		buf[28], buf[29], buf[30], buf[31]);
+
+	memcpy(hdmirx->vnd, buf, sizeof(hdmirx->vnd));
+
+	ieee_oui = buf[5] | buf[6] << 8 | buf[7] << 16;
+
+	/* Get IEEE OUI */
+	if (ieee_oui == 0x000C03)
+		dev_info(&hdmirx->pdev->dev, "HDMI 1.4b Vendor Specific Infoframe\n");
+	else if (ieee_oui == 0xC45DD8)
+		dev_info(&hdmirx->pdev->dev, "HDMI 2.0 Vendor Specific Infoframe\n");
+	else
+		dev_err(&hdmirx->pdev->dev,
+			"Error Vendro Infoframe IEEE OUI=0x%6X\n", ieee_oui);
+
+	/* Extened resoluction format */
+	if ((buf[8] >> 5 & 0x07) == 1) {
+		hdmirx->hdmi_vic = buf[9];
+		dev_info(&hdmirx->pdev->dev, "hdmi_vic=%d\n", hdmirx->hdmi_vic);
+	}
+
+	return 1;
+}
+
+static void get_color_depth(struct cdns_hdmirx_device *hdmirx, int clk_ratio)
+{
+	u8 pixel_encoding = hdmirx->pixel_encoding;
+
+	hdmirx->color_depth = 8;
+
+	switch (pixel_encoding) {
+	case PIXEL_ENCODING_YUV422:
+		switch (clk_ratio) {
+		case CLK_RATIO_1_1:
+			hdmirx->color_depth = 8;
+			break;
+		case CLK_RATIO_5_4:
+		case CLK_RATIO_3_2:
+		case CLK_RATIO_2_1:
+		case CLK_RATIO_1_2:
+		case CLK_RATIO_5_8:
+		case CLK_RATIO_3_4:
+		default:
+			pr_err("YUV422 Not supported clk ration\n");
+		}
+		break;
+	case PIXEL_ENCODING_YUV420:
+		switch (clk_ratio) {
+		case CLK_RATIO_1_1:
+			hdmirx->color_depth = 16;
+			break;
+		case CLK_RATIO_1_2:
+			hdmirx->color_depth = 8;
+			break;
+		case CLK_RATIO_5_8:
+			hdmirx->color_depth = 10;
+			break;
+		case CLK_RATIO_3_4:
+			hdmirx->color_depth = 12;
+			break;
+		case CLK_RATIO_5_4:
+		case CLK_RATIO_3_2:
+		case CLK_RATIO_2_1:
+		default:
+			pr_err("YUV420 Not supported clk ration\n");
+		}
+		break;
+	default:		/* RGB/YUV444 */
+		switch (clk_ratio) {
+		case CLK_RATIO_1_1:
+			hdmirx->color_depth = 8;
+			break;
+		case CLK_RATIO_5_4:
+			hdmirx->color_depth = 10;
+			break;
+		case CLK_RATIO_3_2:
+			hdmirx->color_depth = 12;
+			break;
+		case CLK_RATIO_2_1:
+			hdmirx->color_depth = 16;
+			break;
+		case CLK_RATIO_1_2:
+		case CLK_RATIO_5_8:
+		case CLK_RATIO_3_4:
+		default:
+			pr_err("RGB/YUV444 Not supported clk ration\n");
+		}
+	}
+
+	switch (pixel_encoding) {
+	case PIXEL_ENCODING_YUV422:
+		if ((0 != hdmirx->vic_code) || (0 == hdmirx->hdmi_vic))
+			dev_info(&hdmirx->pdev->dev, "Detect mode VIC %d %dbit YUV422\n",
+					hdmirx->vic_code,  hdmirx->color_depth);
+		else
+			dev_info(&hdmirx->pdev->dev, "Detect mode VIC %d and HDMI_VIC=%d %dbit YUV422\n",
+					hdmirx->vic_code, hdmirx->hdmi_vic,  hdmirx->color_depth);
+		break;
+	case PIXEL_ENCODING_YUV420:
+		if ((0 != hdmirx->vic_code) || (0 == hdmirx->hdmi_vic))
+			dev_info(&hdmirx->pdev->dev, "Detect mode VIC %d %dbit YUV420\n",
+				hdmirx->vic_code,  hdmirx->color_depth);
+		else
+			dev_info(&hdmirx->pdev->dev, "Detect mode VIC %d and HDMI_VIC=%d %dbit YUV422\n",
+				hdmirx->vic_code, hdmirx->hdmi_vic,  hdmirx->color_depth);
+		break;
+	case PIXEL_ENCODING_YUV444:
+		if ((0 != hdmirx->vic_code) || (0 == hdmirx->hdmi_vic))
+			dev_info(&hdmirx->pdev->dev, "Detect mode VIC %d %dbit YUV444\n",
+				hdmirx->vic_code,  hdmirx->color_depth);
+		else
+			dev_info(&hdmirx->pdev->dev, "Detect mode VIC %d and HDMI_VIC=%d %dbit YUV422\n",
+				hdmirx->vic_code, hdmirx->hdmi_vic,  hdmirx->color_depth);
+		break;
+	case PIXEL_ENCODING_RGB:
+		if ((0 != hdmirx->vic_code) || (0 == hdmirx->hdmi_vic))
+			dev_info(&hdmirx->pdev->dev, "Detect mode VIC %d %dbit RGB\n",
+				hdmirx->vic_code, hdmirx->color_depth);
+		else
+			dev_info(&hdmirx->pdev->dev, "Detect mode VIC %d and HDMI_VIC=%d %dbit YUV422\n",
+				hdmirx->vic_code, hdmirx->hdmi_vic,  hdmirx->color_depth);
+		break;
+	default:
+		dev_err(&hdmirx->pdev->dev, "Unknow color format\n");
+	}
+}
+
+/* Set edid data sample */
+static void hdmirx_edid_set(struct cdns_hdmirx_device *hdmirx)
+{
+	/* Set EDID - block 0 */
+	cdns_hdmirx_set_edid(hdmirx, 0, 0, &block0[0]);
+	/* Set EDID - block 1 */
+	cdns_hdmirx_set_edid(hdmirx, 0, 1, &block1[0]);
+	dev_dbg(&hdmirx->pdev->dev, "EDID block 0/1 set complete.\n");
+}
+
+/* Set SCDC data sample */
+static void hdmirx_scdc_set(struct cdns_hdmirx_device *hdmirx)
+{
+	cdns_hdmirx_set_scdc_slave(hdmirx, &scdcexampledata);
+	dev_dbg(&hdmirx->pdev->dev, "SCDC set complete.\n");
+}
+
+/* Set AVI data */
+static inline void hdmirx_avi_set(struct cdns_hdmirx_device *hdmirx)
+{
+	memset(hdmirx->avi, 0, sizeof(hdmirx->avi));
+}
+
+static int hdmirx_firmware_write_section(struct cdns_hdmirx_device *hdmirx,
+					const u8 *data, int size, int addr)
+{
+	int i;
+
+	for (i = 0; i < size; i += 4) {
+		u32 val = (unsigned int)data[i] << 0 |
+					(unsigned int)data[i + 1] << 8 |
+					(unsigned int)data[i + 2] << 16 |
+					(unsigned int)data[i + 3] << 24;
+		cdns_hdmirx_bus_write(val, hdmirx, addr + i);
+	}
+
+	return 0;
+}
+
+static void hdmirx_firmware_load_cont(const struct firmware *fw, void *context)
+{
+	struct cdns_hdmirx_device *hdmirx = context;
+
+	hdmirx->fw = fw;
+}
+
+static int hdmirx_firmware_load(struct cdns_hdmirx_device *hdmirx)
+{
+	const u8 *iram;
+	const u8 *dram;
+	int ret;
+
+	/* skip fw loading if none is specified */
+	if (!hdmirx->firmware_name)
+		return 0;
+
+	if (!hdmirx->fw) {
+		ret = request_firmware_nowait(THIS_MODULE, FW_ACTION_NOUEVENT,
+					      hdmirx->firmware_name,
+					      &hdmirx->pdev->dev, GFP_KERNEL,
+					      hdmirx,
+					      hdmirx_firmware_load_cont);
+		if (ret < 0) {
+			DRM_ERROR("failed to load firmware\n");
+			return -ENOENT;
+		}
+	} else {
+		iram = hdmirx->fw->data + FW_IRAM_OFFSET;
+		dram = iram + FW_IRAM_SIZE;
+
+		hdmirx_firmware_write_section(hdmirx, iram, FW_IRAM_SIZE, ADDR_IMEM);
+		hdmirx_firmware_write_section(hdmirx, dram, FW_DRAM_SIZE, ADDR_DMEM);
+	}
+
+	DRM_INFO("Started RX firmware!\n");
+
+	return 0;
+}
+
+int cdns_hdmirx_init(struct cdns_hdmirx_device *hdmirx)
+{
+	int ret = 0;
+
+	hdmirx_firmware_load(hdmirx);
+
+	/* Set uCPU Clock frequency for FW's use [MHz]; */
+	cdns_hdmirx_set_clock(hdmirx, 200);
+
+	/* Relase uCPU */
+	cdns_hdmirx_bus_write(0, hdmirx, APB_CTRL);
+
+	/* Check if the firmware is running */
+	ret = cdns_hdmirx_check_alive(hdmirx);
+	if (ret == false) {
+		pr_err("NO HDMI RX FW running\n");
+		return -ENXIO;
+	}
+
+	/* Set driver and firmware active */
+	cdns_hdmirx_maincontrol(hdmirx, 1);
+	cdns_hdmirx_sethpd(hdmirx, 0);
+
+	cdns_hdmirx_maincontrol(hdmirx, 0);
+	imx8qm_hdmi_phy_reset(hdmirx, 0);
+	cdns_hdmirx_general_assertphyreset(hdmirx);
+
+	cdns_hdmirx_maincontrol(hdmirx, 1);
+	msleep(500);
+
+	/* Set sample edid and scdc */
+	hdmirx_edid_set(hdmirx);
+	hdmirx_scdc_set(hdmirx);
+	hdmirx_avi_set(hdmirx);
+	msleep(200);
+
+	return ret;
+}
+
+void cdns_hdmirx_hotplug_trigger(struct cdns_hdmirx_device *hdmirx)
+{
+	dev_dbg(&hdmirx->pdev->dev, "%s Triggering a 200ms HPD event\n", __func__);
+	/* Clear HPD */
+	cdns_hdmirx_sethpd(hdmirx, 0);
+	/* provide minimum low pulse length (100ms) */
+	msleep(200);
+	cdns_hdmirx_sethpd(hdmirx, 1);
+}
+
+static void hdmirx_phy_pix_engine_reset(struct cdns_hdmirx_device *hdmirx)
+{
+	u32 val;
+
+	val = cdns_hdmirx_reg_read(hdmirx, SINK_MHL_HD_CAR);
+	cdns_hdmirx_reg_write(hdmirx, SINK_MHL_HD_CAR, val & 0x3D);
+	cdns_hdmirx_reg_write(hdmirx, SINK_MHL_HD_CAR, val);
+}
+
+#ifdef debug
+static void do_test_fw_read_check(struct cdns_hdmirx_device *hdmirx)
+{
+	u32 val;
+
+	val = cdns_hdmirx_reg_read(hdmirx, TMDS_CH0_ERR_CNT);
+	dev_info(&hdmirx->pdev->dev, "Got TMDS_CH0_ERR_CNT: 0x%08X\n", val);
+	val = cdns_hdmirx_reg_read(hdmirx, TMDS_CH1_ERR_CNT);
+	dev_info(&hdmirx->pdev->dev, "Got TMDS_CH1_ERR_CNT: 0x%08X\n", val);
+	val = cdns_hdmirx_reg_read(hdmirx, TMDS_CH2_ERR_CNT);
+	dev_info(&hdmirx->pdev->dev, "Got TMDS_CH2_ERR_CNT: 0x%08X\n", val);
+	val = cdns_hdmirx_reg_read(hdmirx, TMDS_DEC_ST);
+	dev_info(&hdmirx->pdev->dev, "Got TMDS_DEC_ST: 0x%08X\n", val);
+	val = cdns_hdmirx_reg_read(hdmirx, 0x5834);
+	dev_info(&hdmirx->pdev->dev, "Got 0x5834: 0x%08X\n", val);
+	val = cdns_hdmirx_reg_read(hdmirx, PKT_AVI_DATA_LOW);
+	dev_info(&hdmirx->pdev->dev, "Got PKT_AVI_DATA_LOW: 0x%08X\n", val);
+	val = cdns_hdmirx_reg_read(hdmirx, PKT_AVI_DATA_HIGH);
+	dev_info(&hdmirx->pdev->dev, "Got PKT_AVI_DATA_HIGH: 0x%08X\n", val);
+	val = cdns_hdmirx_reg_read(hdmirx, PKT_ERR_CNT_HEADER);
+	dev_info(&hdmirx->pdev->dev, "Got PKT_ERR_CNT_HEADER: 0x%08X\n", val);
+	val = cdns_hdmirx_reg_read(hdmirx, PKT_ERR_CNT_01);
+	dev_info(&hdmirx->pdev->dev, "Got PKT_ERR_CNT_01: 0x%08X\n", val);
+	val = cdns_hdmirx_reg_read(hdmirx, PKT_ERR_CNT_23);
+	dev_info(&hdmirx->pdev->dev, "Got PKT_ERR_CNT_23: 0x%08X\n", val);
+	val = cdns_hdmirx_reg_read(hdmirx, 0x5828);
+	dev_info(&hdmirx->pdev->dev, "Got 0x5828: 0x%08X\n", val);
+	val = cdns_hdmirx_reg_read(hdmirx, 0x582c);
+	dev_info(&hdmirx->pdev->dev, "Got 0x582C: 0x%08X\n", val);
+	val = cdns_hdmirx_reg_read(hdmirx, 0x5830);
+	dev_info(&hdmirx->pdev->dev, "Got 0x5830: 0x%08X\n", val);
+}
+#endif
+
+int cdns_hdmirx_phyinit(struct cdns_hdmirx_device *hdmirx)
+{
+	cdns_hdmirx_maincontrol(hdmirx, 0x40);
+	dev_dbg(&hdmirx->pdev->dev, "%s(): called MainControl(0x40)\n", __func__);
+	imx8qm_hdmi_phy_reset(hdmirx, 0);
+	cdns_hdmirx_general_assertphyreset(hdmirx);
+
+	cdns_hdmirx_maincontrol(hdmirx, 1);
+	dev_dbg(&hdmirx->pdev->dev, "%s(): called MainControl(1)\n", __func__);
+	cdns_hdmirx_general_deassertphyreset(hdmirx);
+
+	if (hdmirx->rescal_val > 0)
+		set_rescal_code(hdmirx, hdmirx->rescal_val);
+	else
+		reset_rescal_code(hdmirx);
+
+	set_slicer_tune_val(hdmirx, hdmirx->slicer_tune_val);
+
+	/* First check to see if PHY is in reset, if so we need to
+	 * do pma_config then arc_config, this is always going to be
+	 * the case for now... */
+	if (phy_in_reset(hdmirx)) {
+		/* Configure the PHY */
+		dev_info(&hdmirx->pdev->dev, "Doing initial PHY configuration\n");
+		pma_config(hdmirx);
+		dev_info(&hdmirx->pdev->dev, "Releasing PHY reset\n");
+		imx8qm_hdmi_phy_reset(hdmirx, 1);
+		dev_info(&hdmirx->pdev->dev, "Waiting for pma_cmn_ready\n");
+		if (pma_cmn_ready(hdmirx) < 0) {
+			dev_err(&hdmirx->pdev->dev, "pma_cmn_ready failed\n");
+			dev_info(&hdmirx->pdev->dev, "Setting PHY reset\n");
+			imx8qm_hdmi_phy_reset(hdmirx, 0);
+			return -1;
+		}
+
+		/* init ARC */
+		arc_config(hdmirx);
+		get_rescal_code(hdmirx);
+
+		/* Don't care about this initial status read,
+		 * just clearing it out first before triggering HPD...
+		 */
+		{
+			uint32_t events;
+			msleep(200);
+			events = cdns_hdmirx_bus_read(hdmirx, SW_EVENTS1);
+			cdns_hdmirx_hotplug_trigger(hdmirx);
+			cdns_hdmirx_wait_edid_read(hdmirx);
+			mdelay(200);
+		}
+	} else {
+		dev_dbg(&hdmirx->pdev->dev, "Prepare for rate change\n");
+		pre_data_rate_change(hdmirx);
+	}
+
+	get_rescal_code(hdmirx);
+	return 0;
+}
+
+int hdmirx_config(struct cdns_hdmirx_device *hdmirx)
+{
+	struct S_HDMI_SCDC_GET_MSG *scdcData = &hdmirx->scdcData;
+	u8 clk_ratio, clk_ratio_detected;
+	u8 data_rate_change = 0;
+	u8 scrambling_en;
+	u32 tmds_bit_clock_ratio;
+	int ret;
+	ktime_t timeout;
+	u32 val;
+	u8 null_info[16] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+						0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+
+	dev_dbg(&hdmirx->pdev->dev, "Prepare for rate change\n");
+	pre_data_rate_change(hdmirx);
+
+	/* Detect rx clk signal */
+	if (pma_rx_clk_signal_detect(hdmirx)) {
+		dev_err(&hdmirx->pdev->dev, "Common rx_clk signal detect failed\n");
+		return -1;
+	} else
+		dev_dbg(&hdmirx->pdev->dev, "pma_rx_clk_signal detected\n");
+
+	/* Get TMDS_Bit_Clock_Ratio and Scrambling setting */
+	cdns_hdmirx_get_scdc_slave(hdmirx, scdcData);
+	tmds_bit_clock_ratio = ((scdcData->TMDS_Config & (1 << 1)) >> 1) ?
+			       TMDS_BIT_CLOCK_RATIO_1_40 :
+			       TMDS_BIT_CLOCK_RATIO_1_10;
+	scrambling_en = scdcData->TMDS_Config & (1 << 0);
+
+	dev_dbg(&hdmirx->pdev->dev,
+		"TMDS ratio: 1/%0d, Scrambling %0d).\n", tmds_bit_clock_ratio, scrambling_en);
+
+	/* Get TMDS clock frequency */
+	hdmirx->tmds_clk = cdns_hdmirx_get_stable_tmds(hdmirx);
+	if (hdmirx->tmds_clk <= 0) {
+		dev_err(&hdmirx->pdev->dev, "detect tmds clock failed\n");
+		return -1;
+	}
+	dev_info(&hdmirx->pdev->dev, "Detect TMDS clock freq: %d kHz\n",
+		 hdmirx->tmds_clk);
+
+	/* Start from TMDS/pixel clock ratio of 1:1.
+	 * It affects only pixel clock frequency as the character/data clocks
+	 * are generated based on a measured TMDS clock.
+	 * This guarantees that the TMDS characters are correctly decoded in
+	 * the controller regardless of the pixel clock ratio being
+	 * programmed.
+	 */
+	clk_ratio = CLK_RATIO_1_1;
+
+	ret = pma_pll_config(hdmirx, hdmirx->tmds_clk, clk_ratio,
+			     tmds_bit_clock_ratio, data_rate_change);
+	if (ret < 0) {
+		dev_err(&hdmirx->pdev->dev, "pma_pll_config failed, this is a critical error will try resetting PHY\n");
+		cdns_hdmirx_phyinit(hdmirx);
+		return -1;
+	}
+
+#ifdef debug
+	do_test_fw_read_check(hdmirx);
+#endif
+
+	/* Setup the scrambling mode */
+	cdns_hdmirx_reg_write(hdmirx, TMDS_SCR_CTRL, F_SCRAMBLER_MODE(scrambling_en));
+	dev_dbg(&hdmirx->pdev->dev,
+				"Scrambling %s.\n", (scrambling_en) ? "enabled" : "disabled");
+
+	/*Just to initiate the counters: */
+	cdns_hdmirx_reg_write(hdmirx, TMDS_SCR_CNT_INT_CTRL,
+					F_SCRAMBLER_SSCP_LINE_DET_THR(0) |
+					F_SCRAMBLER_CTRL_LINE_DET_THR(0));
+
+	cdns_hdmirx_reg_write(hdmirx, TMDS_SCR_VALID_CTRL,
+						F_SCRAMBLER_SSCP_LINE_VALID_THR(1) |
+						F_SCRAMBLER_CTRL_LINE_VALID_THR(0));
+
+	/* Clear the TMDS decoder */
+	cdns_hdmirx_reg_write(hdmirx, TMDS_DEC_CTRL,
+						F_DECODER_ERR_CORR_EN(1) |
+						F_TMDS_DECODER_SW_RST(1));
+
+	/* Read to clear register for status */
+	val = cdns_hdmirx_reg_read(hdmirx, TMDS_DEC_ST);
+
+	cdns_hdmirx_reg_write(hdmirx, TMDS_DEC_CTRL,
+						F_DECODER_ERR_CORR_EN(1) |
+						F_TMDS_DECODER_SW_RST(0));
+
+	/* Wait for lock to TMDS datastream before continuing...*/
+	timeout = ktime_timeout_ms(50);
+	do {
+		val = cdns_hdmirx_reg_read(hdmirx, TMDS_DEC_ST);
+		dev_dbg(&hdmirx->pdev->dev, "Got TMDS_DEC_ST: 0x%08X\n", val);
+
+		if (ktime_after(ktime_get(), timeout)) {
+			dev_err(&hdmirx->pdev->dev, "Timeout locking to TMDS datastream\n");
+			return -1;
+		}
+	} while ((val & 0x200) == 0);
+
+	/* Do post PHY programming settings */
+	cdns_hdmirx_maincontrol(hdmirx, 0x80);
+	dev_dbg(&hdmirx->pdev->dev, "MainControl() Initial Stage 2 complete.\n");
+
+	/* Clear down VIF side in case we weren't able to do so before...*/
+	cdns_hdmirx_reg_write(hdmirx, VIDEO_UNPACK_CTRL, 0);
+	cdns_hdmirx_reg_write(hdmirx, VANLYZ_CTRL, F_VANLYZ_RESET(1));
+
+	memcpy(hdmirx->avi, null_info, sizeof(hdmirx->avi));
+	memcpy(hdmirx->vnd, null_info, sizeof(hdmirx->vnd));
+	hdmirx->hdmi_vic = 0;
+	hdmirx->vic_code = 0;
+	hdmirx->pixel_encoding = PIXEL_ENCODING_RGB;
+
+	/* The PHY got programmed with the assumed TMDS/pixel clock ratio of 1:1.
+	 * Implement the link training procedure to find out the real clock ratio:
+	 * 1. Wait for AVI InfoFrame packet
+	 * 2. Get the VIC code and pixel encoding from the packet
+	 * 3. Evaluate the TMDS/pixel clock ratio based on the vic_table.c
+	 * 4. Compare the programmed clock ratio with evaluated one
+	 * 5. If mismatch found - reprogram the PHY
+	 * 6. Enable the video data path in the controller */
+
+	if (hdmirx->allow_hdcp) {
+		struct hdcprx_status status;
+		u8 hdcp_ver;
+
+		/* First check to see what was the HDCP status */
+		cdns_hdcprx_get_status(hdmirx, &status);
+
+		/* Now do a quick check to see if we can receive an AVI Infoframe.
+		   If so then all good can skip re-authentication, otherwise if
+		   there had been some HDCP activity then try to authenticate..
+		*/
+		ret = cdns_hdmirx_get_avi_infoframe(hdmirx, 200);
+
+		/* It is difficult to avoid a race condition here as we don't know
+		   when authentication completed vs the above stage 2 call which is
+		   needed to activate parts of the firmware and init some FIFOs in
+		   the controller so we will just wait for any authentication to
+		   complete then request a re-authentication
+		*/
+		hdcp_ver = (status.flags >> 1) & 0x3;
+		if ((ret < 0) && (hdcp_ver > 0)) {	/* Possibly authenticating */
+			cdns_hdcprx_wait_auth_complete(hdmirx, 2000);
+			dev_dbg(&hdmirx->pdev->dev, "Requesting HDCP re-authentication\n");
+			cdns_hdcprx_reauth_req_wait(hdmirx, 2000);
+		}
+		/* Clear out any logged errors by reading */
+		cdns_hdmirx_reg_read(hdmirx, PKT_ERR_CNT_HEADER);
+	}
+
+	ret = cdns_hdmirx_get_avi_infoframe(hdmirx, 2500);
+
+	hdmirx_phy_pix_engine_reset(hdmirx);
+
+	/* We also want to check what the decoder status was in case above failed... */
+	val = cdns_hdmirx_reg_read(hdmirx, TMDS_DEC_ST);
+	/* Read to get proper value */
+	val = cdns_hdmirx_reg_read(hdmirx, TMDS_DEC_ST);
+	dev_dbg(&hdmirx->pdev->dev, "Got TMDS_DEC_ST: 0x%08X\n", val);
+
+	if (ret < 0) {
+		if ((val & 0x200) == 0) {
+			dev_dbg(&hdmirx->pdev->dev, "Lost link alignment.\n");
+			goto error_exit;
+		} else if ((val & 0x1) == 0) {
+			dev_dbg(&hdmirx->pdev->dev, "\nLink looks to be in DVI mode.\n");
+			dev_dbg(&hdmirx->pdev->dev, "Not currently handled by driver, exiting...\n\n");
+			goto error_exit;
+		} else {
+			dev_err(&hdmirx->pdev->dev, "Get AVI info frame failed\n");
+			goto error_exit;
+		}
+	}
+
+	ret = cdns_hdmirx_get_vendor_infoframe(hdmirx, 250);
+	if (ret < 0)
+		dev_dbg(&hdmirx->pdev->dev, "No Vendor info frame\n");
+
+	dev_dbg(&hdmirx->pdev->dev, "VIC: %0d, pixel_encoding: %0d.\n",
+			hdmirx->vic_code, hdmirx->pixel_encoding);
+	ret = cdns_hdmirx_frame_timing(hdmirx);
+	if (ret < 0) {
+		dev_err(&hdmirx->pdev->dev, "Get frame timing failed\n\n");
+		goto error_exit;
+	}
+
+	clk_ratio_detected = clk_ratio_detect(hdmirx, hdmirx->tmds_clk,
+					      hdmirx->timings->timings.bt.
+					      pixelclock / 1000,
+					      hdmirx->vic_code,
+					      hdmirx->pixel_encoding,
+					      tmds_bit_clock_ratio);
+
+	data_rate_change = (clk_ratio != clk_ratio_detected);
+	if (data_rate_change) {
+		dev_dbg(&hdmirx->pdev->dev,
+				"TMDS/pixel clock ratio mismatch detected (programmed: %0d, detected: %0d)\n",
+				clk_ratio, clk_ratio_detected);
+
+		cdns_hdmirx_maincontrol(hdmirx, 0x40);
+		dev_dbg(&hdmirx->pdev->dev, "%s(): called MainControl(0x40)\n", __func__);
+		cdns_hdmirx_maincontrol(hdmirx, 1);
+		dev_dbg(&hdmirx->pdev->dev, "%s(): called MainControl(1)\n", __func__);
+
+		/* Reconfigure the PHY */
+		dev_dbg(&hdmirx->pdev->dev, "Prepare to change rate\n");
+		pre_data_rate_change(hdmirx);
+
+		/* Re-use last measured TMDS frequency... */
+		ret = pma_pll_config(hdmirx, hdmirx->tmds_clk, clk_ratio_detected,
+			       tmds_bit_clock_ratio, data_rate_change);
+		if (ret < 0) {
+			dev_err(&hdmirx->pdev->dev, "pma_pll_config failed\n");
+			return -1;
+		}
+
+		/* Do post PHY programming settings */
+		cdns_hdmirx_maincontrol(hdmirx, 0x80);
+		dev_dbg(&hdmirx->pdev->dev, "MainControl() Initial Stage 2 complete.\n");
+
+		if (hdmirx->allow_hdcp) {
+			struct hdcprx_status status;
+			u8 hdcp_ver;
+
+			/* First check to see what was the HDCP status */
+			cdns_hdcprx_get_status(hdmirx, &status);
+
+			/* Now do a quick check to see if we can receive an AVI Infoframe.
+			 * If so then all good can skip re-authentication, otherwise if
+			 * there had been some HDCP activity then try to authenticate..
+			 */
+			ret = cdns_hdmirx_get_avi_infoframe(hdmirx, 200);
+
+			/* It is difficult to avoid a race condition here as we don't know
+			 * when authentication completed vs the above stage 2 call which is
+			 * needed to activate parts of the firmware and init some FIFOs in
+			 * the controller so we will just wait for any authentication to
+			 * complete then request a re-authentication
+			 */
+			hdcp_ver = (status.flags >> 1) & 0x3;
+			if ((ret < 0) && (hdcp_ver > 0)) {	/* Possibly authenticating */
+				cdns_hdcprx_wait_auth_complete(hdmirx, 2000);
+				dev_dbg(&hdmirx->pdev->dev, "Requesting HDCP re-authentication\n");
+				cdns_hdcprx_reauth_req_wait(hdmirx, 2000);
+			}
+			/* Clear out any logged errors by reading */
+			cdns_hdmirx_reg_read(hdmirx, PKT_ERR_CNT_HEADER);
+		}
+		hdmirx_phy_pix_engine_reset(hdmirx);
+
+	} else
+		dev_dbg(&hdmirx->pdev->dev, "TMDS/pixel clock ratio correct\n");
+
+	get_color_depth(hdmirx, clk_ratio_detected);
+	get_rescal_code(hdmirx);
+	return 0;
+
+error_exit:
+	cdns_hdmirx_maincontrol(hdmirx, 0x40);
+	dev_dbg(&hdmirx->pdev->dev, "%s(): called MainControl(0x40)\n", __func__);
+	cdns_hdmirx_maincontrol(hdmirx, 1);
+	dev_dbg(&hdmirx->pdev->dev, "%s(): called MainControl(1)\n", __func__);
+
+	return -1;
+}
+
+/* Bring-up sequence for the HDMI-RX */
+int cdns_hdmirx_startup(struct cdns_hdmirx_device *hdmirx)
+{
+	int ret = 0;
+	u8 val;
+
+	ret = hdmirx_config(hdmirx);
+	if (ret) {
+		dev_err(&hdmirx->pdev->dev, "PHY configuration failed\n");
+		hdmirx->tmds_clk = -1;
+		return ret;
+	}
+
+	/* Initialize HDMI RX */
+	cdns_hdmirx_reg_write(hdmirx, VIDEO_UNPACK_CTRL, F_CD_ENABLE(1));
+	val = F_VANLYZ_START(1) | F_VANLYZ_FRAMES_CHECK_EN(1) | F_VANLYZ_FORMAT_FINDER_EN(1);
+	cdns_hdmirx_reg_write(hdmirx, VANLYZ_CTRL, val);
+
+	dev_dbg(&hdmirx->pdev->dev,
+				"HDMIRX_Init() complete.\n");
+
+	/* Initialize HDMI RX CEC */
+	cdns_hdmirx_reg_write(hdmirx, SINK_CEC_CAR,
+				F_SINK_CEC_SYS_CLK_EN(1) |
+				F_SINK_CEC_SYS_CLK_RSTN_EN(1));
+	return 0;
+}
diff --git a/drivers/staging/media/imx/hdmirx/cdns-hdmirx-phy.c b/drivers/staging/media/imx/hdmirx/cdns-hdmirx-phy.c
new file mode 100644
index 000000000..1aa271ae1
--- /dev/null
+++ b/drivers/staging/media/imx/hdmirx/cdns-hdmirx-phy.c
@@ -0,0 +1,1483 @@
+/*
+ * Copyright 2020 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+#include <linux/ktime.h>
+#include "cdns-hdmirx-phy.h"
+
+#define PMA_REF_CLK_TMR_VALUE_DEF 0x0801
+#define PMA_CMN_READY_TIMEOUT_MS 5
+#define PMA_RX_CLK_SIGNAL_DETECT_TIMEOUT_MS 200
+#define PMA_RX_CLK_FREQ_DETECT_TIMEOUT_MS 5
+#define PMA_RX_CLK_FREQ_DETECT_MIN_THRESH 24000
+#define PMA_RX_CLK_FREQ_DETECT_MAX_THRESH 340000
+#define PMA_POWER_CHNG_TIMEOUT_MS 100
+#define TMDS_STABLE_DETECT_COUNT_THRESHOLD 3
+#define TMDS_STABLE_DETECT_TIMEOUT_MS 500
+
+static int pma_power_state_chng(struct cdns_hdmirx_device *hdmirx, u8 power_state);
+
+typedef struct {
+	u32 value;
+	u8 lsb;
+	u8 msb;
+	u8 *label;
+} reg_field_t;
+
+static void set_field_value(reg_field_t *reg_field, u32 value)
+{
+	u8 length;
+	u32 max_value;
+	u32 trunc_val;
+	length = (reg_field->msb - reg_field->lsb + 1);
+
+    max_value = (1 << length) - 1;
+    if (value > max_value) {
+		trunc_val = value;
+		trunc_val &= (1 << length) - 1;
+		pr_err("set_field_value() Error! Specified value (0x%0X)\
+				exceeds field capacity - it will by truncated to\
+				0x%0X (%0d-bit field - max value: %0d dec)\n",
+				value, trunc_val, length, max_value);
+	} else
+		reg_field->value = value;
+}
+
+static int set_reg_value(reg_field_t reg_field)
+{
+    return reg_field.value << reg_field.lsb;
+}
+
+static int cdns_hdmirx_phy_reg_write(struct cdns_hdmirx_device *hdmirx, u32 addr, u32 val)
+{
+    return cdns_hdmirx_reg_write(hdmirx, ADDR_PHY_AFE + (addr << 2), val);
+}
+
+static int cdns_hdmirx_phy_reg_read(struct cdns_hdmirx_device *hdmirx, u32 addr)
+{
+    return cdns_hdmirx_reg_read(hdmirx, ADDR_PHY_AFE + (addr << 2));
+}
+
+static inline void write16(struct cdns_hdmirx_device *hdmirx, u32 addr, u16 val)
+{
+	cdns_hdmirx_phy_reg_write(hdmirx, addr, val);
+}
+
+static inline void multi_write16(struct cdns_hdmirx_device *hdmirx, u32 addr, u16 val)
+{
+	u16 addr_tmp = addr;
+
+	if ((addr & 0x1E00) == LINK_ID << 9) {
+		addr_tmp |= LINK_WRITE;
+		cdns_hdmirx_phy_reg_write(hdmirx, addr_tmp, val);
+	} else {
+		cdns_hdmirx_phy_reg_write(hdmirx, addr_tmp, val);
+	}
+}
+
+static inline u16 read16(struct cdns_hdmirx_device *hdmirx, u32 addr)
+{
+	return cdns_hdmirx_phy_reg_read(hdmirx, addr);
+}
+
+u16 inside_i(u16 value, u16 left_sharp_corner,
+		  u16 right_sharp_corner)
+{
+	if (value < left_sharp_corner)
+		return 0;
+	if (value > right_sharp_corner)
+		return 0;
+	return 1;
+}
+
+u16 inside_f(u32 value, u32 left_sharp_corner, u32 right_sharp_corner)
+{
+	if (value < left_sharp_corner)
+		return 0;
+	if (value > right_sharp_corner)
+		return 0;
+	return 1;
+}
+
+void arc_config(struct cdns_hdmirx_device *hdmirx)
+{
+	u16 reg_val;
+
+	write16(hdmirx, TXDA_CYA_AUXDA_CYA_ADDR, 0x0001);
+	udelay(1);
+	write16(hdmirx, TX_DIG_CTRL_REG_1_ADDR, 0x3);
+	udelay(1);
+	write16(hdmirx, TX_DIG_CTRL_REG_2_ADDR, 0x0024);
+	udelay(1);
+
+	reg_val = read16(hdmirx, TX_ANA_CTRL_REG_1_ADDR);
+	reg_val |= 0x2000;
+	write16(hdmirx, TX_ANA_CTRL_REG_1_ADDR, reg_val);
+	udelay(1);
+
+	write16(hdmirx, TX_ANA_CTRL_REG_2_ADDR, 0x0100);
+	udelay(1);
+	write16(hdmirx, TX_ANA_CTRL_REG_2_ADDR, 0x0300);
+	udelay(1);
+	write16(hdmirx, TX_ANA_CTRL_REG_3_ADDR, 0x0000);
+	udelay(1);
+	write16(hdmirx, TX_ANA_CTRL_REG_1_ADDR, 0x2008);
+	udelay(1);
+	write16(hdmirx, TX_ANA_CTRL_REG_1_ADDR, 0x2018);
+	udelay(1);
+	write16(hdmirx, TX_ANA_CTRL_REG_1_ADDR, 0x2098);
+	udelay(1);
+	write16(hdmirx, TX_ANA_CTRL_REG_2_ADDR, 0x030C);
+	udelay(1);
+	write16(hdmirx, TX_ANA_CTRL_REG_5_ADDR, 0x0010);
+	udelay(1);
+	write16(hdmirx, TX_ANA_CTRL_REG_4_ADDR, 0x4001);
+	udelay(1);
+	write16(hdmirx, TX_ANA_CTRL_REG_1_ADDR, 0x2198);
+	udelay(1);
+	write16(hdmirx, TX_ANA_CTRL_REG_2_ADDR, 0x030D);
+	udelay(1);
+	write16(hdmirx, TX_ANA_CTRL_REG_2_ADDR, 0x030F);
+}
+
+void pma_config(struct cdns_hdmirx_device *hdmirx)
+{
+	int i;
+
+	u16 const RX_CLK_SLICER_CAL_TUNE_VAL = 0x0008;
+	u16 const RX_CLK_TERM_CTRL_VAL = 0x0001;
+	u16 const RX_CLK_SLICER_CAL_INIT_TMR_VAL = 0x00FF;
+	u16 const RX_CLK_SLICER_CAL_ITER_TMR_VAL = 0x00FF;
+
+	dev_dbg(&hdmirx->pdev->dev, "pma_config() Configuring PMA\n");
+
+	write16(hdmirx, CMN_CMSMT_REF_CLK_TMR_VALUE_ADDR, PMA_REF_CLK_TMR_VALUE_DEF);
+
+	dev_dbg(&hdmirx->pdev->dev, "Changing RX_CLK_TERM_CTRL from 0x%.4X to 0x%.4X\n",
+		read16(hdmirx, RX_CLK_TERM_CTRL_ADDR),
+		RX_CLK_TERM_CTRL_VAL);
+	write16(hdmirx, RX_CLK_TERM_CTRL_ADDR, RX_CLK_TERM_CTRL_VAL);
+
+	dev_dbg(&hdmirx->pdev->dev, "Changing RX_CLK_SLICER_CAL_TUNE_ADDR from 0x%.4X to 0x%.4X\n",
+		read16(hdmirx, RX_CLK_SLICER_CAL_TUNE_ADDR),
+		RX_CLK_SLICER_CAL_TUNE_VAL);
+	write16(hdmirx, RX_CLK_SLICER_CAL_TUNE_ADDR, RX_CLK_SLICER_CAL_TUNE_VAL);
+
+	dev_dbg(&hdmirx->pdev->dev, "Changing RX_CLK_SLICER_CAL_INIT_TMR from 0x%.4X to 0x%.4X\n",
+		read16(hdmirx, RX_CLK_SLICER_CAL_INIT_TMR_ADDR),
+		RX_CLK_SLICER_CAL_INIT_TMR_VAL);
+	write16(hdmirx, RX_CLK_SLICER_CAL_INIT_TMR_ADDR,
+		RX_CLK_SLICER_CAL_INIT_TMR_VAL);
+
+	dev_dbg(&hdmirx->pdev->dev, "Changing RX_CLK_SLICER_CAL_ITER_TMR from 0x%.4X to 0x%.4X\n",
+		read16(hdmirx, RX_CLK_SLICER_CAL_ITER_TMR_ADDR),
+		RX_CLK_SLICER_CAL_ITER_TMR_VAL);
+	write16(hdmirx, RX_CLK_SLICER_CAL_ITER_TMR_ADDR,
+		RX_CLK_SLICER_CAL_ITER_TMR_VAL);
+
+	write16(hdmirx, CMN_RXCAL_INIT_TMR_ADDR, 0x003F);
+	write16(hdmirx, CMN_DIAG_PLL0_TEST_MODE_ADDR, 0x0022);
+	multi_write16(hdmirx, XCVR_PSM_CAL_TMR_ADDR, 0x0160);
+
+	/* Drives the rx_differential_invert PMA input for the selected lane */
+	for (i = 0; i < 3; i++) {
+		u16 const reg_val = 0x0c61;
+		write16(hdmirx, (PHY_PMA_XCVR_CTRL_ADDR | (i << 6)), reg_val);
+	}
+}
+
+void pre_data_rate_change(struct cdns_hdmirx_device *hdmirx)
+{
+	u16 reg_val;
+	int i;
+	int ret_val;
+	const ktime_t timeout = ktime_timeout_ms(1500);
+
+	/* Turn off frequency measurement: */
+	write16(hdmirx, CMN_CMSMT_CLK_FREQ_MSMT_CTRL_ADDR, 0x0000);
+
+	/* Request A3 power hdmirx */
+	/* Can only really do this if PHY already in A0 hdmirx, all other
+	   times are meaningless and can cause issues if PLL not running...
+	*/
+	reg_val = read16(hdmirx, PHY_MODE_CTL_ADDR);
+	if ((reg_val & 0x00F0) == 0x0010) {
+		ret_val = pma_power_state_chng(hdmirx, 0x8);
+		dev_dbg(&hdmirx->pdev->dev, "Shutting down PLL\n");
+		write16(hdmirx, PHY_MODE_CTL_ADDR, reg_val & 0xEF00);
+		do {
+			if (ktime_after(ktime_get(), timeout)) {
+				dev_dbg(&hdmirx->pdev->dev, "Timed out PHY_PMA_CMN_CTRL2_ADDR: 0x%04X\n", reg_val);
+				dev_dbg(&hdmirx->pdev->dev, "Setting PHY reset\n");
+				imx8qm_hdmi_phy_reset(hdmirx, 0);
+				break;
+			}
+			reg_val = read16(hdmirx, PHY_PMA_CMN_CTRL2_ADDR);
+		} while ((reg_val & 0x0004) == 0x0000);
+	} else
+		dev_dbg(&hdmirx->pdev->dev, "Skipping A3 power change since PHY_MODE_CTL: 0x%04X\n", reg_val);
+
+
+	/* Clear power hdmirx and set transceiver resets active */
+	write16(hdmirx, PHY_MODE_CTL_ADDR, 0x0000);
+
+	/* Setting PMA Transceiver Control for each lane to default */
+	for (i = 0; i < 3; i++) {
+		reg_val = 0x0C61;
+		write16(hdmirx, PHY_PMA_XCVR_CTRL_ADDR | (i << 6), reg_val);
+	}
+
+	/* De-assert PHY reset in case we applied it earlier due to timeout...*/
+	imx8qm_hdmi_phy_reset(hdmirx, 1);
+}
+
+int pma_cmn_ready(struct cdns_hdmirx_device *hdmirx)
+{
+	const ktime_t timeout = ktime_timeout_ms(PMA_CMN_READY_TIMEOUT_MS);
+
+	do {
+		udelay(10);
+		if (read16(hdmirx, PHY_PMA_CMN_CTRL1_ADDR) & (1 << 0))
+			return 0;
+	} while (ktime_before(ktime_get(), timeout));
+
+	dev_warn(&hdmirx->pdev->dev, "%s timeout\n", __func__);
+
+	return -1;
+}
+
+int phy_in_reset(struct cdns_hdmirx_device *hdmirx)
+{
+	if (read16(hdmirx, PHY_PMA_CMN_CTRL1_ADDR) & (1 << 0))
+		return 0;
+	else
+		return 1;
+}
+
+int pma_rx_clk_signal_detect(struct cdns_hdmirx_device *hdmirx)
+{
+	const ktime_t timeout =
+		ktime_timeout_ms(PMA_RX_CLK_SIGNAL_DETECT_TIMEOUT_MS);
+
+	do {
+		if (read16(hdmirx, PHY_MODE_CTL_ADDR) & (1 << 8))
+			return 0;
+	} while (ktime_before(ktime_get(), timeout));
+
+	return -1;
+}
+
+/* This is raw version returning whether signal is currently
+   detected or not whereas above will wait for signal...
+*/
+bool pma_rx_clk_sig_detected(struct cdns_hdmirx_device *hdmirx)
+{
+	if (read16(hdmirx, PHY_MODE_CTL_ADDR) & (1 << 8))
+		return true;
+	else
+		return false;
+}
+
+static int pma_rx_clk_freq_detect(struct cdns_hdmirx_device *hdmirx)
+{
+	u16 reg_val;
+	u32 rx_clk_freq;
+	ktime_t timeout;
+
+	/* Turn off measurement in case not already off... */
+	write16(hdmirx, CMN_CMSMT_CLK_FREQ_MSMT_CTRL_ADDR, 0x0000);
+
+	/* Start by triggering a frequency measurement timeout to
+	   check that at is somewhat working..
+	   We will reset this back to PMA_REF_CLK_TMR_VALUE_DEF later..*/
+	write16(hdmirx, CMN_CMSMT_REF_CLK_TMR_VALUE_ADDR, 0x0001);
+
+	/* Start frequency detection: */
+	write16(hdmirx, CMN_CMSMT_CLK_FREQ_MSMT_CTRL_ADDR, 0x8000);
+	udelay(5);
+	/* Should be done by now */
+	if (!(read16(hdmirx, CMN_CMSMT_CLK_FREQ_MSMT_CTRL_ADDR) & (1 << 14))) {
+		dev_err(&hdmirx->pdev->dev, "%s() freq detect -> initial timeout check failed\n", __func__);
+		goto meas_error;
+	}
+	/* Check that measured value is 0 */
+	reg_val = read16(hdmirx, CMN_CMSMT_TEST_CLK_CNT_VALUE_ADDR);
+	if (reg_val != 0) {
+		dev_err(&hdmirx->pdev->dev, "%s() freq detect -> initial check expected 0 got 0x%04X\n", __func__, reg_val);
+		goto meas_error;
+	}
+	/* Turn off measurement */
+	write16(hdmirx, CMN_CMSMT_CLK_FREQ_MSMT_CTRL_ADDR, 0x0000);
+	udelay(5);
+	/* Zero check of status */
+	reg_val = read16(hdmirx, CMN_CMSMT_CLK_FREQ_MSMT_CTRL_ADDR);
+	if (reg_val != 0) {
+		dev_err(&hdmirx->pdev->dev, "%s() freq detect -> initial check ctrl expected 0 got 0x%04X\n", __func__, reg_val);
+		goto meas_error;
+	}
+	/* Reset count value back to default */
+	write16(hdmirx, CMN_CMSMT_REF_CLK_TMR_VALUE_ADDR, PMA_REF_CLK_TMR_VALUE_DEF);
+
+	/* Check if signal actually exists before starting measurement...*/
+	if (!pma_rx_clk_sig_detected(hdmirx))
+		goto meas_error;
+
+	/* Start proper frequency detection: */
+	timeout = ktime_timeout_ms(PMA_RX_CLK_FREQ_DETECT_TIMEOUT_MS);
+	write16(hdmirx, CMN_CMSMT_CLK_FREQ_MSMT_CTRL_ADDR, 0x8000);
+
+	/* Wait for pma_rx_clk_freq_detect_done */
+	while (!(read16(hdmirx, CMN_CMSMT_CLK_FREQ_MSMT_CTRL_ADDR) & (1 << 14))) {
+		if (ktime_after(ktime_get(), timeout)) {
+			dev_err(&hdmirx->pdev->dev, "%s() freq detect -> timeout\n", __func__);
+			goto meas_error;
+		}
+		if (!pma_rx_clk_sig_detected(hdmirx)) {
+			dev_err(&hdmirx->pdev->dev, "%s() freq detect -> signal lost during measurement\n", __func__);
+			goto meas_error;
+		}
+	}
+
+	/* Read the measured value */
+	reg_val = read16(hdmirx, CMN_CMSMT_TEST_CLK_CNT_VALUE_ADDR);
+
+	/* Calculate TMDS clock frequency */
+	rx_clk_freq = reg_val * REFCLK_FREQ_KHZ / 2048;
+
+	/* Turn off frequency measurement: */
+	write16(hdmirx, CMN_CMSMT_CLK_FREQ_MSMT_CTRL_ADDR, 0x0000);
+	udelay(5);
+
+	return rx_clk_freq;
+
+meas_error:
+	write16(hdmirx, CMN_CMSMT_CLK_FREQ_MSMT_CTRL_ADDR, 0x0000);
+	udelay(5);
+	return -1;
+}
+
+int cdns_hdmirx_get_stable_tmds(struct cdns_hdmirx_device *hdmirx)
+{
+	const ktime_t timeout = ktime_timeout_ms(TMDS_STABLE_DETECT_TIMEOUT_MS);
+	char i = 0;
+	int tmds = -1;
+
+	dev_dbg(&hdmirx->pdev->dev, "MEASURING TMDS\n");
+	do {
+		int val;
+
+		if (hdmirx->tmdsmon_state == 2) {
+			dev_dbg(&hdmirx->pdev->dev, "TMDS Monitor cleanup in progress...\n");
+			return -1;
+		}
+
+		val = pma_rx_clk_freq_detect(hdmirx);
+		if ((tmds < (val + 50)) && (tmds > (val - 50))) {
+			i++;
+		} else if (tmds != val) {
+			i = 0;
+			tmds = val;
+		}
+
+		if (i == TMDS_STABLE_DETECT_COUNT_THRESHOLD) {
+			dev_dbg(&hdmirx->pdev->dev, "DONE MEASURING TMDS, got %d\n", tmds);
+			if (((tmds < PMA_RX_CLK_FREQ_DETECT_MIN_THRESH) && (tmds >= 0)) ||
+			     (tmds > PMA_RX_CLK_FREQ_DETECT_MAX_THRESH)) {
+				dev_dbg(&hdmirx->pdev->dev, "hdmirx_get_stable_tmds() measured value not valid %d, will try again after 100ms\n", tmds);
+				i = 0;
+				tmds = 0;
+				mdelay(100);	/* Give source some settling time */
+			} else
+				return tmds; /* Can be -1 */
+		}
+
+		udelay(10);
+
+	} while (ktime_before(ktime_get(), timeout));
+
+	dev_warn(&hdmirx->pdev->dev, "hdmirx_get_stable_tmds() timeout\n");
+	return -1;
+}
+
+int get_rescal_code(struct cdns_hdmirx_device *hdmirx)
+{
+	u16 reg_val;
+	reg_val = read16(hdmirx, 0xD0);
+	dev_dbg(&hdmirx->pdev->dev, "Done with CMN_RXCAL_CTRL: 0x%04X\n", reg_val);
+	return (reg_val & 0xFF);
+}
+
+int set_rescal_code(struct cdns_hdmirx_device *hdmirx, u8 rescal_code)
+{
+	write16(hdmirx, 0x1EC, 0x3F4);
+	write16(hdmirx, 0xD1, 0x8000 | rescal_code);
+	return 0;
+}
+int reset_rescal_code(struct cdns_hdmirx_device *hdmirx)
+{
+	write16(hdmirx, 0x1EC, 0x7F4);
+	write16(hdmirx, 0xD1, 0x0);
+	return 0;
+}
+
+int set_slicer_tune_val(struct cdns_hdmirx_device *hdmirx, u8 tune_val)
+{
+	write16(hdmirx, 0x8623, tune_val);
+	return 0;
+}
+
+int set_sigdet_refcnt_adj(struct cdns_hdmirx_device *hdmirx, u32 sigdet_refcnt_adj)
+{
+	u32 temp_val;
+	temp_val = sigdet_refcnt_adj;
+	write16(hdmirx, 0x8600, temp_val & 0xff);
+	temp_val = temp_val >> 8;
+	write16(hdmirx, 0x8601, temp_val & 0xff);
+	temp_val = temp_val >> 8;
+	write16(hdmirx, 0x8602, temp_val & 0xff);
+	temp_val = temp_val >> 8;
+	write16(hdmirx, 0x8603, temp_val & 0xff);
+	return 0;
+}
+
+int pma_power_state_chng(struct cdns_hdmirx_device *hdmirx, u8 power_state)
+{
+	u16 reg_val;
+	reg_field_t xcvr_power_state_req;
+	reg_field_t xcvr_power_state_ack;
+	ktime_t timeout;
+
+	xcvr_power_state_req.label = "xcvr_power_state_req";
+	xcvr_power_state_ack.label = "xcvr_power_state_ack";
+	xcvr_power_state_req.msb = 3;
+	xcvr_power_state_req.lsb = 0;
+	xcvr_power_state_ack.msb = 7;
+	xcvr_power_state_ack.lsb = 4;
+	set_field_value(&xcvr_power_state_req, power_state);
+	set_field_value(&xcvr_power_state_ack, power_state);
+
+	/* Get current power state: */
+	/* PHY_MODE_CTL */
+	reg_val = read16(hdmirx, PHY_MODE_CTL_ADDR);
+	dev_dbg(&hdmirx->pdev->dev, "pma_power_state_chng() PHY_MODE_CTL: 0x%04X\n", reg_val);
+
+	reg_val &= 0xFFF0;
+	reg_val |= set_reg_value(xcvr_power_state_req);
+
+	write16(hdmirx, PHY_MODE_CTL_ADDR, reg_val);
+	dev_dbg(&hdmirx->pdev->dev, "pma_power_state_chng() Requested power mode 0x%02X\n", power_state);
+
+	/* Wait for power mode acknowledged: */
+	/* PHY_MODE_CTL */
+	timeout = ktime_timeout_ms(PMA_POWER_CHNG_TIMEOUT_MS);
+	do {
+		udelay(5);
+		reg_val = read16(hdmirx, PHY_MODE_CTL_ADDR);
+		if ((reg_val & 0x00F0) == set_reg_value(xcvr_power_state_ack)) {
+			write16(hdmirx, PHY_MODE_CTL_ADDR, reg_val & 0xFFF0);
+			dev_dbg(&hdmirx->pdev->dev, "pma_power_state_chng() Done with PHY_MODE_CTL: 0x%04X\n", reg_val);
+			return 0;
+		}
+	} while (ktime_before(ktime_get(), timeout));
+
+	dev_warn(&hdmirx->pdev->dev, "pma_power_state_chng() Timed out with PHY_MODE_CTL: 0x%04X\n", reg_val);
+	write16(hdmirx, PHY_MODE_CTL_ADDR, reg_val & 0xFFF0);
+	return -1;
+}
+
+int pma_pll_config(struct cdns_hdmirx_device *hdmirx,
+		    u32 rx_clk_freq,
+		    u32 clk_ratio,
+		    u32 tmds_bit_clk_ratio,
+		    u8 data_rate_change)
+{
+	int i, loop;
+	u16 reg_val;
+	u64 vco_freq_khz;
+	const ktime_t timeout = ktime_timeout_ms(1000);
+
+	reg_field_t cmnda_pll0_ip_div;
+	reg_field_t cmnda_pll0_hs_sym_div_sel;
+	reg_field_t cmn_pll0_fb_div_high_ovrd_en;
+	reg_field_t cmnda_pll0_fb_div_high_out;
+	reg_field_t cmn_pll0_fb_div_low_ovrd_en;
+	reg_field_t cmnda_pll0_fb_div_low_out;
+	reg_field_t cmn_pll_clk_osr;
+	reg_field_t cmn_pll_clk_div2_ratio;
+	reg_field_t cmn_pll_clk_div2_sel;
+	reg_field_t rx_diag_smplr_osr;
+	reg_field_t rx_psc_a0;
+	reg_field_t rx_ree_pergcsm_eqenm_ph1;
+	reg_field_t rx_ree_pergcsm_eqenm_ph2;
+	reg_field_t vga_gain_accum_override_en;
+	reg_field_t vga_gain_accum_override;
+	reg_field_t vga_gain_tgt_adj_override_en;
+	reg_field_t vga_gain_tgt_adj_override;
+	reg_field_t ree_gen_sm_en_usb;
+	reg_field_t ree_gen_sm_en_periodic;
+	reg_field_t ana_en_epath_gen_ctrl_sm_usb;
+	reg_field_t ana_en_epath_gen_ctrl_sm_periodic;
+	reg_field_t rxda_eq_range_sel;
+	reg_field_t rxda_vga_sa_range_sel;
+	reg_field_t vco_ring_select;
+	reg_field_t cmnda_pll0_v2i_prog;
+	reg_field_t cmnda_pll0_coarse_prog;
+	reg_field_t cmnda_pll0_cp_gain;
+	reg_field_t cmnda_pll0_const_ndac_cntrl;
+	reg_field_t cmnda_pll0_const_pmos_cntrl;
+	reg_field_t cmnda_pll0_ptat_ndac_cntrl;
+	reg_field_t rxda_pi_iq_bias_trim;
+	reg_field_t rxda_pi_iq_pload_bias_trim;
+	reg_field_t rxda_pi_iq_pload_trim;
+	reg_field_t rxda_pi_e_bias_trim;
+	reg_field_t rxda_pi_e_pload_bias_trim;
+	reg_field_t rxda_pi_e_pload_trim;
+	reg_field_t rxda_pi_range_sel;
+	reg_field_t rxda_pi_cal_cm_trim;
+	reg_field_t xcvr_pll_en;
+	reg_field_t xcvr_link_reset_n;
+	reg_field_t xcvr_power_state_req;
+	reg_field_t xcvr_power_state_ack;
+	reg_field_t iso_pma_cmn_pll0_clk_datart1_div;
+	reg_field_t iso_pma_cmn_pll0_clk_datart0_div;
+	reg_field_t iso_pma_cmn_pll0_clk_en;
+
+	/* Set fields' labels */
+	cmnda_pll0_ip_div.label = "cmnda_pll0_ip_div";
+	cmnda_pll0_hs_sym_div_sel.label = "cmnda_pll0_hs_sym_div_sel";
+	cmn_pll0_fb_div_high_ovrd_en.label = "cmn_pll0_fb_div_high_ovrd_en";
+	cmnda_pll0_fb_div_high_out.label = "cmnda_pll0_fb_div_high_out";
+	cmn_pll0_fb_div_low_ovrd_en.label = "cmn_pll0_fb_div_low_ovrd_en";
+	cmnda_pll0_fb_div_low_out.label = "cmnda_pll0_fb_div_low_out";
+	cmn_pll_clk_osr.label = "cmn_pll_clk_osr";
+	cmn_pll_clk_div2_ratio.label = "cmn_pll_clk_div2_ratio";
+	cmn_pll_clk_div2_sel.label = "cmn_pll_clk_div2_sel";
+	rx_diag_smplr_osr.label = "rx_diag_smplr_osr";
+	rx_psc_a0.label = "rx_psc_a0";
+	rx_ree_pergcsm_eqenm_ph1.label = "rx_ree_pergcsm_eqenm_ph1";
+	rx_ree_pergcsm_eqenm_ph2.label = "rx_ree_pergcsm_eqenm_ph2";
+	vga_gain_accum_override_en.label = "vga_gain_accum_override_en";
+	vga_gain_accum_override.label = "vga_gain_accum_override";
+	vga_gain_tgt_adj_override_en.label = "vga_gain_tgt_adj_override_en";
+	vga_gain_tgt_adj_override.label = "vga_gain_tgt_adj_override";
+	ree_gen_sm_en_usb.label = "ree_gen_sm_en_usb";
+	ree_gen_sm_en_periodic.label = "ree_gen_sm_en_periodic";
+	ana_en_epath_gen_ctrl_sm_usb.label = "ana_en_epath_gen_ctrl_sm_usb";
+	ana_en_epath_gen_ctrl_sm_periodic.label =
+	    "ana_en_epath_gen_ctrl_sm_periodic";
+	rxda_eq_range_sel.label = "rxda_eq_range_sel";
+	rxda_vga_sa_range_sel.label = "rxda_vga_sa_range_sel";
+	vco_ring_select.label = "vco_ring_select";
+	cmnda_pll0_v2i_prog.label = "cmnda_pll0_v2i_prog";
+	cmnda_pll0_coarse_prog.label = "cmnda_pll0_coarse_prog";
+	cmnda_pll0_cp_gain.label = "cmnda_pll0_cp_gain";
+	cmnda_pll0_const_ndac_cntrl.label = "cmnda_pll0_const_ndac_cntrl";
+	cmnda_pll0_const_pmos_cntrl.label = "cmnda_pll0_const_pmos_cntrl";
+	cmnda_pll0_ptat_ndac_cntrl.label = "cmnda_pll0_ptat_ndac_cntrl";
+	rxda_pi_iq_bias_trim.label = "rxda_pi_iq_bias_trim";
+	rxda_pi_iq_pload_bias_trim.label = "rxda_pi_iq_pload_bias_trim";
+	rxda_pi_iq_pload_trim.label = "rxda_pi_iq_pload_trim";
+	rxda_pi_e_bias_trim.label = "rxda_pi_e_bias_trim";
+	rxda_pi_e_pload_bias_trim.label = "rxda_pi_e_pload_bias_trim";
+	rxda_pi_e_pload_trim.label = "rxda_pi_e_pload_trim";
+	rxda_pi_range_sel.label = "rxda_pi_range_sel";
+	rxda_pi_cal_cm_trim.label = "rxda_pi_cal_cm_trim";
+	xcvr_pll_en.label = "xcvr_pll_en";
+	xcvr_link_reset_n.label = "xcvr_link_reset_n";
+	xcvr_power_state_req.label = "xcvr_power_state_req";
+	xcvr_power_state_ack.label = "xcvr_power_state_ack";
+	iso_pma_cmn_pll0_clk_datart1_div.label = "iso_pma_cmn_pll0_clk_datart1_div";
+	iso_pma_cmn_pll0_clk_datart0_div.label = "iso_pma_cmn_pll0_clk_datart0_div";
+	iso_pma_cmn_pll0_clk_en.label = "iso_pma_cmn_pll0_clk_en";
+
+	/* Set field position in a target register */
+	cmnda_pll0_ip_div.msb = 7;
+	cmnda_pll0_ip_div.lsb = 0;
+	cmnda_pll0_hs_sym_div_sel.msb = 9;
+	cmnda_pll0_hs_sym_div_sel.lsb = 8;
+	cmn_pll0_fb_div_high_ovrd_en.msb = 15;
+	cmn_pll0_fb_div_high_ovrd_en.lsb = 15;
+	cmnda_pll0_fb_div_high_out.msb = 9;
+	cmnda_pll0_fb_div_high_out.lsb = 0;
+	cmn_pll0_fb_div_low_ovrd_en.msb = 15;
+	cmn_pll0_fb_div_low_ovrd_en.lsb = 15;
+	cmnda_pll0_fb_div_low_out.msb = 9;
+	cmnda_pll0_fb_div_low_out.lsb = 0;
+	cmn_pll_clk_osr.msb = 2;
+	cmn_pll_clk_osr.lsb = 0;
+	cmn_pll_clk_div2_ratio.msb = 6;
+	cmn_pll_clk_div2_ratio.lsb = 4;
+	cmn_pll_clk_div2_sel.msb = 9;
+	cmn_pll_clk_div2_sel.lsb = 8;
+	rx_diag_smplr_osr.msb = 2;
+	rx_diag_smplr_osr.lsb = 0;
+	rx_psc_a0.msb = 15;
+	rx_psc_a0.lsb = 0;
+	rx_ree_pergcsm_eqenm_ph1.msb = 15;
+	rx_ree_pergcsm_eqenm_ph1.lsb = 0;
+	rx_ree_pergcsm_eqenm_ph2.msb = 15;
+	rx_ree_pergcsm_eqenm_ph2.lsb = 0;
+	vga_gain_accum_override_en.msb = 7;
+	vga_gain_accum_override_en.lsb = 7;
+	vga_gain_accum_override.msb = 4;
+	vga_gain_accum_override.lsb = 0;
+	vga_gain_tgt_adj_override_en.msb = 15;
+	vga_gain_tgt_adj_override_en.lsb = 15;
+	vga_gain_tgt_adj_override.msb = 12;
+	vga_gain_tgt_adj_override.lsb = 8;
+	ree_gen_sm_en_usb.msb = 3;
+	ree_gen_sm_en_usb.lsb = 0;
+	ree_gen_sm_en_periodic.msb = 11;
+	ree_gen_sm_en_periodic.lsb = 8;
+	ana_en_epath_gen_ctrl_sm_usb.msb = 7;
+	ana_en_epath_gen_ctrl_sm_usb.lsb = 4;
+	ana_en_epath_gen_ctrl_sm_periodic.msb = 15;
+	ana_en_epath_gen_ctrl_sm_periodic.lsb = 12;
+	rxda_eq_range_sel.msb = 2;
+	rxda_eq_range_sel.lsb = 0;
+	rxda_vga_sa_range_sel.msb = 6;
+	rxda_vga_sa_range_sel.lsb = 4;
+	vco_ring_select.msb = 12;
+	vco_ring_select.lsb = 12;
+	cmnda_pll0_v2i_prog.msb = 5;
+	cmnda_pll0_v2i_prog.lsb = 4;
+	cmnda_pll0_coarse_prog.msb = 2;
+	cmnda_pll0_coarse_prog.lsb = 0;
+	cmnda_pll0_cp_gain.msb = 8;
+	cmnda_pll0_cp_gain.lsb = 0;
+	cmnda_pll0_const_ndac_cntrl.msb = 11;
+	cmnda_pll0_const_ndac_cntrl.lsb = 8;
+	cmnda_pll0_const_pmos_cntrl.msb = 7;
+	cmnda_pll0_const_pmos_cntrl.lsb = 0;
+	cmnda_pll0_ptat_ndac_cntrl.msb = 5;
+	cmnda_pll0_ptat_ndac_cntrl.lsb = 0;
+	rxda_pi_iq_bias_trim.msb = 14;
+	rxda_pi_iq_bias_trim.lsb = 12;
+	rxda_pi_iq_pload_bias_trim.msb = 10;
+	rxda_pi_iq_pload_bias_trim.lsb = 8;
+	rxda_pi_iq_pload_trim.msb = 7;
+	rxda_pi_iq_pload_trim.lsb = 0;
+	rxda_pi_e_bias_trim.msb = 14;
+	rxda_pi_e_bias_trim.lsb = 12;
+	rxda_pi_e_pload_bias_trim.msb = 10;
+	rxda_pi_e_pload_bias_trim.lsb = 8;
+	rxda_pi_e_pload_trim.msb = 7;
+	rxda_pi_e_pload_trim.lsb = 0;
+	rxda_pi_range_sel.msb = 11;
+	rxda_pi_range_sel.lsb = 8;
+	rxda_pi_cal_cm_trim.msb = 7;
+	rxda_pi_cal_cm_trim.lsb = 0;
+	xcvr_pll_en.msb = 12;
+	xcvr_pll_en.lsb = 12;
+	xcvr_link_reset_n.msb = 13;
+	xcvr_link_reset_n.lsb = 13;
+	xcvr_power_state_req.msb = 3;
+	xcvr_power_state_req.lsb = 0;
+	xcvr_power_state_ack.msb = 7;
+	xcvr_power_state_ack.lsb = 4;
+	iso_pma_cmn_pll0_clk_datart1_div.msb = 14;
+	iso_pma_cmn_pll0_clk_datart1_div.lsb = 11;
+	iso_pma_cmn_pll0_clk_datart0_div.msb = 10;
+	iso_pma_cmn_pll0_clk_datart0_div.lsb = 7;
+	iso_pma_cmn_pll0_clk_en.msb = 5;
+	iso_pma_cmn_pll0_clk_en.lsb = 5;
+
+	dev_dbg(&hdmirx->pdev->dev, "pma_pll_config() Configuring PLL0 ...\n");
+
+	if (tmds_bit_clk_ratio == TMDS_BIT_CLOCK_RATIO_1_10) {
+		if (inside_f(rx_clk_freq, 18750, 37500)) {
+			set_field_value(&cmnda_pll0_ip_div, 0x1);
+			set_field_value(&cmnda_pll0_hs_sym_div_sel, 0x0);
+			set_field_value(&cmn_pll0_fb_div_high_ovrd_en, 0x1);
+			set_field_value(&cmnda_pll0_fb_div_high_out, 0x1E);
+			set_field_value(&cmn_pll0_fb_div_low_ovrd_en, 0x1);
+			set_field_value(&cmnda_pll0_fb_div_low_out, 0x7E);
+			set_field_value(&rx_diag_smplr_osr, 0x4);
+			set_field_value(&rx_psc_a0, 0x8BF5);
+			set_field_value(&rx_ree_pergcsm_eqenm_ph1, 0x0080);
+			set_field_value(&rx_ree_pergcsm_eqenm_ph2, 0x0080);
+			set_field_value(&vga_gain_accum_override_en, 0x1);
+			set_field_value(&vga_gain_accum_override, 0x1A);
+			set_field_value(&vga_gain_tgt_adj_override_en, 0x0);
+			set_field_value(&vga_gain_tgt_adj_override, 0x00);
+			set_field_value(&ree_gen_sm_en_usb, 0x1);
+			set_field_value(&ree_gen_sm_en_periodic, 0x1);
+			set_field_value(&ana_en_epath_gen_ctrl_sm_usb, 0x0);
+			set_field_value(&ana_en_epath_gen_ctrl_sm_periodic,
+					0x0);
+			set_field_value(&rxda_eq_range_sel, 0x1);
+			set_field_value(&rxda_vga_sa_range_sel, 0x2);
+			switch (clk_ratio) {
+			case CLK_RATIO_1_1:
+				set_field_value(&cmn_pll_clk_osr, 0x4);
+				set_field_value(&cmn_pll_clk_div2_ratio, 0x0);
+				set_field_value(&cmn_pll_clk_div2_sel, 0x0);
+				break;
+			case CLK_RATIO_5_4:
+				set_field_value(&cmn_pll_clk_osr, 0x4);
+				set_field_value(&cmn_pll_clk_div2_ratio, 0x4);
+				set_field_value(&cmn_pll_clk_div2_sel, 0x1);
+				break;
+			case CLK_RATIO_3_2:
+				set_field_value(&cmn_pll_clk_osr, 0x4);
+				set_field_value(&cmn_pll_clk_div2_ratio, 0x5);
+				set_field_value(&cmn_pll_clk_div2_sel, 0x1);
+				break;
+			case CLK_RATIO_2_1:
+				set_field_value(&cmn_pll_clk_osr, 0x4);
+				set_field_value(&cmn_pll_clk_div2_ratio, 0x0);
+				set_field_value(&cmn_pll_clk_div2_sel, 0x3);
+				break;
+			case CLK_RATIO_1_2:
+				set_field_value(&cmn_pll_clk_osr, 0x4);
+				set_field_value(&cmn_pll_clk_div2_ratio, 0x0);
+				set_field_value(&cmn_pll_clk_div2_sel, 0x1);
+				break;
+			case CLK_RATIO_5_8:
+				set_field_value(&cmn_pll_clk_osr, 0x4);
+				set_field_value(&cmn_pll_clk_div2_ratio, 0x1);
+				set_field_value(&cmn_pll_clk_div2_sel, 0x1);
+				break;
+			case CLK_RATIO_3_4:
+				set_field_value(&cmn_pll_clk_osr, 0x4);
+				set_field_value(&cmn_pll_clk_div2_ratio, 0x2);
+				set_field_value(&cmn_pll_clk_div2_sel, 0x1);
+				break;
+			}
+		} else if (inside_f(rx_clk_freq, 37500, 75000)) {
+			set_field_value(&cmnda_pll0_ip_div, 0x1);
+			set_field_value(&cmnda_pll0_hs_sym_div_sel, 0x0);
+			set_field_value(&cmn_pll0_fb_div_high_ovrd_en, 0x1);
+			set_field_value(&cmnda_pll0_fb_div_high_out, 0x0E);
+			set_field_value(&cmn_pll0_fb_div_low_ovrd_en, 0x1);
+			set_field_value(&cmnda_pll0_fb_div_low_out, 0x3E);
+			set_field_value(&rx_diag_smplr_osr, 0x3);
+			set_field_value(&rx_psc_a0, 0x8BF5);
+			set_field_value(&rx_ree_pergcsm_eqenm_ph1, 0x0080);
+			set_field_value(&rx_ree_pergcsm_eqenm_ph2, 0x0080);
+			set_field_value(&vga_gain_accum_override_en, 0x1);
+			set_field_value(&vga_gain_accum_override, 0x1A);
+			set_field_value(&vga_gain_tgt_adj_override_en, 0x0);
+			set_field_value(&vga_gain_tgt_adj_override, 0x00);
+			set_field_value(&ree_gen_sm_en_usb, 0x1);
+			set_field_value(&ree_gen_sm_en_periodic, 0x1);
+			set_field_value(&ana_en_epath_gen_ctrl_sm_usb, 0x0);
+			set_field_value(&ana_en_epath_gen_ctrl_sm_periodic,
+					0x0);
+			set_field_value(&rxda_eq_range_sel, 0x1);
+			set_field_value(&rxda_vga_sa_range_sel, 0x2);
+			switch (clk_ratio) {
+			case CLK_RATIO_1_1:
+				set_field_value(&cmn_pll_clk_osr, 0x3);
+				set_field_value(&cmn_pll_clk_div2_ratio, 0x0);
+				set_field_value(&cmn_pll_clk_div2_sel, 0x0);
+				break;
+			case CLK_RATIO_5_4:
+				set_field_value(&cmn_pll_clk_osr, 0x3);
+				set_field_value(&cmn_pll_clk_div2_ratio, 0x4);
+				set_field_value(&cmn_pll_clk_div2_sel, 0x1);
+				break;
+			case CLK_RATIO_3_2:
+				set_field_value(&cmn_pll_clk_osr, 0x3);
+				set_field_value(&cmn_pll_clk_div2_ratio, 0x5);
+				set_field_value(&cmn_pll_clk_div2_sel, 0x1);
+				break;
+			case CLK_RATIO_2_1:
+				set_field_value(&cmn_pll_clk_osr, 0x3);
+				set_field_value(&cmn_pll_clk_div2_ratio, 0x0);
+				set_field_value(&cmn_pll_clk_div2_sel, 0x3);
+				break;
+			case CLK_RATIO_1_2:
+				set_field_value(&cmn_pll_clk_osr, 0x3);
+				set_field_value(&cmn_pll_clk_div2_ratio, 0x0);
+				set_field_value(&cmn_pll_clk_div2_sel, 0x1);
+				break;
+			case CLK_RATIO_5_8:
+				set_field_value(&cmn_pll_clk_osr, 0x3);
+				set_field_value(&cmn_pll_clk_div2_ratio, 0x1);
+				set_field_value(&cmn_pll_clk_div2_sel, 0x1);
+				break;
+			case CLK_RATIO_3_4:
+				set_field_value(&cmn_pll_clk_osr, 0x3);
+				set_field_value(&cmn_pll_clk_div2_ratio, 0x2);
+				set_field_value(&cmn_pll_clk_div2_sel, 0x1);
+				break;
+			}
+		} else if (inside_f(rx_clk_freq, 75000, 150000)) {
+			set_field_value(&cmnda_pll0_ip_div, 0x1);
+			set_field_value(&cmnda_pll0_hs_sym_div_sel, 0x0);
+			set_field_value(&cmn_pll0_fb_div_high_ovrd_en, 0x1);
+			set_field_value(&cmnda_pll0_fb_div_high_out, 0x0A);
+			set_field_value(&cmn_pll0_fb_div_low_ovrd_en, 0x1);
+			set_field_value(&cmnda_pll0_fb_div_low_out, 0x1A);
+			set_field_value(&rx_diag_smplr_osr, 0x2);
+			set_field_value(&rx_psc_a0, 0x8BF5);
+			set_field_value(&rx_ree_pergcsm_eqenm_ph1, 0x0080);
+			set_field_value(&rx_ree_pergcsm_eqenm_ph2, 0x0080);
+			set_field_value(&vga_gain_accum_override_en, 0x1);
+			set_field_value(&vga_gain_accum_override, 0x1A);
+			set_field_value(&vga_gain_tgt_adj_override_en, 0x0);
+			set_field_value(&vga_gain_tgt_adj_override, 0x00);
+			set_field_value(&ree_gen_sm_en_usb, 0x1);
+			set_field_value(&ree_gen_sm_en_periodic, 0x1);
+			set_field_value(&ana_en_epath_gen_ctrl_sm_usb, 0x0);
+			set_field_value(&ana_en_epath_gen_ctrl_sm_periodic,
+					0x0);
+			set_field_value(&rxda_eq_range_sel, 0x1);
+			set_field_value(&rxda_vga_sa_range_sel, 0x2);
+			switch (clk_ratio) {
+			case CLK_RATIO_1_1:
+				set_field_value(&cmn_pll_clk_osr, 0x2);
+				set_field_value(&cmn_pll_clk_div2_ratio, 0x0);
+				set_field_value(&cmn_pll_clk_div2_sel, 0x0);
+				break;
+			case CLK_RATIO_5_4:
+				set_field_value(&cmn_pll_clk_osr, 0x2);
+				set_field_value(&cmn_pll_clk_div2_ratio, 0x4);
+				set_field_value(&cmn_pll_clk_div2_sel, 0x1);
+				break;
+			case CLK_RATIO_3_2:
+				set_field_value(&cmn_pll_clk_osr, 0x2);
+				set_field_value(&cmn_pll_clk_div2_ratio, 0x5);
+				set_field_value(&cmn_pll_clk_div2_sel, 0x1);
+				break;
+			case CLK_RATIO_2_1:
+				set_field_value(&cmn_pll_clk_osr, 0x2);
+				set_field_value(&cmn_pll_clk_div2_ratio, 0x0);
+				set_field_value(&cmn_pll_clk_div2_sel, 0x3);
+				break;
+			case CLK_RATIO_1_2:
+				set_field_value(&cmn_pll_clk_osr, 0x2);
+				set_field_value(&cmn_pll_clk_div2_ratio, 0x0);
+				set_field_value(&cmn_pll_clk_div2_sel, 0x1);
+				break;
+			case CLK_RATIO_5_8:
+				set_field_value(&cmn_pll_clk_osr, 0x2);
+				set_field_value(&cmn_pll_clk_div2_ratio, 0x1);
+				set_field_value(&cmn_pll_clk_div2_sel, 0x1);
+				break;
+			case CLK_RATIO_3_4:
+				set_field_value(&cmn_pll_clk_osr, 0x2);
+				set_field_value(&cmn_pll_clk_div2_ratio, 0x2);
+				set_field_value(&cmn_pll_clk_div2_sel, 0x1);
+				break;
+			}
+		} else if (inside_f(rx_clk_freq, 150000, 300000)) {
+			set_field_value(&cmnda_pll0_ip_div, 0x2);
+			set_field_value(&cmnda_pll0_hs_sym_div_sel, 0x0);
+			set_field_value(&cmn_pll0_fb_div_high_ovrd_en, 0x1);
+			set_field_value(&cmnda_pll0_fb_div_high_out, 0x0A);
+			set_field_value(&cmn_pll0_fb_div_low_ovrd_en, 0x1);
+			set_field_value(&cmnda_pll0_fb_div_low_out, 0x1A);
+			set_field_value(&rx_diag_smplr_osr, 0x1);
+			set_field_value(&rx_psc_a0, 0x8BF5);
+			set_field_value(&rx_ree_pergcsm_eqenm_ph1, 0x0080);
+			set_field_value(&rx_ree_pergcsm_eqenm_ph2, 0x0080);
+			set_field_value(&vga_gain_accum_override_en, 0x1);
+			set_field_value(&vga_gain_accum_override, 0x1A);
+			set_field_value(&vga_gain_tgt_adj_override_en, 0x0);
+			set_field_value(&vga_gain_tgt_adj_override, 0x00);
+			set_field_value(&ree_gen_sm_en_usb, 0x1);
+			set_field_value(&ree_gen_sm_en_periodic, 0x1);
+			set_field_value(&ana_en_epath_gen_ctrl_sm_usb, 0x0);
+			set_field_value(&ana_en_epath_gen_ctrl_sm_periodic,
+					0x0);
+			set_field_value(&rxda_eq_range_sel, 0x2);
+			set_field_value(&rxda_vga_sa_range_sel, 0x3);
+			switch (clk_ratio) {
+			case CLK_RATIO_1_1:
+				set_field_value(&cmn_pll_clk_osr, 0x1);
+				set_field_value(&cmn_pll_clk_div2_ratio, 0x0);
+				set_field_value(&cmn_pll_clk_div2_sel, 0x0);
+				break;
+			case CLK_RATIO_5_4:
+				set_field_value(&cmn_pll_clk_osr, 0x1);
+				set_field_value(&cmn_pll_clk_div2_ratio, 0x4);
+				set_field_value(&cmn_pll_clk_div2_sel, 0x1);
+				break;
+			case CLK_RATIO_3_2:
+				set_field_value(&cmn_pll_clk_osr, 0x1);
+				set_field_value(&cmn_pll_clk_div2_ratio, 0x5);
+				set_field_value(&cmn_pll_clk_div2_sel, 0x1);
+				break;
+			case CLK_RATIO_2_1:
+				set_field_value(&cmn_pll_clk_osr, 0x1);
+				set_field_value(&cmn_pll_clk_div2_ratio, 0x0);
+				set_field_value(&cmn_pll_clk_div2_sel, 0x3);
+				break;
+			case CLK_RATIO_1_2:
+				set_field_value(&cmn_pll_clk_osr, 0x1);
+				set_field_value(&cmn_pll_clk_div2_ratio, 0x0);
+				set_field_value(&cmn_pll_clk_div2_sel, 0x1);
+				break;
+			case CLK_RATIO_5_8:
+				set_field_value(&cmn_pll_clk_osr, 0x1);
+				set_field_value(&cmn_pll_clk_div2_ratio, 0x1);
+				set_field_value(&cmn_pll_clk_div2_sel, 0x1);
+				break;
+			case CLK_RATIO_3_4:
+				set_field_value(&cmn_pll_clk_osr, 0x1);
+				set_field_value(&cmn_pll_clk_div2_ratio, 0x2);
+				set_field_value(&cmn_pll_clk_div2_sel, 0x1);
+				break;
+			}
+		} else if (inside_f(rx_clk_freq, 300000, 340000)) {
+			set_field_value(&cmnda_pll0_ip_div, 0x3);
+			set_field_value(&cmnda_pll0_hs_sym_div_sel, 0x0);
+			set_field_value(&cmn_pll0_fb_div_high_ovrd_en, 0x1);
+			set_field_value(&cmnda_pll0_fb_div_high_out, 0x0A);
+			set_field_value(&cmn_pll0_fb_div_low_ovrd_en, 0x1);
+			set_field_value(&cmnda_pll0_fb_div_low_out, 0x10);
+			set_field_value(&rx_diag_smplr_osr, 0x0);
+			set_field_value(&rx_psc_a0, 0x8BF5);
+			set_field_value(&rx_ree_pergcsm_eqenm_ph1, 0x0080);
+			set_field_value(&rx_ree_pergcsm_eqenm_ph2, 0x0080);
+			set_field_value(&vga_gain_accum_override_en, 0x1);
+			set_field_value(&vga_gain_accum_override, 0x1A);
+			set_field_value(&vga_gain_tgt_adj_override_en, 0x0);
+			set_field_value(&vga_gain_tgt_adj_override, 0x00);
+			set_field_value(&ree_gen_sm_en_usb, 0x1);
+			set_field_value(&ree_gen_sm_en_periodic, 0x1);
+			set_field_value(&ana_en_epath_gen_ctrl_sm_usb, 0x0);
+			set_field_value(&ana_en_epath_gen_ctrl_sm_periodic,
+					0x0);
+			set_field_value(&rxda_eq_range_sel, 0x3);
+			set_field_value(&rxda_vga_sa_range_sel, 0x3);
+			switch (clk_ratio) {
+			case CLK_RATIO_1_1:
+				set_field_value(&cmn_pll_clk_osr, 0x0);
+				set_field_value(&cmn_pll_clk_div2_ratio, 0x0);
+				set_field_value(&cmn_pll_clk_div2_sel, 0x0);
+				break;
+			case CLK_RATIO_5_4:
+				set_field_value(&cmn_pll_clk_osr, 0x0);
+				set_field_value(&cmn_pll_clk_div2_ratio, 0x4);
+				set_field_value(&cmn_pll_clk_div2_sel, 0x1);
+				break;
+			case CLK_RATIO_3_2:
+				set_field_value(&cmn_pll_clk_osr, 0x0);
+				set_field_value(&cmn_pll_clk_div2_ratio, 0x5);
+				set_field_value(&cmn_pll_clk_div2_sel, 0x1);
+				break;
+			case CLK_RATIO_2_1:
+				set_field_value(&cmn_pll_clk_osr, 0x0);
+				set_field_value(&cmn_pll_clk_div2_ratio, 0x0);
+				set_field_value(&cmn_pll_clk_div2_sel, 0x3);
+				break;
+			case CLK_RATIO_1_2:
+				set_field_value(&cmn_pll_clk_osr, 0x0);
+				set_field_value(&cmn_pll_clk_div2_ratio, 0x0);
+				set_field_value(&cmn_pll_clk_div2_sel, 0x1);
+				break;
+			case CLK_RATIO_5_8:
+				set_field_value(&cmn_pll_clk_osr, 0x0);
+				set_field_value(&cmn_pll_clk_div2_ratio, 0x1);
+				set_field_value(&cmn_pll_clk_div2_sel, 0x1);
+				break;
+			case CLK_RATIO_3_4:
+				set_field_value(&cmn_pll_clk_osr, 0x0);
+				set_field_value(&cmn_pll_clk_div2_ratio, 0x2);
+				set_field_value(&cmn_pll_clk_div2_sel, 0x1);
+				break;
+			}
+		} else {
+			dev_err(&hdmirx->pdev->dev, "TMDS clock frequency (%d KHz) is out of range\n", rx_clk_freq);
+			return -1;
+		}
+
+	} else {		/* TMDS_BIT_CLOCK_RATIO_1_40 */
+		if (inside_f(rx_clk_freq, 85000, 150000)) {
+			set_field_value(&cmnda_pll0_ip_div, 0x1);
+			set_field_value(&cmnda_pll0_hs_sym_div_sel, 0x0);
+			set_field_value(&cmn_pll0_fb_div_high_ovrd_en, 0x1);
+			set_field_value(&cmnda_pll0_fb_div_high_out, 0x0A);
+			set_field_value(&cmn_pll0_fb_div_low_ovrd_en, 0x1);
+			set_field_value(&cmnda_pll0_fb_div_low_out, 0x1A);
+			set_field_value(&rx_diag_smplr_osr, 0x0);
+			set_field_value(&rx_psc_a0, 0x8BFD);
+			set_field_value(&rx_ree_pergcsm_eqenm_ph1, 0x019F);
+			set_field_value(&rx_ree_pergcsm_eqenm_ph2, 0x019F);
+			set_field_value(&vga_gain_accum_override_en, 0x0);
+			set_field_value(&vga_gain_accum_override, 0x01);
+			set_field_value(&vga_gain_tgt_adj_override_en, 0x0);
+			set_field_value(&vga_gain_tgt_adj_override, 0x1F);
+			set_field_value(&ree_gen_sm_en_usb, 0x1);
+			set_field_value(&ree_gen_sm_en_periodic, 0x1);
+			set_field_value(&ana_en_epath_gen_ctrl_sm_usb, 0x0);
+			set_field_value(&ana_en_epath_gen_ctrl_sm_periodic, 0x1);
+			set_field_value(&rxda_eq_range_sel, 0x3);
+			set_field_value(&rxda_vga_sa_range_sel, 0x3);
+			switch (clk_ratio) {
+			case CLK_RATIO_1_1:
+				set_field_value(&cmn_pll_clk_osr, 0x00);
+				set_field_value(&cmn_pll_clk_div2_ratio, 0x0);
+				set_field_value(&cmn_pll_clk_div2_sel, 0x0);
+				break;
+			case CLK_RATIO_5_4:
+				set_field_value(&cmn_pll_clk_osr, 0x00);
+				set_field_value(&cmn_pll_clk_div2_ratio, 0x4);
+				set_field_value(&cmn_pll_clk_div2_sel, 0x1);
+				break;
+			case CLK_RATIO_3_2:
+				set_field_value(&cmn_pll_clk_osr, 0x00);
+				set_field_value(&cmn_pll_clk_div2_ratio, 0x5);
+				set_field_value(&cmn_pll_clk_div2_sel, 0x1);
+				break;
+			case CLK_RATIO_2_1:
+				set_field_value(&cmn_pll_clk_osr, 0x00);
+				set_field_value(&cmn_pll_clk_div2_ratio, 0x0);
+				set_field_value(&cmn_pll_clk_div2_sel, 0x3);
+				break;
+			case CLK_RATIO_1_2:
+				set_field_value(&cmn_pll_clk_osr, 0x00);
+				set_field_value(&cmn_pll_clk_div2_ratio, 0x0);
+				set_field_value(&cmn_pll_clk_div2_sel, 0x1);
+				break;
+			case CLK_RATIO_5_8:
+				set_field_value(&cmn_pll_clk_osr, 0x00);
+				set_field_value(&cmn_pll_clk_div2_ratio, 0x1);
+				set_field_value(&cmn_pll_clk_div2_sel, 0x1);
+				break;
+			case CLK_RATIO_3_4:
+				set_field_value(&cmn_pll_clk_osr, 0x00);
+				set_field_value(&cmn_pll_clk_div2_ratio, 0x2);
+				set_field_value(&cmn_pll_clk_div2_sel, 0x1);
+				break;
+			}
+		} else {
+			dev_err(&hdmirx->pdev->dev, "pma_pll_config() *E: TMDS clock frequency (%d kHz) is out of range\n",
+			     rx_clk_freq);
+			return -1;
+		}
+	}
+
+	vco_freq_khz =
+	    (2048 * (u64) rx_clk_freq * (1 << cmn_pll_clk_osr.value) * tmds_bit_clk_ratio) / 2047;
+
+	dev_info(&hdmirx->pdev->dev, "VCO frequency (refclk: %d kHz, TMDS clk: %d kHz, OSR: %0d, tmds_bit_clk_ratio: %d) equals %llu kHz\n",
+	     REFCLK_FREQ_KHZ, rx_clk_freq, 1 << cmn_pll_clk_osr.value,
+	     tmds_bit_clk_ratio, vco_freq_khz);
+
+	if (inside_f(vco_freq_khz, 3000000, 3400000 - 1000)) {
+		set_field_value(&vco_ring_select, 0x0);
+		set_field_value(&cmnda_pll0_v2i_prog, 0x0);
+		set_field_value(&cmnda_pll0_coarse_prog, 0x3);
+		switch (cmnda_pll0_fb_div_low_out.value) {
+		case 0x7E:
+			set_field_value(&cmnda_pll0_cp_gain, 0x78);
+			break;
+		case 0x3E:
+			set_field_value(&cmnda_pll0_cp_gain, 0x78);
+			break;
+		case 0x10:
+			set_field_value(&cmnda_pll0_cp_gain, 0x58);
+			break;
+		default:
+			set_field_value(&cmnda_pll0_cp_gain, 0x78);
+		}
+		set_field_value(&cmnda_pll0_const_ndac_cntrl, 0x0);
+		set_field_value(&cmnda_pll0_const_pmos_cntrl, 0x04);
+		set_field_value(&cmnda_pll0_ptat_ndac_cntrl, 0x0D);
+	} else if (inside_f(vco_freq_khz, 3400000, 3687000 - 1000)) {
+		set_field_value(&vco_ring_select, 0x1);
+		set_field_value(&cmnda_pll0_v2i_prog, 0x1);
+		set_field_value(&cmnda_pll0_coarse_prog, 0x7);
+		switch (cmnda_pll0_fb_div_low_out.value) {
+		case 0x7E:
+			set_field_value(&cmnda_pll0_cp_gain, 0x68);
+			break;
+		case 0x3E:
+			set_field_value(&cmnda_pll0_cp_gain, 0x68);
+			break;
+		case 0x10:
+			set_field_value(&cmnda_pll0_cp_gain, 0x59);
+			break;
+		default:
+			set_field_value(&cmnda_pll0_cp_gain, 0x68);
+		}
+		set_field_value(&cmnda_pll0_const_ndac_cntrl, 0x0);
+		set_field_value(&cmnda_pll0_const_pmos_cntrl, 0x8E);
+		set_field_value(&cmnda_pll0_ptat_ndac_cntrl, 0x2F);
+	} else if (inside_f(vco_freq_khz, 3687000, 3999000 - 1000)) {
+		set_field_value(&vco_ring_select, 0x1);
+		set_field_value(&cmnda_pll0_v2i_prog, 0x1);
+		set_field_value(&cmnda_pll0_coarse_prog, 0x7);
+		set_field_value(&cmnda_pll0_cp_gain, 0x64);
+		set_field_value(&cmnda_pll0_const_ndac_cntrl, 0x0);
+		set_field_value(&cmnda_pll0_const_pmos_cntrl, 0x8E);
+		set_field_value(&cmnda_pll0_ptat_ndac_cntrl, 0x2F);
+	} else if (inside_f(vco_freq_khz, 3999000, 4337000 - 1000)) {
+		set_field_value(&vco_ring_select, 0x1);
+		set_field_value(&cmnda_pll0_v2i_prog, 0x1);
+		set_field_value(&cmnda_pll0_coarse_prog, 0x7);
+		set_field_value(&cmnda_pll0_cp_gain, 0x56);
+		set_field_value(&cmnda_pll0_const_ndac_cntrl, 0x0);
+		set_field_value(&cmnda_pll0_const_pmos_cntrl, 0x8E);
+		set_field_value(&cmnda_pll0_ptat_ndac_cntrl, 0x2F);
+	} else if (inside_f(vco_freq_khz, 4337000, 4703000 - 1000)) {
+		set_field_value(&vco_ring_select, 0x1);
+		set_field_value(&cmnda_pll0_v2i_prog, 0x1);
+		set_field_value(&cmnda_pll0_coarse_prog, 0x7);
+		set_field_value(&cmnda_pll0_cp_gain, 0x58);
+		set_field_value(&cmnda_pll0_const_ndac_cntrl, 0x0);
+		set_field_value(&cmnda_pll0_const_pmos_cntrl, 0x8E);
+		set_field_value(&cmnda_pll0_ptat_ndac_cntrl, 0x2F);
+	} else if (inside_f(vco_freq_khz, 4703000, 5101000 - 1000)) {
+		set_field_value(&vco_ring_select, 0x1);
+		set_field_value(&cmnda_pll0_v2i_prog, 0x1);
+		set_field_value(&cmnda_pll0_coarse_prog, 0x7);
+		set_field_value(&cmnda_pll0_cp_gain, 0x54);
+		set_field_value(&cmnda_pll0_const_ndac_cntrl, 0x0);
+		set_field_value(&cmnda_pll0_const_pmos_cntrl, 0x04);
+		set_field_value(&cmnda_pll0_ptat_ndac_cntrl, 0x0D);
+	} else if (inside_f(vco_freq_khz, 5101000, 5532000 - 1000)) {
+		set_field_value(&vco_ring_select, 0x1);
+		set_field_value(&cmnda_pll0_v2i_prog, 0x1);
+		set_field_value(&cmnda_pll0_coarse_prog, 0x7);
+		set_field_value(&cmnda_pll0_cp_gain, 0x49);
+		set_field_value(&cmnda_pll0_const_ndac_cntrl, 0x0);
+		set_field_value(&cmnda_pll0_const_pmos_cntrl, 0x04);
+		set_field_value(&cmnda_pll0_ptat_ndac_cntrl, 0x0D);
+	} else if (inside_f(vco_freq_khz, 5532000, 6000000 - 1000)) {
+		set_field_value(&vco_ring_select, 0x1);
+		set_field_value(&cmnda_pll0_v2i_prog, 0x1);
+		set_field_value(&cmnda_pll0_coarse_prog, 0x7);
+		set_field_value(&cmnda_pll0_cp_gain, 0x3E);
+		set_field_value(&cmnda_pll0_const_ndac_cntrl, 0x0);
+		set_field_value(&cmnda_pll0_const_pmos_cntrl, 0x04);
+		set_field_value(&cmnda_pll0_ptat_ndac_cntrl, 0x0D);
+	} else {
+		dev_err(&hdmirx->pdev->dev, "%s VCO frequency (%llu KHz) is out of range\n", __func__, vco_freq_khz);
+		return -1;
+	}
+
+	if (inside_f(vco_freq_khz, 3000000, 4000000)) {
+		set_field_value(&rxda_pi_iq_bias_trim, 0x5);
+		set_field_value(&rxda_pi_iq_pload_bias_trim, 0x2);
+		set_field_value(&rxda_pi_iq_pload_trim, 0x3F);
+		set_field_value(&rxda_pi_e_bias_trim, 0x5);
+		set_field_value(&rxda_pi_e_pload_bias_trim, 0x2);
+		set_field_value(&rxda_pi_e_pload_trim, 0x3F);
+		set_field_value(&rxda_pi_range_sel, 0x2);
+		set_field_value(&rxda_pi_cal_cm_trim, 0x00);
+	} else if (inside_f(vco_freq_khz, 4000000, 6000000)) {
+		set_field_value(&rxda_pi_iq_bias_trim, 0x5);
+		set_field_value(&rxda_pi_iq_pload_bias_trim, 0x4);
+		set_field_value(&rxda_pi_iq_pload_trim, 0x3F);
+		set_field_value(&rxda_pi_e_bias_trim, 0x5);
+		set_field_value(&rxda_pi_e_pload_bias_trim, 0x4);
+		set_field_value(&rxda_pi_e_pload_trim, 0x3F);
+		set_field_value(&rxda_pi_range_sel, 0x3);
+		set_field_value(&rxda_pi_cal_cm_trim, 0x00);
+	}
+	set_field_value(&xcvr_pll_en, 0x1);
+	set_field_value(&xcvr_link_reset_n, 0x0);
+	set_field_value(&xcvr_power_state_req, 0x0);
+	set_field_value(&iso_pma_cmn_pll0_clk_datart1_div, 0x1);
+	set_field_value(&iso_pma_cmn_pll0_clk_datart0_div, 0x2);
+	set_field_value(&iso_pma_cmn_pll0_clk_en, 0x1);
+
+	/*******************************************************
+	* Register setting
+	********************************************************/
+
+	/* CMN_DIAG_PLL0_INCLK_CTRL */
+	reg_val = set_reg_value(cmnda_pll0_ip_div);
+	reg_val |= set_reg_value(cmnda_pll0_hs_sym_div_sel);
+	write16(hdmirx, CMN_DIAG_PLL0_INCLK_CTRL_ADDR, reg_val);
+
+	/* CMN_DIAG_PLL0_FBH_OVRD */
+	reg_val = set_reg_value(cmn_pll0_fb_div_high_ovrd_en);
+	reg_val |= set_reg_value(cmnda_pll0_fb_div_high_out);
+	write16(hdmirx, CMN_DIAG_PLL0_FBH_OVRD_ADDR, reg_val);
+
+	/* CMN_DIAG_PLL0_FBL_OVRD */
+	reg_val = set_reg_value(cmn_pll0_fb_div_low_ovrd_en);
+	reg_val |= set_reg_value(cmnda_pll0_fb_div_low_out);
+	write16(hdmirx, CMN_DIAG_PLL0_FBL_OVRD_ADDR, reg_val);
+
+	/* CMN_PLL0_DIV2SEL_OSR_CTRL */
+	reg_val = set_reg_value(cmn_pll_clk_osr);
+	reg_val |= set_reg_value(cmn_pll_clk_div2_ratio);
+	reg_val |= set_reg_value(cmn_pll_clk_div2_sel);
+	write16(hdmirx, CMN_PLL0_DIV2SEL_OSR_CTRL_ADDR, reg_val);
+
+	/* RX_DIAG_SMPLR_OSR */
+	reg_val = set_reg_value(rx_diag_smplr_osr);
+	multi_write16(hdmirx, RX_DIAG_SMPLR_OSR_ADDR, reg_val);
+
+	/* RX_PSC_A0 */
+	reg_val = set_reg_value(rx_psc_a0);
+	multi_write16(hdmirx, RX_PSC_A0_ADDR, reg_val);
+
+	/* RX_REE_PERGCSM_EQENM_PH1 */
+	reg_val = set_reg_value(rx_ree_pergcsm_eqenm_ph1);
+	multi_write16(hdmirx, RX_REE_PERGCSM_EQENM_PH1_ADDR, reg_val);
+
+	/* RX_REE_PERGCSM_EQENM_PH1 */
+	reg_val = set_reg_value(rx_ree_pergcsm_eqenm_ph2);
+	multi_write16(hdmirx, RX_REE_PERGCSM_EQENM_PH2_ADDR, reg_val);
+
+	/* RX_REE_VGA_GAIN_OVRD */
+	reg_val = set_reg_value(vga_gain_accum_override_en);
+	reg_val |= set_reg_value(vga_gain_accum_override);
+	reg_val |= set_reg_value(vga_gain_tgt_adj_override_en);
+	reg_val |= set_reg_value(vga_gain_tgt_adj_override);
+	multi_write16(hdmirx, RX_REE_VGA_GAIN_OVRD_ADDR, reg_val);
+
+	/* RX_REE_SMGM_CTRL1 */
+	reg_val = set_reg_value(ree_gen_sm_en_usb);
+	reg_val |= set_reg_value(ree_gen_sm_en_periodic);
+	reg_val |= set_reg_value(ana_en_epath_gen_ctrl_sm_usb);
+	reg_val |= set_reg_value(ana_en_epath_gen_ctrl_sm_periodic);
+	multi_write16(hdmirx, RX_REE_SMGM_CTRL1_ADDR, reg_val);
+
+	/* RX_DIAG_DFE_CTRL2 */
+	reg_val = set_reg_value(rxda_eq_range_sel);
+	reg_val |= set_reg_value(rxda_vga_sa_range_sel);
+	multi_write16(hdmirx, RX_DIAG_DFE_CTRL2_ADDR, reg_val);
+
+	/* CMN_PLLSM0_USER_DEF_CTRL */
+	reg_val = set_reg_value(vco_ring_select);
+	write16(hdmirx, CMN_PLLSM0_USER_DEF_CTRL_ADDR, reg_val);
+
+	/* CMN_DIAG_PLL0_V2I_TUNE */
+	reg_val = set_reg_value(cmnda_pll0_v2i_prog);
+	reg_val |= set_reg_value(cmnda_pll0_coarse_prog);
+	write16(hdmirx, CMN_DIAG_PLL0_V2I_TUNE_ADDR, reg_val);
+
+	/* CMN_DIAG_PLL0_CP_TUNE */
+	reg_val = set_reg_value(cmnda_pll0_cp_gain);
+	write16(hdmirx, CMN_DIAG_PLL0_CP_TUNE_ADDR, reg_val);
+
+	/* CMN_DIAG_PLL0_PTATIS_TUNE1 */
+	reg_val = set_reg_value(cmnda_pll0_const_ndac_cntrl);
+	reg_val |= set_reg_value(cmnda_pll0_const_pmos_cntrl);
+	write16(hdmirx, CMN_DIAG_PLL0_PTATIS_TUNE1_ADDR, reg_val);
+
+	/* CMN_DIAG_PLL0_PTATIS_TUNE2 */
+	reg_val = set_reg_value(cmnda_pll0_ptat_ndac_cntrl);
+	write16(hdmirx, CMN_DIAG_PLL0_PTATIS_TUNE2_ADDR, reg_val);
+
+	/* RX_DIAG_ILL_IQ_TRIM0 */
+	reg_val = set_reg_value(rxda_pi_iq_bias_trim);
+	reg_val |= set_reg_value(rxda_pi_iq_pload_bias_trim);
+	reg_val |= set_reg_value(rxda_pi_iq_pload_trim);
+	write16(hdmirx, RX_DIAG_ILL_IQ_TRIM0_ADDR, reg_val);
+
+	/* RX_DIAG_ILL_E_TRIM0 */
+	reg_val = set_reg_value(rxda_pi_e_bias_trim);
+	reg_val |= set_reg_value(rxda_pi_e_pload_bias_trim);
+	reg_val |= set_reg_value(rxda_pi_e_pload_trim);
+	write16(hdmirx, RX_DIAG_ILL_E_TRIM0_ADDR, reg_val);
+
+	/* RX_DIAG_ILL_IQE_TRIM2 */
+	reg_val = set_reg_value(rxda_pi_range_sel);
+	reg_val |= set_reg_value(rxda_pi_cal_cm_trim);
+	write16(hdmirx, RX_DIAG_ILL_IQE_TRIM2_ADDR, reg_val);
+
+	/* Enable PLL */
+	/* PHY_MODE_CTL */
+	reg_val = set_reg_value(xcvr_pll_en);
+	reg_val |= set_reg_value(xcvr_link_reset_n);
+	reg_val |= set_reg_value(xcvr_power_state_req);
+	write16(hdmirx, PHY_MODE_CTL_ADDR, reg_val);
+
+	/* Wait for PLL0 ready: */
+	/* PHY_PMA_CMN_CTRL2 */
+	do {
+		if (ktime_after(ktime_get(), timeout))
+			goto timeout_err;
+		udelay(10);
+	} while ((read16(hdmirx, PHY_PMA_CMN_CTRL2_ADDR) & (1 << 0)) == 0);
+
+	/* Turn on output clocks: */
+	/* PHY_PMA_CMN_CTRL2 */
+	reg_val = set_reg_value(iso_pma_cmn_pll0_clk_datart1_div);
+	reg_val |= set_reg_value(iso_pma_cmn_pll0_clk_datart0_div);
+	reg_val |= set_reg_value(iso_pma_cmn_pll0_clk_en);
+	write16(hdmirx, PHY_PMA_CMN_CTRL2_ADDR, reg_val);
+
+	dev_dbg(&hdmirx->pdev->dev, "pma_pll_config() Disable Rx Eq Training\n");
+	for (i = 0; i < 3; i++) {
+		reg_val =
+		    read16(hdmirx, PHY_PMA_XCVR_CTRL_ADDR | (i << 6));
+		reg_val &= 0xFFEF;
+		write16(hdmirx, PHY_PMA_XCVR_CTRL_ADDR | (i << 6), reg_val);
+	}
+
+	/* Get current power state: */
+	/* PHY_MODE_CTL */
+	reg_val = read16(hdmirx, PHY_MODE_CTL_ADDR);
+	dev_dbg(&hdmirx->pdev->dev, "pma_pll_config() PHY_MODE_CTL: 0x%04X\n", reg_val);
+
+	reg_val &= 0x00F0;
+	dev_dbg(&hdmirx->pdev->dev, "pma_pll_config() Current power state: 0x%02X\n", (reg_val >> 4));
+
+	/* Deassert link reset: */
+	/* PHY_MODE_CTL */
+	dev_dbg(&hdmirx->pdev->dev, "pma_pll_config() Deassert link reset\n");
+	set_field_value(&xcvr_link_reset_n, 0x1);
+	reg_val |= set_reg_value(xcvr_pll_en);
+	reg_val |= set_reg_value(xcvr_link_reset_n);
+	write16(hdmirx, PHY_MODE_CTL_ADDR, reg_val);
+
+	/* Wait for xcvr_psm_ready for all the lanes */
+	loop = 0;
+	do {
+		reg_val = (1 << 13);
+		if (ktime_after(ktime_get(), timeout))
+			goto timeout_err;
+
+		for (i = 0; i < 3; i++) {
+			reg_val &= read16(hdmirx, PHY_PMA_XCVR_CTRL_ADDR | (i << 6)) & (1 << 13);
+			dev_dbg(&hdmirx->pdev->dev, "pma_pll_config() xcvr_psm_ready(%0d): 0x%0X\n", i, reg_val >> 13);
+		}
+	} while (!reg_val && loop < 20);
+
+	/* Set A0 power state: */
+	/* PHY_MODE_CTL */
+	if (pma_power_state_chng(hdmirx, 0x1))
+		goto timeout_err;
+
+	dev_dbg(&hdmirx->pdev->dev, "pma_pll_config() Enable Rx Eq Training\n");
+	for (i = 0; i < 3; i++) {
+		reg_val =
+		    read16(hdmirx, PHY_PMA_XCVR_CTRL_ADDR | (i << 6));
+		reg_val |= 0x0010;
+		write16(hdmirx, PHY_PMA_XCVR_CTRL_ADDR | (i << 6), reg_val);
+	}
+
+	return 0;
+
+timeout_err:
+	dev_err(&hdmirx->pdev->dev, "pma_pll_config() Timeout error!\n");
+	return -1;
+
+}
+
+u32 clk_ratio_detect(struct cdns_hdmirx_device *hdmirx,
+				u32 rx_clk_freq,	/* khz */
+				u32 pxl_clk_freq,	/* khz */
+				u8 vic,
+				u32 pixel_encoding,
+				u32 tmds_bit_clk_ratio)
+{
+	u32 clk_ratio_detected = CLK_RATIO_1_1;
+
+	u64 tmds_freq_nominal_1_1, tmds_freq_nominal_1_1_min,
+	    tmds_freq_nominal_1_1_max;
+	u64 tmds_freq_nominal_5_4, tmds_freq_nominal_5_4_min,
+	    tmds_freq_nominal_5_4_max;
+	u64 tmds_freq_nominal_3_2, tmds_freq_nominal_3_2_min,
+	    tmds_freq_nominal_3_2_max;
+	u64 tmds_freq_nominal_2_1, tmds_freq_nominal_2_1_min,
+	    tmds_freq_nominal_2_1_max;
+	u64 tmds_freq_nominal_1_2, tmds_freq_nominal_1_2_min,
+	    tmds_freq_nominal_1_2_max;
+	u64 tmds_freq_nominal_5_8, tmds_freq_nominal_5_8_min,
+	    tmds_freq_nominal_5_8_max;
+	u64 tmds_freq_nominal_3_4, tmds_freq_nominal_3_4_min,
+	    tmds_freq_nominal_3_4_max;
+	u64 min, max;
+
+	/* Check the TMDS/pixel clock ratio. */
+	dev_info(&hdmirx->pdev->dev, "VIC %0d, pixel encoding: %0d, TMDS bit clock ratio: %0d and TMDS clk %d KHz\n",
+	     vic, pixel_encoding, tmds_bit_clk_ratio, rx_clk_freq);
+
+	tmds_freq_nominal_1_1 = pxl_clk_freq;
+
+	min = 990;
+	max = 1010;
+
+	tmds_freq_nominal_5_4 = tmds_freq_nominal_1_1;
+	tmds_freq_nominal_3_2 = tmds_freq_nominal_1_1;
+	tmds_freq_nominal_2_1 = tmds_freq_nominal_1_1;
+	tmds_freq_nominal_1_2 = tmds_freq_nominal_1_1;
+	tmds_freq_nominal_5_8 = tmds_freq_nominal_1_1;
+	tmds_freq_nominal_3_4 = tmds_freq_nominal_1_1;
+
+	/* Exclude some of the clock ratios based on pixel excoding */
+	switch (pixel_encoding) {
+	case PIXEL_ENCODING_YUV422:
+		tmds_freq_nominal_5_4 = 0;
+		tmds_freq_nominal_3_2 = 0;
+		tmds_freq_nominal_2_1 = 0;
+		tmds_freq_nominal_1_2 = 0;
+		tmds_freq_nominal_5_8 = 0;
+		tmds_freq_nominal_3_4 = 0;
+		break;
+	case PIXEL_ENCODING_YUV420:
+		tmds_freq_nominal_5_4 = 0;
+		tmds_freq_nominal_3_2 = 0;
+		tmds_freq_nominal_2_1 = 0;
+		break;
+	default:		/* RGB/YUV444 */
+		tmds_freq_nominal_1_2 = 0;
+		tmds_freq_nominal_5_8 = 0;
+		tmds_freq_nominal_3_4 = 0;
+	}
+
+	tmds_freq_nominal_1_1_min =
+	    min * tmds_freq_nominal_1_1 * 10 * 1 / (tmds_bit_clk_ratio * 1000 * 1);
+	tmds_freq_nominal_1_1_max =
+	    max * tmds_freq_nominal_1_1 * 10 * 1 / (tmds_bit_clk_ratio * 1000 * 1);
+	tmds_freq_nominal_5_4_min =
+	    min * tmds_freq_nominal_5_4 * 10 * 5 / (tmds_bit_clk_ratio * 1000 * 4);
+	tmds_freq_nominal_5_4_max =
+	    max * tmds_freq_nominal_5_4 * 10 * 5 / (tmds_bit_clk_ratio * 1000 * 4);
+	tmds_freq_nominal_3_2_min =
+	    min * tmds_freq_nominal_3_2 * 10 * 3 / (tmds_bit_clk_ratio * 1000 * 2);
+	tmds_freq_nominal_3_2_max =
+	    max * tmds_freq_nominal_3_2 * 10 * 3 / (tmds_bit_clk_ratio * 1000 * 2);
+	tmds_freq_nominal_2_1_min =
+	    min * tmds_freq_nominal_2_1 * 10 * 2 / (tmds_bit_clk_ratio * 1000 * 1);
+	tmds_freq_nominal_2_1_max =
+	    max * tmds_freq_nominal_2_1 * 10 * 2 / (tmds_bit_clk_ratio * 1000 * 1);
+	tmds_freq_nominal_1_2_min =
+	    min * tmds_freq_nominal_1_2 * 10 * 1 / (tmds_bit_clk_ratio * 1000 * 2);
+	tmds_freq_nominal_1_2_max =
+	    max * tmds_freq_nominal_1_2 * 10 * 1 / (tmds_bit_clk_ratio * 1000 * 2);
+	tmds_freq_nominal_5_8_min =
+	    min * tmds_freq_nominal_5_8 * 10 * 5 / (tmds_bit_clk_ratio * 1000 * 8);
+	tmds_freq_nominal_5_8_max =
+	    max * tmds_freq_nominal_5_8 * 10 * 5 / (tmds_bit_clk_ratio * 1000 * 8);
+	tmds_freq_nominal_3_4_min =
+	    min * tmds_freq_nominal_3_4 * 10 * 3 / (tmds_bit_clk_ratio * 1000 * 4);
+	tmds_freq_nominal_3_4_max =
+	    max * tmds_freq_nominal_3_4 * 10 * 3 / (tmds_bit_clk_ratio * 1000 * 4);
+
+	if (rx_clk_freq > tmds_freq_nominal_1_1_min
+	    && rx_clk_freq < tmds_freq_nominal_1_1_max)
+		clk_ratio_detected = CLK_RATIO_1_1;
+	else if (rx_clk_freq > tmds_freq_nominal_5_4_min
+		   && rx_clk_freq < tmds_freq_nominal_5_4_max)
+		clk_ratio_detected = CLK_RATIO_5_4;
+	else if (rx_clk_freq > tmds_freq_nominal_3_2_min
+		   && rx_clk_freq < tmds_freq_nominal_3_2_max)
+		clk_ratio_detected = CLK_RATIO_3_2;
+	else if (rx_clk_freq > tmds_freq_nominal_2_1_min
+		   && rx_clk_freq < tmds_freq_nominal_2_1_max)
+		clk_ratio_detected = CLK_RATIO_2_1;
+	else if (rx_clk_freq > tmds_freq_nominal_1_2_min
+		   && rx_clk_freq < tmds_freq_nominal_1_2_max)
+		clk_ratio_detected = CLK_RATIO_1_2;
+	else if (rx_clk_freq > tmds_freq_nominal_5_8_min
+		   && rx_clk_freq < tmds_freq_nominal_5_8_max)
+		clk_ratio_detected = CLK_RATIO_5_8;
+	else if (rx_clk_freq > tmds_freq_nominal_3_4_min
+		   && rx_clk_freq < tmds_freq_nominal_3_4_max)
+		clk_ratio_detected = CLK_RATIO_3_4;
+	else {
+		dev_err(&hdmirx->pdev->dev, "Unable to detected TMDS/pixel clock ratio - using default\n");
+		dev_err(&hdmirx->pdev->dev, "VIC: %02d and TMDS clock of %d KHz\n", vic, rx_clk_freq);
+	}
+	dev_dbg(&hdmirx->pdev->dev, "Detected TMDS/pixel clock ratio of %d\n", clk_ratio_detected);
+
+	return clk_ratio_detected;
+}
diff --git a/drivers/staging/media/imx/hdmirx/cdns-hdmirx-phy.h b/drivers/staging/media/imx/hdmirx/cdns-hdmirx-phy.h
new file mode 100644
index 000000000..350fbadf5
--- /dev/null
+++ b/drivers/staging/media/imx/hdmirx/cdns-hdmirx-phy.h
@@ -0,0 +1,105 @@
+/*
+ * Copyright 2020 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef _CDNS_HDMIRX_PHY_H_
+#define _CDNS_HDMIRX_PHY_H_
+
+#include <linux/io.h>
+#include "cdns-mhdp-hdmirx.h"
+
+#define REFCLK_FREQ_KHZ                        24000
+#define LINK_WRITE                             0x2000
+#define LINK_ID                                0x0
+
+#define CMN_PLLSM0_PLLEN_TMR_ADDR              0x0029
+#define CMN_PLLSM0_PLLPRE_TMR_ADDR             0x002A
+#define CMN_PLLSM0_PLLVREF_TMR_ADDR            0x002B
+#define CMN_PLLSM0_PLLLOCK_TMR_ADDR            0x002C
+#define CMN_PLLSM0_USER_DEF_CTRL_ADDR          0x002F
+#define CMN_PLL0_VCOCAL_CTRL_ADDR              0x0080
+#define CMN_PLL0_VCOCAL_OVRD_ADDR              0x0083
+#define CMN_PLL0_LOCK_REFCNT_START_ADDR        0x0090
+#define CMN_PLL0_LOCK_PLLCNT_START_ADDR        0x0092
+#define CMN_PLL0_DIV2SEL_OSR_CTRL_ADDR         0x009B
+#define CMN_ICAL_CTRL_ADDR                     0x00C0
+#define CMN_ICAL_OVRD_ADDR                     0x00C1
+#define CMN_RXCAL_CTRL_ADDR                    0x00D0
+#define CMN_RXCAL_OVRD_ADDR                    0x00D1
+#define CMN_RXCAL_INIT_TMR_ADDR                0x00D4
+#define CMN_TXPUCAL_OVRD_ADDR                  0x00E1
+#define CMN_TXPDCAL_OVRD_ADDR                  0x00F1
+#define CMN_CMSMT_CLK_FREQ_MSMT_CTRL_ADDR      0x01A0
+#define CMN_CMSMT_REF_CLK_TMR_VALUE_ADDR       0x01A2
+#define CMN_CMSMT_TEST_CLK_CNT_VALUE_ADDR      0x01A3
+#define CMN_DIAG_PLL0_FBH_OVRD_ADDR            0x01C0
+#define CMN_DIAG_PLL0_FBL_OVRD_ADDR            0x01C1
+#define CMN_DIAG_PLL0_TEST_MODE_ADDR           0x01C4
+#define CMN_DIAG_PLL0_INCLK_CTRL_ADDR          0x01CA
+#define CMN_DIAG_PLL0_V2I_TUNE_ADDR            0x01C5
+#define CMN_DIAG_PLL0_CP_TUNE_ADDR             0x01C6
+#define CMN_DIAG_PLL0_PTATIS_TUNE1_ADDR        0x01C8
+#define CMN_DIAG_PLL0_PTATIS_TUNE2_ADDR        0x01C9
+#define XCVR_PSM_CAL_TMR_ADDR                  0x4002
+#define XCVR_PSM_A0IN_TMR_ADDR                 0x4003
+#define XCVR_DIAG_RX_LANE_CAL_RST_TMR_ADDR     0x40EA
+#define TX_ANA_CTRL_REG_1_ADDR                 0x5020
+#define TX_ANA_CTRL_REG_2_ADDR                 0x5021
+#define TX_DIG_CTRL_REG_1_ADDR                 0x5023
+#define TX_DIG_CTRL_REG_2_ADDR                 0x5024
+#define TXDA_CYA_AUXDA_CYA_ADDR                0x5025
+#define TX_ANA_CTRL_REG_3_ADDR                 0x5026
+#define TX_ANA_CTRL_REG_4_ADDR                 0x5027
+#define TX_ANA_CTRL_REG_5_ADDR                 0x5029
+#define RX_PSC_A0_ADDR                         0x8000
+#define RX_IQPI_ILL_CAL_OVRD_ADDR              0x8023
+#define RX_EPI_ILL_CAL_OVRD_ADDR               0x8033
+#define RX_SLC_CTRL_ADDR                       0x80E0
+#define RX_REE_PERGCSM_EQENM_PH1_ADDR          0x8179
+#define RX_REE_PERGCSM_EQENM_PH2_ADDR          0x817A
+#define RX_REE_VGA_GAIN_OVRD_ADDR              0x81AD
+#define RX_REE_SMGM_CTRL1_ADDR                 0x81BD
+#define RX_DIAG_ILL_IQ_TRIM0_ADDR              0x81C1
+#define RX_DIAG_ILL_E_TRIM0_ADDR               0x81C2
+#define RX_DIAG_ILL_IQE_TRIM2_ADDR             0x81C5
+#define RX_DIAG_DFE_CTRL2_ADDR                 0x81D4
+#define RX_DIAG_SC2C_DELAY_ADDR                0x81E1
+#define RX_DIAG_SMPLR_OSR_ADDR                 0x81E2
+#define RX_CLK_SLICER_CAL_OVRD_ADDR            0x8621
+#define RX_CLK_SLICER_CAL_TUNE_ADDR            0x8623
+#define RX_CLK_SLICER_CAL_INIT_TMR_ADDR        0x8624
+#define RX_CLK_SLICER_CAL_ITER_TMR_ADDR        0x8625
+#define RX_CLK_TERM_CTRL_ADDR                  0x8660
+#define PHY_MODE_CTL_ADDR                      0xC008
+#define PHY_PMA_CMN_CTRL1_ADDR                 0xC800
+#define PHY_PMA_CMN_CTRL2_ADDR                 0xC801
+#define PHY_PMA_SSM_STATE_ADDR                 0xC802
+#define PHY_PMA_PLL_SM_STATE_ADDR              0xC803
+#define PHY_PMA_XCVR_CTRL_ADDR                 0xCC00
+
+enum {
+  TMDS_BIT_CLOCK_RATIO_1_10 = 10,
+  TMDS_BIT_CLOCK_RATIO_1_40 = 40
+};
+
+void arc_config(struct cdns_hdmirx_device *hdmirx);
+void pma_config(struct cdns_hdmirx_device *hdmirx);
+int pma_cmn_ready(struct cdns_hdmirx_device *hdmirx);
+int phy_in_reset(struct cdns_hdmirx_device *hdmirx);
+int pma_rx_clk_signal_detect(struct cdns_hdmirx_device *hdmirx);
+bool pma_rx_clk_sig_detected(struct cdns_hdmirx_device *hdmirx);
+void pre_data_rate_change(struct cdns_hdmirx_device *hdmirx);
+int pma_pll_config(struct cdns_hdmirx_device *hdmirx, u32, u32, u32, u8);
+u32 clk_ratio_detect(struct cdns_hdmirx_device *hdmirx, u32, u32, u8, u32, u32);
+int get_rescal_code(struct cdns_hdmirx_device *hdmirx);
+int set_rescal_code(struct cdns_hdmirx_device *hdmirx, u8 rescal_code);
+int reset_rescal_code(struct cdns_hdmirx_device *hdmirx);
+int set_slicer_tune_val(struct cdns_hdmirx_device *hdmirx, u8 tune_val);
+int set_sigdet_refcnt_adj(struct cdns_hdmirx_device *hdmirx, u32 sigdet_refcnt_adj);
+#endif
diff --git a/drivers/staging/media/imx/hdmirx/cdns-hdmirx.c b/drivers/staging/media/imx/hdmirx/cdns-hdmirx.c
new file mode 100644
index 000000000..5167c225d
--- /dev/null
+++ b/drivers/staging/media/imx/hdmirx/cdns-hdmirx.c
@@ -0,0 +1,1491 @@
+/*
+ * Copyright 2019-2020 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+#include <dt-bindings/firmware/imx/rsrc.h>
+#include <linux/firmware/imx/sci.h>
+#include <linux/freezer.h>
+#include <linux/irq.h>
+#include <linux/kthread.h>
+
+#include "cdns-hdmirx-phy.h"
+#include "cdns-mhdp-hdmirx.h"
+
+#define HDMIRX_MIN_WIDTH		640
+#define HDMIRX_MAX_WIDTH		3840
+#define HDMIRX_MIN_HEIGHT		480
+#define HDMIRX_MAX_HEIGHT		2160
+/* V4L2_DV_BT_CEA_640X480P59_94 */
+#define HDMIRX_MIN_PIXELCLOCK	24000000
+/* V4L2_DV_BT_CEA_3840X2160P30 */
+#define HDMIRX_MAX_PIXELCLOCK	297000000
+
+#define VIDEO_MODE_CHANGE 0x40
+
+#define cdns_sd_to_hdmi(sd) container_of(sd, struct cdns_hdmirx_device, sd)
+
+/* Attibutes for sysfs */
+static ssize_t HDCPRX_status_show(struct device *dev,
+			struct device_attribute *attr, char *buf);
+
+static ssize_t HDCPRX_request_reauthentication_show(struct device *dev,
+			struct device_attribute *attr, char *buf);
+
+static ssize_t HDCPRX_enable_store(struct device *dev,
+			struct device_attribute *attr, const char *buf, size_t count);
+
+static struct device_attribute HDCPRX_status = __ATTR_RO(HDCPRX_status);
+static struct device_attribute HDCPRX_request_reauthentication = __ATTR_RO(HDCPRX_request_reauthentication);
+static struct device_attribute HDCPRX_enable = __ATTR_WO(HDCPRX_enable);
+
+static ssize_t HDCPRX_status_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct hdcprx_status status;
+	struct cdns_hdmirx_device *hdmirx = dev_get_drvdata(dev);
+	ssize_t size = 0;
+
+	if (NULL != hdmirx) {
+		if (hdmirx->initialized == true && hdmirx->hdcp_fw_loaded == true
+					&& !cdns_hdcprx_get_status(hdmirx, &status))
+			size = sprintf(buf, "HCDP key_arrived 0x%02x\nHCDP hdcp_ver 0x%02x\nHCDP error 0x%02x\n",
+					status.flags & 1,
+					(status.flags >> 1) & 0x3,
+					(status.flags >> 4) & 0xF);
+		else
+			size = sprintf(buf, "HDCPRX status read failed, link is not up or HDCP not enabled.\n");
+	} else
+		size = sprintf(buf, "hdmirx is NULL\n");
+	return size;
+}
+
+static ssize_t HDCPRX_request_reauthentication_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct cdns_hdmirx_device *hdmirx = dev_get_drvdata(dev);
+	ssize_t size;
+
+	if (NULL != hdmirx && hdmirx->initialized == true &&
+			hdmirx->hdcp_fw_loaded == true) {
+		if (!cdns_hdcprx_reauth_req_wait(hdmirx, 2000))
+			size = sprintf(buf, "cdns_hdcprx_reauth_req done\n");
+		else {
+			size = sprintf(buf, "HDCPRX cdns_hdcprx_reauth_req failed.\n");
+			return size;
+		}
+	} else
+		size = sprintf(buf, "hdmirx is NULL or HDCP not enabled\n");
+
+	return size;
+}
+
+static ssize_t HDCPRX_enable_store(struct device *dev,
+			struct device_attribute *attr, const char *buf, size_t count)
+{
+    int value;
+    struct cdns_hdmirx_device *hdmirx = dev_get_drvdata(dev);
+
+	if (hdmirx == NULL) {
+		dev_dbg(&hdmirx->pdev->dev, "%s hdmirx\n", __func__);
+		return -1;
+	}
+
+    sscanf(buf, "%d", &value);
+    /* HDCP start/stop and load/unload of modules will be handled
+       in the tmdsmon function. We just setup the flags here.
+    */
+	if (value == 1) {
+		dev_dbg(&hdmirx->pdev->dev, "%s enable hdcp\n", __func__);
+		hdmirx->allow_hdcp = true;
+	} else if (value == 0) {
+		dev_dbg(&hdmirx->pdev->dev, "%s disable hdcp\n", __func__);
+		hdmirx->allow_hdcp = false;
+	} else
+		dev_dbg(&hdmirx->pdev->dev, "%s invalid hdcp command\n", __func__);
+
+    return count;
+}
+
+static int hdmi_sysfs_init(struct device *dev)
+{
+	int retval;
+
+	retval = device_create_file(dev, &HDCPRX_status);
+	if (retval) {
+		printk(KERN_ERR "Unable to create hdmirx status sysfs\n");
+		device_remove_file(dev, &HDCPRX_status);
+		return retval;
+	}
+
+	retval = device_create_file(dev, &HDCPRX_enable);
+	if (retval) {
+		printk(KERN_ERR "Unable to create hdmirx enable sysfs\n");
+		device_remove_file(dev, &HDCPRX_enable);
+		return retval;
+	}
+
+	retval = device_create_file(dev, &HDCPRX_request_reauthentication);
+	if (retval) {
+		printk(KERN_ERR "Unable to create HDCPRX_request_reauthentication sysfs\n");
+		device_remove_file(dev, &HDCPRX_request_reauthentication);
+		return retval;
+	}
+
+	return 0;
+}
+
+static const struct v4l2_dv_timings_cap hdmirx_timings_cap = {
+	.type = V4L2_DV_BT_656_1120,
+	/* keep this initialization for compatibility with GCC < 4.4.6 */
+	.reserved = { 0 },
+
+	V4L2_INIT_BT_TIMINGS(HDMIRX_MIN_WIDTH, HDMIRX_MAX_WIDTH,
+			     HDMIRX_MIN_HEIGHT, HDMIRX_MAX_HEIGHT,
+			     HDMIRX_MIN_PIXELCLOCK,
+			     HDMIRX_MAX_PIXELCLOCK,
+			     V4L2_DV_BT_STD_CEA861 | V4L2_DV_BT_STD_DMT,
+			     V4L2_DV_BT_CAP_PROGRESSIVE)
+};
+
+struct cdns_hdmirx_dev_video_standards
+cdns_hdmi_video_standards[] = {
+	{V4L2_DV_BT_CEA_640X480P59_94, 1, 0, 60},
+	{V4L2_DV_BT_CEA_720X480P59_94, 2, 0, 60},
+	{V4L2_DV_BT_CEA_720X480P59_94, 3, 0, 60},
+	{V4L2_DV_BT_CEA_720X576P50,   18, 0, 50},
+	{V4L2_DV_BT_CEA_720X576P50,   17, 0, 50},
+	{V4L2_DV_BT_CEA_1280X720P60,   4, 0, 60},
+	{V4L2_DV_BT_CEA_1280X720P50,  19, 0, 50},
+	{V4L2_DV_BT_CEA_1280X720P30,  62, 0, 30},
+	{V4L2_DV_BT_CEA_1280X720P25,  61, 0, 25},
+	{V4L2_DV_BT_CEA_1280X720P24,  60, 0, 24},
+	{V4L2_DV_BT_CEA_1920X1080P60, 16, 0, 60},
+	{V4L2_DV_BT_CEA_1920X1080P50, 31, 0, 50},
+	{V4L2_DV_BT_CEA_1920X1080P30, 34, 0, 30},
+	{V4L2_DV_BT_CEA_1920X1080P25, 33, 0, 25},
+	{V4L2_DV_BT_CEA_1920X1080P24, 32, 0, 24},
+	{V4L2_DV_BT_CEA_3840X2160P24, 93, 3, 24},
+	{V4L2_DV_BT_CEA_3840X2160P25, 94, 2, 25},
+	{V4L2_DV_BT_CEA_3840X2160P30, 95, 1, 30},
+	{V4L2_DV_BT_CEA_4096X2160P24, 98, 4, 24},
+	{V4L2_DV_BT_CEA_4096X2160P25, 99, 0, 25},
+	{V4L2_DV_BT_CEA_4096X2160P30, 100, 0, 30},
+	/* SVGA */
+	{V4L2_DV_BT_DMT_800X600P56, 0x0, 0, 56},
+	{V4L2_DV_BT_DMT_800X600P60, 0x0, 0, 60},
+	{V4L2_DV_BT_DMT_800X600P72, 0x0, 0, 72},
+	{V4L2_DV_BT_DMT_800X600P75, 0x0, 0, 75},
+	{V4L2_DV_BT_DMT_800X600P85, 0x0, 0, 85},
+	/* SXGA */
+	{V4L2_DV_BT_DMT_1280X1024P60, 0x0, 0, 60},
+	{V4L2_DV_BT_DMT_1280X1024P75, 0x0, 0, 75},
+	/* VGA */
+	{ V4L2_DV_BT_DMT_640X480P72, 0x0, 0, 72},
+	{ V4L2_DV_BT_DMT_640X480P75, 0x0, 0, 75},
+	{ V4L2_DV_BT_DMT_640X480P85, 0x0, 0, 85},
+	/* XGA */
+	{ V4L2_DV_BT_DMT_1024X768P60, 0x0, 0, 60},
+	{ V4L2_DV_BT_DMT_1024X768P70, 0x0, 0, 70},
+	{ V4L2_DV_BT_DMT_1024X768P75, 0x0, 0, 75},
+	{ V4L2_DV_BT_DMT_1024X768P85, 0x0, 0, 85},
+	/* UXGA */
+	{ V4L2_DV_BT_DMT_1600X1200P60, 0x0, 0, 60},
+};
+
+int cdns_hdmirx_frame_timing(struct cdns_hdmirx_device *hdmirx)
+{
+	struct cdns_hdmirx_dev_video_standards *stds;
+	u32 i, vic, hdmi_vic;
+
+	vic = hdmirx->vic_code;
+	hdmi_vic = hdmirx->hdmi_vic;
+	stds = cdns_hdmi_video_standards;
+
+	if (vic == 0 && hdmi_vic != 0) {
+		for (i = 0; i < ARRAY_SIZE(cdns_hdmi_video_standards); i++) {
+			if (stds[i].hdmi_vic == hdmi_vic) {
+				hdmirx->timings = &stds[i];
+				return true;
+			}
+		}
+	} else if (vic > 109) {
+		dev_err(&hdmirx->pdev->dev,
+				"Unsupported mode vic=%d, hdmi_vic=%d\n", vic, hdmi_vic);
+		return -EINVAL;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(cdns_hdmi_video_standards); i++) {
+		if (stds[i].vic == vic) {
+			hdmirx->timings = &stds[i];
+			return true;
+		}
+	}
+
+	if (i >= ARRAY_SIZE(cdns_hdmi_video_standards))
+		return -EINVAL;
+
+	return true;
+}
+
+static int hdmirx_clock_init(struct cdns_hdmirx_device *hdmirx)
+{
+	struct device *dev = &hdmirx->pdev->dev;
+
+	hdmirx->ref_clk = devm_clk_get(dev, "ref_clk");
+	if (IS_ERR(hdmirx->ref_clk)) {
+		dev_err(dev, "failed to get hdmi rx ref clk\n");
+		return PTR_ERR(hdmirx->ref_clk);
+	}
+
+	hdmirx->pxl_clk = devm_clk_get(dev, "pxl_clk");
+	if (IS_ERR(hdmirx->pxl_clk)) {
+		dev_err(dev, "failed to get hdmi rx pxl clk\n");
+		return PTR_ERR(hdmirx->pxl_clk);
+	}
+
+	hdmirx->lpcg_pclk = devm_clk_get(dev, "lpcg_pclk");
+	if (IS_ERR(hdmirx->lpcg_pclk)) {
+		dev_err(dev, "failed to get hdmi rx pclk\n");
+		return PTR_ERR(hdmirx->lpcg_pclk);
+	}
+
+	hdmirx->lpcg_sclk = devm_clk_get(dev, "lpcg_sclk");
+	if (IS_ERR(hdmirx->lpcg_sclk)) {
+		dev_err(dev, "failed to get hdmi rx lpcg_sclk\n");
+		return PTR_ERR(hdmirx->lpcg_sclk);
+	}
+
+	hdmirx->lpcg_enc_clk = devm_clk_get(dev, "lpcg_enc_clk");
+	if (IS_ERR(hdmirx->lpcg_enc_clk)) {
+		dev_err(dev, "failed to get hdmi rx lpcg_enc clk\n");
+		return PTR_ERR(hdmirx->lpcg_enc_clk);
+	}
+
+	hdmirx->i2s_clk = devm_clk_get(dev, "i2s_clk");
+	if (IS_ERR(hdmirx->i2s_clk)) {
+		dev_err(dev, "failed to get hdmi rx i2s clk\n");
+		return PTR_ERR(hdmirx->i2s_clk);
+	}
+
+	hdmirx->spdif_clk = devm_clk_get(dev, "spdif_clk");
+	if (IS_ERR(hdmirx->spdif_clk)) {
+		dev_err(dev, "failed to get hdmi rx spdif clk\n");
+		return PTR_ERR(hdmirx->spdif_clk);
+	}
+
+	hdmirx->lpcg_pxl_link_clk = devm_clk_get(dev, "lpcg_pxl_link_clk");
+	if (IS_ERR(hdmirx->lpcg_pxl_link_clk)) {
+		dev_err(dev, "failed to get hdmi rx lpcg_pixel link clk\n");
+		return PTR_ERR(hdmirx->lpcg_pxl_link_clk);
+	}
+
+	return 0;
+}
+
+static int hdmirx_clock_enable(struct cdns_hdmirx_device *hdmirx)
+{
+	struct device *dev = &hdmirx->pdev->dev;
+	int ret;
+
+	dev_dbg(dev, "%s\n", __func__);
+	ret = clk_prepare_enable(hdmirx->ref_clk);
+	if (ret < 0) {
+		dev_err(dev, "%s, pre ref_clk error %d\n", __func__, ret);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(hdmirx->pxl_clk);
+	if (ret < 0) {
+		dev_err(dev, "%s, pre pxl_clk error %d\n", __func__, ret);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(hdmirx->i2s_clk);
+	if (ret < 0) {
+		dev_err(dev, "%s, pre i2s_clk error %d\n", __func__, ret);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(hdmirx->spdif_clk);
+	if (ret < 0) {
+		dev_err(dev, "%s, pre spdif_clk error %d\n", __func__, ret);
+		return ret;
+	}
+	ret = clk_prepare_enable(hdmirx->lpcg_enc_clk);
+	if (ret < 0) {
+		dev_err(dev, "%s, pre enc_clk error %d\n", __func__, ret);
+		return ret;
+	}
+	ret = clk_prepare_enable(hdmirx->lpcg_sclk);
+	if (ret < 0) {
+		dev_err(dev, "%s, pre sclk error %d\n", __func__, ret);
+		return ret;
+	}
+	ret = clk_prepare_enable(hdmirx->lpcg_pclk);
+	if (ret < 0) {
+		dev_err(dev, "%s, pre pclk error %d\n", __func__, ret);
+		return ret;
+	}
+	ret = clk_prepare_enable(hdmirx->lpcg_pxl_link_clk);
+	if (ret < 0) {
+		dev_err(dev, "%s, pre pxl_link_clk error %d\n", __func__, ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static void hdmirx_clock_disable(struct cdns_hdmirx_device *hdmirx)
+{
+	dev_dbg(&hdmirx->pdev->dev, "%s\n", __func__);
+
+	clk_disable_unprepare(hdmirx->ref_clk);
+	clk_disable_unprepare(hdmirx->pxl_clk);
+	clk_disable_unprepare(hdmirx->lpcg_enc_clk);
+	clk_disable_unprepare(hdmirx->lpcg_sclk);
+	clk_disable_unprepare(hdmirx->lpcg_pclk);
+	clk_disable_unprepare(hdmirx->i2s_clk);
+	clk_disable_unprepare(hdmirx->spdif_clk);
+	clk_disable_unprepare(hdmirx->lpcg_pxl_link_clk);
+}
+
+static void hdmirx_pixel_link_encoder(struct cdns_hdmirx_device *hdmirx)
+{
+	u32 val;
+
+	switch (hdmirx->pixel_encoding) {
+	case PIXEL_ENCODING_YUV422:
+		val = 3;
+		break;
+	case PIXEL_ENCODING_YUV420:
+		val = 4;
+		break;
+	case PIXEL_ENCODING_YUV444:
+		val = 2;
+		break;
+	case PIXEL_ENCODING_RGB:
+		val = 0;
+		break;
+	default:
+		val = 0x6;
+	}
+
+	/* HDMI RX H/Vsync Polarity */
+	if (hdmirx->timings->timings.bt.polarities & V4L2_DV_VSYNC_POS_POL)
+		val |= 1 << PL_ENC_CTL_PXL_VCP;
+	if (hdmirx->timings->timings.bt.polarities & V4L2_DV_HSYNC_POS_POL)
+		val |= 1 << PL_ENC_CTL_PXL_HCP;
+
+	writel(val, hdmirx->regs_sec);
+}
+
+/* -----------------------------------------------------------------------------
+ * v4l2_subdev_video_ops
+ */
+static int hdmirx_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *a)
+{
+	struct cdns_hdmirx_device *hdmirx = cdns_sd_to_hdmi(sd);
+	struct device *dev = &hdmirx->pdev->dev;
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	return 0;
+}
+
+static int hdmirx_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *a)
+{
+	struct v4l2_captureparm *cparm = &a->parm.capture;
+	struct cdns_hdmirx_device *hdmirx = cdns_sd_to_hdmi(sd);
+	int ret = 0;
+
+	if (hdmirx->cable_plugin == false) {
+		dev_warn(&hdmirx->pdev->dev, "No Cable Connected!\n");
+		return -EINVAL;
+	}
+
+	switch (a->type) {
+	/* This is the only case currently handled. */
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:
+		memset(a, 0, sizeof(*a));
+		a->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+		cparm->timeperframe.denominator = hdmirx->timings->fps;
+		cparm->timeperframe.numerator = 1;
+		ret = 0;
+		break;
+
+	/* These are all the possible cases. */
+	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
+	case V4L2_BUF_TYPE_VIDEO_OVERLAY:
+	case V4L2_BUF_TYPE_VBI_CAPTURE:
+	case V4L2_BUF_TYPE_VBI_OUTPUT:
+	case V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:
+	case V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:
+		ret = -EINVAL;
+		break;
+	default:
+		pr_debug("type is unknown - %d\n", a->type);
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static int hdmirx_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct cdns_hdmirx_device *hdmirx = cdns_sd_to_hdmi(sd);
+	struct device *dev = &hdmirx->pdev->dev;
+	u32 val;
+
+	dev_dbg(dev, "%s\n", __func__);
+	if (hdmirx->cable_plugin == false) {
+		dev_warn(dev, "No Cable Connected!\n");
+		return -EINVAL;
+	}
+
+	hdmirx_pixel_link_encoder(hdmirx);
+
+	if (enable) {
+		pm_runtime_get_sync(dev);
+		if (!hdmirx->running++) {
+			val = readl(hdmirx->regs_sec + CSR_PIXEL_LINK_ENC_CTL);
+			val |=  1 << PL_ENC_CTL_PXL_EN;
+			writel(val, hdmirx->regs_sec + CSR_PIXEL_LINK_ENC_CTL);
+			mdelay(17);
+
+			val = readl(hdmirx->regs_sec + CSR_PIXEL_LINK_ENC_CTL);
+			val |=  1 << PL_ENC_CTL_PXL_VAL;
+			writel(val, hdmirx->regs_sec + CSR_PIXEL_LINK_ENC_CTL);
+		}
+	} else {
+		if (!--hdmirx->running) {
+			val = readl(hdmirx->regs_sec + CSR_PIXEL_LINK_ENC_CTL);
+			val |=  ~(1 << PL_ENC_CTL_PXL_VAL);
+			writel(val, hdmirx->regs_sec + CSR_PIXEL_LINK_ENC_CTL);
+			mdelay(17);
+
+			val = readl(hdmirx->regs_sec + CSR_PIXEL_LINK_ENC_CTL);
+			val |=  ~(1 << PL_ENC_CTL_PXL_EN);
+			writel(val, hdmirx->regs_sec + CSR_PIXEL_LINK_ENC_CTL);
+		}
+		pm_runtime_put(dev);
+	}
+
+	return 0;
+}
+
+static const struct v4l2_subdev_video_ops cdns_video_ops_hdmi = {
+	.s_stream = hdmirx_s_stream,
+	.g_parm =	hdmirx_g_parm,
+	.s_parm =	hdmirx_s_parm,
+};
+
+/* -----------------------------------------------------------------------------
+ * Media Operations
+ */
+
+static const struct media_entity_operations hdmi_media_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+/* -----------------------------------------------------------------------------
+ * v4l2_subdev_pad_ops
+ */
+static int hdmirx_enum_framesizes(struct v4l2_subdev *sd,
+			       struct v4l2_subdev_state *state,
+			       struct v4l2_subdev_frame_size_enum *fse)
+{
+	struct cdns_hdmirx_device *hdmirx = cdns_sd_to_hdmi(sd);
+
+	/* Check for hdmirx->timings correctness,
+	 * as sometimes it is null, and a kernel panic arises.
+	 * For the sake of precision, also hdmirx is checked,
+	 * but no crash was found due to it being null */
+	if (fse->index > 1 || hdmirx == NULL ||
+			hdmirx->timings == NULL || hdmirx->cable_plugin == false)
+		return -EINVAL;
+
+	fse->min_width = hdmirx->timings->timings.bt.width;
+	fse->max_width = fse->min_width;
+
+	fse->min_height = hdmirx->timings->timings.bt.height;
+	fse->max_height = fse->min_height;
+	return 0;
+}
+static int hdmirx_enum_frame_interval(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_state *state,
+				   struct v4l2_subdev_frame_interval_enum *fie)
+{
+	struct cdns_hdmirx_device *hdmirx = cdns_sd_to_hdmi(sd);
+
+	if (fie->index > 8)
+		return -EINVAL;
+
+	if (fie->width == 0 || fie->height == 0 ||
+	    fie->code == 0) {
+		pr_warn("Please assign pixel format, width and height.\n");
+		return -EINVAL;
+	}
+
+	fie->interval.numerator = 1;
+
+	 /* TODO Reserved to extension */
+	fie->interval.denominator = hdmirx->timings->fps;
+	return 0;
+}
+
+static int hdmirx_enum_mbus_code(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_state *state,
+				  struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->index != 0)
+		return -EINVAL;
+
+	code->code = MEDIA_BUS_FMT_RGB888_1X24;
+
+	return 0;
+}
+
+static int hdmirx_get_format(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_state *state,
+				   struct v4l2_subdev_format *sdformat)
+{
+	struct cdns_hdmirx_device *hdmirx = cdns_sd_to_hdmi(sd);
+	struct v4l2_mbus_framefmt *mbusformat = &sdformat->format;
+
+	if (hdmirx->cable_plugin == false) {
+		dev_warn(&hdmirx->pdev->dev, "No Cable Connected!\n");
+		return -EINVAL;
+	}
+
+	switch (hdmirx->pixel_encoding) {
+	case PIXEL_ENCODING_YUV422:
+		mbusformat->code = MEDIA_BUS_FMT_YUYV8_1X16;
+		break;
+	case PIXEL_ENCODING_YUV420:
+		mbusformat->code = MEDIA_BUS_FMT_UV8_1X8;
+		break;
+	case PIXEL_ENCODING_YUV444:
+		mbusformat->code = MEDIA_BUS_FMT_AYUV8_1X32;
+		break;
+	default:
+		mbusformat->code = MEDIA_BUS_FMT_RGB888_1X24;
+	}
+
+	mbusformat->width =  hdmirx->timings->timings.bt.width;
+	mbusformat->height = hdmirx->timings->timings.bt.height;
+	mbusformat->colorspace = V4L2_COLORSPACE_JPEG;
+
+	return 0;
+}
+
+static int hdmirx_get_edid(struct v4l2_subdev *sd, struct v4l2_edid *edid)
+{
+	struct cdns_hdmirx_device *hdmirx = cdns_sd_to_hdmi(sd);
+
+	memset(edid->reserved, 0, sizeof(edid->reserved));
+
+	if (!hdmirx->edid.present)
+		return -ENODATA;
+
+	if (edid->start_block == 0 && edid->blocks == 0) {
+		edid->blocks = hdmirx->edid.blocks;
+		return 0;
+	}
+
+	if (edid->start_block >= hdmirx->edid.blocks)
+		return -EINVAL;
+
+	if (edid->start_block + edid->blocks > hdmirx->edid.blocks)
+		edid->blocks = hdmirx->edid.blocks - edid->start_block;
+
+	memcpy(edid->edid, hdmirx->edid.edid + edid->start_block * 128,
+			edid->blocks * 128);
+
+	return 0;
+}
+
+static int hdmirx_set_edid(struct v4l2_subdev *sd, struct v4l2_edid *edid)
+{
+	struct cdns_hdmirx_device *hdmirx = cdns_sd_to_hdmi(sd);
+	int err, i;
+
+	memset(edid->reserved, 0, sizeof(edid->reserved));
+
+	if (edid->start_block != 0)
+		return -EINVAL;
+
+	if (edid->blocks == 0) {
+		/* Default EDID */
+		hdmirx->edid.blocks = 2;
+		hdmirx->edid.present = true;
+	} else if (edid->blocks > 4) {
+		edid->blocks = 4;
+		return -E2BIG;
+	} else {
+		memcpy(hdmirx->edid.edid, edid->edid, 128 * edid->blocks);
+		hdmirx->edid.blocks = edid->blocks;
+		hdmirx->edid.present = true;
+	}
+
+	for (i = 0; i < hdmirx->edid.blocks; i++) {
+		/* EDID block */
+		err = cdns_hdmirx_set_edid(hdmirx, 0, i, &hdmirx->edid.edid[i * 128]);
+		if (err) {
+			v4l2_err(sd, "error %d writing edid pad %d\n", err, edid->pad);
+			return -err;
+		}
+	}
+
+	return 0;
+}
+
+static bool check_dv_timings(const struct v4l2_dv_timings *timings,
+					  void *hdl)
+{
+	const struct cdns_hdmirx_dev_video_standards *stds =
+		cdns_hdmi_video_standards;
+	u32 i;
+
+	for (i = 0; stds[i].timings.bt.width; i++)
+		if (v4l2_match_dv_timings(timings, &stds[i].timings, 0, false))
+			return true;
+
+	return false;
+}
+
+static int hdmirx_enum_dv_timings(struct v4l2_subdev *sd,
+					struct v4l2_enum_dv_timings *timings)
+{
+	return v4l2_enum_dv_timings_cap(timings, &hdmirx_timings_cap,
+					check_dv_timings, NULL);
+}
+
+static int hdmirx_dv_timings_cap(struct v4l2_subdev *sd,
+				       struct v4l2_dv_timings_cap *cap)
+{
+	*cap = hdmirx_timings_cap;
+	return 0;
+}
+
+static const struct v4l2_subdev_pad_ops cdns_pad_ops_hdmi = {
+	.enum_mbus_code = hdmirx_enum_mbus_code,
+	.enum_frame_size = hdmirx_enum_framesizes,
+	.enum_frame_interval = hdmirx_enum_frame_interval,
+	.get_fmt = hdmirx_get_format,
+	.get_edid = hdmirx_get_edid,
+	.set_edid = hdmirx_set_edid,
+	.dv_timings_cap = hdmirx_dv_timings_cap,
+	.enum_dv_timings = hdmirx_enum_dv_timings,
+};
+
+static int hdmirx_s_power(struct v4l2_subdev *sd, int on)
+{
+	struct cdns_hdmirx_device *hdmirx = cdns_sd_to_hdmi(sd);
+	struct device *dev = &hdmirx->pdev->dev;
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	return 0;
+}
+static struct v4l2_subdev_core_ops cdns_core_ops_hdmi = {
+	.s_power = hdmirx_s_power,
+};
+
+/* -----------------------------------------------------------------------------
+ * v4l2_subdev_ops
+ */
+static const struct v4l2_subdev_ops cdns_ops_hdmi = {
+	.core = &cdns_core_ops_hdmi,
+	.video = &cdns_video_ops_hdmi,
+	.pad = &cdns_pad_ops_hdmi,
+};
+
+void imx8qm_hdmi_phy_reset(struct cdns_hdmirx_device *hdmirx, u8 reset)
+{
+	struct imx_sc_ipc *handle;
+	int ret;
+
+	dev_dbg(&hdmirx->pdev->dev, "%s\n", __func__);
+
+	imx_scu_get_handle(&handle);
+	/* set the pixel link mode and pixel type */
+	ret = imx_sc_misc_set_control(handle, IMX_SC_R_HDMI_RX, IMX_SC_C_PHY_RESET, reset);
+	if (ret)
+		DRM_ERROR("SC_R_HDMI PHY reset failed %d!\n", ret);
+}
+
+#ifdef CONFIG_MHDP_HDMIRX_CEC
+static void hdmirx_cec_init(struct cdns_hdmirx_device *hdmirx)
+{
+	struct cdns_mhdp_cec *cec = &hdmirx->cec;
+
+	cec->dev = &hdmirx->pdev->dev;
+	cec->iolock = &hdmirx->iolock;
+	cec->regs_base = hdmirx->regs_base;
+	cec->regs_sec = hdmirx->regs_sec;
+	cec->bus_type = hdmirx->bus_type;
+}
+#endif
+
+static void dump_debug_regs(struct cdns_hdmirx_device *hdmirx)
+{
+	u16 dbgp = 0xFFFF;
+	u16 dbg;
+	u32 reg;
+
+	dev_info(&hdmirx->pdev->dev, "Checking debug registers...\n");
+	reg = cdns_hdmirx_bus_read(hdmirx, SW_DEBUG_L);
+	dbg = (u8)reg;
+	reg = cdns_hdmirx_bus_read(hdmirx, SW_DEBUG_H);
+	dbg |= (u8)reg << 8;
+
+	if (dbgp != dbg) {
+		u32 addr;
+		u32 r1, r2, r3, r4;
+
+		dev_info(&hdmirx->pdev->dev, "=== DBG: 0x%.4X\n", dbgp = dbg);
+
+		r1 = cdns_hdmirx_bus_read(hdmirx, VER_LIB_L_ADDR);
+		r2 = cdns_hdmirx_bus_read(hdmirx, VER_LIB_H_ADDR);
+		r3 = cdns_hdmirx_bus_read(hdmirx, VER_L);
+		r4 = cdns_hdmirx_bus_read(hdmirx, VER_H);
+
+		addr = r1 << 24 | r2 << 16 | r3 << 8 | r4;
+		dev_info(&hdmirx->pdev->dev, "=== DBG: addr 0x%.8X\n", addr);
+	}
+}
+
+static void alive(struct cdns_hdmirx_device *hdmirx)
+{
+	u32 ret;
+
+	/* Check if FW is still alive */
+	ret = cdns_hdmirx_check_alive(hdmirx);
+	if (ret == false) {
+		dev_err(&hdmirx->pdev->dev, "NO HDMI RX FW running\n");
+		dev_err(&hdmirx->pdev->dev, "Checking debug registers...\n");
+		dump_debug_regs(hdmirx);
+		/* BUG(); */
+	}
+}
+
+static int tmdsmon_fn(void *data)
+{
+	struct cdns_hdmirx_device *hdmirx = (struct cdns_hdmirx_device *)data;
+	int tmds;
+	u8 startup_attempts;
+	u8 avi_fail_cnt;
+	u16 tmds_measure_cnt;
+	u8 bad_tmds_cnt;
+
+	dev_dbg(&hdmirx->pdev->dev, "= starting tmdsmon thread\n");
+
+	startup_attempts = 0;
+	avi_fail_cnt = 0;
+	tmds_measure_cnt = 0;
+	bad_tmds_cnt = 0;
+
+	set_freezable();
+
+	while (1) {
+		bool change = false;
+
+		cpu_relax();
+		msleep(200);
+
+		if (kthread_freezable_should_stop(NULL))
+			break;
+
+		if (hdmirx->tmdsmon_state != 1) {
+			if (hdmirx->tmdsmon_state == 2)
+				dev_dbg(&hdmirx->pdev->dev, "= stopping tmdsmon thread\n");
+			hdmirx->tmdsmon_state = 0;
+			startup_attempts = 0;
+			avi_fail_cnt = 0;
+			continue;
+		}
+
+		alive(hdmirx);
+
+		if (phy_in_reset(hdmirx)) {
+			if (cdns_hdmirx_phyinit(hdmirx))
+				continue;
+		}
+
+		tmds = -1;
+		if (pma_rx_clk_sig_detected(hdmirx)) {
+			tmds = cdns_hdmirx_get_stable_tmds(hdmirx);
+			if (tmds < 0) {
+				bad_tmds_cnt++;
+				if (bad_tmds_cnt > 50) {
+					bad_tmds_cnt = 0;
+					dev_dbg(&hdmirx->pdev->dev, "Re-initialising PHY as no valid clock from source");
+					cdns_hdmirx_phyinit(hdmirx);
+					continue;
+				}
+			}
+		} else
+			bad_tmds_cnt = 0;
+
+		if (tmds < 0) {
+			if (hdmirx->initialized)
+				dev_info(&hdmirx->pdev->dev, "Lost TMDS clock\n\n");
+			hdmirx->cable_plugin = false;
+			hdmirx->initialized = false;
+			hdmirx->tmds_clk = -1;
+			startup_attempts = 0;
+			avi_fail_cnt = 0;
+			tmds_measure_cnt = 0;
+			continue;
+		}
+
+		tmds_measure_cnt++;
+		if (tmds_measure_cnt == 500) {
+			tmds_measure_cnt = 0;
+			dev_info(&hdmirx->pdev->dev, "Measured TMDS is %d\n\n", tmds);
+		}
+
+		if (tmds > (hdmirx->tmds_clk + 50) ||
+		    tmds < (hdmirx->tmds_clk - 50)) {
+			dev_info(&hdmirx->pdev->dev, "TMDS change detect: %d -> %d\n\n",
+				hdmirx->tmds_clk, tmds);
+			change = true;
+		} else if ((tmds > 0) && (hdmirx->initialized)) {
+			u32 val;
+			hdmirx->tmds_clk = tmds;
+
+			val = cdns_hdmirx_reg_read(hdmirx, TMDS_DEC_ST);
+			if (val & 1) {
+				/* Only if detected as HDMI mode */
+				int avi_change;
+
+				/* Try to get an AVI infoframe */
+				avi_change = cdns_hdmirx_get_avi_infoframe(hdmirx, 200);
+
+				/* First check to see if we are already authenticated in
+				 * HDCP mode, if so we need to request re-authentication
+				 * if there are too many errors...
+				 * However if get_avi_infoframe was successful then skip
+				 * as all good... */
+				if ((avi_change < 0) && hdmirx->hdcp_fw_loaded) {
+					struct hdcprx_status status;
+					u8 key_arrived, hdcp_ver;
+
+					cdns_hdcprx_get_status(hdmirx, &status);
+					key_arrived = status.flags & 1;
+					hdcp_ver = (status.flags >> 1) & 0x3,
+
+					val = cdns_hdmirx_reg_read(hdmirx, PKT_ERR_CNT_HEADER);
+					/* Already authenticated */
+					if (key_arrived) {
+						if (val & 0xff) {
+							dev_dbg(&hdmirx->pdev->dev, "Got PKT_ERR_CNT_HEADER 0x%08X\n", val);
+							dev_info(&hdmirx->pdev->dev, "Requesting HDCP re-authentication\n");
+							cdns_hdcprx_reauth_req_wait(hdmirx, 2000);
+						}
+					} else if (hdcp_ver > 0)
+						/* Possibly authenticating */
+						cdns_hdcprx_wait_auth_complete(hdmirx, 2000);
+				}
+
+				/* Clear out status register */
+				val = cdns_hdmirx_reg_read(hdmirx, PKT_ERR_CNT_HEADER);
+				if (avi_change < 0) {
+					avi_fail_cnt++;
+
+					if (avi_fail_cnt >= 3) {
+						uint32_t events;
+
+						dev_info(&hdmirx->pdev->dev, "Failed to get AVI infoframe after %d attempts\n", avi_fail_cnt);
+						dev_dbg(&hdmirx->pdev->dev, "Triggering re-init via HPD\n");
+						events = cdns_hdmirx_bus_read(hdmirx, SW_EVENTS1);
+						cdns_hdmirx_hotplug_trigger(hdmirx);
+						cdns_hdmirx_wait_edid_read(hdmirx);
+						change = true;
+						avi_fail_cnt = 0;
+					}
+				} else {
+					avi_fail_cnt = 0;
+					if (avi_change == 1) {
+						dev_info(&hdmirx->pdev->dev, "\nAVI change detect\n\n");
+						change = true;
+						if (hdmirx->vic_code == 0) {
+							int vnd_change = cdns_hdmirx_get_vendor_infoframe(hdmirx, 250);
+							if (vnd_change == 1) {
+								dev_info(&hdmirx->pdev->dev, "\nVendor info change detect\n\n");
+								cdns_hdmirx_frame_timing(hdmirx);
+							}
+						}
+					}
+				}
+			} else
+				/* DVI mode */
+				avi_fail_cnt = 0;
+		}
+
+		/* Check in case about to shut down... */
+		if (hdmirx->tmdsmon_state != 1)
+			continue;
+
+		if (change) {
+			if (hdmirx->initialized) {
+				if (hdmirx->hdcp_fw_loaded && !hdmirx->allow_hdcp)
+					cdns_hdcprx_disable(hdmirx);
+				/* We may not have a clock anymore at this point
+				   so clear it later...
+				hdmirx_phy_pix_engine_reset(hdmirx);
+				hdmirx_stop(hdmirx);
+				*/
+			}
+			hdmirx->initialized = false;
+			hdmirx->cable_plugin = false;
+
+			if (!hdmirx->allow_hdcp && hdmirx->hdcp_fw_loaded)
+				cdns_hdmirx_general_unloadhdcprx(hdmirx);
+
+			cdns_hdmirx_maincontrol(hdmirx, VIDEO_MODE_CHANGE);
+			dev_dbg(&hdmirx->pdev->dev, "%s(): called MainControl(0) with VIDEO_MODE_CHANGE\n",  __func__);
+
+			cdns_hdmirx_maincontrol(hdmirx, 1);
+			dev_dbg(&hdmirx->pdev->dev, "%s(): called MainControl(1)\n", __func__);
+
+			if (hdmirx->allow_hdcp && !hdmirx->hdcp_fw_loaded) {
+				cdns_hdmirx_general_loadhdcprx(hdmirx);
+				cdns_hdcprx_enable(hdmirx);
+			}
+			hdmirx->hdcp_fw_loaded = hdmirx->allow_hdcp;
+
+			dev_dbg(&hdmirx->pdev->dev, "= TMDS Mon calling cdns_hdmirx_startup after seeing TMDS of %d\n", tmds);
+			if (cdns_hdmirx_startup(hdmirx) < 0) {
+				hdmirx->tmds_clk = -1;
+				if (startup_attempts > 1) {
+					dev_dbg(&hdmirx->pdev->dev, "= TMDS Mon re-initialising PHY due to %d failed startup attempts\n", startup_attempts);
+					cdns_hdmirx_phyinit(hdmirx);
+					startup_attempts = 0;
+				} else
+					startup_attempts++;
+				continue;
+			}
+#ifdef CONFIG_MHDP_HDMIRX_CEC
+			if (hdmirx->is_cec && !hdmirx->cec_running) {
+				hdmirx_cec_init(hdmirx);
+				cdns_mhdp_register_cec_driver(&hdmirx->cec);
+				hdmirx->cec_running = true;
+			}
+#endif
+			startup_attempts = 0;
+			hdmirx->initialized = true;
+			hdmirx->cable_plugin = true;
+		} else {
+			if (hdmirx->initialized) {
+
+				if (!hdmirx->allow_hdcp && hdmirx->hdcp_fw_loaded) {
+					cdns_hdcprx_disable(hdmirx);
+					cdns_hdmirx_general_unloadhdcprx(hdmirx);
+				}
+				if (hdmirx->allow_hdcp && !hdmirx->hdcp_fw_loaded) {
+					cdns_hdmirx_general_loadhdcprx(hdmirx);
+					cdns_hdcprx_enable(hdmirx);
+				}
+				hdmirx->hdcp_fw_loaded = hdmirx->allow_hdcp;
+			}
+			startup_attempts = 0;
+		}
+	}
+
+	dev_info(&hdmirx->pdev->dev, "= exiting tmdsmon thread\n");
+
+	/* Avoid compiler warning */
+	return 0;
+}
+
+static int tmdsmon_init(struct cdns_hdmirx_device *hdmirx)
+{
+	static const char name[] = "tmdsmon_th";
+
+	if (hdmirx->tmdsmon_th) {
+		dev_dbg(&hdmirx->pdev->dev, "Resuming thread for monitoring TMDS changes\n");
+		hdmirx->tmdsmon_state = 1;
+		return 0;
+	}
+
+	dev_dbg(&hdmirx->pdev->dev, "Creating thread for monitoring TMDS changes\n");
+
+	hdmirx->tmdsmon_th = kthread_create(tmdsmon_fn, hdmirx, name);
+	if (!IS_ERR(hdmirx->tmdsmon_th)) {
+		hdmirx->tmdsmon_state = 1;
+		wake_up_process(hdmirx->tmdsmon_th);
+	} else {
+		dev_err(&hdmirx->pdev->dev,
+			"Failed to spawn TMDS monitor thread\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+static void tmdsmon_cleanup(struct cdns_hdmirx_device *hdmirx)
+{
+	dev_dbg(&hdmirx->pdev->dev, "= stopping tmds mon\n");
+	hdmirx->tmdsmon_state = 2;
+	while (hdmirx->tmdsmon_state == 2)
+		schedule();
+	dev_dbg(&hdmirx->pdev->dev, "= stopped tmds mon\n");
+}
+
+int cdns_hdmirx_wait_edid_read(struct cdns_hdmirx_device *hdmirx)
+{
+	uint32_t events;
+
+	ktime_t timeout = ktime_timeout_ms(2000);
+	dev_info(&hdmirx->pdev->dev, "hdmirx_wait_edid_read wait for EDID to be read\n");
+	do {
+		events = cdns_hdmirx_bus_read(hdmirx, SW_EVENTS1);
+		if (ktime_after(ktime_get(), timeout))
+			goto timeout_err;
+		msleep(1);
+	} while ((events & 0x1) == 0);
+	dev_dbg(&hdmirx->pdev->dev, "hdmirx_wait_edid_read detected, now wait for status to be 0");
+
+	timeout = ktime_timeout_ms(500);
+	do {
+		msleep(50);
+		events = cdns_hdmirx_bus_read(hdmirx, SW_EVENTS1);
+		if (ktime_after(ktime_get(), timeout))
+			goto timeout_err;
+	} while ((events & 0x1) == 1);
+
+	dev_dbg(&hdmirx->pdev->dev, "hdmirx_wait_edid_read Finished successfully, final status 0x%08X\n", events);
+	return 0;
+
+timeout_err:
+	dev_dbg(&hdmirx->pdev->dev, "hdmirx_wait_edid_read timed out waiting for EDID to be read\n");
+	return -1;
+}
+
+static void hpd5v_work_func(struct work_struct *work)
+{
+	struct cdns_hdmirx_device *hdmirx = container_of(work,
+						       struct cdns_hdmirx_device,
+						       hpd5v_work.work);
+	char event_string[32];
+	char *envp[] = { event_string, NULL };
+	u8 hpd = ~0;
+
+	dev_dbg(&hdmirx->pdev->dev, "%s hello\n", __func__);
+
+	/* Check cable hdmirxs before enable irq */
+	hpd = cdns_hdmirx_read_hpd(hdmirx);
+	if (hdmirx->last_5v_state == hpd)
+		return;
+
+	hdmirx->last_5v_state = hpd;
+	if (hpd == 1) {
+		dev_info(&hdmirx->pdev->dev, "HDMI RX Cable Plug In\n");
+
+		dev_dbg(&hdmirx->pdev->dev, "hpd5v_work_func calling cdns_hdmirx_phyinit\n");
+		if (cdns_hdmirx_phyinit(hdmirx))
+			dev_err(&hdmirx->pdev->dev, "Failed to init PHY, try replugging.\n");
+		if (hdmirx->allow_hdcp) {
+			cdns_hdmirx_general_loadhdcprx(hdmirx);
+			cdns_hdcprx_enable(hdmirx);
+		}
+		hdmirx->initialized = 0;
+		hdmirx->tmds_clk = -1;
+
+		sprintf(event_string, "EVENT=hdmirxin");
+		kobject_uevent_env(&hdmirx->pdev->dev.kobj, KOBJ_CHANGE, envp);
+		hdmirx->cable_plugin = true;
+#ifdef CONFIG_MHDP_HDMIRX_CEC
+		if (hdmirx->is_cec) {
+			hdmirx_cec_init(hdmirx);
+			cdns_mhdp_register_cec_driver(&hdmirx->cec);
+			hdmirx->cec_running = true;
+		}
+#endif
+		tmdsmon_init(hdmirx);
+		enable_irq(hdmirx->irq[HPD5V_IRQ_OUT]);
+	} else if (hpd == 0) {
+		tmdsmon_cleanup(hdmirx);
+		cdns_hdmirx_sethpd(hdmirx, 0);
+		if (hdmirx->initialized) {
+			/* We may not have a clock anymore at this point
+			   so clear it later...
+			hdmirx_phy_pix_engine_reset(hdmirx);
+			hdmirx_stop(hdmirx);
+			*/
+		}
+		hdmirx->initialized = false;
+#ifdef CONFIG_MHDP_HDMIRX_CEC
+		if (hdmirx->is_cec && hdmirx->cec_running) {
+			cdns_mhdp_unregister_cec_driver(&hdmirx->cec);
+			hdmirx->cec_running = false;
+		}
+#endif
+		sprintf(event_string, "EVENT=hdmirxout");
+		kobject_uevent_env(&hdmirx->pdev->dev.kobj, KOBJ_CHANGE, envp);
+		hdmirx->cable_plugin = false;
+
+		cdns_hdmirx_maincontrol(hdmirx, 0);
+		dev_dbg(&hdmirx->pdev->dev, "%s(): called MainControl_blocking(0x0)\n", __func__);
+		imx8qm_hdmi_phy_reset(hdmirx, 0);
+		cdns_hdmirx_general_assertphyreset(hdmirx);
+
+		enable_irq(hdmirx->irq[HPD5V_IRQ_IN]);
+	} else
+		dev_warn(&hdmirx->pdev->dev, "HDMI RX Cable State unknow\n");
+}
+
+#define RX_HOTPLUG_DEBOUNCE_MS		200
+static irqreturn_t hdp5v_irq_thread(int irq, void *data)
+{
+	struct cdns_hdmirx_device *hdmirx =  data;
+
+	dev_dbg(&hdmirx->pdev->dev, "%s hello\n", __func__);
+
+	disable_irq_nosync(irq);
+
+	mod_delayed_work(system_wq, &hdmirx->hpd5v_work,
+			msecs_to_jiffies(RX_HOTPLUG_DEBOUNCE_MS));
+
+	return IRQ_HANDLED;
+}
+
+static void print_fw_ver(struct cdns_hdmirx_device *hdmirx)
+{
+	u8 r1, r2, r3, r4;
+
+	r1 = cdns_hdmirx_bus_read(hdmirx, VER_LIB_L_ADDR);
+	r2 = cdns_hdmirx_bus_read(hdmirx, VER_LIB_H_ADDR);
+	r3 = cdns_hdmirx_bus_read(hdmirx, VER_L);
+	r4 = cdns_hdmirx_bus_read(hdmirx, VER_H);
+    printk("HDMI RX FIRMWARE VERSION: %d, LIB VERSION: %d\n", (r4 << 8) | r3, (r2 << 8) | r1);
+}
+
+static int hdmirx_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct cdns_hdmirx_device *hdmirx;
+	struct resource *res;
+	u8 hpd;
+	int ret = 0;
+
+	dev_dbg(dev, "%s\n", __func__);
+	hdmirx = devm_kzalloc(dev, sizeof(*hdmirx), GFP_KERNEL);
+	if (!hdmirx)
+		return -ENOMEM;
+
+	hdmirx->pdev = pdev;
+	mutex_init(&hdmirx->iolock);
+	mutex_init(&hdmirx->pif_mutex);
+
+	/* register map */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res) {
+		hdmirx->regs_base = devm_ioremap(dev, res->start, resource_size(res));
+		if (IS_ERR(hdmirx->regs_base)) {
+			dev_err(dev, "Failed to get HDMI RX CTRL base register\n");
+			return -EINVAL;
+		}
+	} else
+		dev_err(dev, "Error Not get memory resource");
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (res) {
+		hdmirx->regs_sec = devm_ioremap(dev, res->start, resource_size(res));
+		if (IS_ERR(hdmirx->regs_sec)) {
+			dev_err(dev, "Failed to get HDMI RX CRS base register\n");
+			return -EINVAL;
+		}
+	} else
+		dev_err(dev, "Error Not get memory resource");
+
+	hdmirx->irq[HPD5V_IRQ_IN] = platform_get_irq_byname(pdev, "plug_in");
+	if (hdmirx->irq[HPD5V_IRQ_IN] < 0)
+		dev_info(&pdev->dev, "No plug_in irq number\n");
+
+	hdmirx->irq[HPD5V_IRQ_OUT] = platform_get_irq_byname(pdev, "plug_out");
+	if (hdmirx->irq[HPD5V_IRQ_OUT] < 0)
+		dev_info(&pdev->dev, "No plug_out irq number\n");
+
+	INIT_DELAYED_WORK(&hdmirx->hpd5v_work, hpd5v_work_func);
+
+	v4l2_subdev_init(&hdmirx->sd, &cdns_ops_hdmi);
+	/* sd.dev may use by match_of */
+	hdmirx->sd.dev = dev;
+
+	/* the owner is the same as the i2c_client's driver owner */
+	hdmirx->sd.owner = THIS_MODULE;
+	hdmirx->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	hdmirx->sd.entity.function = MEDIA_ENT_F_IO_DTV;
+
+	/* This allows to retrieve the platform device id by the host driver */
+	v4l2_set_subdevdata(&hdmirx->sd, pdev);
+
+	/* initialize name */
+	snprintf(hdmirx->sd.name, sizeof(hdmirx->sd.name), "%s", HDMIRX_SUBDEV_NAME);
+
+	hdmirx->pads[MXC_HDMI_RX_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+	hdmirx->pads[MXC_HDMI_RX_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+
+	hdmirx->sd.entity.ops = &hdmi_media_ops;
+	ret = media_entity_pads_init(&hdmirx->sd.entity,
+				     MXC_HDMI_RX_PADS_NUM, hdmirx->pads);
+	if (ret)
+		return ret;
+
+	platform_set_drvdata(pdev, hdmirx);
+	ret = v4l2_async_register_subdev(&hdmirx->sd);
+	if (ret < 0) {
+		dev_err(dev,
+					"%s--Async register failed, ret=%d\n", __func__, ret);
+		media_entity_cleanup(&hdmirx->sd.entity);
+	}
+
+	hdmirx->is_cec = of_property_read_bool(pdev->dev.of_node, "fsl,cec");
+
+	of_property_read_string(pdev->dev.of_node, "firmware-name",
+					&hdmirx->firmware_name);
+
+	hdmirx_clock_init(hdmirx);
+
+	hdmirx->bus_type = BUS_TYPE_LOW4K_HDMI_RX;
+
+	hdmirx->flags = HDMIRX_PM_POWERED;
+
+	hdmirx->allow_hdcp = true;
+	hdmirx->hdcp_fw_loaded = false;
+	hdmirx->rescal_val = 0;
+	hdmirx->slicer_tune_val = 0;
+	hdmirx->running = 0;
+
+	hdmirx_clock_enable(hdmirx);
+
+	pm_runtime_set_active(dev);
+	pm_runtime_enable(dev);
+	pm_runtime_get_sync(dev);
+
+	hdmirx->tmdsmon_th = NULL;
+	hdmirx->tmdsmon_state = 0;
+
+	ret = cdns_hdmirx_init(hdmirx);
+	if (ret < 0) {
+		dev_err(dev, "mxc hdmi rx init failed\n");
+		goto failed;
+	}
+	hdmi_sysfs_init(dev);
+	cdns_hdcprx_enable(hdmirx);
+
+	/* Check cable states before enable irq */
+	hpd = cdns_hdmirx_read_hpd(hdmirx);
+	hdmirx->last_5v_state = hpd;
+
+	/* Enable Hotplug Detect IRQ thread */
+	if (hdmirx->irq[HPD5V_IRQ_IN] > 0) {
+		irq_set_status_flags(hdmirx->irq[HPD5V_IRQ_IN], IRQ_NOAUTOEN);
+		ret = devm_request_threaded_irq(dev, hdmirx->irq[HPD5V_IRQ_IN],
+						NULL, hdp5v_irq_thread,
+						IRQF_ONESHOT, dev_name(dev), hdmirx);
+		if (ret) {
+			dev_err(&pdev->dev, "can't claim irq %d\n",
+							hdmirx->irq[HPD5V_IRQ_IN]);
+			goto failed;
+		}
+		/* Cable Disconnedted, enable Plug in IRQ */
+		if (hpd == 0) {
+			cdns_hdmirx_sethpd(hdmirx, 0);
+			hdmirx->cable_plugin = false;
+			cdns_hdmirx_maincontrol(hdmirx, 0);
+			dev_dbg(&hdmirx->pdev->dev, "%s(): called MainControl_blocking(0x0)\n", __func__);
+			imx8qm_hdmi_phy_reset(hdmirx, 0);
+			cdns_hdmirx_general_assertphyreset(hdmirx);
+			enable_irq(hdmirx->irq[HPD5V_IRQ_IN]);
+		}
+	}
+
+	if (hdmirx->irq[HPD5V_IRQ_OUT] > 0) {
+		irq_set_status_flags(hdmirx->irq[HPD5V_IRQ_OUT], IRQ_NOAUTOEN);
+		ret = devm_request_threaded_irq(dev, hdmirx->irq[HPD5V_IRQ_OUT],
+						NULL, hdp5v_irq_thread,
+						IRQF_ONESHOT, dev_name(dev), hdmirx);
+		if (ret) {
+			dev_err(&pdev->dev, "can't claim irq %d\n",
+				hdmirx->irq[HPD5V_IRQ_OUT]);
+			goto failed;
+		}
+		if (hpd == 1) {
+			dev_dbg(&hdmirx->pdev->dev, "hdmirx_probe calling cdns_hdmirx_phyinit\n");
+			if (cdns_hdmirx_phyinit(hdmirx))
+				dev_err(&hdmirx->pdev->dev, "Failed to init PHY, try replugging.\n");
+			if (hdmirx->allow_hdcp) {
+				cdns_hdmirx_general_loadhdcprx(hdmirx);
+				cdns_hdcprx_enable(hdmirx);
+			}
+			hdmirx->hdcp_fw_loaded = hdmirx->allow_hdcp;
+			hdmirx->initialized = 0;
+			hdmirx->tmds_clk = -1;
+			hdmirx->cable_plugin = true;
+#ifdef CONFIG_MHDP_HDMIRX_CEC
+			if (hdmirx->is_cec) {
+				hdmirx_cec_init(hdmirx);
+				cdns_mhdp_register_cec_driver(&hdmirx->cec);
+				hdmirx->cec_running = true;
+			}
+#endif
+			tmdsmon_init(hdmirx);
+			/* Cable Connected, enable Plug out IRQ */
+			enable_irq(hdmirx->irq[HPD5V_IRQ_OUT]);
+		}
+	}
+
+	cdns_hdmirx_register_audio_driver(dev);
+	print_fw_ver(hdmirx);
+	dev_dbg(dev, "iMX8 HDMI RX probe successfully\n");
+
+	return ret;
+failed:
+	v4l2_async_unregister_subdev(&hdmirx->sd);
+	media_entity_cleanup(&hdmirx->sd.entity);
+
+	hdmirx_clock_disable(hdmirx);
+	pm_runtime_disable(dev);
+	dev_warn(dev, "mxc hdmi rx probe failed\n");
+	return ret;
+}
+
+static int hdmirx_remove(struct platform_device *pdev)
+{
+	struct cdns_hdmirx_device *hdmirx = platform_get_drvdata(pdev);
+	struct device *dev = &pdev->dev;
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	tmdsmon_cleanup(hdmirx);
+	v4l2_async_unregister_subdev(&hdmirx->sd);
+	media_entity_cleanup(&hdmirx->sd.entity);
+
+#ifdef CONFIG_MHDP_HDMIRX_CEC
+	if (hdmirx->is_cec)
+		cdns_mhdp_unregister_cec_driver(&hdmirx->cec);
+#endif
+
+	cdns_hdmirx_sethpd(hdmirx, 0);
+
+	cdns_hdmirx_maincontrol(hdmirx, 0x0);
+	dev_dbg(dev, "%s(): called MainControl_blocking(0x0)\n", __func__);
+
+	hdmirx_clock_disable(hdmirx);
+	pm_runtime_put_sync(dev);
+	pm_runtime_disable(dev);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int hdmirx_pm_suspend(struct device *dev)
+{
+	struct cdns_hdmirx_device *hdmirx = dev_get_drvdata(dev);
+
+	dev_dbg(dev, "%s\n", __func__);
+	if (hdmirx->running > 0) {
+		dev_warn(dev, "running, prevent entering suspend.\n");
+		return -EAGAIN;
+	}
+
+	if ((hdmirx->flags & HDMIRX_PM_SUSPENDED) ||
+		(hdmirx->flags & HDMIRX_RUNTIME_SUSPEND))
+		return 0;
+
+	hdmirx_clock_disable(hdmirx);
+	hdmirx->flags |= HDMIRX_PM_SUSPENDED;
+	hdmirx->flags &= ~HDMIRX_PM_POWERED;
+
+	return 0;
+}
+
+static int hdmirx_pm_resume(struct device *dev)
+{
+	struct cdns_hdmirx_device *hdmirx = dev_get_drvdata(dev);
+	int ret;
+
+	if (hdmirx->flags & HDMIRX_PM_POWERED)
+		return 0;
+
+	hdmirx->flags |= HDMIRX_PM_POWERED;
+	hdmirx->flags &= ~HDMIRX_PM_SUSPENDED;
+
+	hdmirx_clock_enable(hdmirx);
+
+	/* reset hdmi rx status flags */
+	hdmirx->initialized = 0;
+	hdmirx->tmds_clk = -1;
+	hdmirx->hdcp_fw_loaded = false;
+
+	ret = cdns_hdmirx_init(hdmirx);
+	if (ret < 0)
+		return -EAGAIN;
+
+	ret = cdns_hdmirx_phyinit(hdmirx);
+	return (ret) ? -EAGAIN : 0;
+}
+#endif
+
+static int hdmirx_runtime_suspend(struct device *dev)
+{
+	struct cdns_hdmirx_device *hdmirx = dev_get_drvdata(dev);
+
+	if (hdmirx->flags & HDMIRX_RUNTIME_SUSPEND)
+		return 0;
+
+	if (hdmirx->flags & HDMIRX_PM_POWERED) {
+		hdmirx_clock_disable(hdmirx);
+		hdmirx->flags |= HDMIRX_RUNTIME_SUSPEND;
+		hdmirx->flags &= ~HDMIRX_PM_POWERED;
+	}
+	return 0;
+}
+
+static int hdmirx_runtime_resume(struct device *dev)
+{
+	struct cdns_hdmirx_device *hdmirx = dev_get_drvdata(dev);
+
+	if (hdmirx->flags & HDMIRX_PM_POWERED)
+		return 0;
+
+	if (hdmirx->flags & HDMIRX_RUNTIME_SUSPEND) {
+		hdmirx_clock_enable(hdmirx);
+		hdmirx->flags |= HDMIRX_PM_POWERED;
+		hdmirx->flags &= ~HDMIRX_RUNTIME_SUSPEND;
+	}
+	return 0;
+}
+
+static const struct dev_pm_ops hdmirx_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(hdmirx_pm_suspend, hdmirx_pm_resume)
+	SET_RUNTIME_PM_OPS(hdmirx_runtime_suspend, hdmirx_runtime_resume, NULL)
+};
+
+static const struct of_device_id hdmirx_of_match[] = {
+	{.compatible = "cdn,imx8qm-hdmirx",},
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, hdmirx_of_match);
+
+static struct platform_driver hdmirx_driver = {
+	.probe		= hdmirx_probe,
+	.remove		= hdmirx_remove,
+	.driver = {
+		.of_match_table = hdmirx_of_match,
+		.name		= HDMIRX_DRIVER_NAME,
+		.pm		= &hdmirx_pm_ops,
+	}
+};
+
+module_platform_driver(hdmirx_driver);
diff --git a/drivers/staging/media/imx/hdmirx/cdns-mhdp-hdmirx.c b/drivers/staging/media/imx/hdmirx/cdns-mhdp-hdmirx.c
new file mode 100644
index 000000000..e0d1d5e68
--- /dev/null
+++ b/drivers/staging/media/imx/hdmirx/cdns-mhdp-hdmirx.c
@@ -0,0 +1,503 @@
+/*
+ * Copyright 2020 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#include <asm/unaligned.h>
+#include <drm/bridge/cdns-mhdp.h>
+#include "cdns-mhdp-hdmirx.h"
+
+#define MAILBOX_RETRY_US		1000
+#define MAILBOX_TIMEOUT_US		5000000
+
+#define hdmirx_readx_poll_timeout(op, addr, offset, val, cond, sleep_us, timeout_us)	\
+({ \
+	u64 __timeout_us = (timeout_us); \
+	unsigned long __sleep_us = (sleep_us); \
+	ktime_t __timeout = ktime_add_us(ktime_get(), __timeout_us); \
+	might_sleep_if((__sleep_us) != 0); \
+	for (;;) { \
+		(val) = op(addr, offset); \
+		if (cond) \
+			break; \
+		if (__timeout_us && \
+		    ktime_compare(ktime_get(), __timeout) > 0) { \
+			(val) = op(addr, offset); \
+			break; \
+		} \
+		if (__sleep_us) \
+			usleep_range((__sleep_us >> 2) + 1, __sleep_us); \
+	} \
+	(cond) ? 0 : -ETIMEDOUT; \
+})
+
+
+u32 cdns_hdmirx_bus_read(struct cdns_hdmirx_device *hdmirx, u32 offset)
+{
+	u32 val;
+
+	mutex_lock(&hdmirx->iolock);
+
+	if (hdmirx->bus_type == BUS_TYPE_LOW4K_HDMI_RX) {
+		/* Remap address to low 4K memory */
+		writel(offset >> 12, hdmirx->regs_sec + 4);
+		val = readl((offset & 0xfff) + hdmirx->regs_base);
+	} else
+		val = readl(hdmirx->regs_base + offset);
+
+	mutex_unlock(&hdmirx->iolock);
+
+	return val;
+}
+
+void cdns_hdmirx_bus_write(u32 val, struct cdns_hdmirx_device *hdmirx, u32 offset)
+{
+	mutex_lock(&hdmirx->iolock);
+
+	if (hdmirx->bus_type == BUS_TYPE_LOW4K_HDMI_RX) {
+		/* Remap address to low 4K memory */
+		writel(offset >> 12, hdmirx->regs_sec + 4);
+		writel(val, (offset & 0xfff) + hdmirx->regs_base);
+	} else
+		writel(val, hdmirx->regs_base + offset);
+
+	mutex_unlock(&hdmirx->iolock);
+}
+
+bool cdns_hdmirx_check_alive(struct cdns_hdmirx_device *hdmirx)
+{
+	u32  alive, newalive;
+	u8 retries_left = 50;
+
+	alive = cdns_hdmirx_bus_read(hdmirx, KEEP_ALIVE);
+
+	while (retries_left--) {
+		udelay(2);
+
+		newalive = cdns_hdmirx_bus_read(hdmirx, KEEP_ALIVE);
+		if (alive == newalive)
+			continue;
+		return true;
+	}
+	return false;
+}
+
+int hdmirx_mailbox_read(struct cdns_hdmirx_device *hdmirx)
+{
+	int val, ret;
+
+	ret = hdmirx_readx_poll_timeout(cdns_hdmirx_bus_read, hdmirx, MAILBOX_EMPTY_ADDR,
+				 val, !val, MAILBOX_RETRY_US,
+				 MAILBOX_TIMEOUT_US);
+	if (ret < 0)
+		return ret;
+
+	return cdns_hdmirx_bus_read(hdmirx, MAILBOX0_RD_DATA) & 0xff;
+}
+
+static int hdmirx_mailbox_write(struct cdns_hdmirx_device *hdmirx, u8 val)
+{
+	int ret, full;
+
+	ret = hdmirx_readx_poll_timeout(cdns_hdmirx_bus_read, hdmirx, MAILBOX_FULL_ADDR,
+				 full, !full, MAILBOX_RETRY_US,
+				 MAILBOX_TIMEOUT_US);
+	if (ret < 0)
+		return ret;
+
+	cdns_hdmirx_bus_write(val, hdmirx, MAILBOX0_WR_DATA);
+
+	return 0;
+}
+
+int cdns_hdmirx_mailbox_validate_receive(struct cdns_hdmirx_device *hdmirx,
+					      u8 module_id, u8 opcode, u16 req_size)
+{
+	u32 mbox_size, i;
+	u8 header[4];
+	int ret;
+
+	/* read the header of the message */
+	for (i = 0; i < 4; i++) {
+		ret = hdmirx_mailbox_read(hdmirx);
+		if (ret < 0)
+			return ret;
+
+		header[i] = ret;
+	}
+
+	mbox_size = get_unaligned_be16(header + 2);
+
+	if (opcode != header[0] || module_id != header[1] ||
+	    req_size != mbox_size) {
+		/*
+		 * If the message in mailbox is not what we want, we need to
+		 * clear the mailbox by reading its contents.
+		 */
+		for (i = 0; i < mbox_size; i++)
+			if (hdmirx_mailbox_read(hdmirx) < 0)
+				break;
+
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+int cdns_hdmirx_mailbox_read_receive(struct cdns_hdmirx_device *hdmirx,
+					  u8 *buff, u16 buff_size)
+{
+	u32 i;
+	int ret;
+
+	for (i = 0; i < buff_size; i++) {
+		ret = hdmirx_mailbox_read(hdmirx);
+		if (ret < 0)
+			return ret;
+
+		buff[i] = ret;
+	}
+
+	return 0;
+}
+
+int cdns_hdmirx_mailbox_send(struct cdns_hdmirx_device *hdmirx, u8 module_id,
+				  u8 opcode, u16 size, u8 *message)
+{
+	u8 header[4];
+	int ret, i;
+
+	header[0] = opcode;
+	header[1] = module_id;
+	put_unaligned_be16(size, header + 2);
+
+	for (i = 0; i < 4; i++) {
+		ret = hdmirx_mailbox_write(hdmirx, header[i]);
+		if (ret)
+			return ret;
+	}
+
+	for (i = 0; i < size; i++) {
+		ret = hdmirx_mailbox_write(hdmirx, message[i]);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+int cdns_hdmirx_reg_read(struct cdns_hdmirx_device *hdmirx, u32 addr)
+{
+	u8 msg[4], resp[8];
+	u32 val;
+	int ret;
+
+	if (addr == 0) {
+		ret = -EINVAL;
+		goto err_reg_read;
+	}
+
+	put_unaligned_be32(addr, msg);
+
+	ret = cdns_hdmirx_mailbox_send(hdmirx, MB_MODULE_ID_GENERAL,
+				     GENERAL_READ_REGISTER,
+				     sizeof(msg), msg);
+	if (ret)
+		goto err_reg_read;
+
+	ret = cdns_hdmirx_mailbox_validate_receive(hdmirx, MB_MODULE_ID_GENERAL,
+						 GENERAL_READ_REGISTER,
+						 sizeof(resp));
+	if (ret)
+		goto err_reg_read;
+
+	ret = cdns_hdmirx_mailbox_read_receive(hdmirx, resp, sizeof(resp));
+	if (ret)
+		goto err_reg_read;
+
+	/* Returned address value should be the same as requested */
+	if (memcmp(msg, resp, sizeof(msg))) {
+		ret = -EINVAL;
+		goto err_reg_read;
+	}
+
+	val = get_unaligned_be32(resp + 4);
+
+	return val;
+err_reg_read:
+	dev_err(&hdmirx->pdev->dev, "Failed to read register.\n");
+
+	return ret;
+}
+
+int cdns_hdmirx_reg_write(struct cdns_hdmirx_device *hdmirx, u32 addr, u32 val)
+{
+	u8 msg[8];
+
+	put_unaligned_be32(addr, msg);
+	put_unaligned_be32(val, msg + 4);
+
+	return cdns_hdmirx_mailbox_send(hdmirx, MB_MODULE_ID_GENERAL,
+				      GENERAL_WRITE_REGISTER, sizeof(msg), msg);
+}
+
+int cdns_hdmirx_reg_write_bit(struct cdns_hdmirx_device *hdmirx, u16 addr,
+				   u8 start_bit, u8 bits_no, u32 val)
+{
+	u8 field[8];
+
+	put_unaligned_be16(addr, field);
+	field[2] = start_bit;
+	field[3] = bits_no;
+	put_unaligned_be32(val, field + 4);
+
+	return cdns_hdmirx_mailbox_send(hdmirx, MB_MODULE_ID_DP_TX,
+				      DPTX_WRITE_FIELD, sizeof(field), field);
+}
+
+int cdns_hdmirx_set_edid(struct cdns_hdmirx_device *hdmirx,
+						u8 segment,	u8 extension, u8 *edid)
+{
+	struct hdmirx_edid_set_msg msg;
+
+	msg.segment = segment;
+	msg.extension = extension;
+	memcpy(msg.edid, edid, 128);
+	return cdns_hdmirx_mailbox_send(hdmirx, MB_MODULE_ID_HDMI_RX,
+			HDMI_RX_SET_EDID, sizeof(struct hdmirx_edid_set_msg), (u8 *)&msg);
+}
+
+int cdns_hdmirx_set_scdc_slave(struct cdns_hdmirx_device *hdmirx,
+							struct S_HDMI_SCDC_SET_MSG *scdcdata)
+{
+	return cdns_hdmirx_mailbox_send(hdmirx, MB_MODULE_ID_HDMI_RX,
+			HDMI_RX_SCDC_SET, sizeof(struct S_HDMI_SCDC_SET_MSG), (u8 *)scdcdata);
+}
+
+int cdns_hdmirx_get_scdc_slave(struct cdns_hdmirx_device *hdmirx,
+					     struct S_HDMI_SCDC_GET_MSG *scdcdata)
+{
+	int len, ret;
+
+	ret = cdns_hdmirx_mailbox_send(hdmirx, MB_MODULE_ID_HDMI_RX,
+				     HDMI_RX_SCDC_GET, 0, NULL);
+	if (ret)
+		goto err_scdc_get;
+
+	len = sizeof(struct S_HDMI_SCDC_GET_MSG);
+	ret = cdns_hdmirx_mailbox_validate_receive(hdmirx, MB_MODULE_ID_HDMI_RX,
+						 HDMI_RX_SCDC_GET, len);
+	if (ret)
+		goto err_scdc_get;
+
+	ret = cdns_hdmirx_mailbox_read_receive(hdmirx, (u8 *)scdcdata, len);
+	if (ret)
+		goto err_scdc_get;
+
+err_scdc_get:
+	if (ret)
+		dev_err(&hdmirx->pdev->dev, "hdmirx scdc get failed: %d\n", ret);
+	return ret;
+}
+
+int cdns_hdmirx_sethpd(struct cdns_hdmirx_device *hdmirx, u8 hpd)
+{
+	return cdns_hdmirx_mailbox_send(hdmirx, MB_MODULE_ID_HDMI_RX,
+			HDMI_RX_SET_HPD, sizeof(hpd), &hpd);
+}
+
+int cdns_hdmirx_audioautoconfig(
+						struct cdns_hdmirx_device *hdmirx,
+						u8 max_ch_num,
+						u8 i2s_ports_num,
+						u8 dis_port3,
+						u8 enc_sample_width,
+						u8 i2s_sample_width)
+{
+	u32 regread;
+	u8 num_of_pairs_of_channels_per_port = max_ch_num / (i2s_ports_num * 2);
+	u8 enc_size_code;
+	u8 i2s_size_code;
+	u8 i2s_port3_dis = (dis_port3 != 0 && i2s_ports_num == 4) ? 1 : 0;
+	u8 times = 0;
+
+	/* Valid values: 1/2/4. */
+	/* 3 ports can be emulated with 'i2s_ports_num = 4' and 'dis_port3 = 1'. */
+	if (i2s_ports_num == 0 || i2s_ports_num == 3 || i2s_ports_num > 4)
+		return -1;
+
+	/* 'dis_port3' makes sense only with 4 ports enabled */
+	if (dis_port3 != 0 && i2s_ports_num < 4)
+		return -1;
+
+	switch (enc_sample_width) {
+	case 16:
+		enc_size_code = 0x0;
+		break;
+	case 24:
+		enc_size_code = 0x1;
+		break;
+	case 32:
+		enc_size_code = 0x2;
+		break;
+	default:
+		return -1;
+	}
+
+	switch (i2s_sample_width) {
+	case 16:
+		i2s_size_code = 0x0;
+		break;
+	case 24:
+		i2s_size_code = 0x1;
+		break;
+	case 32:
+		i2s_size_code = 0x2;
+		break;
+	default:
+		return -1;
+	}
+
+	/* Maximum number of channels has to be in range from 2 to 32 */
+	if (max_ch_num < 2 || max_ch_num > 32)
+		return -1;
+	/* Maximum number of channels has to be power of 2 */
+	else if (max_ch_num & (max_ch_num - 1))
+		return -1;
+	/* Each active port shall carry the same number of sub-channels */
+	else if (max_ch_num % i2s_ports_num)
+		return -1;
+
+	/* Disable ACR during configuration */
+	cdns_hdmirx_bus_write(F_ACR_SW_RESET(1), hdmirx, ACR_CFG);
+
+	/* Configuring audio FIFO */
+	cdns_hdmirx_bus_write(
+				F_CFG_FIFO_SW_RST(0) | F_CFG_INDEX_SYNC_EN(1) |
+				F_CFG_FIFO_DIR(1) |   F_CFG_DIS_PORT3(i2s_port3_dis),
+				hdmirx, FIFO_CNTL_ADDR);
+
+	/* Configuring audio parameters */
+	cdns_hdmirx_bus_write(
+				F_ENC_LOW_INDEX_MSB(0) | F_SINK_AUDIO_CH_NUM(max_ch_num - 1) |
+				F_ENC_SAMPLE_JUST(0x0) | F_ENC_SMPL_WIDTH(enc_size_code) |
+				F_I2S_ENC_WL_SIZE(i2s_size_code) | F_CNTL_SMPL_ONLY_EN(1) |
+				F_CNTL_TYPE_OVRD(0x0) | F_CNTL_TYPE_OVRD_EN(0) |
+				F_I2S_ENC_PORT_EN((1 << i2s_ports_num) - 1) | F_WS_POLARITY(0),
+				hdmirx, AUDIO_SINK_CNFG);
+
+	/* Waiting for N value... */
+	do {
+		regread = cdns_hdmirx_bus_read(hdmirx, AIF_ACR_N_ST);
+		times++;
+		udelay(10);
+	} while (!(regread) && times < 100);
+
+	if (times == 100)
+		return -1;
+
+	/* Enable ACR */
+	cdns_hdmirx_bus_write(F_ACR_SW_RESET(0), hdmirx, ACR_CFG);
+
+	/* Important:
+	 * Write to AIF_ACR_N_OFST_CFG register is interpreted as new N_CTS value.
+	 * The ACR has to be enabled (reset released) to register that event.
+	 */
+	cdns_hdmirx_bus_write(F_ACR_N_OFFSET(regread * (num_of_pairs_of_channels_per_port - 1)),
+				hdmirx, AIF_ACR_N_OFST_CFG);
+
+	/* Enable sample decoder */
+	cdns_hdmirx_bus_write(F_PKT2SMPL_EN(1), hdmirx, PKT2SMPL_CNTL);
+
+	/* Enable I2S encoder */
+	cdns_hdmirx_bus_write(F_I2S_ENC_START(1), hdmirx, AUDIO_SINK_CNTL);
+
+	return 0;
+}
+
+/* common API function HDMI TX && RX */
+void cdns_hdmirx_set_clock(struct cdns_hdmirx_device *hdmirx, int clk)
+{
+	cdns_hdmirx_bus_write(clk, hdmirx, SW_CLK_H);
+}
+
+int cdns_hdmirx_maincontrol(struct cdns_hdmirx_device *hdmirx, u8 mode)
+{
+	u8 status;
+	int ret;
+
+	ret = cdns_hdmirx_mailbox_send(hdmirx, MB_MODULE_ID_GENERAL,
+				GENERAL_MAIN_CONTROL, sizeof(mode), &mode);
+	if (ret)
+		goto err_main_ctrl;
+
+	ret = cdns_hdmirx_mailbox_validate_receive(hdmirx, MB_MODULE_ID_GENERAL,
+							GENERAL_MAIN_CONTROL, sizeof(status));
+	if (ret)
+		goto err_main_ctrl;
+
+	ret = cdns_hdmirx_mailbox_read_receive(hdmirx, &status, sizeof(status));
+	if (ret)
+		goto err_main_ctrl;
+
+	return status;
+
+err_main_ctrl:
+	dev_err(&hdmirx->pdev->dev, "hdmirx set mode failed: %d\n", ret);
+	return ret;
+}
+
+int cdns_hdmirx_general_assertphyreset(struct cdns_hdmirx_device *hdmirx)
+{
+	return cdns_hdmirx_mailbox_send(hdmirx, MB_MODULE_ID_GENERAL,
+				GENERAL_ASSERT_PHY_BUS_RESET, 0, NULL);
+}
+
+int cdns_hdmirx_general_deassertphyreset(struct cdns_hdmirx_device *hdmirx)
+{
+	return cdns_hdmirx_mailbox_send(hdmirx, MB_MODULE_ID_GENERAL,
+				GENERAL_DEASSERT_PHY_BUS_RESET, 0, NULL);
+}
+
+int cdns_hdmirx_general_loadhdcprx(struct cdns_hdmirx_device *hdmirx)
+{
+	return cdns_hdmirx_mailbox_send(hdmirx, MB_MODULE_ID_GENERAL,
+			GENERAL_LOAD_HDCP_RX, 0, NULL);
+}
+
+int cdns_hdmirx_general_unloadhdcprx(struct cdns_hdmirx_device *hdmirx)
+{
+	return cdns_hdmirx_mailbox_send(hdmirx, MB_MODULE_ID_GENERAL,
+			GENERAL_UNLOAD_HDCP_RX, 0, NULL);
+}
+
+int cdns_hdmirx_read_hpd(struct cdns_hdmirx_device *hdmirx)
+{
+	u8 status;
+	int ret;
+
+	ret = cdns_hdmirx_mailbox_send(hdmirx, MB_MODULE_ID_GENERAL, GENERAL_GET_HPD_STATE,
+				  0, NULL);
+	if (ret)
+		goto err_get_hpd;
+
+	ret = cdns_hdmirx_mailbox_validate_receive(hdmirx, MB_MODULE_ID_GENERAL,
+							GENERAL_GET_HPD_STATE, sizeof(status));
+	if (ret)
+		goto err_get_hpd;
+
+	ret = cdns_hdmirx_mailbox_read_receive(hdmirx, &status, sizeof(status));
+	if (ret)
+		goto err_get_hpd;
+
+	return status;
+
+err_get_hpd:
+	DRM_ERROR("read hpd  failed: %d\n", ret);
+	return ret;
+}
diff --git a/drivers/staging/media/imx/hdmirx/cdns-mhdp-hdmirx.h b/drivers/staging/media/imx/hdmirx/cdns-mhdp-hdmirx.h
new file mode 100644
index 000000000..d8b00dd4e
--- /dev/null
+++ b/drivers/staging/media/imx/hdmirx/cdns-mhdp-hdmirx.h
@@ -0,0 +1,436 @@
+/*
+ * Copyright 2020 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef _CDNS_MHDP_HDMIRX_
+#define _CDNS_MHDP_HDMIRX_
+
+#include <linux/module.h>
+#include <linux/mutex.h>
+
+#include <linux/clk.h>
+#include <linux/kthread.h>
+#include <linux/of.h>
+#include <linux/of_graph.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-dv-timings.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-subdev.h>
+#include <drm/drm_of.h>
+#include <drm/drm_print.h>
+
+#include <uapi/linux/v4l2-dv-timings.h>
+#include <drm/bridge/cdns-mhdp.h>
+#include "../imx8-common.h"
+
+#define HDMIRX_DRIVER_NAME        "mxc-hdmi-rx"
+#define HDMIRX_SUBDEV_NAME        HDMIRX_DRIVER_NAME
+
+/* HDMIRX Subsystem CSR */
+#define CSR_PIXEL_LINK_ENC_CTL		0x00
+#define PL_ENC_CTL_PXL_VAL          15
+#define PL_ENC_CTL_PXL_VPP          14
+#define PL_ENC_CTL_PXL_HPP          13
+#define PL_ENC_CTL_PXL_VCP          12
+#define PL_ENC_CTL_PXL_HCP          11
+#define PL_ENC_CTL_PXL_ADD          9
+#define PL_ENC_CTL_PXL_EXT          7
+#define PL_ENC_CTL_PXL_EN           6
+#define PL_ENC_CTL_PXL_ITC          4
+#define PL_ENC_CTL_PXL_ODD_EVEN     3
+#define PL_ENC_CTL_PXL_TYP          1
+#define PL_ENC_CTL_PXL_YUV          0
+
+#define CSR_HDP_RX_CTRL_CTRL0		0x04
+#define CSR_HDP_RX_CTRL_CTRL1		0x08
+
+/* Module ID Code */
+#define MB_MODULE_ID_HDMI_RX        0x04
+#define MB_MODULE_ID_HDCP_RX        0x08
+#define MB_MODULE_ID_HDCP_GENERAL	0x09
+
+/* HDMI RX opcode */
+#define HDMI_RX_SET_EDID			0x00
+#define HDMI_RX_SCDC_SET			0x01
+#define HDMI_RX_SCDC_GET			0x02
+#define HDMI_RX_SET_HPD				0x04
+
+#define HDMI_RX_READ_EVENTS			0x03
+#define HDMI_RX_DEBUG_ECHO			0xAA
+#define HDMI_RX_TEST				0xBB
+
+/* HDCP RX opcode */
+#define HDCP_RX_SET_CONFIG			0x04
+#define HDCP_RX_GET_STATUS			0x05
+#define HDCP_RX_NOT_SYNC			0x06
+
+/* Sink VIF */
+#define VIDEO_UNPACK_CTRL			0x1804
+#define F_CD_ENABLE(x) (((x) & ((1 << 1) - 1)) << 1)
+
+#define VANLYZ_CTRL					0x1810
+#define F_VANLYZ_START(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_VANLYZ_RESET(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_VANLYZ_FRAMES_CHECK_EN(x) (((x) & ((1 << 1) - 1)) << 2)
+#define F_VANLYZ_FORMAT_FINDER_EN(x) (((x) & ((1 << 1) - 1)) << 3)
+
+/* Sink_CAR */
+#define ADDR_SINK_CAR 0x00900
+#define SINK_MHL_HD_CAR 0x00900
+#define SINK_CEC_CAR 0x00904
+#define F_SINK_CEC_SYS_CLK_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_SINK_CEC_SYS_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 1)
+
+/* Sink MHL HD_Comp */
+#define ADDR_SINK_MHL_HD 0x01000
+#define TMDS_DEC_CTRL 0x1004
+#define F_DECODER_ERR_CORR_EN(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_TMDS_DECODER_SW_RST(x) (((x) & ((1 << 1) - 1)) << 1)
+
+#define TMDS_DEC_ST 0x1008
+
+#define TMDS_CH0_ERR_CNT 0x100c
+
+#define TMDS_CH1_ERR_CNT 0x1010
+
+#define TMDS_CH2_ERR_CNT 0x1014
+
+#define PKT_ERR_CNT_HEADER 0x1034
+
+#define PKT_ERR_CNT_01 0x1038
+
+#define PKT_ERR_CNT_23 0x103c
+
+#define TMDS_SCR_CTRL 0x1040
+#define F_SCRAMBLER_MODE(x) (((x) & ((1 << 1) - 1)) << 0)
+
+#define TMDS_SCR_CNT_INT_CTRL 0x1044
+#define F_SCRAMBLER_SSCP_LINE_DET_THR(x) (((x) & ((1 << 8) - 1)) << 0)
+#define F_SCRAMBLER_CTRL_LINE_DET_THR(x) (((x) & ((1 << 24) - 1)) << 8)
+
+#define TMDS_SCR_VALID_CTRL 0x1048
+#define F_SCRAMBLER_SSCP_LINE_VALID_THR(x) (((x) & ((1 << 8) - 1)) << 0)
+#define F_SCRAMBLER_CTRL_LINE_VALID_THR(x) (((x) & ((1 << 24) - 1)) << 8)
+
+#define PKT_AVI_DATA_LOW 0x10A4
+#define PKT_AVI_DATA_HIGH 0x10A8
+
+/* HDMIRX Audio */
+#define ADDR_AIF_ENCODER 0x30000
+#define PKT2SMPL_CNTL 0x30000
+#define F_PKT2SMPL_EN(x) (((x) & ((1 << 1) - 1)) << 1)
+
+/* register ACR_CFG */
+#define ACR_CFG 0x30004
+#define F_ACR_SW_RESET(x) (((x) & ((1 << 1) - 1)) << 5)
+
+/* register AIF_ACR_N_ST */
+#define AIF_ACR_N_ST 0x30028
+
+/* register AIF_ACR_N_OFST_CFG */
+#define AIF_ACR_N_OFST_CFG 0x30030
+#define F_ACR_N_OFFSET(x) (((x) & ((1 << 24) - 1)) << 0)
+
+/* register AUDIO_SINK_CNTL */
+#define AUDIO_SINK_CNTL 0x30100
+#define F_I2S_ENC_START(x) (((x) & ((1 << 1) - 1)) << 1)
+
+/* register AUDIO_SINK_CNFG */
+#define AUDIO_SINK_CNFG 0x30108
+#define F_ENC_LOW_INDEX_MSB(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_SINK_AUDIO_CH_NUM(x) (((x) & ((1 << 5) - 1)) << 1)
+#define F_ENC_SAMPLE_JUST(x) (((x) & ((1 << 2) - 1)) << 6)
+#define F_ENC_SMPL_WIDTH(x) (((x) & ((1 << 2) - 1)) << 8)
+#define F_I2S_ENC_WL_SIZE(x) (((x) & ((1 << 2) - 1)) << 10)
+#define F_CNTL_SMPL_ONLY_EN(x) (((x) & ((1 << 1) - 1)) << 12)
+#define F_CNTL_TYPE_OVRD(x) (((x) & ((1 << 4) - 1)) << 17)
+#define F_CNTL_TYPE_OVRD_EN(x) (((x) & ((1 << 1) - 1)) << 21)
+#define F_I2S_ENC_PORT_EN(x) (((x) & ((1 << 4) - 1)) << 22)
+#define F_WS_POLARITY(x) (((x) & ((1 << 1) - 1)) << 26)
+
+/* register FIFO_CNTL_ADDR */
+#define FIFO_CNTL_ADDR 0x3010C
+#define F_CFG_FIFO_SW_RST(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_CFG_INDEX_SYNC_EN(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_CFG_FIFO_DIR(x) (((x) & ((1 << 1) - 1)) << 2)
+#define F_CFG_DIS_PORT3(x) (((x) & ((1 << 1) - 1)) << 3)
+
+/* HDMI Sink PIF */
+#define ADDR_SINK_PIF 0x30800
+
+#define PKT_INFO_TYPE_CFG1 0x30800
+#define F_INFO_TYPE1(x) (((x) & ((1 << 8) - 1)) << 0)
+#define F_INFO_TYPE2(x) (((x) & ((1 << 8) - 1)) << 8)
+
+#define PKT_INFO_CTRL 0x30810
+#define F_PACKET_RDN_WR(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_PACKET_NUM(x) (((x) & ((1 << 4) - 1)) << 1)
+
+#define PKT_INFO_HEADER 0x3081c
+#define PKT_INT_STATUS 0x3083c
+#define PKT_INT_MASK 0x30840
+#define PKT_TRANS_CTRL 0x30844
+
+/* From HDCP standard */
+#define HDCP_RRX_SIZE 8
+#define HDCP_KSV_SIZE 5
+#define HDCP_NUM_DEVICE_KEY_SIZE 7
+#define HDCP_NUM_OF_DEVICE_KEYS 40
+
+#define HDCPRX_NUM_LONG_DELAYS 5
+#define HDCPRX_DEBUG_NUM_ERRORS 5
+
+#define HDCPRX_ERR_NONE 0
+#define HDCPRX_ERR_5V 1
+#define HDCPRX_ERR_DDC 2
+#define HDCPRX_ERR_SYNC 3
+
+#define HDCPRX_VERSION_2 0x0
+#define HDCPRX_VERSION_1 0x1
+#define HDCPRX_VERSION_BOTH 0x2
+
+#define ktime_timeout_ms(ms_) ktime_add(ktime_get(), ms_to_ktime(ms_))
+
+/**
+ * HDCP config.
+ *
+ * @field activate [in] Activate HDCP module.
+ * @field version [in] Supported HDCP versions.
+ *      0 - HDCP 2.2 only.
+ *      1 - HDCP 1.3/1.4 only.
+ *      2 - HDCP 1.3/1.4 and 2.2.
+ *      3 - reserved
+ * @field repeater [in] Set for HDCP Repeater.
+ * @field use_secondary_link [in] Set to use the Secondary Link.
+ * @field use_km_key [in] Set to enable km-key encryption.
+ * @field bcaps [in] Bcaps value. HDCP 1.3/1.4 only.
+ * @field bstatus [in] Bstatus value. HDCP 1.3/1.4 only.
+ */
+struct hdcprx_config {
+	u8 activate : 1;
+	u8 version : 2;
+	u8 repeater : 1;
+	u8 use_secondary_link : 1;
+	u8 use_km_key : 1;
+	u8 bcaps; // for HDCP 1.4
+	u16 bstatus; // for HDCP 1.4
+};
+
+enum clk_ratio_t{
+	CLK_RATIO_1_1,
+	CLK_RATIO_5_4,
+	CLK_RATIO_3_2,
+	CLK_RATIO_2_1,
+	CLK_RATIO_1_2,
+	CLK_RATIO_5_8,
+	CLK_RATIO_3_4
+};
+
+enum {
+	PIXEL_ENCODING_RGB    = 0,
+	PIXEL_ENCODING_YUV422 = 1,
+	PIXEL_ENCODING_YUV444 = 2,
+	PIXEL_ENCODING_YUV420 = 3,
+};
+
+/**
+ * HDCP Receiver Status.
+ *
+ * @field key_arrived [out] TODO: what key?
+ * @field hdcp_ver [out] HDCP version.
+ *      0 - no HDCP
+ *      1 - HDCP 1.3/1.4
+ *      2 - HDCP 2.2
+ *      3 - not valid / reserved
+ * @field error [out] Last error code.
+ * @field aksv [out] Aksv value sent by HDCP Source (HDCP 1.3/1.4 only).
+ * @field ainfo [out] Ainfo value sent by HDCP Source (HDCP 1.3/1.4 only).
+ */
+struct hdcprx_status {
+	u8 flags;
+	u8 aksv[HDCP_KSV_SIZE];
+	u8 ainfo;
+} ;
+
+
+struct cdns_hdmirx_dev_video_standards {
+	struct v4l2_dv_timings timings;
+	u8 vic;
+	u8 hdmi_vic;
+	u8 fps;
+};
+
+struct S_HDMI_SCDC_SET_MSG{
+	u8 sink_ver;
+	u8 manufacturer_oui_1;
+	u8 manufacturer_oui_2;
+	u8 manufacturer_oui_3;
+	u8 devId[8];
+	u8 hardware_major_rev;
+	u8 hardware_minor_rev;
+	u8 software_major_rev;
+	u8 software_minor_rev;
+	u8 manufacturerSpecific[34];
+};
+
+struct S_HDMI_SCDC_GET_MSG {
+	u8 source_ver;
+	u8 TMDS_Config;
+	u8 config_0;
+	u8 manufacturerSpecific[34];
+};
+
+struct hdmirx_edid_set_msg {
+	u8 segment;
+	u8 extension;
+	u8 edid[128];
+};
+
+enum hdp_rx_irq {
+	HPD5V_IRQ_IN,
+	HPD5V_IRQ_OUT,
+	HPD5V_IRQ_NUM,
+};
+
+struct cdns_hdmirx_device {
+	struct v4l2_subdev sd;
+	struct mutex			lock;
+	wait_queue_head_t		irq_queue;
+	struct media_pad pads[MXC_HDMI_RX_PADS_NUM];
+
+	struct platform_device		*pdev;
+	struct v4l2_device			*v4l2_dev;
+	struct v4l2_async_subdev asd;
+	struct v4l2_ctrl_handler ctrl_hdl;
+	struct v4l2_mbus_framefmt format;
+	struct v4l2_fract aspect_ratio;
+	struct {
+		u8 edid[512];
+		u32 present;
+		u32 blocks;
+	} edid;
+
+	struct clk		*ref_clk;
+	struct clk		*pxl_clk;
+	struct clk		*i2s_clk;
+	struct clk		*spdif_clk;
+	struct clk		*lpcg_sclk;
+	struct clk		*lpcg_pclk;
+	struct clk		*lpcg_enc_clk;
+	struct clk		*lpcg_pxl_link_clk;
+	void __iomem		*regs_base;
+	void __iomem		*regs_sec;
+
+	u32 flags;
+    struct S_HDMI_SCDC_GET_MSG          scdcData;
+	int bus_type;
+
+	struct cdns_hdmirx_dev_video_standards *timings;
+    u8 vic_code;
+	u8 hdmi_vic;
+    u8 pixel_encoding;
+	u8 color_depth;
+	bool cable_plugin;
+
+	u8 is_cec;
+	bool cec_running;
+	struct cdns_mhdp_cec  cec;
+	u32 sample_rate;
+	u32 sample_width;
+	u32 channels;
+
+	int irq[HPD5V_IRQ_NUM];
+	struct delayed_work hpd5v_work;
+	int tmds_clk;
+	struct task_struct *tmdsmon_th;
+	int tmdsmon_state;
+	u32 last_avi;
+	u8 avi[13];
+	u8 vnd[10];
+	bool allow_hdcp;
+	bool hdcp_fw_loaded;
+	bool initialized;
+	struct mutex pif_mutex;
+	struct mutex iolock;
+
+	u8 last_5v_state;
+	u8 rescal_val;
+	u8 slicer_tune_val;
+	u8 running;
+
+	const struct firmware *fw;
+	const char *firmware_name;
+};
+
+enum hdmirx_power_state {
+	HDMIRX_PM_SUSPENDED = 0x01,
+	HDMIRX_PM_POWERED = 0x02,
+	HDMIRX_RUNTIME_SUSPEND = 0x04,
+};
+
+int cdns_hdmirx_mailbox_send(struct cdns_hdmirx_device *hdmirx, u8 module_id,
+				  u8 opcode, u16 size, u8 *message);
+int cdns_hdmirx_mailbox_validate_receive(struct cdns_hdmirx_device *hdmirx,
+					      u8 module_id, u8 opcode, u16 req_size);
+int cdns_hdmirx_mailbox_read_receive(struct cdns_hdmirx_device *hdmirx,
+					  u8 *buff, u16 buff_size);
+void cdns_hdmirx_bus_write(u32 val, struct cdns_hdmirx_device *hdmirx, u32 offset);
+u32 cdns_hdmirx_bus_read(struct cdns_hdmirx_device *hdmirx, u32 offset);
+int cdns_hdmirx_reg_read(struct cdns_hdmirx_device *hdmirx, u32 addr);
+int cdns_hdmirx_reg_write(struct cdns_hdmirx_device *hdmirx, u32 addr, u32 val);
+int cdns_hdmirx_read_hpd(struct cdns_hdmirx_device *hdmirx);
+int cdns_hdmirx_sethpd(struct cdns_hdmirx_device *hdmirx, u8 hpd);
+void cdns_hdmirx_hotplug_trigger(struct cdns_hdmirx_device *hdmirx);
+void cdns_hdmirx_set_clock(struct cdns_hdmirx_device *hdmirx, int clk);
+bool cdns_hdmirx_check_alive(struct cdns_hdmirx_device *hdmirx);
+int cdns_hdmirx_maincontrol(struct cdns_hdmirx_device *hdmirx, u8 mode);
+int cdns_hdmirx_readevent(struct cdns_hdmirx_device *hdmirx, u8 *events_5v);
+int cdns_hdmirx_set_edid(struct cdns_hdmirx_device *hdmirx,
+						u8 segment,	u8 extension, u8 *edid);
+int cdns_hdmirx_wait_edid_read(struct cdns_hdmirx_device *hdmirx);
+int cdns_hdmirx_set_scdc_slave(struct cdns_hdmirx_device *hdmirx,
+							struct S_HDMI_SCDC_SET_MSG *scdcdata);
+int cdns_hdmirx_get_scdc_slave(struct cdns_hdmirx_device *hdmirx,
+					     struct S_HDMI_SCDC_GET_MSG *scdcdata);
+int cdns_hdmirx_general_loadhdcprx(struct cdns_hdmirx_device *hdmirx);
+int cdns_hdmirx_general_unloadhdcprx(struct cdns_hdmirx_device *hdmirx);
+int cdns_hdmirx_general_assertphyreset(struct cdns_hdmirx_device *hdmirx);
+int cdns_hdmirx_general_deassertphyreset(struct cdns_hdmirx_device *hdmirx);
+
+int cdns_hdmirx_phyinit(struct cdns_hdmirx_device *hdmirx);
+int cdns_hdmirx_startup(struct cdns_hdmirx_device *hdmirx);
+int cdns_hdmirx_init(struct cdns_hdmirx_device *hdmirx);
+int cdns_hdmirx_get_stable_tmds(struct cdns_hdmirx_device *hdmirx);
+int cdns_hdmirx_frame_timing(struct cdns_hdmirx_device *hdmirx);
+void imx8qm_hdmi_phy_reset(struct cdns_hdmirx_device *hdmirx, u8 reset);
+int cdns_hdmirx_get_avi_infoframe(struct cdns_hdmirx_device *hdmirx, u16 timeout_ms);
+int cdns_hdmirx_get_vendor_infoframe(struct cdns_hdmirx_device *hdmirx, u16 timeout_ms);
+int infoframe_poll(struct cdns_hdmirx_device *hdmirx, u8 type, u8 *buf, u16 timeout_ms);
+
+/* HDMIRX HDCP  */
+int cdns_hdcprx_reauth_req_wait(struct cdns_hdmirx_device *hdmirx, u16 timeout_ms);
+int cdns_hdcprx_get_status(struct cdns_hdmirx_device *hdmirx,
+			   struct hdcprx_status *status);
+void cdns_hdcprx_enable(struct cdns_hdmirx_device *hdmirx);
+void cdns_hdcprx_disable(struct cdns_hdmirx_device *hdmirx);
+int cdns_hdcprx_wait_auth_complete(struct cdns_hdmirx_device *hdmirx, u16 timeout_ms);
+
+/* HDMIRX Audio */
+int cdns_hdmirx_audioautoconfig(
+						struct cdns_hdmirx_device *hdmirx,
+						u8 max_ch_num,
+						u8 i2s_ports_num,
+						u8 dis_port3,
+						u8 enc_sample_width,
+						u8 i2s_sample_width);
+void cdns_hdmirx_register_audio_driver(struct device *dev);
+#endif
diff --git a/drivers/staging/media/imx/imx7-mipi-csis.c b/drivers/staging/media/imx/imx7-mipi-csis.c
index d35e52374..41e33535d 100644
--- a/drivers/staging/media/imx/imx7-mipi-csis.c
+++ b/drivers/staging/media/imx/imx7-mipi-csis.c
@@ -32,6 +32,7 @@
 #include <media/v4l2-subdev.h>
 
 #define CSIS_DRIVER_NAME			"imx7-mipi-csis"
+#define CSIS_SUBDEV_NAME			CSIS_DRIVER_NAME
 
 #define CSIS_PAD_SINK				0
 #define CSIS_PAD_SOURCE				1
@@ -310,6 +311,7 @@ struct csi_state {
 	struct reset_control *mrst;
 	struct regulator *mipi_phy_regulator;
 	const struct mipi_csis_info *info;
+	u8 index;
 
 	struct v4l2_subdev sd;
 	struct media_pad pads[CSIS_PADS_NUM];
@@ -1301,8 +1303,8 @@ static int mipi_csis_subdev_init(struct csi_state *state)
 
 	v4l2_subdev_init(sd, &mipi_csis_subdev_ops);
 	sd->owner = THIS_MODULE;
-	snprintf(sd->name, sizeof(sd->name), "csis-%s",
-		 dev_name(state->dev));
+	snprintf(sd->name, sizeof(sd->name), "%s.%d",
+		 CSIS_SUBDEV_NAME, state->index);
 
 	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
 	sd->ctrl_handler = NULL;
diff --git a/drivers/staging/media/imx/imx8-common.h b/drivers/staging/media/imx/imx8-common.h
new file mode 100644
index 000000000..3160fc87b
--- /dev/null
+++ b/drivers/staging/media/imx/imx8-common.h
@@ -0,0 +1,108 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * V4L2 Capture ISI subdev for i.MX8QXP/QM platform
+ *
+ * ISI is a Image Sensor Interface of i.MX8QXP/QM platform, which
+ * used to process image from camera sensor to memory or DC
+ *
+ * Copyright 2019-2021 NXP
+ *
+ */
+
+#ifndef __MXC_COMMON_H__
+#define __MXC_COMMON_H__
+
+#define ISI_OF_NODE_NAME	"isi"
+#define MIPI_CSI2_OF_NODE_NAME  "csi"
+#define PARALLEL_OF_NODE_NAME   "pcsi"
+#define HDMI_RX_OF_NODE_NAME	"hdmi_rx"
+
+#define MXC_ISI_MAX_DEVS	8
+#define MXC_MIPI_CSI2_MAX_DEVS	2
+#define MXC_MAX_SENSORS		3
+
+/* ISI PADS */
+#define MXC_ISI_SD_PAD_SINK_MIPI0_VC0		0
+#define MXC_ISI_SD_PAD_SINK_MIPI0_VC1		1
+#define MXC_ISI_SD_PAD_SINK_MIPI0_VC2		2
+#define MXC_ISI_SD_PAD_SINK_MIPI0_VC3		3
+#define MXC_ISI_SD_PAD_SINK_MIPI1_VC0		4
+#define MXC_ISI_SD_PAD_SINK_MIPI1_VC1		5
+#define MXC_ISI_SD_PAD_SINK_MIPI1_VC2		6
+#define MXC_ISI_SD_PAD_SINK_MIPI1_VC3		7
+
+#define MXC_ISI_SD_PAD_SINK_DC0			8
+#define MXC_ISI_SD_PAD_SINK_DC1			9
+#define MXC_ISI_SD_PAD_SINK_HDMI		10
+#define MXC_ISI_SD_PAD_SINK_MEM			11
+#define MXC_ISI_SD_PAD_SOURCE_MEM		12
+#define MXC_ISI_SD_PAD_SOURCE_DC0		13
+#define MXC_ISI_SD_PAD_SOURCE_DC1		14
+#define MXC_ISI_SD_PAD_SINK_PARALLEL_CSI	15
+#define MXC_ISI_SD_PADS_NUM			16
+
+/* MIPI CSI PADS */
+#define MXC_MIPI_CSI2_VC0_PAD_SINK		0
+#define MXC_MIPI_CSI2_VC1_PAD_SINK		1
+#define MXC_MIPI_CSI2_VC2_PAD_SINK		2
+#define MXC_MIPI_CSI2_VC3_PAD_SINK		3
+
+#define MXC_MIPI_CSI2_VC0_PAD_SOURCE		4
+#define MXC_MIPI_CSI2_VC1_PAD_SOURCE		5
+#define MXC_MIPI_CSI2_VC2_PAD_SOURCE		6
+#define MXC_MIPI_CSI2_VC3_PAD_SOURCE		7
+#define MXC_MIPI_CSI2_VCX_PADS_NUM		8
+
+/* Parallel CSI PADS */
+#define MXC_PARALLEL_CSI_PAD_SOURCE		0
+#define MXC_PARALLEL_CSI_PAD_SINK		1
+#define MXC_PARALLEL_CSI_PADS_NUM		2
+
+/* HDMI PADS */
+#define MXC_HDMI_RX_PAD_SINK		1
+#define MXC_HDMI_RX_PAD_SOURCE		2
+#define MXC_HDMI_RX_PADS_NUM		3
+
+#define ISI_2K		2048U
+#define ISI_4K		4096U
+#define ISI_8K		8192U
+#define ISI_MIN		32U
+
+enum {
+	IN_PORT,
+	SUB_IN_PORT,
+	OUT_PORT,
+	MAX_PORTS,
+};
+
+enum isi_input_interface {
+	ISI_INPUT_INTERFACE_DC0 = 0,
+	ISI_INPUT_INTERFACE_DC1,
+	ISI_INPUT_INTERFACE_MIPI0_CSI2,
+	ISI_INPUT_INTERFACE_MIPI1_CSI2,
+	ISI_INPUT_INTERFACE_HDMI,
+	ISI_INPUT_INTERFACE_MEM,
+	ISI_INPUT_INTERFACE_PARALLEL_CSI,
+	ISI_INPUT_INTERFACE_MAX,
+};
+
+enum isi_input_sub_interface {
+	ISI_INPUT_SUB_INTERFACE_VC0 = 0,
+	ISI_INPUT_SUB_INTERFACE_VC1,
+	ISI_INPUT_SUB_INTERFACE_VC2,
+	ISI_INPUT_SUB_INTERFACE_VC3,
+};
+
+enum isi_output_interface {
+	ISI_OUTPUT_INTERFACE_DC0 = 0,
+	ISI_OUTPUT_INTERFACE_DC1,
+	ISI_OUTPUT_INTERFACE_MEM,
+	ISI_OUTPUT_INTERFACE_MAX,
+};
+
+enum mxc_isi_buf_id {
+	MXC_ISI_BUF1 = 0x0,
+	MXC_ISI_BUF2,
+};
+
+#endif /* MXC_ISI_CORE_H_ */
diff --git a/drivers/staging/media/imx/imx8-isi-cap.c b/drivers/staging/media/imx/imx8-isi-cap.c
new file mode 100644
index 000000000..880f0023f
--- /dev/null
+++ b/drivers/staging/media/imx/imx8-isi-cap.c
@@ -0,0 +1,1868 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * V4L2 Capture ISI subdev driver for i.MX8QXP/QM platform
+ *
+ * ISI is a Image Sensor Interface of i.MX8QXP/QM platform, which
+ * used to process image from camera sensor to memory or DC
+ *
+ * Copyright 2019-2021 NXP
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/bug.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/pm_runtime.h>
+#include <linux/list.h>
+#include <linux/slab.h>
+#include <linux/of_graph.h>
+#include <linux/videodev2.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-mem2mem.h>
+#include <media/v4l2-event.h>
+#include <media/videobuf2-core.h>
+#include <media/videobuf2-dma-contig.h>
+
+#include "imx8-isi-hw.h"
+#include "imx8-common.h"
+#include "imx8-isi-fmt.h"
+
+#define sd_to_cap_dev(ptr)	container_of(ptr, struct mxc_isi_cap_dev, sd)
+static int mxc_isi_cap_streamoff(struct file *file, void *priv,
+				 enum v4l2_buf_type type);
+
+/*
+ * Pixel link input format
+ */
+struct mxc_isi_fmt mxc_isi_src_formats[] = {
+	{
+		.name		= "RGB32",
+		.fourcc		= V4L2_PIX_FMT_RGB32,
+		.depth		= { 32 },
+		.memplanes	= 1,
+		.colplanes	= 1,
+		.align		= 2,
+	}, {
+		.name		= "YUV32 (X-Y-U-V)",
+		.fourcc		= V4L2_PIX_FMT_YUV32,
+		.depth		= { 32 },
+		.memplanes	= 1,
+		.colplanes	= 1,
+		.align		= 2,
+	}
+};
+
+struct mxc_isi_fmt *mxc_isi_get_format(unsigned int index)
+{
+	return &mxc_isi_out_formats[index];
+}
+
+/*
+ * lookup mxc_isi color format by fourcc or media bus format
+ */
+struct mxc_isi_fmt *mxc_isi_find_format(const u32 *pixelformat,
+					const u32 *mbus_code, int index)
+{
+	struct mxc_isi_fmt *fmt, *def_fmt = NULL;
+	unsigned int i;
+	int id = 0;
+
+	if (index >= (int)mxc_isi_out_formats_size)
+		return NULL;
+
+	for (i = 0; i < mxc_isi_out_formats_size; i++) {
+		fmt = &mxc_isi_out_formats[i];
+		if (pixelformat && fmt->fourcc == *pixelformat)
+			return fmt;
+		if (mbus_code && fmt->mbus_code == *mbus_code)
+			return fmt;
+		if (index == id)
+			def_fmt = fmt;
+		id++;
+	}
+	return def_fmt;
+}
+
+struct mxc_isi_fmt *mxc_isi_get_src_fmt(struct v4l2_subdev_format *sd_fmt)
+{
+	u32 index;
+
+	/* two fmt RGB32 and YUV444 from pixellink */
+	if (sd_fmt->format.code == MEDIA_BUS_FMT_YUYV8_1X16 ||
+	    sd_fmt->format.code == MEDIA_BUS_FMT_YVYU8_2X8 ||
+	    sd_fmt->format.code == MEDIA_BUS_FMT_AYUV8_1X32 ||
+	    sd_fmt->format.code == MEDIA_BUS_FMT_UYVY8_2X8 ||
+	    sd_fmt->format.code == MEDIA_BUS_FMT_YUYV8_2X8)
+		index = 1;
+	else
+		index = 0;
+	return &mxc_isi_src_formats[index];
+}
+
+static inline struct mxc_isi_buffer *to_isi_buffer(struct vb2_v4l2_buffer *v4l2_buf)
+{
+	return container_of(v4l2_buf, struct mxc_isi_buffer, v4l2_buf);
+}
+
+/*
+ * mxc_isi_pipeline_enable() - Enable streaming on a pipeline
+ */
+static int mxc_isi_pipeline_enable(struct mxc_isi_cap_dev *isi_cap, bool enable)
+{
+	struct device *dev = &isi_cap->pdev->dev;
+	struct media_entity *entity = &isi_cap->vdev.entity;
+	struct media_device *mdev = entity->graph_obj.mdev;
+	struct media_graph graph;
+	struct v4l2_subdev *subdev;
+	int ret = 0;
+
+	mutex_lock(&mdev->graph_mutex);
+
+	ret = media_graph_walk_init(&graph, entity->graph_obj.mdev);
+	if (ret) {
+		mutex_unlock(&mdev->graph_mutex);
+		return ret;
+	}
+	media_graph_walk_start(&graph, entity);
+
+	while ((entity = media_graph_walk_next(&graph))) {
+		if (!entity) {
+			dev_dbg(dev, "entity is NULL\n");
+			continue;
+		}
+
+		if (!is_media_entity_v4l2_subdev(entity)) {
+			dev_dbg(dev, "%s is no v4l2 subdev\n", entity->name);
+			continue;
+		}
+
+		subdev = media_entity_to_v4l2_subdev(entity);
+		if (!subdev) {
+			dev_dbg(dev, "%s subdev is NULL\n", entity->name);
+			continue;
+		}
+
+		ret = v4l2_subdev_call(subdev, video, s_stream, enable);
+		if (ret < 0 && ret != -ENOIOCTLCMD) {
+			dev_err(dev, "subdev %s s_stream failed\n", subdev->name);
+			break;
+		}
+	}
+	mutex_unlock(&mdev->graph_mutex);
+	media_graph_walk_cleanup(&graph);
+
+	return ret;
+}
+
+static int mxc_isi_update_buf_paddr(struct mxc_isi_buffer *buf, int memplanes)
+{
+	struct frame_addr *paddr = &buf->paddr;
+	struct vb2_buffer *vb2 = &buf->v4l2_buf.vb2_buf;
+
+	paddr->cb = 0;
+	paddr->cr = 0;
+
+	switch (memplanes) {
+	case 3:
+		paddr->cr = vb2_dma_contig_plane_dma_addr(vb2, 2);
+		fallthrough;
+	case 2:
+		paddr->cb = vb2_dma_contig_plane_dma_addr(vb2, 1);
+		fallthrough;
+	case 1:
+		paddr->y = vb2_dma_contig_plane_dma_addr(vb2, 0);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+void mxc_isi_cap_frame_write_done(struct mxc_isi_dev *mxc_isi)
+{
+	struct mxc_isi_cap_dev *isi_cap = mxc_isi->isi_cap;
+	struct device *dev = &isi_cap->pdev->dev;
+	struct mxc_isi_buffer *buf;
+	struct vb2_buffer *vb2;
+
+	if (list_empty(&isi_cap->out_active)) {
+		dev_warn(dev, "trying to access empty active list\n");
+		return;
+	}
+
+	buf = list_first_entry(&isi_cap->out_active, struct mxc_isi_buffer, list);
+
+	/*
+	 * Skip frame when buffer number is not match ISI trigger
+	 * buffer
+	 */
+	if ((is_buf_active(mxc_isi, 1) && buf->id == MXC_ISI_BUF1) ||
+	    (is_buf_active(mxc_isi, 2) && buf->id == MXC_ISI_BUF2)) {
+		dev_dbg(dev, "status=0x%x id=%d\n", mxc_isi->status, buf->id);
+		return;
+	}
+
+	if (buf->discard) {
+		list_move_tail(isi_cap->out_active.next, &isi_cap->out_discard);
+	} else {
+		vb2 = &buf->v4l2_buf.vb2_buf;
+		list_del_init(&buf->list);
+		buf->v4l2_buf.vb2_buf.timestamp = ktime_get_ns();
+		vb2_buffer_done(&buf->v4l2_buf.vb2_buf, VB2_BUF_STATE_DONE);
+	}
+
+	isi_cap->frame_count++;
+
+	if (list_empty(&isi_cap->out_pending)) {
+		if (list_empty(&isi_cap->out_discard)) {
+			dev_warn(dev, "trying to access empty discard list\n");
+			return;
+		}
+
+		buf = list_first_entry(&isi_cap->out_discard,
+				       struct mxc_isi_buffer, list);
+		buf->v4l2_buf.sequence = isi_cap->frame_count;
+		mxc_isi_channel_set_outbuf(mxc_isi, buf);
+		list_move_tail(isi_cap->out_discard.next, &isi_cap->out_active);
+		return;
+	}
+
+	/* ISI channel output buffer */
+	buf = list_first_entry(&isi_cap->out_pending, struct mxc_isi_buffer, list);
+	buf->v4l2_buf.sequence = isi_cap->frame_count;
+	mxc_isi_channel_set_outbuf(mxc_isi, buf);
+	vb2 = &buf->v4l2_buf.vb2_buf;
+	vb2->state = VB2_BUF_STATE_ACTIVE;
+	list_move_tail(isi_cap->out_pending.next, &isi_cap->out_active);
+}
+EXPORT_SYMBOL_GPL(mxc_isi_cap_frame_write_done);
+
+static int cap_vb2_queue_setup(struct vb2_queue *q,
+			       unsigned int *num_buffers,
+			       unsigned int *num_planes,
+			       unsigned int sizes[],
+			       struct device *alloc_devs[])
+{
+	struct mxc_isi_cap_dev *isi_cap = vb2_get_drv_priv(q);
+	struct mxc_isi_frame *dst_f = &isi_cap->dst_f;
+	struct mxc_isi_fmt *fmt = dst_f->fmt;
+	unsigned long wh;
+	int i;
+
+	if (!fmt)
+		return -EINVAL;
+
+	if (*num_planes) {
+		if (*num_planes != fmt->memplanes)
+			return -EINVAL;
+
+		for (i = 0; i < *num_planes; i++)
+			if (sizes[i] < dst_f->sizeimage[i])
+				return -EINVAL;
+		return 0;
+	}
+
+	for (i = 0; i < fmt->memplanes; i++)
+		alloc_devs[i] = &isi_cap->pdev->dev;
+
+	wh = dst_f->width * dst_f->height;
+
+	*num_planes = fmt->memplanes;
+
+	for (i = 0; i < fmt->memplanes; i++) {
+		unsigned int size = (wh * fmt->depth[i]) / 8;
+
+		if (i == 1 && fmt->fourcc == V4L2_PIX_FMT_NV12)
+			size >>= 1;
+		sizes[i] = max_t(u32, size, dst_f->sizeimage[i]);
+	}
+	dev_dbg(&isi_cap->pdev->dev, "%s, buf_n=%d, size=%d\n",
+		__func__, *num_buffers, sizes[0]);
+
+	return 0;
+}
+
+static int cap_vb2_buffer_prepare(struct vb2_buffer *vb2)
+{
+	struct vb2_queue *q = vb2->vb2_queue;
+	struct mxc_isi_cap_dev *isi_cap = vb2_get_drv_priv(q);
+	struct mxc_isi_frame *dst_f = &isi_cap->dst_f;
+	int i;
+
+	dev_dbg(&isi_cap->pdev->dev, "%s\n", __func__);
+
+	if (!isi_cap->dst_f.fmt)
+		return -EINVAL;
+
+	for (i = 0; i < dst_f->fmt->memplanes; i++) {
+		unsigned long size = dst_f->sizeimage[i];
+
+		if (vb2_plane_size(vb2, i) < size) {
+			v4l2_err(&isi_cap->vdev,
+				 "User buffer too small (%ld < %ld)\n",
+				 vb2_plane_size(vb2, i), size);
+
+			return -EINVAL;
+		}
+
+		vb2_set_plane_payload(vb2, i, size);
+	}
+
+	return 0;
+}
+
+static void cap_vb2_buffer_queue(struct vb2_buffer *vb2)
+{
+	struct vb2_v4l2_buffer *v4l2_buf = to_vb2_v4l2_buffer(vb2);
+	struct mxc_isi_buffer *buf = to_isi_buffer(v4l2_buf);
+	struct mxc_isi_cap_dev *isi_cap = vb2_get_drv_priv(vb2->vb2_queue);
+	unsigned long flags;
+
+	spin_lock_irqsave(&isi_cap->slock, flags);
+
+	mxc_isi_update_buf_paddr(buf, isi_cap->dst_f.fmt->mdataplanes);
+	list_add_tail(&buf->list, &isi_cap->out_pending);
+	v4l2_buf->field = V4L2_FIELD_NONE;
+
+	spin_unlock_irqrestore(&isi_cap->slock, flags);
+}
+
+static int cap_vb2_start_streaming(struct vb2_queue *q, unsigned int count)
+{
+	struct mxc_isi_cap_dev *isi_cap = vb2_get_drv_priv(q);
+	struct mxc_isi_dev *mxc_isi = mxc_isi_get_hostdata(isi_cap->pdev);
+	struct mxc_isi_buffer *buf;
+	struct vb2_buffer *vb2;
+	unsigned long flags;
+	int i, j;
+	int ret;
+
+	dev_dbg(&isi_cap->pdev->dev, "%s\n", __func__);
+
+	if (count < 2) {
+		ret = -ENOBUFS;
+		goto err;
+	}
+
+	if (!mxc_isi) {
+		ret = -EINVAL;
+		goto err;
+	}
+
+	/* Create a buffer for discard operation */
+	for (i = 0; i < isi_cap->pix.num_planes; i++) {
+		isi_cap->discard_size[i] = isi_cap->dst_f.sizeimage[i];
+		isi_cap->discard_buffer[i] =
+			dma_alloc_coherent(&isi_cap->pdev->dev,
+					   PAGE_ALIGN(isi_cap->discard_size[i]),
+					   &isi_cap->discard_buffer_dma[i],
+					   GFP_DMA | GFP_KERNEL);
+		if (!isi_cap->discard_buffer[i]) {
+			for (j = 0; j < i; j++) {
+				dma_free_coherent(&isi_cap->pdev->dev,
+						  PAGE_ALIGN(isi_cap->discard_size[j]),
+						  isi_cap->discard_buffer[j],
+						  isi_cap->discard_buffer_dma[j]);
+				dev_err(&isi_cap->pdev->dev,
+					"alloc dma buffer(%d) fail\n", j);
+			}
+			ret = -ENOMEM;
+			goto err;
+		}
+		dev_dbg(&isi_cap->pdev->dev,
+			"%s: num_plane=%d discard_size=%d discard_buffer=%p\n"
+			, __func__, i,
+			PAGE_ALIGN((int)isi_cap->discard_size[i]),
+			isi_cap->discard_buffer[i]);
+	}
+
+	spin_lock_irqsave(&isi_cap->slock, flags);
+
+	/* add two list member to out_discard list head */
+	isi_cap->buf_discard[0].discard = true;
+	list_add_tail(&isi_cap->buf_discard[0].list, &isi_cap->out_discard);
+
+	isi_cap->buf_discard[1].discard = true;
+	list_add_tail(&isi_cap->buf_discard[1].list, &isi_cap->out_discard);
+
+	/* ISI channel output buffer 1 */
+	buf = list_first_entry(&isi_cap->out_discard, struct mxc_isi_buffer, list);
+	buf->v4l2_buf.sequence = 0;
+	vb2 = &buf->v4l2_buf.vb2_buf;
+	vb2->state = VB2_BUF_STATE_ACTIVE;
+	mxc_isi_channel_set_outbuf(mxc_isi, buf);
+	list_move_tail(isi_cap->out_discard.next, &isi_cap->out_active);
+
+	/* ISI channel output buffer 2 */
+	buf = list_first_entry(&isi_cap->out_pending, struct mxc_isi_buffer, list);
+	buf->v4l2_buf.sequence = 1;
+	vb2 = &buf->v4l2_buf.vb2_buf;
+	vb2->state = VB2_BUF_STATE_ACTIVE;
+	mxc_isi_channel_set_outbuf(mxc_isi, buf);
+	list_move_tail(isi_cap->out_pending.next, &isi_cap->out_active);
+
+	/* Clear frame count */
+	isi_cap->frame_count = 1;
+	spin_unlock_irqrestore(&isi_cap->slock, flags);
+
+	return 0;
+
+err:
+	spin_lock_irqsave(&isi_cap->slock, flags);
+	while (!list_empty(&isi_cap->out_active)) {
+		buf = list_entry(isi_cap->out_active.next,
+				 struct mxc_isi_buffer, list);
+		list_del_init(&buf->list);
+		if (buf->discard)
+			continue;
+
+		vb2_buffer_done(&buf->v4l2_buf.vb2_buf, VB2_BUF_STATE_ERROR);
+	}
+
+	while (!list_empty(&isi_cap->out_pending)) {
+		buf = list_entry(isi_cap->out_pending.next,
+				 struct mxc_isi_buffer, list);
+		list_del_init(&buf->list);
+		vb2_buffer_done(&buf->v4l2_buf.vb2_buf, VB2_BUF_STATE_ERROR);
+	}
+	spin_unlock_irqrestore(&isi_cap->slock, flags);
+
+	return ret;
+}
+
+static void cap_vb2_stop_streaming(struct vb2_queue *q)
+{
+	struct mxc_isi_cap_dev *isi_cap = vb2_get_drv_priv(q);
+	struct mxc_isi_dev *mxc_isi = mxc_isi_get_hostdata(isi_cap->pdev);
+	struct mxc_isi_buffer *buf;
+	unsigned long flags;
+	int i;
+
+	dev_dbg(&isi_cap->pdev->dev, "%s\n", __func__);
+
+	mxc_isi_channel_disable(mxc_isi);
+
+	spin_lock_irqsave(&isi_cap->slock, flags);
+
+	while (!list_empty(&isi_cap->out_active)) {
+		buf = list_entry(isi_cap->out_active.next,
+				 struct mxc_isi_buffer, list);
+		list_del_init(&buf->list);
+		if (buf->discard)
+			continue;
+
+		vb2_buffer_done(&buf->v4l2_buf.vb2_buf, VB2_BUF_STATE_ERROR);
+	}
+
+	while (!list_empty(&isi_cap->out_pending)) {
+		buf = list_entry(isi_cap->out_pending.next,
+				 struct mxc_isi_buffer, list);
+		list_del_init(&buf->list);
+		vb2_buffer_done(&buf->v4l2_buf.vb2_buf, VB2_BUF_STATE_ERROR);
+	}
+
+	while (!list_empty(&isi_cap->out_discard)) {
+		buf = list_entry(isi_cap->out_discard.next,
+				 struct mxc_isi_buffer, list);
+		list_del_init(&buf->list);
+	}
+
+	INIT_LIST_HEAD(&isi_cap->out_active);
+	INIT_LIST_HEAD(&isi_cap->out_pending);
+	INIT_LIST_HEAD(&isi_cap->out_discard);
+
+	spin_unlock_irqrestore(&isi_cap->slock, flags);
+
+	for (i = 0; i < isi_cap->pix.num_planes; i++)
+		dma_free_coherent(&isi_cap->pdev->dev,
+				  PAGE_ALIGN(isi_cap->discard_size[i]),
+				  isi_cap->discard_buffer[i],
+				  isi_cap->discard_buffer_dma[i]);
+}
+
+static struct vb2_ops mxc_cap_vb2_qops = {
+	.queue_setup		= cap_vb2_queue_setup,
+	.buf_prepare		= cap_vb2_buffer_prepare,
+	.buf_queue		= cap_vb2_buffer_queue,
+	.wait_prepare		= vb2_ops_wait_prepare,
+	.wait_finish		= vb2_ops_wait_finish,
+	.start_streaming	= cap_vb2_start_streaming,
+	.stop_streaming		= cap_vb2_stop_streaming,
+};
+
+/*
+ * V4L2 controls handling
+ */
+static inline struct mxc_isi_cap_dev *ctrl_to_isi_cap(struct v4l2_ctrl *ctrl)
+{
+	return container_of(ctrl->handler, struct mxc_isi_cap_dev, ctrls.handler);
+}
+
+static int mxc_isi_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct mxc_isi_cap_dev *isi_cap = ctrl_to_isi_cap(ctrl);
+	struct mxc_isi_dev *mxc_isi = mxc_isi_get_hostdata(isi_cap->pdev);
+	unsigned long flags;
+
+	dev_dbg(&isi_cap->pdev->dev, "%s\n", __func__);
+
+	if (ctrl->flags & V4L2_CTRL_FLAG_INACTIVE)
+		return 0;
+
+	spin_lock_irqsave(&mxc_isi->slock, flags);
+
+	switch (ctrl->id) {
+	case V4L2_CID_HFLIP:
+		if (ctrl->val < 0)
+			return -EINVAL;
+		mxc_isi->hflip = (ctrl->val > 0) ? 1 : 0;
+		break;
+
+	case V4L2_CID_VFLIP:
+		if (ctrl->val < 0)
+			return -EINVAL;
+		mxc_isi->vflip = (ctrl->val > 0) ? 1 : 0;
+		break;
+
+	case V4L2_CID_ALPHA_COMPONENT:
+		if (ctrl->val < 0 || ctrl->val > 255)
+			return -EINVAL;
+		mxc_isi->alpha = ctrl->val;
+		mxc_isi->alphaen = 1;
+		break;
+
+	default:
+		dev_err(&isi_cap->pdev->dev,
+			"%s: Not support %d CID\n", __func__, ctrl->id);
+		return -EINVAL;
+	}
+
+	spin_unlock_irqrestore(&mxc_isi->slock, flags);
+	return 0;
+}
+
+static const struct v4l2_ctrl_ops mxc_isi_ctrl_ops = {
+	.s_ctrl = mxc_isi_s_ctrl,
+};
+
+int mxc_isi_ctrls_create(struct mxc_isi_cap_dev *isi_cap)
+{
+	struct mxc_isi_ctrls *ctrls = &isi_cap->ctrls;
+	struct v4l2_ctrl_handler *handler = &ctrls->handler;
+
+	if (isi_cap->ctrls.ready)
+		return 0;
+
+	v4l2_ctrl_handler_init(handler, 4);
+
+	ctrls->hflip = v4l2_ctrl_new_std(handler, &mxc_isi_ctrl_ops,
+					 V4L2_CID_HFLIP, 0, 1, 1, 0);
+	ctrls->vflip = v4l2_ctrl_new_std(handler, &mxc_isi_ctrl_ops,
+					 V4L2_CID_VFLIP, 0, 1, 1, 0);
+	ctrls->alpha = v4l2_ctrl_new_std(handler, &mxc_isi_ctrl_ops,
+					 V4L2_CID_ALPHA_COMPONENT,
+					 0, 0xff, 1, 0);
+
+	if (!handler->error)
+		ctrls->ready = true;
+
+	return handler->error;
+}
+
+void mxc_isi_ctrls_delete(struct mxc_isi_cap_dev *isi_cap)
+{
+	struct mxc_isi_ctrls *ctrls = &isi_cap->ctrls;
+
+	if (ctrls->ready) {
+		v4l2_ctrl_handler_free(&ctrls->handler);
+		ctrls->ready = false;
+		ctrls->alpha = NULL;
+	}
+}
+
+static struct media_pad
+*mxc_isi_get_remote_source_pad(struct v4l2_subdev *subdev)
+{
+	struct media_pad *sink_pad, *source_pad;
+	int i;
+
+	while (1) {
+		source_pad = NULL;
+		for (i = 0; i < subdev->entity.num_pads; i++) {
+			sink_pad = &subdev->entity.pads[i];
+
+			if (sink_pad->flags & MEDIA_PAD_FL_SINK) {
+				source_pad = media_entity_remote_pad(sink_pad);
+				if (source_pad)
+					break;
+			}
+		}
+		/* return first pad point in the loop  */
+		return source_pad;
+	}
+
+	if (i == subdev->entity.num_pads)
+		v4l2_err(subdev, "(%d): No remote pad found!\n", __LINE__);
+
+	return NULL;
+}
+
+static struct v4l2_subdev *mxc_get_remote_subdev(struct v4l2_subdev *subdev,
+						 const char * const label)
+{
+	struct media_pad *source_pad;
+	struct v4l2_subdev *sen_sd;
+
+	/* Get remote source pad */
+	source_pad = mxc_isi_get_remote_source_pad(subdev);
+	if (!source_pad) {
+		v4l2_err(subdev, "%s, No remote pad found!\n", label);
+		return NULL;
+	}
+
+	/* Get remote source pad subdev */
+	sen_sd = media_entity_to_v4l2_subdev(source_pad->entity);
+	if (!sen_sd) {
+		v4l2_err(subdev, "%s, No remote subdev found!\n", label);
+		return NULL;
+	}
+
+	return sen_sd;
+}
+
+static bool is_entity_link_setup(struct mxc_isi_cap_dev *isi_cap)
+{
+	struct video_device *vdev = &isi_cap->vdev;
+	struct v4l2_subdev *csi_sd, *sen_sd;
+
+	if (!vdev->entity.num_links || !isi_cap->sd.entity.num_links)
+		return false;
+
+	csi_sd = mxc_get_remote_subdev(&isi_cap->sd, __func__);
+	if (!csi_sd || !csi_sd->entity.num_links)
+		return false;
+
+	/* No sensor subdev for hdmi rx */
+	if (strstr(csi_sd->name, "hdmi"))
+		return true;
+
+	sen_sd = mxc_get_remote_subdev(csi_sd, __func__);
+	if (!sen_sd || !sen_sd->entity.num_links)
+		return false;
+
+	return true;
+}
+
+static int isi_cap_fmt_init(struct mxc_isi_cap_dev *isi_cap)
+{
+	struct mxc_isi_frame *dst_f = &isi_cap->dst_f;
+	struct mxc_isi_frame *src_f = &isi_cap->src_f;
+	struct v4l2_subdev_format src_fmt;
+	struct v4l2_subdev *src_sd;
+	int i, ret;
+
+	src_sd = mxc_get_remote_subdev(&isi_cap->sd, __func__);
+	if (!src_sd) {
+		v4l2_err(&isi_cap->sd, "get remote subdev fail!\n");
+		return -EINVAL;
+	}
+
+	memset(&src_fmt, 0, sizeof(src_fmt));
+	src_fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+	ret = v4l2_subdev_call(src_sd, pad, get_fmt, NULL, &src_fmt);
+	if (ret < 0 && ret != -ENOIOCTLCMD) {
+		v4l2_err(&isi_cap->sd, "get remote fmt fail!\n");
+		return ret;
+	}
+
+	if (dst_f->width == 0 || dst_f->height == 0)
+		set_frame_bounds(dst_f, src_fmt.format.width, src_fmt.format.height);
+
+	if (!dst_f->fmt)
+		dst_f->fmt = &mxc_isi_out_formats[0];
+
+	for (i = 0; i < dst_f->fmt->memplanes; i++) {
+		if (dst_f->bytesperline[i] == 0)
+			dst_f->bytesperline[i] = dst_f->width * dst_f->fmt->depth[i] >> 3;
+		if (dst_f->sizeimage[i] == 0)
+			dst_f->sizeimage[i] = dst_f->bytesperline[i] * dst_f->height;
+	}
+
+	if (!src_f->fmt)
+		memcpy(src_f, dst_f, sizeof(*dst_f));
+	return 0;
+}
+
+
+static int mxc_isi_capture_open(struct file *file)
+{
+	struct mxc_isi_cap_dev *isi_cap = video_drvdata(file);
+	struct mxc_isi_dev *mxc_isi = mxc_isi_get_hostdata(isi_cap->pdev);
+	struct device *dev = &isi_cap->pdev->dev;
+	int ret = -EBUSY;
+
+	mutex_lock(&isi_cap->lock);
+	isi_cap->is_link_setup = is_entity_link_setup(isi_cap);
+	if (!isi_cap->is_link_setup) {
+		mutex_unlock(&isi_cap->lock);
+		return 0;
+	}
+	mutex_unlock(&isi_cap->lock);
+
+	if (mxc_isi->m2m_enabled) {
+		dev_err(dev, "ISI channel[%d] is busy\n", isi_cap->id);
+		return ret;
+	}
+
+	mutex_lock(&isi_cap->lock);
+	ret = v4l2_fh_open(file);
+	if (ret) {
+		mutex_unlock(&isi_cap->lock);
+		return ret;
+	}
+	mutex_unlock(&isi_cap->lock);
+
+	pm_runtime_get_sync(dev);
+
+	mutex_lock(&isi_cap->lock);
+	ret = isi_cap_fmt_init(isi_cap);
+	mutex_unlock(&isi_cap->lock);
+
+	/* increase usage count for ISI channel */
+	mutex_lock(&mxc_isi->lock);
+	atomic_inc(&mxc_isi->usage_count);
+	mxc_isi->cap_enabled = true;
+	mutex_unlock(&mxc_isi->lock);
+
+	return ret;
+}
+
+static int mxc_isi_capture_release(struct file *file)
+{
+	struct mxc_isi_cap_dev *isi_cap = video_drvdata(file);
+	struct video_device *vdev = video_devdata(file);
+	struct mxc_isi_dev *mxc_isi = mxc_isi_get_hostdata(isi_cap->pdev);
+	struct device *dev = &isi_cap->pdev->dev;
+	struct vb2_queue *q = vdev->queue;
+	int ret = -1;
+
+	if (!isi_cap->is_link_setup)
+		return 0;
+
+	if (isi_cap->is_streaming[isi_cap->id])
+		mxc_isi_cap_streamoff(file, NULL, q->type);
+
+	mutex_lock(&isi_cap->lock);
+	ret = _vb2_fop_release(file, NULL);
+	if (ret) {
+		dev_err(dev, "%s fail\n", __func__);
+		mutex_unlock(&isi_cap->lock);
+		goto label;
+	}
+	mutex_unlock(&isi_cap->lock);
+
+	if (atomic_read(&mxc_isi->usage_count) > 0 &&
+	    atomic_dec_and_test(&mxc_isi->usage_count))
+		mxc_isi_channel_deinit(mxc_isi);
+
+label:
+	mutex_lock(&mxc_isi->lock);
+	mxc_isi->cap_enabled = false;
+	mutex_unlock(&mxc_isi->lock);
+
+	pm_runtime_put(dev);
+	return (ret) ? ret : 0;
+}
+
+static const struct v4l2_file_operations mxc_isi_capture_fops = {
+	.owner		= THIS_MODULE,
+	.open		= mxc_isi_capture_open,
+	.release	= mxc_isi_capture_release,
+	.poll		= vb2_fop_poll,
+	.unlocked_ioctl	= video_ioctl2,
+	.mmap		= vb2_fop_mmap,
+};
+
+/*
+ * The video node ioctl operations
+ */
+static int mxc_isi_cap_querycap(struct file *file, void *priv,
+				struct v4l2_capability *cap)
+{
+	struct mxc_isi_cap_dev *isi_cap = video_drvdata(file);
+
+	strlcpy(cap->driver, MXC_ISI_CAPTURE, sizeof(cap->driver));
+	strlcpy(cap->card, MXC_ISI_CAPTURE, sizeof(cap->card));
+	snprintf(cap->bus_info, sizeof(cap->bus_info), "platform:%s.%d",
+		 dev_name(&isi_cap->pdev->dev), isi_cap->id);
+
+	cap->device_caps = V4L2_CAP_STREAMING | V4L2_CAP_VIDEO_CAPTURE_MPLANE;
+	cap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;
+
+	return 0;
+}
+
+static int mxc_isi_cap_enum_fmt(struct file *file, void *priv,
+				       struct v4l2_fmtdesc *f)
+{
+	struct mxc_isi_cap_dev *isi_cap = video_drvdata(file);
+	struct mxc_isi_fmt *fmt;
+
+	dev_dbg(&isi_cap->pdev->dev, "%s\n", __func__);
+	if (f->index >= (int)mxc_isi_out_formats_size)
+		return -EINVAL;
+
+	fmt = &mxc_isi_out_formats[f->index];
+
+	strncpy(f->description, fmt->name, sizeof(f->description) - 1);
+
+	f->pixelformat = fmt->fourcc;
+
+	return 0;
+}
+
+static int mxc_isi_cap_g_fmt_mplane(struct file *file, void *fh,
+				    struct v4l2_format *f)
+{
+	struct mxc_isi_cap_dev *isi_cap = video_drvdata(file);
+	struct v4l2_pix_format_mplane *pix = &f->fmt.pix_mp;
+	struct mxc_isi_frame *dst_f = &isi_cap->dst_f;
+	int i;
+
+	dev_dbg(&isi_cap->pdev->dev, "%s\n", __func__);
+
+	pix->width = dst_f->o_width;
+	pix->height = dst_f->o_height;
+	pix->field = V4L2_FIELD_NONE;
+	pix->pixelformat = dst_f->fmt->fourcc;
+	pix->colorspace = V4L2_COLORSPACE_SRGB;
+	pix->ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(pix->colorspace);
+	pix->quantization = V4L2_QUANTIZATION_FULL_RANGE;
+	pix->num_planes = dst_f->fmt->memplanes;
+
+	for (i = 0; i < pix->num_planes; ++i) {
+		pix->plane_fmt[i].bytesperline = dst_f->bytesperline[i];
+		pix->plane_fmt[i].sizeimage = dst_f->sizeimage[i];
+	}
+
+	return 0;
+}
+
+static int mxc_isi_cap_try_fmt_mplane(struct file *file, void *fh,
+				      struct v4l2_format *f)
+{
+	struct mxc_isi_cap_dev *isi_cap = video_drvdata(file);
+	struct v4l2_pix_format_mplane *pix = &f->fmt.pix_mp;
+	struct mxc_isi_fmt *fmt;
+	int bpl;
+	int i;
+
+	dev_dbg(&isi_cap->pdev->dev, "%s\n", __func__);
+
+	for (i = 0; i < mxc_isi_out_formats_size; i++) {
+		fmt = &mxc_isi_out_formats[i];
+		if (fmt->fourcc == pix->pixelformat)
+			break;
+	}
+
+	if (i >= mxc_isi_out_formats_size) {
+		fmt = &mxc_isi_out_formats[0];
+		v4l2_warn(&isi_cap->sd, "Not match format, set default\n");
+	}
+
+	/*
+	 * The bit width in CHNL_IMG_CFG[HEIGHT/WIDTH] is 13, so the maximum
+	 * theorical value for image width/height should be 8K, but due to ISI
+	 * line buffer size limitation, the maximum value is 4K
+	 *
+	 * For efficient data transmission, the minimum data width should be
+	 * 16(128/8)
+	 */
+	v4l_bound_align_image(&pix->width, 16, ISI_4K, fmt->align,
+			      &pix->height, 16, ISI_4K, 1, 0);
+
+	pix->num_planes = fmt->memplanes;
+	pix->pixelformat = fmt->fourcc;
+	pix->field = V4L2_FIELD_NONE;
+	pix->colorspace = V4L2_COLORSPACE_SRGB;
+	pix->ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(pix->colorspace);
+	pix->quantization = V4L2_QUANTIZATION_FULL_RANGE;
+	memset(pix->reserved, 0x00, sizeof(pix->reserved));
+
+	for (i = 0; i < pix->num_planes; i++) {
+		bpl = pix->plane_fmt[i].bytesperline;
+
+		if ((bpl == 0) || (bpl / (fmt->depth[i] >> 3)) < pix->width)
+			pix->plane_fmt[i].bytesperline =
+					(pix->width * fmt->depth[i]) >> 3;
+
+		if (pix->plane_fmt[i].sizeimage == 0) {
+			if ((i == 1) && (pix->pixelformat == V4L2_PIX_FMT_NV12))
+				pix->plane_fmt[i].sizeimage =
+				  (pix->width * (pix->height >> 1) * fmt->depth[i] >> 3);
+			else
+				pix->plane_fmt[i].sizeimage =
+					(pix->width * pix->height * fmt->depth[i] >> 3);
+		}
+	}
+
+	return 0;
+}
+
+/* Update input frame size and formate  */
+static int mxc_isi_source_fmt_init(struct mxc_isi_cap_dev *isi_cap)
+{
+	struct mxc_isi_frame *src_f = &isi_cap->src_f;
+	struct mxc_isi_frame *dst_f = &isi_cap->dst_f;
+	struct v4l2_subdev_format src_fmt;
+	struct media_pad *source_pad;
+	struct v4l2_subdev *src_sd;
+	int ret;
+
+	source_pad = mxc_isi_get_remote_source_pad(&isi_cap->sd);
+	if (!source_pad) {
+		v4l2_err(&isi_cap->sd,
+			 "%s, No remote pad found!\n", __func__);
+		return -EINVAL;
+	}
+
+	src_sd = mxc_get_remote_subdev(&isi_cap->sd, __func__);
+	if (!src_sd)
+		return -EINVAL;
+
+	src_fmt.pad = source_pad->index;
+	src_fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+	src_fmt.format.code = MEDIA_BUS_FMT_UYVY8_2X8;
+	src_fmt.format.width = dst_f->width;
+	src_fmt.format.height = dst_f->height;
+	ret = v4l2_subdev_call(src_sd, pad, set_fmt, NULL, &src_fmt);
+	if (ret < 0 && ret != -ENOIOCTLCMD) {
+		v4l2_err(&isi_cap->sd, "set remote fmt fail!\n");
+		return ret;
+	}
+
+	memset(&src_fmt, 0, sizeof(src_fmt));
+	src_fmt.pad = source_pad->index;
+	src_fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+	ret = v4l2_subdev_call(src_sd, pad, get_fmt, NULL, &src_fmt);
+	if (ret < 0 && ret != -ENOIOCTLCMD) {
+		v4l2_err(&isi_cap->sd, "get remote fmt fail!\n");
+		return ret;
+	}
+
+	/* Pixel link master will transfer format to RGB32 or YUV32 */
+	src_f->fmt = mxc_isi_get_src_fmt(&src_fmt);
+
+	set_frame_bounds(src_f, src_fmt.format.width, src_fmt.format.height);
+
+	if (dst_f->width > src_f->width || dst_f->height > src_f->height) {
+		dev_err(&isi_cap->pdev->dev,
+			"%s: src:(%d,%d), dst:(%d,%d) Not support upscale\n",
+			__func__,
+			src_f->width, src_f->height,
+			dst_f->width, dst_f->height);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int mxc_isi_cap_s_fmt_mplane(struct file *file, void *priv,
+				    struct v4l2_format *f)
+{
+	struct mxc_isi_cap_dev *isi_cap = video_drvdata(file);
+	struct v4l2_pix_format_mplane *pix = &f->fmt.pix_mp;
+	struct mxc_isi_frame *dst_f = &isi_cap->dst_f;
+	struct mxc_isi_fmt *fmt;
+	int bpl;
+	int i, ret;
+
+	/* Step1: Check format with output support format list.
+	 * Step2: Update output frame information.
+	 * Step3: Checkout the format whether is supported by remote subdev
+	 *	 Step3.1: If Yes, call remote subdev set_fmt.
+	 *	 Step3.2: If NO, call remote subdev get_fmt.
+	 * Step4: Update input frame information.
+	 * Step5: Update mxc isi channel configuration.
+	 */
+
+	dev_dbg(&isi_cap->pdev->dev, "%s, fmt=0x%X\n", __func__, pix->pixelformat);
+	if (vb2_is_busy(&isi_cap->vb2_q))
+		return -EBUSY;
+
+	for (i = 0; i < mxc_isi_out_formats_size; i++) {
+		fmt = &mxc_isi_out_formats[i];
+		if (fmt->fourcc == pix->pixelformat)
+			break;
+	}
+
+	if (i >= mxc_isi_out_formats_size) {
+		fmt = &mxc_isi_out_formats[0];
+		v4l2_warn(&isi_cap->sd, "Not match format, set default\n");
+	}
+
+	ret = mxc_isi_cap_try_fmt_mplane(file, priv, f);
+	if (ret)
+		return ret;
+
+	dst_f->fmt = fmt;
+	dst_f->height = pix->height;
+	dst_f->width = pix->width;
+
+	pix->num_planes = fmt->memplanes;
+
+	for (i = 0; i < pix->num_planes; i++) {
+		bpl = pix->plane_fmt[i].bytesperline;
+
+		if ((bpl == 0) || (bpl / (fmt->depth[i] >> 3)) < pix->width)
+			pix->plane_fmt[i].bytesperline =
+					(pix->width * fmt->depth[i]) >> 3;
+
+		if (pix->plane_fmt[i].sizeimage == 0) {
+			if ((i == 1) && (pix->pixelformat == V4L2_PIX_FMT_NV12))
+				pix->plane_fmt[i].sizeimage =
+				  (pix->width * (pix->height >> 1) * fmt->depth[i] >> 3);
+			else
+				pix->plane_fmt[i].sizeimage =
+					(pix->width * pix->height * fmt->depth[i] >> 3);
+		}
+	}
+
+	if (pix->num_planes > 1) {
+		for (i = 0; i < pix->num_planes; i++) {
+			dst_f->bytesperline[i] = pix->plane_fmt[i].bytesperline;
+			dst_f->sizeimage[i]    = pix->plane_fmt[i].sizeimage;
+		}
+	} else {
+		dst_f->bytesperline[0] = dst_f->width * dst_f->fmt->depth[0] / 8;
+		dst_f->sizeimage[0]    = dst_f->height * dst_f->bytesperline[0];
+	}
+
+	memcpy(&isi_cap->pix, pix, sizeof(*pix));
+	set_frame_bounds(dst_f, pix->width, pix->height);
+
+	return 0;
+}
+
+static int mxc_isi_config_parm(struct mxc_isi_cap_dev *isi_cap)
+{
+	struct mxc_isi_dev *mxc_isi = mxc_isi_get_hostdata(isi_cap->pdev);
+	int ret;
+
+	ret = mxc_isi_source_fmt_init(isi_cap);
+	if (ret < 0)
+		return -EINVAL;
+
+	mxc_isi_channel_init(mxc_isi);
+	mxc_isi_channel_config(mxc_isi, &isi_cap->src_f, &isi_cap->dst_f);
+
+	return 0;
+}
+
+static int mxc_isi_cap_g_parm(struct file *file, void *fh,
+			      struct v4l2_streamparm *a)
+{
+	struct mxc_isi_cap_dev *isi_cap = video_drvdata(file);
+	struct v4l2_subdev *sd;
+
+	sd = mxc_get_remote_subdev(&isi_cap->sd, __func__);
+	if (!sd)
+		return -ENODEV;
+
+	return v4l2_g_parm_cap(video_devdata(file), sd, a);
+}
+
+static int mxc_isi_cap_s_parm(struct file *file, void *fh,
+			      struct v4l2_streamparm *a)
+{
+	struct mxc_isi_cap_dev *isi_cap = video_drvdata(file);
+	struct v4l2_subdev *sd;
+
+	sd = mxc_get_remote_subdev(&isi_cap->sd, __func__);
+	if (!sd)
+		return -ENODEV;
+
+	return v4l2_s_parm_cap(video_devdata(file), sd, a);
+}
+
+
+static int mxc_isi_cap_streamon(struct file *file, void *priv,
+				enum v4l2_buf_type type)
+{
+	struct mxc_isi_cap_dev *isi_cap = video_drvdata(file);
+	struct mxc_isi_dev *mxc_isi = mxc_isi_get_hostdata(isi_cap->pdev);
+	struct device *dev = &isi_cap->pdev->dev;
+	struct vb2_queue *q = &isi_cap->vb2_q;
+	struct v4l2_subdev *src_sd;
+	int ret;
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	if (!isi_cap->is_streaming[isi_cap->id]) {
+		src_sd = mxc_get_remote_subdev(&isi_cap->sd, __func__);
+		ret = (!src_sd) ? -EINVAL : v4l2_subdev_call(src_sd, core, s_power, 1);
+		if (ret) {
+			v4l2_err(&isi_cap->sd, "Call subdev s_power fail!\n");
+			return ret;
+		}
+
+		ret = mxc_isi_config_parm(isi_cap);
+		if (ret < 0)
+			goto power;
+	}
+
+	ret = vb2_ioctl_streamon(file, priv, type);
+	if (ret < 0) {
+		if (!isi_cap->is_streaming[isi_cap->id])
+			goto power;
+		else
+			return ret;
+	}
+
+	if (!isi_cap->is_streaming[isi_cap->id] &&
+	     q->start_streaming_called) {
+		mxc_isi_channel_enable(mxc_isi, mxc_isi->m2m_enabled);
+		ret = mxc_isi_pipeline_enable(isi_cap, 1);
+		if (ret < 0 && ret != -ENOIOCTLCMD)
+			goto disable;
+
+		isi_cap->is_streaming[isi_cap->id] = 1;
+		mxc_isi->is_streaming = 1;
+	}
+
+	return 0;
+
+disable:
+	mxc_isi_channel_disable(mxc_isi);
+power:
+	v4l2_subdev_call(src_sd, core, s_power, 0);
+	return ret;
+}
+
+static int mxc_isi_cap_streamoff(struct file *file, void *priv,
+				 enum v4l2_buf_type type)
+{
+	struct mxc_isi_cap_dev *isi_cap = video_drvdata(file);
+	struct mxc_isi_dev *mxc_isi = mxc_isi_get_hostdata(isi_cap->pdev);
+	struct device *dev = &isi_cap->pdev->dev;
+	struct v4l2_subdev *src_sd;
+	int ret;
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	ret = vb2_ioctl_streamoff(file, priv, type);
+	if (ret < 0)
+		return ret;
+
+	if (isi_cap->is_streaming[isi_cap->id]) {
+		mxc_isi_pipeline_enable(isi_cap, 0);
+		mxc_isi_channel_disable(mxc_isi);
+
+		isi_cap->is_streaming[isi_cap->id] = 0;
+		mxc_isi->is_streaming = 0;
+
+		src_sd = mxc_get_remote_subdev(&isi_cap->sd, __func__);
+		return v4l2_subdev_call(src_sd, core, s_power, 0);
+	}
+
+	return 0;
+}
+
+static int mxc_isi_cap_g_selection(struct file *file, void *fh,
+				   struct v4l2_selection *s)
+{
+	struct mxc_isi_cap_dev *isi_cap = video_drvdata(file);
+	struct mxc_isi_frame *f = &isi_cap->dst_f;
+
+	dev_dbg(&isi_cap->pdev->dev, "%s\n", __func__);
+
+	if (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT &&
+	    s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)
+		return -EINVAL;
+
+	switch (s->target) {
+	case V4L2_SEL_TGT_COMPOSE_DEFAULT:
+	case V4L2_SEL_TGT_COMPOSE_BOUNDS:
+		s->r.left = 0;
+		s->r.top = 0;
+		s->r.width = f->o_width;
+		s->r.height = f->o_height;
+		return 0;
+
+	case V4L2_SEL_TGT_COMPOSE:
+		s->r.left = f->h_off;
+		s->r.top = f->v_off;
+		s->r.width = f->c_width;
+		s->r.height = f->c_height;
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+static int enclosed_rectangle(struct v4l2_rect *a, struct v4l2_rect *b)
+{
+	if (a->left < b->left || a->top < b->top)
+		return 0;
+
+	if (a->left + a->width > b->left + b->width)
+		return 0;
+
+	if (a->top + a->height > b->top + b->height)
+		return 0;
+
+	return 1;
+}
+
+static int mxc_isi_cap_s_selection(struct file *file, void *fh,
+				   struct v4l2_selection *s)
+{
+	struct mxc_isi_cap_dev *isi_cap = video_drvdata(file);
+	struct mxc_isi_frame *f;
+	struct v4l2_rect rect = s->r;
+	unsigned long flags;
+
+	dev_dbg(&isi_cap->pdev->dev, "%s\n", __func__);
+	if (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT &&
+	    s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)
+		return -EINVAL;
+
+	if (s->target == V4L2_SEL_TGT_COMPOSE)
+		f = &isi_cap->dst_f;
+	else
+		return -EINVAL;
+
+	bounds_adjust(f, &rect);
+
+	if (s->flags & V4L2_SEL_FLAG_LE &&
+	    !enclosed_rectangle(&rect, &s->r))
+		return -ERANGE;
+
+	if (s->flags & V4L2_SEL_FLAG_GE &&
+	    !enclosed_rectangle(&s->r, &rect))
+		return -ERANGE;
+
+	if ((s->flags & V4L2_SEL_FLAG_LE) &&
+	    (s->flags & V4L2_SEL_FLAG_GE) &&
+	    (rect.width != s->r.width || rect.height != s->r.height))
+		return -ERANGE;
+
+	s->r = rect;
+	spin_lock_irqsave(&isi_cap->slock, flags);
+	set_frame_crop(f, s->r.left, s->r.top, s->r.width,
+		       s->r.height);
+	spin_unlock_irqrestore(&isi_cap->slock, flags);
+
+	return 0;
+}
+
+static int mxc_isi_cap_enum_framesizes(struct file *file, void *priv,
+				       struct v4l2_frmsizeenum *fsize)
+{
+	struct mxc_isi_cap_dev *isi_cap = video_drvdata(file);
+	struct device_node *parent;
+	struct v4l2_subdev *sd;
+	struct mxc_isi_fmt *fmt;
+	struct v4l2_subdev_frame_size_enum fse = {
+		.index = fsize->index,
+		.which = V4L2_SUBDEV_FORMAT_ACTIVE,
+	};
+	int ret;
+
+	fmt = mxc_isi_find_format(&fsize->pixel_format, NULL, 0);
+	if (!fmt || fmt->fourcc != fsize->pixel_format)
+		return -EINVAL;
+	fse.code = fmt->mbus_code;
+
+	sd = mxc_get_remote_subdev(&isi_cap->sd, __func__);
+	if (!sd) {
+		v4l2_err(&isi_cap->sd, "Can't find subdev\n");
+		return -ENODEV;
+	}
+
+	ret = v4l2_subdev_call(sd, pad, enum_frame_size, NULL, &fse);
+	if (ret)
+		return ret;
+
+	parent = of_get_parent(isi_cap->pdev->dev.of_node);
+	if ((of_device_is_compatible(parent, "fsl,imx8mp-isi")) &&
+	    (fse.max_width > ISI_2K || fse.min_width > ISI_2K) &&
+	    (isi_cap->id == 1))
+		return -EINVAL;
+
+	if (fse.min_width == fse.max_width &&
+	    fse.min_height == fse.max_height) {
+		fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+		fsize->discrete.width = fse.min_width;
+		fsize->discrete.height = fse.min_height;
+		return 0;
+	}
+
+	fsize->type = V4L2_FRMSIZE_TYPE_STEPWISE;
+	fsize->stepwise.min_width = fse.min_width;
+	fsize->stepwise.max_width = fse.max_width;
+	fsize->stepwise.min_height = fse.min_height;
+	fsize->stepwise.max_height = fse.max_height;
+	fsize->stepwise.step_width = 1;
+	fsize->stepwise.step_height = 1;
+
+	return 0;
+}
+
+static int mxc_isi_cap_enum_frameintervals(struct file *file, void *fh,
+					   struct v4l2_frmivalenum *interval)
+{
+	struct mxc_isi_cap_dev *isi_cap = video_drvdata(file);
+	struct device_node *parent;
+	struct v4l2_subdev *sd;
+	struct mxc_isi_fmt *fmt;
+	struct v4l2_subdev_frame_interval_enum fie = {
+		.index = interval->index,
+		.width = interval->width,
+		.height = interval->height,
+		.which = V4L2_SUBDEV_FORMAT_ACTIVE,
+	};
+	int ret;
+
+	fmt = mxc_isi_find_format(&interval->pixel_format, NULL, 0);
+	if (!fmt || fmt->fourcc != interval->pixel_format)
+		return -EINVAL;
+	fie.code = fmt->mbus_code;
+
+	sd = mxc_get_remote_subdev(&isi_cap->sd, __func__);
+	if (!sd)
+		return -EINVAL;
+
+	ret = v4l2_subdev_call(sd, pad, enum_frame_interval, NULL, &fie);
+	if (ret)
+		return ret;
+
+	parent = of_get_parent(isi_cap->pdev->dev.of_node);
+	if (of_device_is_compatible(parent, "fsl,imx8mp-isi") &&
+	    fie.width > ISI_2K && isi_cap->id == 1)
+		return -EINVAL;
+
+	interval->type = V4L2_FRMIVAL_TYPE_DISCRETE;
+	interval->discrete = fie.interval;
+
+	return 0;
+}
+
+static const struct v4l2_ioctl_ops mxc_isi_capture_ioctl_ops = {
+	.vidioc_querycap		= mxc_isi_cap_querycap,
+
+	.vidioc_enum_fmt_vid_cap	= mxc_isi_cap_enum_fmt,
+	.vidioc_try_fmt_vid_cap_mplane	= mxc_isi_cap_try_fmt_mplane,
+	.vidioc_s_fmt_vid_cap_mplane	= mxc_isi_cap_s_fmt_mplane,
+	.vidioc_g_fmt_vid_cap_mplane	= mxc_isi_cap_g_fmt_mplane,
+
+	.vidioc_reqbufs			= vb2_ioctl_reqbufs,
+	.vidioc_querybuf		= vb2_ioctl_querybuf,
+	.vidioc_qbuf			= vb2_ioctl_qbuf,
+	.vidioc_dqbuf			= vb2_ioctl_dqbuf,
+	.vidioc_expbuf			= vb2_ioctl_expbuf,
+	.vidioc_prepare_buf		= vb2_ioctl_prepare_buf,
+	.vidioc_create_bufs		= vb2_ioctl_create_bufs,
+
+	.vidioc_g_parm			= mxc_isi_cap_g_parm,
+	.vidioc_s_parm			= mxc_isi_cap_s_parm,
+
+	.vidioc_streamon		= mxc_isi_cap_streamon,
+	.vidioc_streamoff		= mxc_isi_cap_streamoff,
+
+	.vidioc_g_selection		= mxc_isi_cap_g_selection,
+	.vidioc_s_selection		= mxc_isi_cap_s_selection,
+
+	.vidioc_enum_framesizes = mxc_isi_cap_enum_framesizes,
+	.vidioc_enum_frameintervals = mxc_isi_cap_enum_frameintervals,
+
+	.vidioc_subscribe_event   =  v4l2_ctrl_subscribe_event,
+	.vidioc_unsubscribe_event =  v4l2_event_unsubscribe,
+};
+
+/* Capture subdev media entity operations */
+static int mxc_isi_link_setup(struct media_entity *entity,
+			      const struct media_pad *local,
+			      const struct media_pad *remote, u32 flags)
+{
+	struct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);
+	struct mxc_isi_cap_dev *isi_cap = v4l2_get_subdevdata(sd);
+
+	if (WARN_ON(!isi_cap))
+		return 0;
+
+	if (!(flags & MEDIA_LNK_FL_ENABLED))
+		return 0;
+
+	/* Add ISI source and sink pad link configuration */
+	if (local->flags & MEDIA_PAD_FL_SOURCE) {
+		switch (local->index) {
+		case MXC_ISI_SD_PAD_SOURCE_DC0:
+		case MXC_ISI_SD_PAD_SOURCE_DC1:
+			break;
+		case MXC_ISI_SD_PAD_SOURCE_MEM:
+			break;
+		default:
+			dev_err(&isi_cap->pdev->dev, "invalid source pad\n");
+			return -EINVAL;
+		}
+	} else if (local->flags & MEDIA_PAD_FL_SINK) {
+		switch (local->index) {
+		case MXC_ISI_SD_PAD_SINK_MIPI0_VC0:
+		case MXC_ISI_SD_PAD_SINK_MIPI0_VC1:
+		case MXC_ISI_SD_PAD_SINK_MIPI0_VC2:
+		case MXC_ISI_SD_PAD_SINK_MIPI0_VC3:
+		case MXC_ISI_SD_PAD_SINK_MIPI1_VC0:
+		case MXC_ISI_SD_PAD_SINK_MIPI1_VC1:
+		case MXC_ISI_SD_PAD_SINK_MIPI1_VC2:
+		case MXC_ISI_SD_PAD_SINK_MIPI1_VC3:
+		case MXC_ISI_SD_PAD_SINK_HDMI:
+		case MXC_ISI_SD_PAD_SINK_DC0:
+		case MXC_ISI_SD_PAD_SINK_DC1:
+		case MXC_ISI_SD_PAD_SINK_MEM:
+		case MXC_ISI_SD_PAD_SINK_PARALLEL_CSI:
+			break;
+		default:
+			dev_err(&isi_cap->pdev->dev,
+				"%s invalid sink pad\n", __func__);
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
+static const struct media_entity_operations mxc_isi_sd_media_ops = {
+	.link_setup = mxc_isi_link_setup,
+};
+
+static int mxc_isi_subdev_enum_mbus_code(struct v4l2_subdev *sd,
+					 struct v4l2_subdev_state *sd_state,
+					 struct v4l2_subdev_mbus_code_enum *code)
+{
+	return 0;
+}
+
+static int mxc_isi_subdev_get_fmt(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_state *sd_state,
+				  struct v4l2_subdev_format *fmt)
+{
+	struct mxc_isi_cap_dev *isi_cap = v4l2_get_subdevdata(sd);
+	struct mxc_isi_frame *f;
+	struct v4l2_mbus_framefmt *mf = &fmt->format;
+
+	mutex_lock(&isi_cap->lock);
+
+	switch (fmt->pad) {
+	case MXC_ISI_SD_PAD_SOURCE_MEM:
+	case MXC_ISI_SD_PAD_SOURCE_DC0:
+	case MXC_ISI_SD_PAD_SOURCE_DC1:
+		f = &isi_cap->dst_f;
+		break;
+	case MXC_ISI_SD_PAD_SINK_MIPI0_VC0:
+	case MXC_ISI_SD_PAD_SINK_MIPI0_VC1:
+	case MXC_ISI_SD_PAD_SINK_MIPI0_VC2:
+	case MXC_ISI_SD_PAD_SINK_MIPI0_VC3:
+	case MXC_ISI_SD_PAD_SINK_MIPI1_VC0:
+	case MXC_ISI_SD_PAD_SINK_MIPI1_VC1:
+	case MXC_ISI_SD_PAD_SINK_MIPI1_VC2:
+	case MXC_ISI_SD_PAD_SINK_MIPI1_VC3:
+	case MXC_ISI_SD_PAD_SINK_HDMI:
+	case MXC_ISI_SD_PAD_SINK_DC0:
+	case MXC_ISI_SD_PAD_SINK_DC1:
+	case MXC_ISI_SD_PAD_SINK_MEM:
+		f = &isi_cap->src_f;
+		break;
+	default:
+		mutex_unlock(&isi_cap->lock);
+		v4l2_err(&isi_cap->sd,
+			 "%s, Pad is not support now!\n", __func__);
+		return -1;
+	}
+
+	if (!WARN_ON(!f->fmt))
+		mf->code = f->fmt->mbus_code;
+
+	/* Source/Sink pads crop rectangle size */
+	mf->width = f->width;
+	mf->height = f->height;
+	mf->colorspace = V4L2_COLORSPACE_SRGB;
+
+	mutex_unlock(&isi_cap->lock);
+
+	return 0;
+}
+
+static int mxc_isi_subdev_set_fmt(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_state *sd_state,
+				  struct v4l2_subdev_format *fmt)
+{
+	struct mxc_isi_cap_dev *isi_cap = v4l2_get_subdevdata(sd);
+	struct device_node *parent;
+	struct v4l2_mbus_framefmt *mf = &fmt->format;
+	struct mxc_isi_frame *dst_f = &isi_cap->dst_f;
+	struct mxc_isi_fmt *out_fmt;
+	int i;
+
+	if (fmt->pad < MXC_ISI_SD_PAD_SOURCE_MEM &&
+	    vb2_is_busy(&isi_cap->vb2_q))
+		return -EBUSY;
+
+	for (i = 0; i < mxc_isi_out_formats_size; i++) {
+		out_fmt = &mxc_isi_out_formats[i];
+		if (mf->code == out_fmt->mbus_code)
+			break;
+	}
+	if (i >= mxc_isi_out_formats_size) {
+		v4l2_err(&isi_cap->sd,
+			 "%s, format is not support!\n", __func__);
+		return -EINVAL;
+	}
+
+	parent = of_get_parent(isi_cap->pdev->dev.of_node);
+	if (of_device_is_compatible(parent, "fsl,imx8mn-isi") &&
+	    mf->width > ISI_2K)
+		return -EINVAL;
+
+	mutex_lock(&isi_cap->lock);
+	/* update out put frame size and formate */
+	dst_f->fmt = &mxc_isi_out_formats[i];
+	set_frame_bounds(dst_f, mf->width, mf->height);
+	mutex_unlock(&isi_cap->lock);
+
+	dev_dbg(&isi_cap->pdev->dev, "pad%d: code: 0x%x, %dx%d",
+		fmt->pad, mf->code, mf->width, mf->height);
+
+	return 0;
+}
+
+static int mxc_isi_subdev_get_selection(struct v4l2_subdev *sd,
+					struct v4l2_subdev_state *sd_state,
+					struct v4l2_subdev_selection *sel)
+{
+	struct mxc_isi_cap_dev *isi_cap = v4l2_get_subdevdata(sd);
+	struct mxc_isi_frame *f = &isi_cap->src_f;
+	struct v4l2_rect *r = &sel->r;
+	struct v4l2_rect *try_sel;
+
+	mutex_lock(&isi_cap->lock);
+
+	switch (sel->target) {
+	case V4L2_SEL_TGT_COMPOSE_BOUNDS:
+		f = &isi_cap->dst_f;
+		fallthrough;
+	case V4L2_SEL_TGT_CROP_BOUNDS:
+		r->width = f->o_width;
+		r->height = f->o_height;
+		r->left = 0;
+		r->top = 0;
+		mutex_unlock(&isi_cap->lock);
+		return 0;
+
+	case V4L2_SEL_TGT_CROP:
+		try_sel = v4l2_subdev_get_try_crop(sd, sd_state, sel->pad);
+		break;
+	case V4L2_SEL_TGT_COMPOSE:
+		try_sel = v4l2_subdev_get_try_compose(sd, sd_state, sel->pad);
+		f = &isi_cap->dst_f;
+		break;
+	default:
+		mutex_unlock(&isi_cap->lock);
+		return -EINVAL;
+	}
+
+	if (sel->which == V4L2_SUBDEV_FORMAT_TRY) {
+		sel->r = *try_sel;
+	} else {
+		r->left = f->h_off;
+		r->top = f->v_off;
+		r->width = f->width;
+		r->height = f->height;
+	}
+
+	dev_dbg(&isi_cap->pdev->dev,
+		"%s, target %#x: l:%d, t:%d, %dx%d, f_w: %d, f_h: %d",
+		__func__, sel->pad, r->left, r->top, r->width, r->height,
+		f->c_width, f->c_height);
+
+	mutex_unlock(&isi_cap->lock);
+	return 0;
+}
+
+static int mxc_isi_subdev_set_selection(struct v4l2_subdev *sd,
+					struct v4l2_subdev_state *sd_state,
+					struct v4l2_subdev_selection *sel)
+{
+	struct mxc_isi_cap_dev *isi_cap = v4l2_get_subdevdata(sd);
+	struct mxc_isi_frame *f = &isi_cap->src_f;
+	struct v4l2_rect *r = &sel->r;
+	struct v4l2_rect *try_sel;
+	unsigned long flags;
+
+	mutex_lock(&isi_cap->lock);
+
+	switch (sel->target) {
+	case V4L2_SEL_TGT_CROP:
+		try_sel = v4l2_subdev_get_try_crop(sd, sd_state, sel->pad);
+		break;
+	case V4L2_SEL_TGT_COMPOSE:
+		try_sel = v4l2_subdev_get_try_compose(sd, sd_state, sel->pad);
+		f = &isi_cap->dst_f;
+		break;
+	default:
+		mutex_unlock(&isi_cap->lock);
+		return -EINVAL;
+	}
+
+	if (sel->which == V4L2_SUBDEV_FORMAT_TRY) {
+		*try_sel = sel->r;
+	} else {
+		spin_lock_irqsave(&isi_cap->slock, flags);
+		set_frame_crop(f, r->left, r->top, r->width, r->height);
+		spin_unlock_irqrestore(&isi_cap->slock, flags);
+	}
+
+	dev_dbg(&isi_cap->pdev->dev, "%s, target %#x: (%d,%d)/%dx%d", __func__,
+		sel->target, r->left, r->top, r->width, r->height);
+
+	mutex_unlock(&isi_cap->lock);
+
+	return 0;
+}
+
+static struct v4l2_subdev_pad_ops mxc_isi_subdev_pad_ops = {
+	.enum_mbus_code = mxc_isi_subdev_enum_mbus_code,
+	.get_selection  = mxc_isi_subdev_get_selection,
+	.set_selection  = mxc_isi_subdev_set_selection,
+	.get_fmt = mxc_isi_subdev_get_fmt,
+	.set_fmt = mxc_isi_subdev_set_fmt,
+};
+
+static struct v4l2_subdev_ops mxc_isi_subdev_ops = {
+	.pad = &mxc_isi_subdev_pad_ops,
+};
+
+static int mxc_isi_register_cap_device(struct mxc_isi_cap_dev *isi_cap,
+				       struct v4l2_device *v4l2_dev)
+{
+	struct video_device *vdev = &isi_cap->vdev;
+	struct vb2_queue *q = &isi_cap->vb2_q;
+	int ret = -ENOMEM;
+
+	dev_dbg(&isi_cap->pdev->dev, "%s\n", __func__);
+	memset(vdev, 0, sizeof(*vdev));
+	snprintf(vdev->name, sizeof(vdev->name), "mxc_isi.%d.capture", isi_cap->id);
+
+	vdev->fops	= &mxc_isi_capture_fops;
+	vdev->ioctl_ops	= &mxc_isi_capture_ioctl_ops;
+	vdev->v4l2_dev	= v4l2_dev;
+	vdev->minor	= -1;
+	vdev->release	= video_device_release_empty;
+	vdev->queue	= q;
+	vdev->lock	= &isi_cap->lock;
+
+	vdev->device_caps = V4L2_CAP_STREAMING | V4L2_CAP_VIDEO_CAPTURE_MPLANE;
+	video_set_drvdata(vdev, isi_cap);
+
+	INIT_LIST_HEAD(&isi_cap->out_pending);
+	INIT_LIST_HEAD(&isi_cap->out_active);
+	INIT_LIST_HEAD(&isi_cap->out_discard);
+
+	memset(q, 0, sizeof(*q));
+	q->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+	q->io_modes = VB2_MMAP | VB2_DMABUF;
+	q->drv_priv = isi_cap;
+	q->ops = &mxc_cap_vb2_qops;
+	q->mem_ops = &vb2_dma_contig_memops;
+	q->buf_struct_size = sizeof(struct mxc_isi_buffer);
+	q->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
+	q->lock = &isi_cap->lock;
+	q->min_buffers_needed = 2;
+	q->dev = &isi_cap->pdev->dev;
+
+	ret = vb2_queue_init(q);
+	if (ret)
+		goto err_free_ctx;
+
+
+	isi_cap->cap_pad.flags = MEDIA_PAD_FL_SINK;
+	vdev->entity.function = MEDIA_ENT_F_PROC_VIDEO_SCALER;
+	ret = media_entity_pads_init(&vdev->entity, 1, &isi_cap->cap_pad);
+	if (ret)
+		goto err_free_ctx;
+
+	ret = mxc_isi_ctrls_create(isi_cap);
+	if (ret)
+		goto err_me_cleanup;
+
+	ret = video_register_device(vdev, VFL_TYPE_VIDEO, -1);
+	if (ret)
+		goto err_ctrl_free;
+
+	vdev->ctrl_handler = &isi_cap->ctrls.handler;
+	v4l2_info(v4l2_dev, "Registered %s as /dev/%s\n",
+		  vdev->name, video_device_node_name(vdev));
+
+	return 0;
+
+err_ctrl_free:
+	mxc_isi_ctrls_delete(isi_cap);
+err_me_cleanup:
+	media_entity_cleanup(&vdev->entity);
+err_free_ctx:
+	return ret;
+}
+
+static int mxc_isi_subdev_registered(struct v4l2_subdev *sd)
+{
+	struct mxc_isi_cap_dev *isi_cap = sd_to_cap_dev(sd);
+	int ret;
+
+	if (!isi_cap)
+		return -ENXIO;
+
+	dev_dbg(&isi_cap->pdev->dev, "%s\n", __func__);
+
+	ret = mxc_isi_register_cap_device(isi_cap, sd->v4l2_dev);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static void mxc_isi_subdev_unregistered(struct v4l2_subdev *sd)
+{
+	struct mxc_isi_cap_dev *isi_cap = v4l2_get_subdevdata(sd);
+	struct video_device *vdev;
+
+	if (!isi_cap)
+		return;
+
+	dev_dbg(&isi_cap->pdev->dev, "%s\n", __func__);
+
+	mutex_lock(&isi_cap->lock);
+	vdev = &isi_cap->vdev;
+	if (video_is_registered(vdev)) {
+		video_unregister_device(vdev);
+		mxc_isi_ctrls_delete(isi_cap);
+		media_entity_cleanup(&vdev->entity);
+	}
+	mutex_unlock(&isi_cap->lock);
+}
+
+static const struct v4l2_subdev_internal_ops mxc_isi_capture_sd_internal_ops = {
+	.registered = mxc_isi_subdev_registered,
+	.unregistered = mxc_isi_subdev_unregistered,
+};
+
+static int isi_cap_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct mxc_isi_dev *mxc_isi;
+	struct mxc_isi_cap_dev *isi_cap;
+	struct v4l2_subdev *sd;
+	int ret;
+
+	isi_cap = devm_kzalloc(dev, sizeof(*isi_cap), GFP_KERNEL);
+	if (!isi_cap)
+		return -ENOMEM;
+
+	dev->parent = mxc_isi_dev_get_parent(pdev);
+	if (!dev->parent) {
+		dev_info(dev, "deferring %s device registration\n", dev_name(dev));
+		return -EPROBE_DEFER;
+	}
+
+	mxc_isi = mxc_isi_get_hostdata(pdev);
+	if (!mxc_isi) {
+		dev_info(dev, "deferring %s device registration\n", dev_name(dev));
+		return -EPROBE_DEFER;
+	}
+
+	isi_cap->pdev = pdev;
+	isi_cap->id = mxc_isi->id;
+	mxc_isi->isi_cap = isi_cap;
+
+	spin_lock_init(&isi_cap->slock);
+	mutex_init(&isi_cap->lock);
+
+	sd = &isi_cap->sd;
+	v4l2_subdev_init(sd, &mxc_isi_subdev_ops);
+	snprintf(sd->name, sizeof(sd->name), "mxc_isi.%d", isi_cap->id);
+
+	sd->entity.function = MEDIA_ENT_F_PROC_VIDEO_PIXEL_FORMATTER;
+
+	/* ISI Sink pads */
+	isi_cap->sd_pads[MXC_ISI_SD_PAD_SINK_MIPI0_VC0].flags = MEDIA_PAD_FL_SINK;
+	isi_cap->sd_pads[MXC_ISI_SD_PAD_SINK_MIPI0_VC1].flags = MEDIA_PAD_FL_SINK;
+	isi_cap->sd_pads[MXC_ISI_SD_PAD_SINK_MIPI0_VC2].flags = MEDIA_PAD_FL_SINK;
+	isi_cap->sd_pads[MXC_ISI_SD_PAD_SINK_MIPI0_VC3].flags = MEDIA_PAD_FL_SINK;
+	isi_cap->sd_pads[MXC_ISI_SD_PAD_SINK_MIPI1_VC0].flags = MEDIA_PAD_FL_SINK;
+	isi_cap->sd_pads[MXC_ISI_SD_PAD_SINK_MIPI1_VC1].flags = MEDIA_PAD_FL_SINK;
+	isi_cap->sd_pads[MXC_ISI_SD_PAD_SINK_MIPI1_VC2].flags = MEDIA_PAD_FL_SINK;
+	isi_cap->sd_pads[MXC_ISI_SD_PAD_SINK_MIPI1_VC3].flags = MEDIA_PAD_FL_SINK;
+	isi_cap->sd_pads[MXC_ISI_SD_PAD_SINK_DC0].flags = MEDIA_PAD_FL_SINK;
+	isi_cap->sd_pads[MXC_ISI_SD_PAD_SINK_DC1].flags = MEDIA_PAD_FL_SINK;
+	isi_cap->sd_pads[MXC_ISI_SD_PAD_SINK_HDMI].flags = MEDIA_PAD_FL_SINK;
+	isi_cap->sd_pads[MXC_ISI_SD_PAD_SINK_MEM].flags = MEDIA_PAD_FL_SINK;
+	isi_cap->sd_pads[MXC_ISI_SD_PAD_SINK_PARALLEL_CSI].flags = MEDIA_PAD_FL_SINK;
+
+	/* ISI source pads */
+	isi_cap->sd_pads[MXC_ISI_SD_PAD_SOURCE_MEM].flags = MEDIA_PAD_FL_SOURCE;
+	isi_cap->sd_pads[MXC_ISI_SD_PAD_SOURCE_DC0].flags = MEDIA_PAD_FL_SOURCE;
+	isi_cap->sd_pads[MXC_ISI_SD_PAD_SOURCE_DC1].flags = MEDIA_PAD_FL_SOURCE;
+
+	ret = media_entity_pads_init(&sd->entity, MXC_ISI_SD_PADS_NUM, isi_cap->sd_pads);
+	if (ret)
+		return ret;
+
+	sd->entity.ops   = &mxc_isi_sd_media_ops;
+	sd->internal_ops = &mxc_isi_capture_sd_internal_ops;
+
+	v4l2_set_subdevdata(sd, isi_cap);
+	platform_set_drvdata(pdev, isi_cap);
+
+	pm_runtime_enable(dev);
+	return 0;
+}
+
+static int isi_cap_remove(struct platform_device *pdev)
+{
+	struct mxc_isi_cap_dev *isi_cap = platform_get_drvdata(pdev);
+	struct v4l2_subdev *sd = &isi_cap->sd;
+
+	v4l2_device_unregister_subdev(sd);
+	media_entity_cleanup(&sd->entity);
+	v4l2_set_subdevdata(sd, NULL);
+	pm_runtime_disable(&pdev->dev);
+
+	return 0;
+}
+
+static const struct of_device_id isi_cap_of_match[] = {
+	{.compatible = "imx-isi-capture",},
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, isi_cap_of_match);
+
+static struct platform_driver isi_cap_driver = {
+	.probe  = isi_cap_probe,
+	.remove = isi_cap_remove,
+	.driver = {
+		.of_match_table = isi_cap_of_match,
+		.name		= "isi-capture",
+	},
+};
+module_platform_driver(isi_cap_driver);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("IMX8 Image Sensor Interface Capture driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("ISI Capture");
+MODULE_VERSION("1.0");
diff --git a/drivers/staging/media/imx/imx8-isi-core.h b/drivers/staging/media/imx/imx8-isi-core.h
new file mode 100644
index 000000000..087d977d0
--- /dev/null
+++ b/drivers/staging/media/imx/imx8-isi-core.h
@@ -0,0 +1,458 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright 2019-2020 NXP
+ */
+
+#ifndef __MXC_ISI_CORE_H__
+#define __MXC_ISI_CORE_H__
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/bug.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/list.h>
+#include <linux/mfd/syscon.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <media/media-device.h>
+#include <media/media-entity.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-mem2mem.h>
+#include <media/videobuf2-core.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-ctrls.h>
+#include <media/videobuf2-core.h>
+#include <media/videobuf2-dma-contig.h>
+#include <linux/regmap.h>
+#include <linux/reset.h>
+#include <linux/sys_soc.h>
+
+#include "imx8-common.h"
+
+#define MXC_ISI_DRIVER_NAME	"mxc-isi"
+#define MXC_ISI_CAPTURE		"mxc-isi-cap"
+#define MXC_ISI_M2M		"mxc-isi-m2m"
+#define MXC_MAX_PLANES		3
+
+struct mxc_isi_dev;
+
+enum mxc_isi_out_fmt {
+	MXC_ISI_OUT_FMT_RGBA32	= 0x0,
+	MXC_ISI_OUT_FMT_ABGR32,
+	MXC_ISI_OUT_FMT_ARGB32,
+	MXC_ISI_OUT_FMT_RGBX32,
+	MXC_ISI_OUT_FMT_XBGR32,
+	MXC_ISI_OUT_FMT_XRGB32,
+	MXC_ISI_OUT_FMT_RGB32P,
+	MXC_ISI_OUT_FMT_BGR32P,
+	MXC_ISI_OUT_FMT_A2BGR10,
+	MXC_ISI_OUT_FMT_A2RGB10,
+	MXC_ISI_OUT_FMT_RGB565,
+	MXC_ISI_OUT_FMT_RAW8,
+	MXC_ISI_OUT_FMT_RAW10,
+	MXC_ISI_OUT_FMT_RAW10P,
+	MXC_ISI_OUT_FMT_RAW12,
+	MXC_ISI_OUT_FMT_RAW16,
+	MXC_ISI_OUT_FMT_YUV444_1P8P,
+	MXC_ISI_OUT_FMT_YUV444_2P8P,
+	MXC_ISI_OUT_FMT_YUV444_3P8P,
+	MXC_ISI_OUT_FMT_YUV444_1P8,
+	MXC_ISI_OUT_FMT_YUV444_1P10,
+	MXC_ISI_OUT_FMT_YUV444_2P10,
+	MXC_ISI_OUT_FMT_YUV444_3P10,
+	MXC_ISI_OUT_FMT_YUV444_1P10P = 0x18,
+	MXC_ISI_OUT_FMT_YUV444_2P10P,
+	MXC_ISI_OUT_FMT_YUV444_3P10P,
+	MXC_ISI_OUT_FMT_YUV444_1P12 = 0x1C,
+	MXC_ISI_OUT_FMT_YUV444_2P12,
+	MXC_ISI_OUT_FMT_YUV444_3P12,
+	MXC_ISI_OUT_FMT_YUV422_1P8P = 0x20,
+	MXC_ISI_OUT_FMT_YUV422_2P8P,
+	MXC_ISI_OUT_FMT_YUV422_3P8P,
+	MXC_ISI_OUT_FMT_YUV422_1P10 = 0x24,
+	MXC_ISI_OUT_FMT_YUV422_2P10,
+	MXC_ISI_OUT_FMT_YUV422_3P10,
+	MXC_ISI_OUT_FMT_YUV422_1P10P = 0x28,
+	MXC_ISI_OUT_FMT_YUV422_2P10P,
+	MXC_ISI_OUT_FMT_YUV422_3P10P,
+	MXC_ISI_OUT_FMT_YUV422_1P12 = 0x2C,
+	MXC_ISI_OUT_FMT_YUV422_2P12,
+	MXC_ISI_OUT_FMT_YUV422_3P12,
+	MXC_ISI_OUT_FMT_YUV420_2P8P = 0x31,
+	MXC_ISI_OUT_FMT_YUV420_3P8P,
+	MXC_ISI_OUT_FMT_YUV420_2P10 = 0x35,
+	MXC_ISI_OUT_FMT_YUV420_3P10,
+	MXC_ISI_OUT_FMT_YUV420_2P10P = 0x39,
+	MXC_ISI_OUT_FMT_YUV420_3P10P,
+	MXC_ISI_OUT_FMT_YUV420_2P12 = 0x3D,
+	MXC_ISI_OUT_FMT_YUV420_3P12,
+};
+
+enum mxc_isi_in_fmt {
+	MXC_ISI_IN_FMT_BGR8P	= 0x0,
+};
+
+enum mxc_isi_m2m_in_fmt {
+	MXC_ISI_M2M_IN_FMT_BGR8P	= 0x0,
+	MXC_ISI_M2M_IN_FMT_RGB8P,
+	MXC_ISI_M2M_IN_FMT_XRGB8,
+	MXC_ISI_M2M_IN_FMT_RGBX8,
+	MXC_ISI_M2M_IN_FMT_XBGR8,
+	MXC_ISI_M2M_IN_FMT_RGB565,
+	MXC_ISI_M2M_IN_FMT_A2BGR10,
+	MXC_ISI_M2M_IN_FMT_A2RGB10,
+	MXC_ISI_M2M_IN_FMT_YUV444_1P8P,
+	MXC_ISI_M2M_IN_FMT_YUV444_1P10,
+	MXC_ISI_M2M_IN_FMT_YUV444_1P10P,
+	MXC_ISI_M2M_IN_FMT_YUV444_1P12,
+	MXC_ISI_M2M_IN_FMT_YUV444_1P8,
+	MXC_ISI_M2M_IN_FMT_YUV422_1P8P,
+	MXC_ISI_M2M_IN_FMT_YUV422_1P10,
+	MXC_ISI_M2M_IN_FMT_YUV422_1P10P,
+};
+
+struct mxc_isi_fmt {
+	char	*name;
+	u32	mbus_code;
+	u32	fourcc;
+	u32	color;
+	u16	memplanes;
+	u16	colplanes;
+	u8	colorspace;
+	u8	depth[MXC_MAX_PLANES];
+	u16	mdataplanes;
+	u16	flags;
+	u16	align;
+};
+
+struct mxc_isi_ctrls {
+	struct v4l2_ctrl_handler handler;
+	struct v4l2_ctrl *hflip;
+	struct v4l2_ctrl *vflip;
+	struct v4l2_ctrl *alpha;
+	struct v4l2_ctrl *num_cap_buf;
+	struct v4l2_ctrl *num_out_buf;
+	bool ready;
+};
+
+/**
+ * struct addr -  physical address set for DMA
+ * @y:	 luminance plane physical address
+ * @cb:	 Cb plane physical address
+ * @cr:	 Cr plane physical address
+ */
+struct frame_addr {
+	u32	y;
+	u32	cb;
+	u32	cr;
+};
+
+/**
+ * struct mxc_isi_frame - source/target frame properties
+ * o_width:	 original image width from sensor
+ * o_height: original image height from sensor
+ * c_width:	 crop image width set by g_selection
+ * c_height: crop image height set by g_selection
+ * h_off:	crop horizontal pixel offset
+ * v_off:	crop vertical pixel offset
+ * width:	out image pixel width
+ * height:	out image pixel weight
+ * bytesperline: bytesperline value for each plane
+ * paddr:	image frame buffer physical addresses
+ * fmt:	color format pointer
+ */
+struct mxc_isi_frame {
+	u32	o_width;
+	u32	o_height;
+	u32	c_width;
+	u32	c_height;
+	u32	h_off;
+	u32	v_off;
+	u32	width;
+	u32	height;
+	unsigned int	sizeimage[MXC_MAX_PLANES];
+	unsigned int	bytesperline[MXC_MAX_PLANES];
+	struct mxc_isi_fmt	*fmt;
+};
+
+struct mxc_isi_roi_alpha {
+	u8 alpha;
+	struct v4l2_rect rect;
+};
+
+struct mxc_isi_buffer {
+	struct vb2_v4l2_buffer  v4l2_buf;
+	struct list_head	list;
+	struct frame_addr	paddr;
+	enum mxc_isi_buf_id	id;
+	bool discard;
+};
+
+struct mxc_isi_m2m_dev {
+	struct platform_device	*pdev;
+
+	struct video_device vdev;
+	struct v4l2_device  v4l2_dev;
+	struct v4l2_m2m_dev *m2m_dev;
+	struct v4l2_fh      fh;
+	struct v4l2_pix_format_mplane pix;
+
+	struct list_head	out_active;
+	struct mxc_isi_ctrls	ctrls;
+
+	struct mxc_isi_frame src_f;
+	struct mxc_isi_frame dst_f;
+
+	struct mutex lock;
+	spinlock_t   slock;
+
+	unsigned int aborting;
+	unsigned int frame_count;
+
+	enum v4l2_colorspace	colorspace;
+	enum v4l2_ycbcr_encoding ycbcr_enc;
+	enum v4l2_quantization	quant;
+	enum v4l2_xfer_func	xfer_func;
+
+	u32 req_cap_buf_num;
+	u32 req_out_buf_num;
+
+	u8 id;
+	int refcnt;
+};
+
+struct mxc_isi_ctx {
+	struct mxc_isi_m2m_dev *isi_m2m;
+	struct v4l2_fh	    fh;
+};
+
+struct mxc_isi_chan_src {
+	u32 src_dc0;
+	u32 src_dc1;
+	u32 src_mipi0;
+	u32 src_mipi1;
+	u32 src_hdmi;
+	u32 src_csi;
+	u32 src_mem;
+};
+
+struct mxc_isi_reg {
+	u32 offset;
+	u32 mask;
+};
+
+struct mxc_isi_ier_reg {
+	/* Overflow Y/U/V triggier enable*/
+	struct mxc_isi_reg oflw_y_buf_en;
+	struct mxc_isi_reg oflw_u_buf_en;
+	struct mxc_isi_reg oflw_v_buf_en;
+
+	/* Excess overflow Y/U/V triggier enable*/
+	struct mxc_isi_reg excs_oflw_y_buf_en;
+	struct mxc_isi_reg excs_oflw_u_buf_en;
+	struct mxc_isi_reg excs_oflw_v_buf_en;
+
+	/* Panic Y/U/V triggier enable*/
+	struct mxc_isi_reg panic_y_buf_en;
+	struct mxc_isi_reg panic_v_buf_en;
+	struct mxc_isi_reg panic_u_buf_en;
+};
+
+struct mxc_isi_dev_ops {
+	int (*clk_get)(struct mxc_isi_dev *mxc_isi);
+	int (*clk_enable)(struct mxc_isi_dev *mxc_isi);
+	void (*clk_disable)(struct mxc_isi_dev *mxc_isi);
+};
+
+struct mxc_isi_panic_thd {
+	u32 mask;
+	u32 offset;
+	u32 threshold;
+};
+
+struct mxc_isi_set_thd {
+	struct mxc_isi_panic_thd panic_set_thd_y;
+	struct mxc_isi_panic_thd panic_set_thd_u;
+	struct mxc_isi_panic_thd panic_set_thd_v;
+};
+
+struct mxc_isi_rst_ops {
+	int (*parse)(struct mxc_isi_dev *mxc_isi);
+	int (*assert)(struct mxc_isi_dev *mxc_isi);
+	int (*deassert)(struct mxc_isi_dev *mxc_isi);
+};
+
+struct mxc_isi_gate_clk_ops {
+	int (*gclk_get)(struct mxc_isi_dev *mxc_isi);
+	int (*gclk_enable)(struct mxc_isi_dev *mxc_isi);
+	int (*gclk_disable)(struct mxc_isi_dev *mxc_isi);
+};
+
+struct mxc_isi_plat_data {
+	struct mxc_isi_dev_ops *ops;
+	struct mxc_isi_chan_src *chan_src;
+	struct mxc_isi_ier_reg  *ier_reg;
+	struct mxc_isi_set_thd *set_thd;
+	struct mxc_isi_rst_ops *rst_ops;
+	struct mxc_isi_gate_clk_ops *gclk_ops;
+};
+
+struct mxc_isi_cap_dev {
+	struct v4l2_subdev  sd;
+	struct video_device vdev;
+	struct v4l2_fh      fh;
+	struct vb2_queue    vb2_q;
+	struct v4l2_pix_format_mplane pix;
+
+	struct mxc_isi_dev     *mxc_isi;
+	struct platform_device *pdev;
+	struct mxc_isi_ctrls   ctrls;
+	struct mxc_isi_buffer  buf_discard[2];
+
+	struct media_pad cap_pad;
+	struct media_pad sd_pads[MXC_ISI_SD_PADS_NUM];
+
+	struct list_head out_pending;
+	struct list_head out_active;
+	struct list_head out_discard;
+
+	struct mxc_isi_frame src_f;
+	struct mxc_isi_frame dst_f;
+
+	u32 frame_count;
+	u32 id;
+	u32 is_streaming[MXC_ISI_MAX_DEVS];
+	bool is_link_setup;
+
+	struct mutex lock;
+	spinlock_t   slock;
+
+	/* dirty buffer */
+	size_t     discard_size[MXC_MAX_PLANES];
+	void       *discard_buffer[MXC_MAX_PLANES];
+	dma_addr_t discard_buffer_dma[MXC_MAX_PLANES];
+};
+
+struct mxc_isi_dev {
+	/* Pointer to isi capture child device driver data */
+	struct mxc_isi_cap_dev *isi_cap;
+
+	/* Pointer to isi m2m child device driver data */
+	struct mxc_isi_m2m_dev *isi_m2m;
+
+	struct platform_device *pdev;
+
+	/* clk for imx8qxp/qm platform */
+	struct clk *clk;
+
+	/* clks for imx8mn platform */
+	struct clk *clk_disp_axi;
+	struct clk *clk_disp_apb;
+	struct clk *clk_root_disp_axi;
+	struct clk *clk_root_disp_apb;
+	struct clk *isi_proc;
+	struct clk *isi_apb;
+	struct clk *isi_bus;
+
+	const struct mxc_isi_plat_data *pdata;
+
+	struct reset_control *soft_resetn;
+	struct reset_control *clk_enable;
+	struct reset_control *isi_rst_proc;
+	struct reset_control *isi_rst_apb;
+	struct reset_control *isi_rst_bus;
+
+	struct regmap *chain;
+
+	struct mutex lock;
+	spinlock_t   slock;
+
+	void __iomem *regs;
+
+	u8 chain_buf;
+	u8 alpha;
+	bool m2m_enabled;
+	bool cap_enabled;
+	bool buf_active_reverse;
+	bool no_dispmix;
+
+	/* manage share ISI channel resource */
+	atomic_t usage_count;
+
+	/* scale factor */
+	u32 xfactor;
+	u32 yfactor;
+	u32 pre_dec_x;
+	u32 pre_dec_y;
+
+	u32 status;
+
+	int interface[MAX_PORTS];
+	int id;
+
+	unsigned int hflip:1;
+	unsigned int vflip:1;
+	unsigned int cscen:1;
+	unsigned int scale:1;
+	unsigned int alphaen:1;
+	unsigned int crop:1;
+	unsigned int deinterlace:3;
+	unsigned int is_streaming:1;
+};
+
+static inline void set_frame_bounds(struct mxc_isi_frame *f,
+				    u32 width, u32 height)
+{
+	f->o_width  = width;
+	f->o_height = height;
+	f->c_width  = width;
+	f->c_height = height;
+	f->width  = width;
+	f->height = height;
+}
+
+static inline void set_frame_out(struct mxc_isi_frame *f,
+				 u32 width, u32 height)
+{
+	f->c_width  = width;
+	f->c_height = height;
+	f->width  = width;
+	f->height = height;
+}
+
+static inline void set_frame_crop(struct mxc_isi_frame *f,
+				  u32 left, u32 top, u32 width, u32 height)
+{
+	f->h_off = left;
+	f->v_off = top;
+	f->c_width  = width;
+	f->c_height = height;
+}
+
+static inline void bounds_adjust(struct mxc_isi_frame *f, struct v4l2_rect *r)
+{
+	if (r->left < 0)
+		r->left = 0;
+	if (r->left >= f->o_width)
+		r->left = f->o_width - 1;
+	if (r->top < 0)
+		r->top = 0;
+	if (r->top >= f->o_height)
+		r->top = f->o_height - 1;
+
+	if (r->left + r->width >= f->o_width)
+		r->width = f->o_width - r->left;
+	if (r->top + r->height >= f->o_height)
+		r->height = f->o_height - r->top;
+}
+#endif /* __MXC_ISI_CORE_H__ */
diff --git a/drivers/staging/media/imx/imx8-isi-fmt.c b/drivers/staging/media/imx/imx8-isi-fmt.c
new file mode 100644
index 000000000..fa26e5a2a
--- /dev/null
+++ b/drivers/staging/media/imx/imx8-isi-fmt.c
@@ -0,0 +1,94 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright 2021 NXP
+ *
+ */
+
+#include "imx8-isi-core.h"
+
+struct mxc_isi_fmt mxc_isi_out_formats[] = {
+	{
+		.name		= "RGB565",
+		.fourcc		= V4L2_PIX_FMT_RGB565,
+		.depth		= { 16 },
+		.color		= MXC_ISI_OUT_FMT_RGB565,
+		.memplanes	= 1,
+		.colplanes	= 1,
+		.align		= 3,
+		.mbus_code  = MEDIA_BUS_FMT_RGB565_1X16,
+	}, {
+		.name		= "RGB24",
+		.fourcc		= V4L2_PIX_FMT_RGB24,
+		.depth		= { 24 },
+		.color		= MXC_ISI_OUT_FMT_BGR32P,
+		.memplanes	= 1,
+		.colplanes	= 1,
+		.align		= 2,
+		.mbus_code  = MEDIA_BUS_FMT_RGB888_1X24,
+	}, {
+		.name		= "BGR24",
+		.fourcc		= V4L2_PIX_FMT_BGR24,
+		.depth		= { 24 },
+		.color		= MXC_ISI_OUT_FMT_RGB32P,
+		.memplanes	= 1,
+		.colplanes	= 1,
+		.align		= 2,
+		.mbus_code  = MEDIA_BUS_FMT_BGR888_1X24,
+	}, {
+		.name		= "YUYV-16",
+		.fourcc		= V4L2_PIX_FMT_YUYV,
+		.depth		= { 16 },
+		.color		= MXC_ISI_OUT_FMT_YUV422_1P8P,
+		.memplanes	= 1,
+		.colplanes	= 1,
+		.align		= 3,
+		.mbus_code	= MEDIA_BUS_FMT_YUYV8_1X16,
+	}, {
+		.name		= "YUV32 (X-Y-U-V)",
+		.fourcc		= V4L2_PIX_FMT_YUV32,
+		.depth		= { 32 },
+		.color		= MXC_ISI_OUT_FMT_YUV444_1P8,
+		.memplanes	= 1,
+		.colplanes	= 1,
+		.align		= 2,
+		.mbus_code	= MEDIA_BUS_FMT_AYUV8_1X32,
+	}, {
+		.name		= "NV12 (YUYV)",
+		.fourcc		= V4L2_PIX_FMT_NV12,
+		.depth		= { 8, 8 },
+		.color		= MXC_ISI_OUT_FMT_YUV420_2P8P,
+		.memplanes	= 2,
+		.colplanes	= 2,
+		.align		= 4,
+		.mbus_code	= MEDIA_BUS_FMT_YUYV8_1X16,
+	}, {
+		.name		= "YUV444M (Y-U-V)",
+		.fourcc		= V4L2_PIX_FMT_YUV444M,
+		.depth		= { 8, 8, 8 },
+		.color		= MXC_ISI_OUT_FMT_YUV444_3P8P,
+		.memplanes	= 3,
+		.colplanes	= 3,
+		.align		= 4,
+		.mbus_code	= MEDIA_BUS_FMT_YUV8_1X24,
+	}, {
+		.name		= "xBGR32",
+		.fourcc		= V4L2_PIX_FMT_XBGR32,
+		.depth		= { 32 },
+		.color		= MXC_ISI_OUT_FMT_XRGB32,
+		.memplanes	= 1,
+		.colplanes	= 1,
+		.align		= 2,
+		.mbus_code	= MEDIA_BUS_FMT_RGB888_1X24,
+	}, {
+		.name		= "ABGR32",
+		.fourcc		= V4L2_PIX_FMT_ABGR32,
+		.depth		= { 32 },
+		.color		= MXC_ISI_OUT_FMT_ARGB32,
+		.memplanes	= 1,
+		.colplanes	= 1,
+		.align		= 2,
+		.mbus_code	= MEDIA_BUS_FMT_RGB888_1X24,
+	}
+};
+
+size_t mxc_isi_out_formats_size = ARRAY_SIZE(mxc_isi_out_formats);
diff --git a/drivers/staging/media/imx/imx8-isi-fmt.h b/drivers/staging/media/imx/imx8-isi-fmt.h
new file mode 100644
index 000000000..d4243943a
--- /dev/null
+++ b/drivers/staging/media/imx/imx8-isi-fmt.h
@@ -0,0 +1,12 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright 2021 NXP
+ */
+
+#ifndef __MXC_ISI_FMT_H__
+#define __MXC_ISI_FMT_H__
+
+extern size_t mxc_isi_out_formats_size;
+extern struct mxc_isi_fmt mxc_isi_out_formats[];
+
+#endif /* __MXC_ISI_FMT_H__ */
diff --git a/drivers/staging/media/imx/imx8-isi-hw.c b/drivers/staging/media/imx/imx8-isi-hw.c
new file mode 100644
index 000000000..08b57fe28
--- /dev/null
+++ b/drivers/staging/media/imx/imx8-isi-hw.c
@@ -0,0 +1,829 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright 2019-2020 NXP
+ *
+ */
+#include <dt-bindings/pinctrl/pads-imx8qxp.h>
+
+#include <linux/module.h>
+#include "imx8-isi-hw.h"
+#include "imx8-common.h"
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("IMX8 Image Sensor Interface Hardware driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1.0");
+
+#define	ISI_DOWNSCALE_THRESHOLD		0x4000
+
+#ifdef DEBUG
+void dump_isi_regs(struct mxc_isi_dev *mxc_isi)
+{
+	struct device *dev = &mxc_isi->pdev->dev;
+	struct {
+		u32 offset;
+		const char *const name;
+	} registers[] = {
+		{ 0x00, "CHNL_CTRL" },
+		{ 0x04, "CHNL_IMG_CTRL" },
+		{ 0x08, "CHNL_OUT_BUF_CTRL" },
+		{ 0x0C, "CHNL_IMG_CFG" },
+		{ 0x10, "CHNL_IER" },
+		{ 0x14, "CHNL_STS" },
+		{ 0x18, "CHNL_SCALE_FACTOR" },
+		{ 0x1C, "CHNL_SCALE_OFFSET" },
+		{ 0x20, "CHNL_CROP_ULC" },
+		{ 0x24, "CHNL_CROP_LRC" },
+		{ 0x28, "CHNL_CSC_COEFF0" },
+		{ 0x2C, "CHNL_CSC_COEFF1" },
+		{ 0x30, "CHNL_CSC_COEFF2" },
+		{ 0x34, "CHNL_CSC_COEFF3" },
+		{ 0x38, "CHNL_CSC_COEFF4" },
+		{ 0x3C, "CHNL_CSC_COEFF5" },
+		{ 0x40, "CHNL_ROI_0_ALPHA" },
+		{ 0x44, "CHNL_ROI_0_ULC" },
+		{ 0x48, "CHNL_ROI_0_LRC" },
+		{ 0x4C, "CHNL_ROI_1_ALPHA" },
+		{ 0x50, "CHNL_ROI_1_ULC" },
+		{ 0x54, "CHNL_ROI_1_LRC" },
+		{ 0x58, "CHNL_ROI_2_ALPHA" },
+		{ 0x5C, "CHNL_ROI_2_ULC" },
+		{ 0x60, "CHNL_ROI_2_LRC" },
+		{ 0x64, "CHNL_ROI_3_ALPHA" },
+		{ 0x68, "CHNL_ROI_3_ULC" },
+		{ 0x6C, "CHNL_ROI_3_LRC" },
+		{ 0x70, "CHNL_OUT_BUF1_ADDR_Y" },
+		{ 0x74, "CHNL_OUT_BUF1_ADDR_U" },
+		{ 0x78, "CHNL_OUT_BUF1_ADDR_V" },
+		{ 0x7C, "CHNL_OUT_BUF_PITCH" },
+		{ 0x80, "CHNL_IN_BUF_ADDR" },
+		{ 0x84, "CHNL_IN_BUF_PITCH" },
+		{ 0x88, "CHNL_MEM_RD_CTRL" },
+		{ 0x8C, "CHNL_OUT_BUF2_ADDR_Y" },
+		{ 0x90, "CHNL_OUT_BUF2_ADDR_U" },
+		{ 0x94, "CHNL_OUT_BUF2_ADDR_V" },
+		{ 0x98, "CHNL_SCL_IMG_CFG" },
+		{ 0x9C, "CHNL_FLOW_CTRL" },
+	};
+	u32 i;
+
+	dev_dbg(dev, "ISI CHNLC register dump, isi%d\n", mxc_isi->id);
+	for (i = 0; i < ARRAY_SIZE(registers); i++) {
+		u32 reg = readl(mxc_isi->regs + registers[i].offset);
+		dev_dbg(dev, "%20s[0x%.2x]: %.2x\n",
+			registers[i].name, registers[i].offset, reg);
+	}
+}
+#else
+void dump_isi_regs(struct mxc_isi_dev *mxc_isi)
+{
+}
+#endif
+
+/* 
+ * A2,A1,      B1, A3,     B3, B2,
+ * C2, C1,     D1, C3,     D3, D2
+ */
+static const u32 coeffs[2][6] = {
+	/* YUV2RGB */
+	{ 0x0000012A, 0x012A0198, 0x0730079C,
+	  0x0204012A, 0x01F00000, 0x01800180 },
+
+	/* RGB->YUV */
+	{ 0x00810041, 0x07db0019, 0x007007b6,
+	  0x07a20070, 0x001007ee, 0x00800080 },
+};
+
+static void printk_pixelformat(char *prefix, int val)
+{
+	pr_info("%s %c%c%c%c\n", prefix ? prefix : "pixelformat",
+		val & 0xff,
+		(val >> 8)  & 0xff,
+		(val >> 16) & 0xff,
+		(val >> 24) & 0xff);
+}
+
+static bool is_rgb(u32 pix_fmt)
+{
+	if ((pix_fmt == V4L2_PIX_FMT_RGB565) ||
+	    (pix_fmt == V4L2_PIX_FMT_RGB24)  ||
+	    (pix_fmt == V4L2_PIX_FMT_RGB32)  ||
+	    (pix_fmt == V4L2_PIX_FMT_BGR32)  ||
+	    (pix_fmt == V4L2_PIX_FMT_XRGB32) ||
+	    (pix_fmt == V4L2_PIX_FMT_XBGR32) ||
+	    (pix_fmt == V4L2_PIX_FMT_BGR24)  ||
+	    (pix_fmt == V4L2_PIX_FMT_RGBA32) ||
+	    (pix_fmt == V4L2_PIX_FMT_ABGR32) ||
+	    (pix_fmt == V4L2_PIX_FMT_ARGB32))
+		return true;
+	else
+		return false;
+}
+
+static bool is_yuv(u32 pix_fmt)
+{
+	if ((pix_fmt == V4L2_PIX_FMT_YUYV)  ||
+	    (pix_fmt == V4L2_PIX_FMT_YUV32) ||
+	    (pix_fmt == V4L2_PIX_FMT_YUV444M) ||
+	    (pix_fmt == V4L2_PIX_FMT_NV12))
+		return true;
+	else
+		return false;
+}
+
+bool is_buf_active(struct mxc_isi_dev *mxc_isi, int buf_id)
+{
+	u32 status = mxc_isi->status;
+	bool reverse = mxc_isi->buf_active_reverse;
+
+	return (buf_id == 1) ? ((reverse) ? (status & 0x100) : (status & 0x200)) :
+			       ((reverse) ? (status & 0x200) : (status & 0x100));
+}
+EXPORT_SYMBOL_GPL(is_buf_active);
+
+static void chain_buf(struct mxc_isi_dev *mxc_isi, struct mxc_isi_frame *frm)
+{
+	u32 val;
+
+	if (frm->o_width > ISI_2K) {
+		val = readl(mxc_isi->regs + CHNL_CTRL);
+		val &= ~CHNL_CTRL_CHAIN_BUF_MASK;
+		val |= (CHNL_CTRL_CHAIN_BUF_2_CHAIN << CHNL_CTRL_CHAIN_BUF_OFFSET);
+		writel(val, mxc_isi->regs + CHNL_CTRL);
+		if (mxc_isi->chain)
+			regmap_write(mxc_isi->chain, CHNL_CTRL, CHNL_CTRL_CLK_EN_MASK);
+		mxc_isi->chain_buf = 1;
+	} else {
+		val = readl(mxc_isi->regs + CHNL_CTRL);
+		val &= ~CHNL_CTRL_CHAIN_BUF_MASK;
+		writel(val, mxc_isi->regs + CHNL_CTRL);
+		mxc_isi->chain_buf = 0;
+	}
+}
+
+struct device *mxc_isi_dev_get_parent(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *parent;
+	struct platform_device *parent_pdev;
+
+	if (!pdev)
+		return NULL;
+
+	/* Get parent for isi capture device */
+	parent = of_get_parent(dev->of_node);
+	parent_pdev = of_find_device_by_node(parent);
+	if (!parent_pdev) {
+		of_node_put(parent);
+		return NULL;
+	}
+	of_node_put(parent);
+
+	return &parent_pdev->dev;
+}
+EXPORT_SYMBOL_GPL(mxc_isi_dev_get_parent);
+
+struct mxc_isi_dev *mxc_isi_get_hostdata(struct platform_device *pdev)
+{
+	struct mxc_isi_dev *mxc_isi;
+
+	if (!pdev || !pdev->dev.parent)
+		return NULL;
+
+	mxc_isi = (struct mxc_isi_dev *)dev_get_drvdata(pdev->dev.parent);
+	if (!mxc_isi)
+		return NULL;
+
+	return mxc_isi;
+}
+EXPORT_SYMBOL_GPL(mxc_isi_get_hostdata);
+
+void mxc_isi_channel_set_outbuf(struct mxc_isi_dev *mxc_isi,
+				struct mxc_isi_buffer *buf)
+{
+	struct vb2_buffer *vb2_buf = &buf->v4l2_buf.vb2_buf;
+	u32 framecount = buf->v4l2_buf.sequence;
+	struct frame_addr *paddr = &buf->paddr;
+	struct mxc_isi_cap_dev *isi_cap;
+	struct v4l2_pix_format_mplane *pix;
+	int val = 0;
+
+	if (buf->discard) {
+		isi_cap = mxc_isi->isi_cap;
+		pix = &isi_cap->pix;
+		paddr->y = isi_cap->discard_buffer_dma[0];
+		if (pix->num_planes == 2)
+			paddr->cb = isi_cap->discard_buffer_dma[1];
+		if (pix->num_planes == 3) {
+			paddr->cb = isi_cap->discard_buffer_dma[1];
+			paddr->cr = isi_cap->discard_buffer_dma[2];
+		}
+	} else {
+		paddr->y = vb2_dma_contig_plane_dma_addr(vb2_buf, 0);
+
+		if (vb2_buf->num_planes == 2)
+			paddr->cb = vb2_dma_contig_plane_dma_addr(vb2_buf, 1);
+		if (vb2_buf->num_planes == 3) {
+			paddr->cb = vb2_dma_contig_plane_dma_addr(vb2_buf, 1);
+			paddr->cr = vb2_dma_contig_plane_dma_addr(vb2_buf, 2);
+		}
+	}
+
+	val = readl(mxc_isi->regs + CHNL_OUT_BUF_CTRL);
+
+	if (framecount == 0 || ((is_buf_active(mxc_isi, 2)) && (framecount != 1))) {
+		writel(paddr->y, mxc_isi->regs + CHNL_OUT_BUF1_ADDR_Y);
+		writel(paddr->cb, mxc_isi->regs + CHNL_OUT_BUF1_ADDR_U);
+		writel(paddr->cr, mxc_isi->regs + CHNL_OUT_BUF1_ADDR_V);
+		val ^= CHNL_OUT_BUF_CTRL_LOAD_BUF1_ADDR_MASK;
+		buf->id = MXC_ISI_BUF1;
+	} else if (framecount == 1 || is_buf_active(mxc_isi, 1)) {
+		writel(paddr->y, mxc_isi->regs + CHNL_OUT_BUF2_ADDR_Y);
+		writel(paddr->cb, mxc_isi->regs + CHNL_OUT_BUF2_ADDR_U);
+		writel(paddr->cr, mxc_isi->regs + CHNL_OUT_BUF2_ADDR_V);
+		val ^= CHNL_OUT_BUF_CTRL_LOAD_BUF2_ADDR_MASK;
+		buf->id = MXC_ISI_BUF2;
+	}
+	writel(val, mxc_isi->regs + CHNL_OUT_BUF_CTRL);
+}
+EXPORT_SYMBOL_GPL(mxc_isi_channel_set_outbuf);
+
+void mxc_isi_channel_set_m2m_src_addr(struct mxc_isi_dev *mxc_isi,
+			struct mxc_isi_buffer *buf)
+{
+	struct vb2_buffer *vb2_buf = &buf->v4l2_buf.vb2_buf;
+	struct frame_addr *paddr = &buf->paddr;
+
+	/* Only support one plane */
+	paddr->y = vb2_dma_contig_plane_dma_addr(vb2_buf, 0);
+	writel(paddr->y, mxc_isi->regs + CHNL_IN_BUF_ADDR);
+}
+EXPORT_SYMBOL_GPL(mxc_isi_channel_set_m2m_src_addr);
+
+void mxc_isi_channel_sw_reset(struct mxc_isi_dev *mxc_isi)
+{
+	u32 val;
+
+	val = readl(mxc_isi->regs + CHNL_CTRL);
+	val |= CHNL_CTRL_SW_RST;
+	writel(val, mxc_isi->regs + CHNL_CTRL);
+	mdelay(5);
+	val &= ~CHNL_CTRL_SW_RST;
+	writel(val, mxc_isi->regs + CHNL_CTRL);
+}
+EXPORT_SYMBOL_GPL(mxc_isi_channel_sw_reset);
+
+void mxc_isi_channel_source_config(struct mxc_isi_dev *mxc_isi)
+{
+	u32 val;
+
+	val = readl(mxc_isi->regs + CHNL_CTRL);
+	val &= ~(CHNL_CTRL_MIPI_VC_ID_MASK |
+		 CHNL_CTRL_SRC_INPUT_MASK | CHNL_CTRL_SRC_TYPE_MASK);
+
+	switch (mxc_isi->interface[IN_PORT]) {
+	case ISI_INPUT_INTERFACE_MIPI0_CSI2:
+		val |= mxc_isi->pdata->chan_src->src_mipi0;
+		if (mxc_isi->interface[SUB_IN_PORT] <= CHNL_CTRL_MIPI_VC_ID_VC3 &&
+		    mxc_isi->interface[SUB_IN_PORT] >= CHNL_CTRL_MIPI_VC_ID_VC0)
+			val |= (mxc_isi->interface[SUB_IN_PORT] << CHNL_CTRL_MIPI_VC_ID_OFFSET);
+		break;
+	case ISI_INPUT_INTERFACE_MIPI1_CSI2:
+		val |= mxc_isi->pdata->chan_src->src_mipi1;
+		if (mxc_isi->interface[SUB_IN_PORT] <= CHNL_CTRL_MIPI_VC_ID_VC3 &&
+		    mxc_isi->interface[SUB_IN_PORT] >= CHNL_CTRL_MIPI_VC_ID_VC0)
+			val |= (mxc_isi->interface[SUB_IN_PORT] << CHNL_CTRL_MIPI_VC_ID_OFFSET);
+		break;
+	case ISI_INPUT_INTERFACE_DC0:
+		val |= mxc_isi->pdata->chan_src->src_dc0;
+		break;
+	case ISI_INPUT_INTERFACE_DC1:
+		val |= mxc_isi->pdata->chan_src->src_dc1;
+		break;
+	case ISI_INPUT_INTERFACE_HDMI:
+		val |= mxc_isi->pdata->chan_src->src_hdmi;
+		break;
+	case ISI_INPUT_INTERFACE_PARALLEL_CSI:
+		val |= mxc_isi->pdata->chan_src->src_csi;
+		break;
+	case ISI_INPUT_INTERFACE_MEM:
+		val |= mxc_isi->pdata->chan_src->src_mem;
+		val |= (CHNL_CTRL_SRC_TYPE_MEMORY << CHNL_CTRL_SRC_TYPE_OFFSET);
+		break;
+	default:
+		dev_err(&mxc_isi->pdev->dev, "invalid interface\n");
+		break;
+	}
+
+	writel(val, mxc_isi->regs + CHNL_CTRL);
+}
+EXPORT_SYMBOL_GPL(mxc_isi_channel_source_config);
+
+void mxc_isi_channel_set_flip(struct mxc_isi_dev *mxc_isi)
+{
+	u32 val;
+
+	val = readl(mxc_isi->regs + CHNL_IMG_CTRL);
+	val &= ~(CHNL_IMG_CTRL_VFLIP_EN_MASK | CHNL_IMG_CTRL_HFLIP_EN_MASK);
+
+	if (mxc_isi->vflip)
+		val |= (CHNL_IMG_CTRL_VFLIP_EN_ENABLE << CHNL_IMG_CTRL_VFLIP_EN_OFFSET);
+	if (mxc_isi->hflip)
+		val |= (CHNL_IMG_CTRL_HFLIP_EN_ENABLE << CHNL_IMG_CTRL_HFLIP_EN_OFFSET);
+
+	writel(val, mxc_isi->regs + CHNL_IMG_CTRL);
+}
+EXPORT_SYMBOL_GPL(mxc_isi_channel_set_chain_buf);
+
+void mxc_isi_channel_set_csc(struct mxc_isi_dev *mxc_isi,
+			     struct mxc_isi_frame *src_f,
+			     struct mxc_isi_frame *dst_f)
+{
+	struct mxc_isi_fmt *src_fmt = src_f->fmt;
+	struct mxc_isi_fmt *dst_fmt = dst_f->fmt;
+	u32 val, csc = 0;
+
+	val = readl(mxc_isi->regs + CHNL_IMG_CTRL);
+	val &= ~(CHNL_IMG_CTRL_FORMAT_MASK |
+		 CHNL_IMG_CTRL_YCBCR_MODE_MASK |
+		 CHNL_IMG_CTRL_CSC_BYPASS_MASK |
+		 CHNL_IMG_CTRL_CSC_MODE_MASK);
+
+	/* set outbuf format */
+	val |= dst_fmt->color << CHNL_IMG_CTRL_FORMAT_OFFSET;
+
+	mxc_isi->cscen = 1;
+
+	if (is_yuv(src_fmt->fourcc) && is_rgb(dst_fmt->fourcc)) {
+		/* YUV2RGB */
+		csc = YUV2RGB;
+		/* YCbCr enable???  */
+		val |= (CHNL_IMG_CTRL_CSC_MODE_YCBCR2RGB << CHNL_IMG_CTRL_CSC_MODE_OFFSET);
+		val |= (CHNL_IMG_CTRL_YCBCR_MODE_ENABLE << CHNL_IMG_CTRL_YCBCR_MODE_OFFSET);
+	} else if (is_rgb(src_fmt->fourcc) && is_yuv(dst_fmt->fourcc)) {
+		/* RGB2YUV */
+		csc = RGB2YUV;
+		val |= (CHNL_IMG_CTRL_CSC_MODE_RGB2YCBCR << CHNL_IMG_CTRL_CSC_MODE_OFFSET);
+	} else {
+		/* Bypass CSC */
+		pr_info("bypass csc\n");
+		mxc_isi->cscen = 0;
+		val |= CHNL_IMG_CTRL_CSC_BYPASS_ENABLE;
+	}
+
+	printk_pixelformat("input fmt", src_fmt->fourcc);
+	printk_pixelformat("output fmt", dst_fmt->fourcc);
+
+	if (mxc_isi->cscen) {
+		writel(coeffs[csc][0], mxc_isi->regs + CHNL_CSC_COEFF0);
+		writel(coeffs[csc][1], mxc_isi->regs + CHNL_CSC_COEFF1);
+		writel(coeffs[csc][2], mxc_isi->regs + CHNL_CSC_COEFF2);
+		writel(coeffs[csc][3], mxc_isi->regs + CHNL_CSC_COEFF3);
+		writel(coeffs[csc][4], mxc_isi->regs + CHNL_CSC_COEFF4);
+		writel(coeffs[csc][5], mxc_isi->regs + CHNL_CSC_COEFF5);
+	}
+
+	writel(val, mxc_isi->regs + CHNL_IMG_CTRL);
+}
+
+void mxc_isi_channel_set_alpha_roi0(struct mxc_isi_dev *mxc_isi,
+				    struct v4l2_rect *rect)
+{
+	u32 val0, val1;
+
+	val0 = (rect->left << 16) | rect->top;
+	writel(val0, mxc_isi->regs + CHNL_ROI_0_ULC);
+	val1 = (rect->width << 16) | rect->height;
+	writel(val0 + val1, mxc_isi->regs + CHNL_ROI_0_LRC);
+}
+
+void mxc_isi_channel_set_alpha(struct mxc_isi_dev *mxc_isi)
+{
+	u32 val;
+
+	val = readl(mxc_isi->regs + CHNL_IMG_CTRL);
+	val &= ~(CHNL_IMG_CTRL_GBL_ALPHA_VAL_MASK | CHNL_IMG_CTRL_GBL_ALPHA_EN_MASK);
+
+	if (mxc_isi->alphaen)
+		val |= ((mxc_isi->alpha << CHNL_IMG_CTRL_GBL_ALPHA_VAL_OFFSET) |
+			(CHNL_IMG_CTRL_GBL_ALPHA_EN_ENABLE << CHNL_IMG_CTRL_GBL_ALPHA_EN_OFFSET));
+
+	writel(val, mxc_isi->regs + CHNL_IMG_CTRL);
+}
+
+void mxc_isi_channel_set_panic_threshold(struct mxc_isi_dev *mxc_isi)
+{
+	struct mxc_isi_set_thd *set_thd = mxc_isi->pdata->set_thd;
+	u32 val;
+
+	val = readl(mxc_isi->regs + CHNL_OUT_BUF_CTRL);
+
+	val &= ~(set_thd->panic_set_thd_y.mask);
+	val |= set_thd->panic_set_thd_y.threshold << set_thd->panic_set_thd_y.offset;
+
+	val &= ~(set_thd->panic_set_thd_u.mask);
+	val |= set_thd->panic_set_thd_u.threshold << set_thd->panic_set_thd_u.offset;
+
+	val &= ~(set_thd->panic_set_thd_v.mask);
+	val |= set_thd->panic_set_thd_v.threshold << set_thd->panic_set_thd_v.offset;
+
+	writel(val, mxc_isi->regs + CHNL_OUT_BUF_CTRL);
+}
+
+void mxc_isi_channel_set_chain_buf(struct mxc_isi_dev *mxc_isi)
+{
+	u32 val;
+
+	if (mxc_isi->chain_buf) {
+		val = readl(mxc_isi->regs + CHNL_CTRL);
+		val &= ~CHNL_CTRL_CHAIN_BUF_MASK;
+		val |= (CHNL_CTRL_CHAIN_BUF_2_CHAIN << CHNL_CTRL_CHAIN_BUF_OFFSET);
+
+		writel(val, mxc_isi->regs + CHNL_CTRL);
+	}
+}
+
+void mxc_isi_channel_deinterlace_init(struct mxc_isi_dev *mxc_isi)
+{
+	/* Config for Blending deinterlace */
+}
+
+void mxc_isi_channel_set_deinterlace(struct mxc_isi_dev *mxc_isi)
+{
+	/* de-interlacing method
+	 * Weaving-------------Yes
+	 * Line Doubling-------No
+	 * Blending -----------TODO
+	 */
+	u32 val;
+
+	val = readl(mxc_isi->regs + CHNL_IMG_CTRL);
+	val &= ~CHNL_IMG_CTRL_DEINT_MASK;
+	if (mxc_isi->deinterlace)
+		val |= mxc_isi->deinterlace << CHNL_IMG_CTRL_DEINT_OFFSET;
+	if ((mxc_isi->deinterlace == CHNL_IMG_CTRL_DEINT_LDOUBLE_ODD_EVEN) ||
+	    (mxc_isi->deinterlace == CHNL_IMG_CTRL_DEINT_LDOUBLE_EVEN_ODD))
+		mxc_isi_channel_deinterlace_init(mxc_isi);
+
+	writel(val, mxc_isi->regs + CHNL_IMG_CTRL);
+}
+
+void mxc_isi_channel_set_crop(struct mxc_isi_dev *mxc_isi,
+			      struct mxc_isi_frame *dst_f)
+{
+	struct v4l2_rect crop;
+	u32 val, val0, val1;
+
+	val = readl(mxc_isi->regs + CHNL_IMG_CTRL);
+	val &= ~CHNL_IMG_CTRL_CROP_EN_MASK;
+
+	if ((dst_f->o_height == dst_f->c_height) &&
+	    (dst_f->o_width == dst_f->c_width)) {
+		mxc_isi->crop = 0;
+		writel(val, mxc_isi->regs + CHNL_IMG_CTRL);
+		return;
+	}
+
+	crop.left = dst_f->h_off;
+	crop.top  = dst_f->v_off;
+	crop.width  = dst_f->c_width - 1;
+	crop.height = dst_f->c_height - 1;
+
+	mxc_isi->crop = 1;
+	val |= (CHNL_IMG_CTRL_CROP_EN_ENABLE << CHNL_IMG_CTRL_CROP_EN_OFFSET);
+	val0 = crop.top | (crop.left << CHNL_CROP_ULC_X_OFFSET);
+	val1 = (crop.top + crop.height) | ((crop.left + crop.width) << CHNL_CROP_LRC_X_OFFSET);
+
+	writel(val0, mxc_isi->regs + CHNL_CROP_ULC);
+	writel(val1, mxc_isi->regs + CHNL_CROP_LRC);
+	writel(val, mxc_isi->regs + CHNL_IMG_CTRL);
+}
+
+static void mxc_isi_channel_clear_scaling(struct mxc_isi_dev *mxc_isi)
+{
+	u32 val0;
+
+	writel(0x10001000, mxc_isi->regs + CHNL_SCALE_FACTOR);
+
+	val0 = readl(mxc_isi->regs + CHNL_IMG_CTRL);
+	val0 &= ~(CHNL_IMG_CTRL_DEC_X_MASK | CHNL_IMG_CTRL_DEC_Y_MASK);
+	writel(val0, mxc_isi->regs + CHNL_IMG_CTRL);
+}
+
+void mxc_isi_channel_set_scaling(struct mxc_isi_dev *mxc_isi,
+				 struct mxc_isi_frame *src_f,
+				 struct mxc_isi_frame *dst_f)
+{
+	u32 decx, decy;
+	u32 xscale, yscale;
+	u32 xdec = 0, ydec = 0;
+	u32 val0, val1;
+
+	if (dst_f->height == src_f->height &&
+	    dst_f->width == src_f->width) {
+		mxc_isi->scale = 0;
+		mxc_isi_channel_clear_scaling(mxc_isi);
+		dev_dbg(&mxc_isi->pdev->dev, "%s: no scale\n", __func__);
+		return;
+	}
+
+	dev_info(&mxc_isi->pdev->dev, "input_size(%d,%d), output_size(%d,%d)\n",
+		 src_f->width, src_f->height, dst_f->width, dst_f->height);
+
+	mxc_isi->scale = 1;
+
+	decx = src_f->width / dst_f->width;
+	decy = src_f->height / dst_f->height;
+
+	if (decx > 1) {
+		/* Down */
+		if (decx >= 2 && decx < 4) {
+			decx = 2;
+			xdec = 1;
+		} else if (decx >= 4 && decx < 8) {
+			decx = 4;
+			xdec = 2;
+		} else if (decx >= 8) {
+			decx = 8;
+			xdec = 3;
+		}
+		xscale = src_f->width * 0x1000 / (dst_f->width * decx);
+	} else {
+		/* Up  */
+		xscale = src_f->width * 0x1000 / dst_f->width;
+	}
+
+	if (decy > 1) {
+		if (decy >= 2 && decy < 4) {
+			decy = 2;
+			ydec = 1;
+		} else if (decy >= 4 && decy < 8) {
+			decy = 4;
+			ydec = 2;
+		} else if (decy >= 8) {
+			decy = 8;
+			ydec = 3;
+		}
+		yscale = src_f->height * 0x1000 / (dst_f->height * decy);
+	} else {
+		yscale = src_f->height * 0x1000 / dst_f->height;
+	}
+
+	val0 = readl(mxc_isi->regs + CHNL_IMG_CTRL);
+	val0 |= CHNL_IMG_CTRL_YCBCR_MODE_MASK;//YCbCr  Sandor???
+	val0 &= ~(CHNL_IMG_CTRL_DEC_X_MASK | CHNL_IMG_CTRL_DEC_Y_MASK);
+	val0 |= (xdec << CHNL_IMG_CTRL_DEC_X_OFFSET) |
+			(ydec << CHNL_IMG_CTRL_DEC_Y_OFFSET);
+	writel(val0, mxc_isi->regs + CHNL_IMG_CTRL);
+
+	if (xscale > ISI_DOWNSCALE_THRESHOLD)
+		xscale = ISI_DOWNSCALE_THRESHOLD;
+	if (yscale > ISI_DOWNSCALE_THRESHOLD)
+		yscale = ISI_DOWNSCALE_THRESHOLD;
+
+	val1 = xscale | (yscale << CHNL_SCALE_FACTOR_Y_SCALE_OFFSET);
+
+	writel(val1, mxc_isi->regs + CHNL_SCALE_FACTOR);
+
+	/* Update scale config if scaling enabled */
+	val1 = dst_f->o_width | (dst_f->o_height << CHNL_SCL_IMG_CFG_HEIGHT_OFFSET);
+	writel(val1, mxc_isi->regs + CHNL_SCL_IMG_CFG);
+
+	writel(0, mxc_isi->regs + CHNL_SCALE_OFFSET);
+
+	return;
+}
+
+void mxc_isi_channel_init(struct mxc_isi_dev *mxc_isi)
+{
+	u32 val;
+
+	/* sw reset */
+	mxc_isi_channel_sw_reset(mxc_isi);
+
+	/* Init channel clk first */
+	val = readl(mxc_isi->regs + CHNL_CTRL);
+	val |= (CHNL_CTRL_CLK_EN_ENABLE << CHNL_CTRL_CLK_EN_OFFSET);
+	writel(val, mxc_isi->regs + CHNL_CTRL);
+}
+EXPORT_SYMBOL_GPL(mxc_isi_channel_init);
+
+void mxc_isi_channel_deinit(struct mxc_isi_dev *mxc_isi)
+{
+	u32 val;
+
+	/* sw reset */
+	mxc_isi_channel_sw_reset(mxc_isi);
+
+	/* deinit channel clk first */
+	val = (CHNL_CTRL_CLK_EN_DISABLE << CHNL_CTRL_CLK_EN_OFFSET);
+	writel(val, mxc_isi->regs + CHNL_CTRL);
+
+	if (mxc_isi->chain_buf && mxc_isi->chain)
+		regmap_write(mxc_isi->chain, CHNL_CTRL, 0x0);
+}
+EXPORT_SYMBOL_GPL(mxc_isi_channel_deinit);
+
+void mxc_isi_channel_config(struct mxc_isi_dev *mxc_isi,
+			    struct mxc_isi_frame *src_f,
+			    struct mxc_isi_frame *dst_f)
+{
+	u32 val;
+
+	/* images having higher than 2048 horizontal resolution */
+	chain_buf(mxc_isi, src_f);
+
+	/* config output frame size and format */
+	val = src_f->o_width | (src_f->o_height << CHNL_IMG_CFG_HEIGHT_OFFSET);
+	writel(val, mxc_isi->regs + CHNL_IMG_CFG);
+
+	/* scale size need to equal input size when scaling disabled*/
+	writel(val, mxc_isi->regs + CHNL_SCL_IMG_CFG);
+
+	/* check csc and scaling  */
+	mxc_isi_channel_set_csc(mxc_isi, src_f, dst_f);
+
+	mxc_isi_channel_set_scaling(mxc_isi, src_f, dst_f);
+
+	/* set cropping */
+	mxc_isi_channel_set_crop(mxc_isi, dst_f);
+
+	/* select the source input / src type / virtual channel for mipi*/
+	mxc_isi_channel_source_config(mxc_isi);
+
+	/* line pitch */
+	val = dst_f->bytesperline[0];
+	writel(val, mxc_isi->regs + CHNL_OUT_BUF_PITCH);
+
+	/* TODO */
+	mxc_isi_channel_set_flip(mxc_isi);
+
+	mxc_isi_channel_set_alpha(mxc_isi);
+
+	mxc_isi_channel_set_panic_threshold(mxc_isi);
+
+	val = readl(mxc_isi->regs + CHNL_CTRL);
+	val &= ~CHNL_CTRL_CHNL_BYPASS_MASK;
+
+	/*  Bypass channel */
+	if (!mxc_isi->cscen && !mxc_isi->scale)
+		val |= (CHNL_CTRL_CHNL_BYPASS_ENABLE << CHNL_CTRL_CHNL_BYPASS_OFFSET);
+
+	writel(val, mxc_isi->regs + CHNL_CTRL);
+}
+EXPORT_SYMBOL_GPL(mxc_isi_channel_config);
+
+void mxc_isi_clean_registers(struct mxc_isi_dev *mxc_isi)
+{
+	u32 status;
+
+	status = mxc_isi_get_irq_status(mxc_isi);
+	mxc_isi_clean_irq_status(mxc_isi, status);
+}
+EXPORT_SYMBOL_GPL(mxc_isi_clean_registers);
+
+void mxc_isi_channel_enable(struct mxc_isi_dev *mxc_isi, bool m2m_enabled)
+{
+	u32 val;
+
+	val = readl(mxc_isi->regs + CHNL_CTRL);
+	val |= 0xff << CHNL_CTRL_BLANK_PXL_OFFSET;
+
+	if (m2m_enabled) {
+		val &= ~(CHNL_CTRL_SRC_TYPE_MASK | CHNL_CTRL_SRC_INPUT_MASK);
+		val |= (mxc_isi->pdata->chan_src->src_mem << CHNL_CTRL_SRC_INPUT_OFFSET |
+			CHNL_CTRL_SRC_TYPE_MEMORY << CHNL_CTRL_SRC_TYPE_OFFSET);
+	}
+
+	val &= ~CHNL_CTRL_CHNL_EN_MASK;
+	val |= CHNL_CTRL_CHNL_EN_ENABLE << CHNL_CTRL_CHNL_EN_OFFSET;
+	writel(val, mxc_isi->regs + CHNL_CTRL);
+
+	mxc_isi_clean_registers(mxc_isi);
+	mxc_isi_enable_irq(mxc_isi);
+
+	if (m2m_enabled) {
+		mxc_isi_m2m_start_read(mxc_isi);
+		return;
+	}
+
+	dump_isi_regs(mxc_isi);
+	msleep(300);
+}
+EXPORT_SYMBOL_GPL(mxc_isi_channel_enable);
+
+void mxc_isi_channel_disable(struct mxc_isi_dev *mxc_isi)
+{
+	u32 val;
+
+	mxc_isi_disable_irq(mxc_isi);
+
+	val = readl(mxc_isi->regs + CHNL_CTRL);
+	val &= ~(CHNL_CTRL_CHNL_EN_MASK | CHNL_CTRL_CLK_EN_MASK);
+	val |= (CHNL_CTRL_CHNL_EN_DISABLE << CHNL_CTRL_CHNL_EN_OFFSET);
+	val |= (CHNL_CTRL_CLK_EN_DISABLE << CHNL_CTRL_CLK_EN_OFFSET);
+	writel(val, mxc_isi->regs + CHNL_CTRL);
+}
+EXPORT_SYMBOL_GPL(mxc_isi_channel_disable);
+
+void  mxc_isi_enable_irq(struct mxc_isi_dev *mxc_isi)
+{
+	struct mxc_isi_ier_reg *ier_reg = mxc_isi->pdata->ier_reg;
+	u32 val;
+
+	val = CHNL_IER_FRM_RCVD_EN_MASK |
+		CHNL_IER_AXI_WR_ERR_U_EN_MASK |
+		CHNL_IER_AXI_WR_ERR_V_EN_MASK |
+		CHNL_IER_AXI_WR_ERR_Y_EN_MASK;
+
+	/* Y/U/V overflow enable */
+	val |= ier_reg->oflw_y_buf_en.mask |
+	       ier_reg->oflw_u_buf_en.mask |
+	       ier_reg->oflw_v_buf_en.mask;
+
+	/* Y/U/V excess overflow enable */
+	val |= ier_reg->excs_oflw_y_buf_en.mask |
+	       ier_reg->excs_oflw_u_buf_en.mask |
+	       ier_reg->excs_oflw_v_buf_en.mask;
+
+	/* Y/U/V panic enable */
+	val |= ier_reg->panic_y_buf_en.mask |
+	       ier_reg->panic_u_buf_en.mask |
+	       ier_reg->panic_v_buf_en.mask;
+
+	writel(val, mxc_isi->regs + CHNL_IER);
+}
+EXPORT_SYMBOL_GPL(mxc_isi_enable_irq);
+
+void mxc_isi_disable_irq(struct mxc_isi_dev *mxc_isi)
+{
+	writel(0, mxc_isi->regs + CHNL_IER);
+}
+EXPORT_SYMBOL_GPL(mxc_isi_disable_irq);
+
+u32 mxc_isi_get_irq_status(struct mxc_isi_dev *mxc_isi)
+{
+	return readl(mxc_isi->regs + CHNL_STS);
+}
+EXPORT_SYMBOL_GPL(mxc_isi_get_irq_status);
+
+void mxc_isi_clean_irq_status(struct mxc_isi_dev *mxc_isi, u32 val)
+{
+	writel(val, mxc_isi->regs + CHNL_STS);
+}
+EXPORT_SYMBOL_GPL(mxc_isi_clean_irq_status);
+
+void mxc_isi_m2m_config_src(struct mxc_isi_dev *mxc_isi,
+			    struct mxc_isi_frame *src_f)
+{
+	u32 val;
+
+	/* source format */
+	val = readl(mxc_isi->regs + CHNL_MEM_RD_CTRL);
+	val &= ~CHNL_MEM_RD_CTRL_IMG_TYPE_MASK;
+	val |= src_f->fmt->color << CHNL_MEM_RD_CTRL_IMG_TYPE_OFFSET;
+	writel(val, mxc_isi->regs + CHNL_MEM_RD_CTRL);
+
+	/* source image width and height */
+	val = (src_f->width << CHNL_IMG_CFG_WIDTH_OFFSET |
+	       src_f->height << CHNL_IMG_CFG_HEIGHT_OFFSET);
+	writel(val, mxc_isi->regs + CHNL_IMG_CFG);
+
+	/* source pitch */
+	val = src_f->bytesperline[0] << CHNL_IN_BUF_PITCH_LINE_PITCH_OFFSET;
+	writel(val, mxc_isi->regs + CHNL_IN_BUF_PITCH);
+}
+EXPORT_SYMBOL_GPL(mxc_isi_m2m_config_src);
+
+void mxc_isi_m2m_config_dst(struct mxc_isi_dev *mxc_isi,
+			    struct mxc_isi_frame *dst_f)
+{
+	u32 val;
+
+	/* out format */
+	val = readl(mxc_isi->regs + CHNL_IMG_CTRL);
+	val &= ~CHNL_IMG_CTRL_FORMAT_MASK;
+	val |= dst_f->fmt->color << CHNL_IMG_CTRL_FORMAT_OFFSET;
+	writel(val, mxc_isi->regs + CHNL_IMG_CTRL);
+
+	/* out pitch */
+	val = readl(mxc_isi->regs + CHNL_OUT_BUF_PITCH);
+	val &= ~CHNL_IN_BUF_PITCH_LINE_PITCH_MASK;
+	val |= dst_f->bytesperline[0] << CHNL_OUT_BUF_PITCH_LINE_PITCH_OFFSET;
+	writel(val, mxc_isi->regs + CHNL_OUT_BUF_PITCH);
+}
+EXPORT_SYMBOL_GPL(mxc_isi_m2m_config_dst);
+
+void mxc_isi_m2m_start_read(struct mxc_isi_dev *mxc_isi)
+{
+	u32 val;
+
+	val = readl(mxc_isi->regs + CHNL_MEM_RD_CTRL);
+	val &= ~ CHNL_MEM_RD_CTRL_READ_MEM_MASK;
+	writel(val, mxc_isi->regs + CHNL_MEM_RD_CTRL);
+	udelay(300);
+
+	val |= CHNL_MEM_RD_CTRL_READ_MEM_ENABLE << CHNL_MEM_RD_CTRL_READ_MEM_OFFSET;
+	writel(val, mxc_isi->regs + CHNL_MEM_RD_CTRL);
+}
+EXPORT_SYMBOL_GPL(mxc_isi_m2m_start_read);
diff --git a/drivers/staging/media/imx/imx8-isi-hw.h b/drivers/staging/media/imx/imx8-isi-hw.h
new file mode 100644
index 000000000..f9979362f
--- /dev/null
+++ b/drivers/staging/media/imx/imx8-isi-hw.h
@@ -0,0 +1,485 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright 2019-2020 NXP
+ *
+ */
+
+#ifndef __MXC_ISI_HW_H__
+#define __MXC_ISI_HW_H__
+
+#include <linux/delay.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/bug.h>
+#include <linux/platform_device.h>
+#include <linux/videodev2.h>
+
+#include "imx8-isi-core.h"
+
+/* ISI Registers Define  */
+/* Channel Control Register */
+#define  CHNL_CTRL				0x0
+#define  CHNL_CTRL_CHNL_EN_OFFSET		31
+#define  CHNL_CTRL_CHNL_EN_MASK			0x80000000
+#define  CHNL_CTRL_CHNL_EN_DISABLE		0
+#define  CHNL_CTRL_CHNL_EN_ENABLE		1
+#define  CHNL_CTRL_CLK_EN_OFFSET		30
+#define  CHNL_CTRL_CLK_EN_MASK			0x40000000
+#define  CHNL_CTRL_CLK_EN_DISABLE		0
+#define  CHNL_CTRL_CLK_EN_ENABLE		1
+#define  CHNL_CTRL_CHNL_BYPASS_OFFSET		29
+#define  CHNL_CTRL_CHNL_BYPASS_MASK		0x20000000
+#define  CHNL_CTRL_CHNL_BYPASS_ENABLE		1
+#define  CHNL_CTRL_CHAIN_BUF_OFFSET		25
+#define  CHNL_CTRL_CHAIN_BUF_MASK		0x6000000
+#define  CHNL_CTRL_CHAIN_BUF_NO_CHAIN		0
+#define  CHNL_CTRL_CHAIN_BUF_2_CHAIN		1
+#define  CHNL_CTRL_SW_RST_OFFSET		24
+#define  CHNL_CTRL_SW_RST_MASK			0x1000000
+#define  CHNL_CTRL_SW_RST			0x1000000
+#define  CHNL_CTRL_BLANK_PXL_OFFSET		16
+#define  CHNL_CTRL_MIPI_VC_ID_OFFSET		6
+#define  CHNL_CTRL_MIPI_VC_ID_MASK		0xc0
+#define  CHNL_CTRL_MIPI_VC_ID_VC0		0
+#define  CHNL_CTRL_MIPI_VC_ID_VC1		1
+#define  CHNL_CTRL_MIPI_VC_ID_VC2		2
+#define  CHNL_CTRL_MIPI_VC_ID_VC3		3
+#define  CHNL_CTRL_SRC_TYPE_OFFSET		4
+#define  CHNL_CTRL_SRC_TYPE_MASK		0x10
+#define  CHNL_CTRL_SRC_TYPE_DEVICE		0
+#define  CHNL_CTRL_SRC_TYPE_MEMORY		1
+#define  CHNL_CTRL_SRC_INPUT_OFFSET		0
+#define  CHNL_CTRL_SRC_INPUT_MASK		0x7
+#define  CHNL_CTRL_SRC_INPUT_MEMORY		5
+
+/* Channel Image Control Register */
+#define  CHNL_IMG_CTRL				0x4
+#define  CHNL_IMG_CTRL_FORMAT_OFFSET		24
+#define  CHNL_IMG_CTRL_FORMAT_MASK		0x3F000000
+#define  CHNL_IMG_CTRL_GBL_ALPHA_VAL_OFFSET	16
+#define  CHNL_IMG_CTRL_GBL_ALPHA_VAL_MASK	0xFF0000
+#define  CHNL_IMG_CTRL_GBL_ALPHA_EN_OFFSET	15
+#define  CHNL_IMG_CTRL_GBL_ALPHA_EN_ENABLE	1
+#define  CHNL_IMG_CTRL_GBL_ALPHA_EN_MASK	0x8000
+#define  CHNL_IMG_CTRL_DEINT_OFFSET		12
+#define  CHNL_IMG_CTRL_DEINT_MASK		0x7000
+#define  CHNL_IMG_CTRL_DEINT_WEAVE_ODD_EVEN	2
+#define  CHNL_IMG_CTRL_DEINT_WEAVE_EVEN_ODD	3
+#define  CHNL_IMG_CTRL_DEINT_BLEND_ODD_EVEN	4
+#define  CHNL_IMG_CTRL_DEINT_BLEND_EVEN_ODD	5
+#define  CHNL_IMG_CTRL_DEINT_LDOUBLE_ODD_EVEN	6
+#define  CHNL_IMG_CTRL_DEINT_LDOUBLE_EVEN_ODD	7
+#define  CHNL_IMG_CTRL_DEC_X_OFFSET		10
+#define  CHNL_IMG_CTRL_DEC_X_MASK		0xC00
+#define  CHNL_IMG_CTRL_DEC_X_0			0
+#define  CHNL_IMG_CTRL_DEC_X_2			1
+#define  CHNL_IMG_CTRL_DEC_X_4			2
+#define  CHNL_IMG_CTRL_DEC_X_8			3
+#define  CHNL_IMG_CTRL_DEC_Y_OFFSET		8
+#define  CHNL_IMG_CTRL_DEC_Y_MASK		0x300
+#define  CHNL_IMG_CTRL_DEC_Y_0			0
+#define  CHNL_IMG_CTRL_DEC_Y_2			1
+#define  CHNL_IMG_CTRL_DEC_Y_4			2
+#define  CHNL_IMG_CTRL_DEC_Y_8			3
+#define  CHNL_IMG_CTRL_CROP_EN_OFFSET		7
+#define  CHNL_IMG_CTRL_CROP_EN_MASK		0x80
+#define  CHNL_IMG_CTRL_CROP_EN_ENABLE		1
+#define  CHNL_IMG_CTRL_VFLIP_EN_OFFSET		6
+#define  CHNL_IMG_CTRL_VFLIP_EN_MASK		0x40
+#define  CHNL_IMG_CTRL_VFLIP_EN_ENABLE		1
+#define  CHNL_IMG_CTRL_HFLIP_EN_OFFSET		5
+#define  CHNL_IMG_CTRL_HFLIP_EN_MASK		0x20
+#define  CHNL_IMG_CTRL_HFLIP_EN_ENABLE		1
+#define  CHNL_IMG_CTRL_YCBCR_MODE_OFFSET	3
+#define  CHNL_IMG_CTRL_YCBCR_MODE_MASK		0x8
+#define  CHNL_IMG_CTRL_YCBCR_MODE_ENABLE	1
+#define  CHNL_IMG_CTRL_CSC_MODE_OFFSET		1
+#define  CHNL_IMG_CTRL_CSC_MODE_MASK		0x6
+#define  CHNL_IMG_CTRL_CSC_MODE_YUV2RGB		0
+#define  CHNL_IMG_CTRL_CSC_MODE_YCBCR2RGB	1
+#define  CHNL_IMG_CTRL_CSC_MODE_RGB2YUV		2
+#define  CHNL_IMG_CTRL_CSC_MODE_RGB2YCBCR	3
+#define  CHNL_IMG_CTRL_CSC_BYPASS_OFFSET	0
+#define  CHNL_IMG_CTRL_CSC_BYPASS_MASK		0x1
+#define  CHNL_IMG_CTRL_CSC_BYPASS_ENABLE	0x1
+
+/* Channel Output Buffer Control Register */
+#define  CHNL_OUT_BUF_CTRL					0x8
+#define  CHNL_OUT_BUF_CTRL_LOAD_BUF2_ADDR_OFFSET		15
+#define  CHNL_OUT_BUF_CTRL_LOAD_BUF2_ADDR_MASK			0x8000
+#define  CHNL_OUT_BUF_CTRL_LOAD_BUF1_ADDR_OFFSET		14
+#define  CHNL_OUT_BUF_CTRL_LOAD_BUF1_ADDR_MASK			0x4000
+#define  CHNL_OUT_BUF_CTRL_OFLW_PANIC_SET_THD_V_OFFSET		6
+#define  CHNL_OUT_BUF_CTRL_OFLW_PANIC_SET_THD_V_MASK		0xC0
+#define  CHNL_OUT_BUF_CTRL_OFLW_PANIC_SET_THD_V_NO_PANIC	0
+#define  CHNL_OUT_BUF_CTRL_OFLW_PANIC_SET_THD_V_PANIC_25	1
+#define  CHNL_OUT_BUF_CTRL_OFLW_PANIC_SET_THD_V_PANIC_50	2
+#define  CHNL_OUT_BUF_CTRL_OFLW_PANIC_SET_THD_V_PANIC_75	3
+#define  CHNL_OUT_BUF_CTRL_OFLW_PANIC_SET_THD_U_OFFSET		3
+#define  CHNL_OUT_BUF_CTRL_OFLW_PANIC_SET_THD_U_MASK		0x18
+#define  CHNL_OUT_BUF_CTRL_OFLW_PANIC_SET_THD_U_NO_PANIC	0
+#define  CHNL_OUT_BUF_CTRL_OFLW_PANIC_SET_THD_U_PANIC_25	1
+#define  CHNL_OUT_BUF_CTRL_OFLW_PANIC_SET_THD_U_PANIC_50	2
+#define  CHNL_OUT_BUF_CTRL_OFLW_PANIC_SET_THD_U_PANIC_75	3
+#define  CHNL_OUT_BUF_CTRL_OFLW_PANIC_SET_THD_Y_OFFSET		0
+#define  CHNL_OUT_BUF_CTRL_OFLW_PANIC_SET_THD_Y_MASK		0x3
+#define  CHNL_OUT_BUF_CTRL_OFLW_PANIC_SET_THD_Y_NO_PANIC	0
+#define  CHNL_OUT_BUF_CTRL_OFLW_PANIC_SET_THD_Y_PANIC_25	1
+#define  CHNL_OUT_BUF_CTRL_OFLW_PANIC_SET_THD_Y_PANIC_50	2
+#define  CHNL_OUT_BUF_CTRL_OFLW_PANIC_SET_THD_Y_PANIC_75	3
+
+/* Channel Image Configuration */
+#define  CHNL_IMG_CFG				0xC
+#define  CHNL_IMG_CFG_HEIGHT_OFFSET		16
+#define  CHNL_IMG_CFG_HEIGHT_MASK		0x1FFF0000
+#define  CHNL_IMG_CFG_WIDTH_OFFSET		0
+#define  CHNL_IMG_CFG_WIDTH_MASK		0x1FFF
+
+/* Channel Interrupt Enable Register */
+#define  CHNL_IER				0x10
+#define  CHNL_IER_MEM_RD_DONE_EN_OFFSET		31
+#define  CHNL_IER_MEM_RD_DONE_EN_MASK		0x80000000
+#define  CHNL_IER_MEM_RD_DONE_EN_ENABLE		1
+#define  CHNL_IER_LINE_RCVD_EN_OFFSET		30
+#define  CHNL_IER_LINE_RCVD_EN_MASK		0x40000000
+#define  CHNL_IER_LINE_RCVD_EN_ENABLE		1
+#define  CHNL_IER_FRM_RCVD_EN_OFFSET		29
+#define  CHNL_IER_FRM_RCVD_EN_MASK		0x20000000
+#define  CHNL_IER_FRM_RCVD_EN_ENABLE		1
+#define  CHNL_IER_AXI_WR_ERR_V_EN_OFFSET	28
+#define  CHNL_IER_AXI_WR_ERR_V_EN_MASK		0x10000000
+#define  CHNL_IER_AXI_WR_ERR_V_EN_ENABLE	1
+#define  CHNL_IER_AXI_WR_ERR_U_EN_OFFSET	27
+#define  CHNL_IER_AXI_WR_ERR_U_EN_MASK		0x8000000
+#define  CHNL_IER_AXI_WR_ERR_U_EN_ENABLE	1
+#define  CHNL_IER_AXI_WR_ERR_Y_EN_OFFSET	26
+#define  CHNL_IER_AXI_WR_ERR_Y_EN_MASK		0x4000000
+#define  CHNL_IER_AXI_WR_ERR_Y_EN_ENABLE	1
+#define  CHNL_IER_AXI_RD_ERR_EN_OFFSET		25
+#define  CHNL_IER_AXI_RD_ERR_EN_MASK		0x2000000
+#define  CHNL_IER_AXI_RD_ERR_EN_ENABLE		1
+
+/* Channel Status Register */
+#define  CHNL_STS				0x14
+#define  CHNL_STS_MEM_RD_DONE_OFFSET		31
+#define  CHNL_STS_MEM_RD_DONE_MASK		0x80000000
+#define  CHNL_STS_MEM_RD_DONE_ENABLE		1
+#define  CHNL_STS_LINE_STRD_OFFSET		30
+#define  CHNL_STS_LINE_STRD_MASK		0x40000000
+#define  CHNL_STS_LINE_STRD_ENABLE		1
+#define  CHNL_STS_FRM_STRD_OFFSET		29
+#define  CHNL_STS_FRM_STRD_MASK			0x20000000
+#define  CHNL_STS_FRM_STRD_ENABLE		1
+#define  CHNL_STS_AXI_WR_ERR_V_OFFSET		28
+#define  CHNL_STS_AXI_WR_ERR_V_MASK		0x10000000
+#define  CHNL_STS_AXI_WR_ERR_V_ENABLE		1
+#define  CHNL_STS_AXI_WR_ERR_U_OFFSET		27
+#define  CHNL_STS_AXI_WR_ERR_U_MASK		0x8000000
+#define  CHNL_STS_AXI_WR_ERR_U_ENABLE		1
+#define  CHNL_STS_AXI_WR_ERR_Y_OFFSET		26
+#define  CHNL_STS_AXI_WR_ERR_Y_MASK		0x4000000
+#define  CHNL_STS_AXI_WR_ERR_Y_ENABLE		1
+#define  CHNL_STS_AXI_RD_ERR_OFFSET		25
+#define  CHNL_STS_AXI_RD_ERR_MASK		0x2000000
+#define  CHNL_STS_AXI_RD_ERR_ENABLE		1
+#define  CHNL_STS_OFLW_PANIC_V_BUF_OFFSET	24
+#define  CHNL_STS_OFLW_PANIC_V_BUF_MASK		0x1000000
+#define  CHNL_STS_OFLW_PANIC_V_BUF_ENABLE	1
+#define  CHNL_STS_EXCS_OFLW_V_BUF_OFFSET	23
+#define  CHNL_STS_EXCS_OFLW_V_BUF_MASK		0x800000
+#define  CHNL_STS_EXCS_OFLW_V_BUF_ENABLE	1
+#define  CHNL_STS_OFLW_V_BUF_OFFSET		22
+#define  CHNL_STS_OFLW_V_BUF_MASK		0x400000
+#define  CHNL_STS_OFLW_V_BUF_ENABLE		1
+#define  CHNL_STS_OFLW_PANIC_U_BUF_OFFSET	21
+#define  CHNL_STS_OFLW_PANIC_U_BUF_MASK		0x200000
+#define  CHNL_STS_OFLW_PANIC_U_BUF_ENABLE	1
+#define  CHNL_STS_EXCS_OFLW_U_BUF_OFFSET	20
+#define  CHNL_STS_EXCS_OFLW_U_BUF_MASK		0x100000
+#define  CHNL_STS_EXCS_OFLW_U_BUF_ENABLE	1
+#define  CHNL_STS_OFLW_U_BUF_OFFSET		19
+#define  CHNL_STS_OFLW_U_BUF_MASK		0x80000
+#define  CHNL_STS_OFLW_U_BUF_ENABLE		1
+#define  CHNL_STS_OFLW_PANIC_Y_BUF_OFFSET	18
+#define  CHNL_STS_OFLW_PANIC_Y_BUF_MASK		0x40000
+#define  CHNL_STS_OFLW_PANIC_Y_BUF_ENABLE	1
+#define  CHNL_STS_EXCS_OFLW_Y_BUF_OFFSET	17
+#define  CHNL_STS_EXCS_OFLW_Y_BUF_MASK		0x20000
+#define  CHNL_STS_EXCS_OFLW_Y_BUF_ENABLE	1
+#define  CHNL_STS_OFLW_Y_BUF_OFFSET		16
+#define  CHNL_STS_OFLW_Y_BUF_MASK		0x10000
+#define  CHNL_STS_OFLW_Y_BUF_ENABLE		1
+#define  CHNL_STS_OFLW_BYTES_OFFSET		0
+#define  CHNL_STS_OFLW_BYTES_MASK		0xFF
+
+/* Channel Scale Factor Register */
+#define  CHNL_SCALE_FACTOR			0x18
+#define  CHNL_SCALE_FACTOR_Y_SCALE_OFFSET	16
+#define  CHNL_SCALE_FACTOR_Y_SCALE_MASK		0x3FFF0000
+#define  CHNL_SCALE_FACTOR_X_SCALE_OFFSET	0
+#define  CHNL_SCALE_FACTOR_X_SCALE_MASK		0x3FFF
+
+/* Channel Scale Offset Register */
+#define  CHNL_SCALE_OFFSET			0x1C
+#define  CHNL_SCALE_OFFSET_Y_SCALE_OFFSET	16
+#define  CHNL_SCALE_OFFSET_Y_SCALE_MASK		0xFFF0000
+#define  CHNL_SCALE_OFFSET_X_SCALE_OFFSET	0
+#define  CHNL_SCALE_OFFSET_X_SCALE_MASK		0xFFF
+
+/* Channel Crop Upper Left Corner Coordinate Register */
+#define  CHNL_CROP_ULC				0x20
+#define  CHNL_CROP_ULC_X_OFFSET			16
+#define  CHNL_CROP_ULC_X_MASK			0xFFF0000
+#define  CHNL_CROP_ULC_Y_OFFSET			0
+#define  CHNL_CROP_ULC_Y_MASK			0xFFF
+
+/* Channel Crop Lower Right Corner Coordinate Register */
+#define  CHNL_CROP_LRC				0x24
+#define  CHNL_CROP_LRC_X_OFFSET			16
+#define  CHNL_CROP_LRC_X_MASK			0xFFF0000
+#define  CHNL_CROP_LRC_Y_OFFSET			0
+#define  CHNL_CROP_LRC_Y_MASK			0xFFF
+
+/* Channel Color Space Conversion Coefficient Register 0 */
+#define  CHNL_CSC_COEFF0			0x28
+#define  CHNL_CSC_COEFF0_A2_OFFSET		16
+#define  CHNL_CSC_COEFF0_A2_MASK		0x7FF0000
+#define  CHNL_CSC_COEFF0_A1_OFFSET		0
+#define  CHNL_CSC_COEFF0_A1_MASK		0x7FF
+
+/* Channel Color Space Conversion Coefficient Register 1 */
+#define  CHNL_CSC_COEFF1			0x2C
+#define  CHNL_CSC_COEFF1_B1_OFFSET		16
+#define  CHNL_CSC_COEFF1_B1_MASK		0x7FF0000
+#define  CHNL_CSC_COEFF1_A3_OFFSET		0
+#define  CHNL_CSC_COEFF1_A3_MASK		0x7FF
+
+/* Channel Color Space Conversion Coefficient Register 2 */
+#define  CHNL_CSC_COEFF2			0x30
+#define  CHNL_CSC_COEFF2_B3_OFFSET		16
+#define  CHNL_CSC_COEFF2_B3_MASK		0x7FF0000
+#define  CHNL_CSC_COEFF2_B2_OFFSET		0
+#define  CHNL_CSC_COEFF2_B2_MASK		0x7FF
+
+/* Channel Color Space Conversion Coefficient Register 3 */
+#define  CHNL_CSC_COEFF3			0x34
+#define  CHNL_CSC_COEFF3_C2_OFFSET		16
+#define  CHNL_CSC_COEFF3_C2_MASK		0x7FF0000
+#define  CHNL_CSC_COEFF3_C1_OFFSET		0
+#define  CHNL_CSC_COEFF3_C1_MASK		0x7FF
+
+/* Channel Color Space Conversion Coefficient Register 4 */
+#define  CHNL_CSC_COEFF4			0x38
+#define  CHNL_CSC_COEFF4_D1_OFFSET		16
+#define  CHNL_CSC_COEFF4_D1_MASK		0x1FF0000
+#define  CHNL_CSC_COEFF4_C3_OFFSET		0
+#define  CHNL_CSC_COEFF4_C3_MASK		0x7FF
+
+/* Channel Color Space Conversion Coefficient Register 5 */
+#define  CHNL_CSC_COEFF5			0x3C
+#define  CHNL_CSC_COEFF5_D3_OFFSET		16
+#define  CHNL_CSC_COEFF5_D3_MASK		0x1FF0000
+#define  CHNL_CSC_COEFF5_D2_OFFSET		0
+#define  CHNL_CSC_COEFF5_D2_MASK		0x1FF
+
+/* Channel Alpha Value Register for ROI 0 */
+#define  CHNL_ROI_0_ALPHA			0x40
+#define  CHNL_ROI_0_ALPHA_OFFSET		24
+#define  CHNL_ROI_0_ALPHA_MASK			0xFF000000
+#define  CHNL_ROI_0_ALPHA_EN_OFFSET		16
+#define  CHNL_ROI_0_ALPHA_EN_MASK		0x10000
+
+/* Channel Upper Left Coordinate Register for ROI 0 */
+#define  CHNL_ROI_0_ULC				0x44
+#define  CHNL_ROI_0_ULC_X_OFFSET		16
+#define  CHNL_ROI_0_ULC_X_MASK			0xFFF0000
+#define  CHNL_ROI_0_ULC_Y_OFFSET		0
+#define  CHNL_ROI_0_ULC_Y_MASK			0xFFF
+
+/* Channel Lower Right Coordinate Register for ROI 0 */
+#define  CHNL_ROI_0_LRC				0x48
+#define  CHNL_ROI_0_LRC_X_OFFSET		16
+#define  CHNL_ROI_0_LRC_X_MASK			0xFFF0000
+#define  CHNL_ROI_0_LRC_Y_OFFSET		0
+#define  CHNL_ROI_0_LRC_Y_MASK			0xFFF
+
+/* Channel Alpha Value Register for ROI 1 */
+#define  CHNL_ROI_1_ALPHA			0x4C
+#define  CHNL_ROI_1_ALPHA_OFFSET		24
+#define  CHNL_ROI_1_ALPHA_MASK			0xFF000000
+#define  CHNL_ROI_1_ALPHA_EN_OFFSET		16
+#define  CHNL_ROI_1_ALPHA_EN_MASK		0x10000
+
+/* Channel Upper Left Coordinate Register for ROI 1 */
+#define  CHNL_ROI_1_ULC				0x50
+#define  CHNL_ROI_1_ULC_X_OFFSET		16
+#define  CHNL_ROI_1_ULC_X_MASK			0xFFF0000
+#define  CHNL_ROI_1_ULC_Y_OFFSET		0
+#define  CHNL_ROI_1_ULC_Y_MASK			0xFFF
+
+/* Channel Lower Right Coordinate Register for ROI 1 */
+#define  CHNL_ROI_1_LRC				0x54
+#define  CHNL_ROI_1_LRC_X_OFFSET		16
+#define  CHNL_ROI_1_LRC_X_MASK			0xFFF0000
+#define  CHNL_ROI_1_LRC_Y_OFFSET		0
+#define  CHNL_ROI_1_LRC_Y_MASK			0xFFF
+
+/* Channel Alpha Value Register for ROI 2 */
+#define  CHNL_ROI_2_ALPHA			0x58
+#define  CHNL_ROI_2_ALPHA_OFFSET		24
+#define  CHNL_ROI_2_ALPHA_MASK			0xFF000000
+#define  CHNL_ROI_2_ALPHA_EN_OFFSET		16
+#define  CHNL_ROI_2_ALPHA_EN_MASK		0x10000
+
+/* Channel Upper Left Coordinate Register for ROI 2 */
+#define  CHNL_ROI_2_ULC				0x5C
+#define  CHNL_ROI_2_ULC_X_OFFSET		16
+#define  CHNL_ROI_2_ULC_X_MASK			0xFFF0000
+#define  CHNL_ROI_2_ULC_Y_OFFSET		0
+#define  CHNL_ROI_2_ULC_Y_MASK			0xFFF
+
+/* Channel Lower Right Coordinate Register for ROI 2 */
+#define  CHNL_ROI_2_LRC				0x60
+#define  CHNL_ROI_2_LRC_X_OFFSET		16
+#define  CHNL_ROI_2_LRC_X_MASK			0xFFF0000
+#define  CHNL_ROI_2_LRC_Y_OFFSET		0
+#define  CHNL_ROI_2_LRC_Y_MASK			0xFFF
+
+/* Channel Alpha Value Register for ROI 3 */
+#define  CHNL_ROI_3_ALPHA			0x64
+#define  CHNL_ROI_3_ALPHA_OFFSET		24
+#define  CHNL_ROI_3_ALPHA_MASK			0xFF000000
+#define  CHNL_ROI_3_ALPHA_EN_OFFSET		16
+#define  CHNL_ROI_3_ALPHA_EN_MASK		0x10000
+
+/* Channel Upper Left Coordinate Register for ROI 3 */
+#define  CHNL_ROI_3_ULC				0x68
+#define  CHNL_ROI_3_ULC_X_OFFSET		16
+#define  CHNL_ROI_3_ULC_X_MASK			0xFFF0000
+#define  CHNL_ROI_3_ULC_Y_OFFSET		0
+#define  CHNL_ROI_3_ULC_Y_MASK			0xFFF
+
+/* Channel Lower Right Coordinate Register for ROI 3 */
+#define  CHNL_ROI_3_LRC				0x6C
+#define  CHNL_ROI_3_LRC_X_OFFSET		16
+#define  CHNL_ROI_3_LRC_X_MASK			0xFFF0000
+#define  CHNL_ROI_3_LRC_Y_OFFSET		0
+#define  CHNL_ROI_3_LRC_Y_MASK			0xFFF
+
+/* Channel RGB or Luma (Y) Output Buffer 1 Address */
+#define  CHNL_OUT_BUF1_ADDR_Y			0x70
+
+/* Channel Chroma (U/Cb/UV/CbCr) Output Buffer 1 Address */
+#define  CHNL_OUT_BUF1_ADDR_U			0x74
+
+/* Channel Chroma (V/Cr) Output Buffer 1 Address */
+#define  CHNL_OUT_BUF1_ADDR_V			0x78
+
+/* Channel Output Buffer Pitch */
+#define  CHNL_OUT_BUF_PITCH			0x7C
+#define  CHNL_OUT_BUF_PITCH_LINE_PITCH_OFFSET	0
+#define  CHNL_OUT_BUF_PITCH_LINE_PITCH_MASK	0xFFFF
+
+/* Channel Input Buffer Address */
+#define  CHNL_IN_BUF_ADDR			0x80
+
+/* Channel Input Buffer Pitch */
+#define  CHNL_IN_BUF_PITCH			0x84
+#define  CHNL_IN_BUF_PITCH_FRM_PITCH_OFFSET	16
+#define  CHNL_IN_BUF_PITCH_FRM_PITCH_MASK	0xFFFF0000
+#define  CHNL_IN_BUF_PITCH_LINE_PITCH_OFFSET	0
+#define  CHNL_IN_BUF_PITCH_LINE_PITCH_MASK	0xFFFF
+
+/* Channel Memory Read Control */
+#define  CHNL_MEM_RD_CTRL			0x88
+#define  CHNL_MEM_RD_CTRL_IMG_TYPE_OFFSET	28
+#define  CHNL_MEM_RD_CTRL_IMG_TYPE_MASK		0xF0000000
+#define  CHNL_MEM_RD_CTRL_READ_MEM_OFFSET	0
+#define  CHNL_MEM_RD_CTRL_READ_MEM_MASK		1
+#define  CHNL_MEM_RD_CTRL_READ_MEM_ENABLE	1
+
+/* Channel RGB or Luma (Y) Output Buffer 2 Address */
+#define  CHNL_OUT_BUF2_ADDR_Y		0x8C
+
+/* Channel Chroma (U/Cb/UV/CbCr) Output Buffer 2 Address  */
+#define  CHNL_OUT_BUF2_ADDR_U		0x90
+
+/* Channel Chroma (V/Cr) Output Buffer 2 Address   */
+#define  CHNL_OUT_BUF2_ADDR_V		0x94
+
+/* Channel scale image config */
+#define  CHNL_SCL_IMG_CFG			0x98
+#define  CHNL_SCL_IMG_CFG_HEIGHT_OFFSET		16
+#define  CHNL_SCL_IMG_CFG_HEIGHT_MASK		0x1FFF0000
+#define  CHNL_SCL_IMG_CFG_WIDTH_OFFSET		0
+#define  CHNL_SCL_IMG_CFG_WIDTH_MASK		0x1FFF
+
+/* Channel Flow Control Register */
+#define  CHNL_FLOW_CTRL				0x9C
+#define  CHNL_FLOW_CTRL_FC_DENOM_MASK		0xFF
+#define  CHNL_FLOW_CTRL_FC_DENOM_OFFSET		0
+#define  CHNL_FLOW_CTRL_FC_NUMER_MASK		0xFF0000
+#define  CHNL_FLOW_CTRL_FC_NUMER_OFFSET		0
+
+enum isi_csi_coeff {
+	YUV2RGB = 0,
+	RGB2YUV,
+};
+
+void mxc_isi_channel_init(struct mxc_isi_dev *mxc_isi);
+void mxc_isi_channel_deinit(struct mxc_isi_dev *mxc_isi);
+void mxc_isi_channel_enable(struct mxc_isi_dev *mxc_isi, bool m2m_enabled);
+void mxc_isi_channel_disable(struct mxc_isi_dev *mxc_isi);
+void mxc_isi_cap_frame_write_done(struct mxc_isi_dev *mxc_isi);
+void mxc_isi_channel_set_deinterlace(struct mxc_isi_dev *mxc_isi);
+void mxc_isi_channel_sw_reset(struct mxc_isi_dev *mxc_isi);
+void mxc_isi_channel_hw_reset(struct mxc_isi_dev *mxc_isi);
+void mxc_isi_channel_source_config(struct mxc_isi_dev *mxc_isi);
+void mxc_isi_channel_set_flip(struct mxc_isi_dev *mxc_isi);
+void mxc_isi_channel_set_alpha(struct mxc_isi_dev *mxc_isi);
+void mxc_isi_channel_set_chain_buf(struct mxc_isi_dev *mxc_isi);
+void mxc_isi_channel_set_deinterlace(struct mxc_isi_dev *mxc_isi);
+void mxc_isi_channel_set_crop(struct mxc_isi_dev *mxc_isi,
+			      struct mxc_isi_frame *dst_f);
+void mxc_isi_channel_set_memory_image(struct mxc_isi_dev *mxc_isi);
+void mxc_isi_channel_set_panic_threshold(struct mxc_isi_dev *mxc_isi);
+
+void mxc_isi_channel_set_scaling(struct mxc_isi_dev *mxc_isi,
+				 struct mxc_isi_frame *src_f,
+				 struct mxc_isi_frame *dst_f);
+
+void mxc_isi_channel_set_outbuf(struct mxc_isi_dev *mxc_isi,
+				struct mxc_isi_buffer *buf);
+
+void mxc_isi_channel_set_csc(struct mxc_isi_dev *mxc_isi,
+			     struct mxc_isi_frame *src_f,
+			     struct mxc_isi_frame *dst_f);
+
+void mxc_isi_channel_config(struct mxc_isi_dev *mxc_isi,
+			    struct mxc_isi_frame *src_f,
+			    struct mxc_isi_frame *dst_f);
+
+void mxc_isi_channel_set_alpha_roi0(struct mxc_isi_dev *mxc_isi,
+				    struct v4l2_rect *rect);
+void mxc_isi_channel_set_m2m_src_addr(struct mxc_isi_dev *mxc_isi,
+			struct mxc_isi_buffer *buf);
+
+void mxc_isi_m2m_config_src(struct mxc_isi_dev *mxc_isi,
+			    struct mxc_isi_frame *src_f);
+void mxc_isi_m2m_config_dst(struct mxc_isi_dev *mxc_isi,
+			    struct mxc_isi_frame *dst_f);
+
+void mxc_isi_m2m_start_read(struct mxc_isi_dev *mxc_isi);
+void mxc_isi_m2m_frame_write_done(struct mxc_isi_dev *mxc_isi);
+void mxc_isi_clean_irq_status(struct mxc_isi_dev *mxc_isi, u32 val);
+void mxc_isi_clean_registers(struct mxc_isi_dev *mxc_isi);
+void mxc_isi_enable_irq(struct mxc_isi_dev *mxc_isi);
+void mxc_isi_disable_irq(struct mxc_isi_dev *mxc_isi);
+void dump_isi_regs(struct mxc_isi_dev *mxc_isi);
+
+u32 mxc_isi_get_irq_status(struct mxc_isi_dev *mxc_isi);
+bool is_buf_active(struct mxc_isi_dev *mxc_isi, int buf_id);
+
+struct device *mxc_isi_dev_get_parent(struct platform_device *pdev);
+struct mxc_isi_dev *mxc_isi_get_hostdata(struct platform_device *pdev);
+#endif /* __MXC_ISI_HW_H__ */
diff --git a/drivers/staging/media/imx/imx8-isi-m2m.c b/drivers/staging/media/imx/imx8-isi-m2m.c
new file mode 100644
index 000000000..46bffa370
--- /dev/null
+++ b/drivers/staging/media/imx/imx8-isi-m2m.c
@@ -0,0 +1,1375 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * ISI V4L2 memory to memory driver for i.MX8QXP/QM platform
+ *
+ * ISI is a Image Sensor Interface of i.MX8QXP/QM platform, which
+ * used to process image from camera sensor or memory to memory or DC
+ *
+ * Copyright 2019-2021 NXP
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/bug.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/pm_runtime.h>
+#include <linux/list.h>
+#include <linux/slab.h>
+#include <linux/of_graph.h>
+#include <linux/videodev2.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-mem2mem.h>
+#include <media/v4l2-event.h>
+#include <media/videobuf2-core.h>
+#include <media/videobuf2-dma-contig.h>
+
+#include "imx8-isi-hw.h"
+#include "imx8-common.h"
+#include "imx8-isi-fmt.h"
+
+#define to_isi_buffer(x)	\
+	container_of((x), struct mxc_isi_buffer, v4l2_buf)
+
+#define file_to_ctx(file)		\
+	container_of(file->private_data, struct mxc_isi_ctx, fh);
+
+struct mxc_isi_fmt mxc_isi_input_formats[] = {
+	/* Pixel link input format */
+	{
+		.name		= "XBGR32",
+		.fourcc		= V4L2_PIX_FMT_XBGR32,
+		.depth		= { 32 },
+		.color =	MXC_ISI_M2M_IN_FMT_XRGB8,
+		.memplanes	= 1,
+		.colplanes	= 1,
+	}, {
+		.name		= "RGB565",
+		.fourcc		= V4L2_PIX_FMT_RGB565,
+		.depth		= { 16 },
+		.color =	MXC_ISI_M2M_IN_FMT_RGB565,
+		.memplanes	= 1,
+		.colplanes	= 1,
+	}, {
+		.name		= "YUV32 (X-Y-U-V)",
+		.fourcc		= V4L2_PIX_FMT_YUV32,
+		.depth		= { 32 },
+		.color = MXC_ISI_M2M_IN_FMT_YUV444_1P8P,
+		.memplanes	= 1,
+		.colplanes	= 1,
+	}, {
+		.name		= "YUV16 (X-Y-U-V)",
+		.fourcc		= V4L2_PIX_FMT_YUYV,
+		.depth		= { 16 },
+		.color = MXC_ISI_M2M_IN_FMT_YUV422_1P8P,
+		.memplanes	= 1,
+		.colplanes	= 1,
+	}, {
+		.name		= "RGBA (R-G-B-A)",
+		.fourcc		= V4L2_PIX_FMT_RGBA32,
+		.depth		= { 32 },
+		.color = MXC_ISI_M2M_IN_FMT_XBGR8,
+		.memplanes	= 1,
+		.colplanes	= 1,
+	}
+};
+
+static struct v4l2_m2m_buffer *to_v4l2_m2m_buffer(struct vb2_v4l2_buffer *vbuf)
+{
+	struct v4l2_m2m_buffer *b;
+
+	b = container_of(vbuf, struct v4l2_m2m_buffer, vb);
+	return b;
+}
+
+void mxc_isi_m2m_frame_write_done(struct mxc_isi_dev *mxc_isi)
+{
+	struct mxc_isi_m2m_dev *isi_m2m = mxc_isi->isi_m2m;
+	struct v4l2_fh *fh;
+	struct mxc_isi_ctx *curr_mxc_ctx;
+	struct vb2_v4l2_buffer *src_vbuf, *dst_vbuf;
+	struct mxc_isi_buffer *src_buf, *dst_buf;
+	struct v4l2_m2m_buffer *b;
+
+	dev_dbg(&isi_m2m->pdev->dev, "%s\n", __func__);
+
+	curr_mxc_ctx = v4l2_m2m_get_curr_priv(isi_m2m->m2m_dev);
+	if (!curr_mxc_ctx) {
+		dev_err(&isi_m2m->pdev->dev,
+			"Instance released before the end of transaction\n");
+		return;
+	}
+	fh = &curr_mxc_ctx->fh;
+
+	if (isi_m2m->aborting) {
+		mxc_isi_channel_disable(mxc_isi);
+		dev_warn(&isi_m2m->pdev->dev, "Aborting current job\n");
+		goto job_finish;
+	}
+
+	src_vbuf = v4l2_m2m_next_src_buf(fh->m2m_ctx);
+	if (!src_vbuf) {
+		dev_err(&isi_m2m->pdev->dev, "No enought source buffers\n");
+		goto job_finish;
+	}
+	src_buf = to_isi_buffer(src_vbuf);
+	v4l2_m2m_src_buf_remove(fh->m2m_ctx);
+	v4l2_m2m_buf_done(src_vbuf, VB2_BUF_STATE_DONE);
+
+	if (!list_empty(&isi_m2m->out_active)) {
+		dst_buf = list_first_entry(&isi_m2m->out_active,
+					   struct mxc_isi_buffer, list);
+		dst_vbuf = &dst_buf->v4l2_buf;
+		list_del_init(&dst_buf->list);
+		dst_buf->v4l2_buf.vb2_buf.timestamp = ktime_get_ns();
+		v4l2_m2m_buf_done(dst_vbuf, VB2_BUF_STATE_DONE);
+
+	}
+	isi_m2m->frame_count++;
+
+	dst_vbuf = v4l2_m2m_next_dst_buf(fh->m2m_ctx);
+	if (dst_vbuf) {
+		dst_vbuf->vb2_buf.state = VB2_BUF_STATE_ACTIVE;
+		dst_buf = to_isi_buffer(dst_vbuf);
+		dst_buf->v4l2_buf.sequence = isi_m2m->frame_count;
+		mxc_isi_channel_set_outbuf(mxc_isi, dst_buf);
+		v4l2_m2m_dst_buf_remove(fh->m2m_ctx);
+		b = to_v4l2_m2m_buffer(dst_vbuf);
+		list_add_tail(&b->list, &isi_m2m->out_active);
+	}
+
+job_finish:
+	v4l2_m2m_job_finish(isi_m2m->m2m_dev, fh->m2m_ctx);
+}
+EXPORT_SYMBOL_GPL(mxc_isi_m2m_frame_write_done);
+
+static void mxc_isi_m2m_device_run(void *priv)
+{
+	struct mxc_isi_ctx *mxc_ctx = priv;
+	struct mxc_isi_m2m_dev *isi_m2m = mxc_ctx->isi_m2m;
+	struct mxc_isi_dev *mxc_isi = mxc_isi_get_hostdata(isi_m2m->pdev);
+	struct v4l2_fh *fh = &mxc_ctx->fh;
+	struct vb2_v4l2_buffer *vbuf;
+	struct mxc_isi_buffer *src_buf;
+	unsigned long flags;
+
+	dev_dbg(&isi_m2m->pdev->dev, "%s enter\n", __func__);
+
+	spin_lock_irqsave(&isi_m2m->slock, flags);
+
+	/* SRC */
+	vbuf = v4l2_m2m_next_src_buf(fh->m2m_ctx);
+	if (!vbuf) {
+		dev_err(&isi_m2m->pdev->dev, "Null src buf\n");
+		goto unlock;
+	}
+
+	src_buf = to_isi_buffer(vbuf);
+	mxc_isi_channel_set_m2m_src_addr(mxc_isi, src_buf);
+	mxc_isi_channel_enable(mxc_isi, mxc_isi->m2m_enabled);
+
+unlock:
+	spin_unlock_irqrestore(&isi_m2m->slock, flags);
+}
+
+static int mxc_isi_m2m_job_ready(void *priv)
+{
+	struct mxc_isi_ctx *mxc_ctx = priv;
+	struct mxc_isi_m2m_dev *isi_m2m = mxc_ctx->isi_m2m;
+	struct v4l2_fh *fh = &mxc_ctx->fh;
+	unsigned int num_src_bufs_ready;
+	unsigned int num_dst_bufs_ready;
+	unsigned long flags;
+
+	dev_dbg(&isi_m2m->pdev->dev, "%s\n", __func__);
+
+	spin_lock_irqsave(&isi_m2m->slock, flags);
+	num_src_bufs_ready = v4l2_m2m_num_src_bufs_ready(fh->m2m_ctx);
+	num_dst_bufs_ready = v4l2_m2m_num_dst_bufs_ready(fh->m2m_ctx);
+	spin_unlock_irqrestore(&isi_m2m->slock, flags);
+
+	if (num_src_bufs_ready >= 1 && num_dst_bufs_ready >= 1)
+		return 1;
+	return 0;
+}
+
+static void mxc_isi_m2m_job_abort(void *priv)
+{
+	struct mxc_isi_ctx *mxc_ctx = priv;
+	struct mxc_isi_m2m_dev *isi_m2m = mxc_ctx->isi_m2m;
+
+	isi_m2m->aborting = 1;
+	dev_dbg(&isi_m2m->pdev->dev, "Abort requested\n");
+}
+
+static struct v4l2_m2m_ops mxc_isi_m2m_ops = {
+	.device_run = mxc_isi_m2m_device_run,
+	.job_ready  = mxc_isi_m2m_job_ready,
+	.job_abort  = mxc_isi_m2m_job_abort,
+};
+
+static int m2m_vb2_queue_setup(struct vb2_queue *q,
+		unsigned int *num_buffers, unsigned int *num_planes,
+		unsigned int sizes[], struct device *alloc_devs[])
+{
+	struct mxc_isi_ctx *mxc_ctx = vb2_get_drv_priv(q);
+	struct mxc_isi_m2m_dev *isi_m2m = mxc_ctx->isi_m2m;
+	struct device *dev = &isi_m2m->pdev->dev;
+	struct mxc_isi_frame *frame;
+	struct mxc_isi_fmt *fmt;
+	unsigned long wh;
+	int i;
+
+	dev_dbg(&isi_m2m->pdev->dev, "%s\n", __func__);
+
+	if (q->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)
+		frame = &isi_m2m->dst_f;
+	else
+		frame = &isi_m2m->src_f;
+
+	if (*num_planes) {
+		if (*num_planes != frame->fmt->memplanes)
+			return -EINVAL;
+
+		for (i = 0; i < *num_planes; i++)
+			if (sizes[i] < frame->sizeimage[i])
+				return -EINVAL;
+	}
+
+	if (q->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {
+		if (*num_buffers < 3) {
+			dev_dbg(dev, "%s at least need 3 buffer\n", __func__);
+			*num_buffers = 3;
+		}
+		isi_m2m->req_cap_buf_num = *num_buffers;
+	} else {
+		if (*num_buffers < 1) {
+			dev_dbg(dev, "%s at least need one buffer\n", __func__);
+			*num_buffers = 1;
+		}
+		isi_m2m->req_out_buf_num = *num_buffers;
+	}
+
+	fmt = frame->fmt;
+	if (fmt == NULL)
+		return -EINVAL;
+
+	for (i = 0; i < fmt->memplanes; i++)
+		alloc_devs[i] = &isi_m2m->pdev->dev;
+
+	*num_planes = fmt->memplanes;
+	wh = frame->width * frame->height;
+
+	for (i = 0; i < fmt->memplanes; i++) {
+		unsigned int size = (wh * fmt->depth[i]) >> 3;
+
+		if (i == 1 && fmt->fourcc == V4L2_PIX_FMT_NV12)
+			size >>= 1;
+		sizes[i] = max_t(u32, size, frame->sizeimage[i]);
+
+		dev_dbg(&isi_m2m->pdev->dev, "%s, buf_n=%d, planes[%d]->size=%d\n",
+					__func__,  *num_buffers, i, sizes[i]);
+	}
+
+	return 0;
+}
+
+static int m2m_vb2_buffer_prepare(struct vb2_buffer *vb2)
+{
+	struct vb2_queue *vq = vb2->vb2_queue;
+	struct mxc_isi_ctx *mxc_ctx = vb2_get_drv_priv(vq);
+	struct mxc_isi_m2m_dev *isi_m2m = mxc_ctx->isi_m2m;
+	struct mxc_isi_frame *frame;
+	int i;
+
+	if (vq->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)
+		frame = &isi_m2m->dst_f;
+	else
+		frame = &isi_m2m->src_f;
+
+	if (frame == NULL)
+		return -EINVAL;
+
+	for (i = 0; i < frame->fmt->memplanes; i++) {
+		unsigned long size = frame->sizeimage[i];
+
+		if (vb2_plane_size(vb2, i) < size) {
+			dev_err(&isi_m2m->pdev->dev,
+				 "User buffer too small (%ld < %ld)\n",
+				 vb2_plane_size(vb2, i), size);
+			return -EINVAL;
+		}
+		vb2_set_plane_payload(vb2, i, size);
+	}
+
+	return 0;
+}
+
+static void m2m_vb2_buffer_queue(struct vb2_buffer *vb2)
+{
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb2);
+	struct mxc_isi_ctx *mxc_ctx = vb2_get_drv_priv(vb2->vb2_queue);
+	struct v4l2_fh *fh = &mxc_ctx->fh;
+
+	v4l2_m2m_buf_queue(fh->m2m_ctx, vbuf);
+}
+
+static int m2m_vb2_start_streaming(struct vb2_queue *q, unsigned int count)
+{
+	struct mxc_isi_ctx *mxc_ctx = vb2_get_drv_priv(q);
+	struct mxc_isi_m2m_dev *isi_m2m = mxc_ctx->isi_m2m;
+	struct mxc_isi_dev *mxc_isi = mxc_isi_get_hostdata(isi_m2m->pdev);
+	struct v4l2_fh *fh = &mxc_ctx->fh;
+	struct vb2_v4l2_buffer *dst_vbuf;
+	struct  v4l2_m2m_buffer *b;
+	struct mxc_isi_buffer *dst_buf;
+	unsigned long flags;
+
+	if (V4L2_TYPE_IS_OUTPUT(q->type))
+		return 0;
+
+	if (count < 2) {
+		dev_err(&isi_m2m->pdev->dev, "Need to at leas 2 buffers\n");
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&isi_m2m->slock, flags);
+
+	/* BUF1 */
+	dst_vbuf = v4l2_m2m_next_dst_buf(fh->m2m_ctx);
+	if (!dst_vbuf) {
+		dev_err(&isi_m2m->pdev->dev, "%d: Null dst buf\n", __LINE__);
+		goto unlock;
+	}
+	dst_vbuf->vb2_buf.state = VB2_BUF_STATE_ACTIVE;
+	dst_buf = to_isi_buffer(dst_vbuf);
+	dst_buf->v4l2_buf.sequence = 0;
+	mxc_isi_channel_set_outbuf(mxc_isi, dst_buf);
+	v4l2_m2m_dst_buf_remove(fh->m2m_ctx);
+	b = to_v4l2_m2m_buffer(dst_vbuf);
+	list_add_tail(&b->list, &isi_m2m->out_active);
+
+	/* BUF2 */
+	dst_vbuf = v4l2_m2m_next_dst_buf(fh->m2m_ctx);
+	if (!dst_vbuf) {
+		dev_err(&isi_m2m->pdev->dev, "%d: Null dst buf\n", __LINE__);
+		goto unlock;
+	}
+	dst_vbuf->vb2_buf.state = VB2_BUF_STATE_ACTIVE;
+	dst_buf = to_isi_buffer(dst_vbuf);
+	dst_buf->v4l2_buf.sequence = 1;
+	mxc_isi_channel_set_outbuf(mxc_isi, dst_buf);
+	v4l2_m2m_dst_buf_remove(fh->m2m_ctx);
+	b = to_v4l2_m2m_buffer(dst_vbuf);
+	list_add_tail(&b->list, &isi_m2m->out_active);
+
+	isi_m2m->frame_count = 1;
+	isi_m2m->aborting = 0;
+unlock:
+	spin_unlock_irqrestore(&isi_m2m->slock, flags);
+
+	return 0;
+}
+
+static void m2m_vb2_stop_streaming(struct vb2_queue *q)
+{
+	struct mxc_isi_ctx *mxc_ctx = vb2_get_drv_priv(q);
+	struct mxc_isi_m2m_dev *isi_m2m = mxc_ctx->isi_m2m;
+	struct vb2_v4l2_buffer *vb2;
+	struct mxc_isi_buffer *buf;
+	unsigned long flags;
+
+	spin_lock_irqsave(&isi_m2m->slock, flags);
+
+	while ((vb2 = v4l2_m2m_src_buf_remove(mxc_ctx->fh.m2m_ctx)) != NULL)
+		v4l2_m2m_buf_done(vb2, VB2_BUF_STATE_ERROR);
+
+	while ((vb2 = v4l2_m2m_dst_buf_remove(mxc_ctx->fh.m2m_ctx)) != NULL)
+		v4l2_m2m_buf_done(vb2, VB2_BUF_STATE_ERROR);
+
+	while (!list_empty(&isi_m2m->out_active)) {
+		buf = list_entry(isi_m2m->out_active.next, struct mxc_isi_buffer, list);
+		list_del(&buf->list);
+		vb2_buffer_done(&buf->v4l2_buf.vb2_buf, VB2_BUF_STATE_ERROR);
+	}
+
+	INIT_LIST_HEAD(&isi_m2m->out_active);
+
+	spin_unlock_irqrestore(&isi_m2m->slock, flags);
+}
+
+static struct vb2_ops mxc_m2m_vb2_qops = {
+	.queue_setup		= m2m_vb2_queue_setup,
+	.buf_prepare		= m2m_vb2_buffer_prepare,
+	.buf_queue		= m2m_vb2_buffer_queue,
+	.wait_prepare		= vb2_ops_wait_prepare,
+	.wait_finish		= vb2_ops_wait_finish,
+	.start_streaming	= m2m_vb2_start_streaming,
+	.stop_streaming		= m2m_vb2_stop_streaming,
+};
+
+static int mxc_m2m_queue_init(void *priv, struct vb2_queue *src_vq,
+			       struct vb2_queue *dst_vq)
+{
+	struct mxc_isi_ctx *mxc_ctx = priv;
+	struct mxc_isi_m2m_dev *isi_m2m = mxc_ctx->isi_m2m;
+	int ret;
+
+	src_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
+	src_vq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;
+	src_vq->drv_priv = mxc_ctx;
+	src_vq->buf_struct_size = sizeof(struct mxc_isi_buffer);
+	src_vq->ops = &mxc_m2m_vb2_qops;
+	src_vq->mem_ops = &vb2_dma_contig_memops;
+	src_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;
+	src_vq->lock = &isi_m2m->lock;
+	src_vq->dev = &isi_m2m->pdev->dev;
+
+	ret = vb2_queue_init(src_vq);
+	if (ret)
+		return ret;
+
+	dst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+	dst_vq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;
+	dst_vq->drv_priv = mxc_ctx;
+	dst_vq->buf_struct_size = sizeof(struct mxc_isi_buffer);
+	dst_vq->ops = &mxc_m2m_vb2_qops;
+	dst_vq->mem_ops = &vb2_dma_contig_memops;
+	dst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;
+	dst_vq->lock = &isi_m2m->lock;
+	dst_vq->dev = &isi_m2m->pdev->dev;
+
+	ret = vb2_queue_init(dst_vq);
+	return ret;
+}
+
+static void isi_m2m_fmt_init(struct mxc_isi_frame *frm, struct mxc_isi_fmt *fmt)
+{
+	int i;
+
+	frm->fmt = fmt;
+	set_frame_bounds(frm, ISI_4K, ISI_8K);
+
+	for (i = 0; i < frm->fmt->memplanes; i++) {
+		frm->bytesperline[i] = frm->width * frm->fmt->depth[i] >> 3;
+		frm->sizeimage[i] = frm->bytesperline[i] * frm->height;
+	}
+}
+
+static int isi_m2m_try_fmt(struct mxc_isi_frame *frame,
+				struct v4l2_format *f)
+{
+	struct v4l2_pix_format_mplane *pix = &f->fmt.pix_mp;
+	struct mxc_isi_fmt *fmt = NULL, *formats;
+	int size;
+	int bpl, i;
+
+	if (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {
+		size = mxc_isi_out_formats_size;
+		formats = mxc_isi_out_formats;
+	} else if (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {
+		size = ARRAY_SIZE(mxc_isi_input_formats);
+		formats = mxc_isi_input_formats;
+	} else {
+		pr_err("%s, not support buf type=%d\n", __func__, f->type);
+		return -EINVAL;
+	}
+
+	for (i = 0; i < size; i++) {
+		fmt = formats + i;
+		if (fmt->fourcc == pix->pixelformat)
+			break;
+	}
+
+	if (i >= size) {
+		pr_err("%s, format is not support!\n", __func__);
+		return -EINVAL;
+	}
+
+
+	pix->num_planes = fmt->memplanes;
+	pix->pixelformat = fmt->fourcc;
+	pix->field = V4L2_FIELD_NONE;
+	pix->width  = clamp(pix->width, ISI_MIN, ISI_4K);
+	pix->height = clamp(pix->height, ISI_MIN, ISI_8K);
+	memset(pix->reserved, 0x00, sizeof(pix->reserved));
+
+	for (i = 0; i < pix->num_planes; i++) {
+		bpl = pix->plane_fmt[i].bytesperline;
+
+		if ((bpl == 0) || (bpl / (fmt->depth[i] >> 3)) < pix->width)
+			pix->plane_fmt[i].bytesperline =
+					(pix->width * fmt->depth[i]) >> 3;
+
+		if (pix->plane_fmt[i].sizeimage == 0) {
+			if ((i == 1) && (pix->pixelformat == V4L2_PIX_FMT_NV12))
+				pix->plane_fmt[i].sizeimage =
+				  (pix->width * (pix->height >> 1) * fmt->depth[i] >> 3);
+			else
+				pix->plane_fmt[i].sizeimage =
+					(pix->width * pix->height * fmt->depth[i] >> 3);
+		}
+	}
+
+	return 0;
+}
+
+static int mxc_isi_m2m_open(struct file *file)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct mxc_isi_m2m_dev *isi_m2m = video_drvdata(file);
+	struct mxc_isi_dev *mxc_isi = mxc_isi_get_hostdata(isi_m2m->pdev);
+	struct device *dev = &isi_m2m->pdev->dev;
+	struct mxc_isi_ctx *mxc_ctx = NULL;
+	int ret = 0;
+
+	mutex_lock(&isi_m2m->lock);
+	if (mxc_isi->cap_enabled) {
+		dev_err(dev, "ISI channel[%d] is busy\n", isi_m2m->id);
+		ret = -EBUSY;
+		goto unlock;
+	}
+
+	if (isi_m2m->refcnt > 0) {
+		ret = -EBUSY;
+		goto unlock;
+	}
+
+	mxc_ctx = kzalloc(sizeof(*mxc_ctx), GFP_KERNEL);
+	if (!mxc_ctx) {
+		ret = -ENOMEM;
+		goto unlock;
+	}
+
+	mxc_ctx->isi_m2m = isi_m2m;
+
+	v4l2_fh_init(&mxc_ctx->fh, vdev);
+	file->private_data = &mxc_ctx->fh;
+
+	mxc_ctx->fh.m2m_ctx = v4l2_m2m_ctx_init(isi_m2m->m2m_dev,
+						mxc_ctx,
+						mxc_m2m_queue_init);
+	if (IS_ERR(mxc_ctx->fh.m2m_ctx)) {
+		dev_err(dev, "v4l2_m2m_ctx_init fail\n");
+		ret = PTR_ERR(mxc_ctx->fh.m2m_ctx);
+		v4l2_fh_exit(&mxc_ctx->fh);
+		kfree(mxc_ctx);
+		goto unlock;
+	}
+	v4l2_fh_add(&mxc_ctx->fh);
+
+	isi_m2m_fmt_init(&isi_m2m->src_f, &mxc_isi_input_formats[0]);
+	isi_m2m_fmt_init(&isi_m2m->dst_f, &mxc_isi_out_formats[0]);
+
+	pm_runtime_get_sync(dev);
+	mxc_isi_channel_init(mxc_isi);
+
+	/* lock host data */
+	mxc_isi->m2m_enabled = true;
+	goto unlock;
+
+unlock:
+	if (ret == 0)
+		isi_m2m->refcnt++;
+	mutex_unlock(&isi_m2m->lock);
+	return ret;
+}
+
+static int mxc_isi_m2m_release(struct file *file)
+{
+	struct mxc_isi_m2m_dev *isi_m2m = video_drvdata(file);
+	struct mxc_isi_dev *mxc_isi = mxc_isi_get_hostdata(isi_m2m->pdev);
+	struct device *dev = &isi_m2m->pdev->dev;
+	struct mxc_isi_ctx *mxc_ctx = file_to_ctx(file);
+
+	mutex_lock(&isi_m2m->lock);
+	isi_m2m->refcnt--;
+	if (isi_m2m->refcnt == 0) {
+		v4l2_fh_del(&mxc_ctx->fh);
+		v4l2_fh_exit(&mxc_ctx->fh);
+
+		v4l2_m2m_ctx_release(mxc_ctx->fh.m2m_ctx);
+
+		kfree(mxc_ctx);
+		mxc_isi_channel_deinit(mxc_isi);
+
+		mxc_isi->m2m_enabled = false;
+
+		pm_runtime_put(dev);
+	}
+	mutex_unlock(&isi_m2m->lock);
+
+	return 0;
+}
+
+static const struct v4l2_file_operations mxc_isi_m2m_fops = {
+	.owner			= THIS_MODULE,
+	.open			= mxc_isi_m2m_open,
+	.release		= mxc_isi_m2m_release,
+	.poll			= v4l2_m2m_fop_poll,
+	.unlocked_ioctl = video_ioctl2,
+	.mmap			= v4l2_m2m_fop_mmap,
+};
+
+static int mxc_isi_m2m_querycap(struct file *file, void *priv,
+					struct v4l2_capability *cap)
+{
+	struct mxc_isi_m2m_dev *isi_m2m = video_drvdata(file);
+
+	strlcpy(cap->driver, MXC_ISI_M2M, sizeof(cap->driver));
+	strlcpy(cap->card, MXC_ISI_M2M, sizeof(cap->card));
+	snprintf(cap->bus_info, sizeof(cap->bus_info), "platform:%s.%d",
+		 dev_name(&isi_m2m->pdev->dev), isi_m2m->id);
+	cap->device_caps = V4L2_CAP_STREAMING | V4L2_CAP_VIDEO_M2M_MPLANE;
+	cap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;
+
+	return 0;
+}
+
+static int mxc_isi_m2m_enum_fmt_vid_out(struct file *file, void *priv,
+				    struct v4l2_fmtdesc *f)
+{
+	struct mxc_isi_m2m_dev *isi_m2m = video_drvdata(file);
+	struct mxc_isi_fmt *fmt;
+
+	dev_dbg(&isi_m2m->pdev->dev, "%s\n", __func__);
+	if (f->index >= (int)ARRAY_SIZE(mxc_isi_input_formats))
+		return -EINVAL;
+
+	fmt = &mxc_isi_input_formats[f->index];
+	strncpy(f->description, fmt->name, sizeof(f->description) - 1);
+
+	f->pixelformat = fmt->fourcc;
+
+	return 0;
+}
+
+static int mxc_isi_m2m_enum_fmt_vid_cap(struct file *file, void *priv,
+				    struct v4l2_fmtdesc *f)
+{
+	struct mxc_isi_m2m_dev *isi_m2m = video_drvdata(file);
+	struct mxc_isi_fmt *fmt;
+
+	dev_dbg(&isi_m2m->pdev->dev, "%s\n", __func__);
+	if (f->index >= (int)mxc_isi_out_formats_size)
+		return -EINVAL;
+
+	fmt = &mxc_isi_out_formats[f->index];
+	strncpy(f->description, fmt->name, sizeof(f->description) - 1);
+
+	f->pixelformat = fmt->fourcc;
+
+	return 0;
+}
+
+static int mxc_isi_m2m_try_fmt_vid_out(struct file *file, void *fh,
+				   struct v4l2_format *f)
+{
+	struct mxc_isi_m2m_dev *isi_m2m = video_drvdata(file);
+	struct v4l2_pix_format_mplane *pix = &f->fmt.pix_mp;
+
+	if (f->type != V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)
+		return -EINVAL;
+
+	if (!pix->colorspace)
+		pix->colorspace = V4L2_COLORSPACE_SRGB;
+
+	return isi_m2m_try_fmt(&isi_m2m->src_f, f);
+}
+
+static int mxc_isi_m2m_try_fmt_vid_cap(struct file *file, void *fh,
+				   struct v4l2_format *f)
+{
+	struct mxc_isi_m2m_dev *isi_m2m = video_drvdata(file);
+	struct v4l2_pix_format_mplane *pix = &f->fmt.pix_mp;
+
+	if (f->type != V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)
+		return -EINVAL;
+
+	if (!pix->colorspace)
+		pix->colorspace = isi_m2m->colorspace;
+	if (!pix->ycbcr_enc)
+		pix->ycbcr_enc  = isi_m2m->ycbcr_enc;
+	if (!pix->xfer_func)
+		pix->xfer_func  = isi_m2m->xfer_func;
+	if (!pix->quantization)
+		pix->quantization = isi_m2m->quant;
+
+	return isi_m2m_try_fmt(&isi_m2m->dst_f, f);
+}
+
+static int mxc_isi_m2m_s_fmt_vid_out(struct file *file, void *priv,
+				 struct v4l2_format *f)
+{
+	struct mxc_isi_m2m_dev *isi_m2m = video_drvdata(file);
+	struct mxc_isi_dev *mxc_isi = mxc_isi_get_hostdata(isi_m2m->pdev);
+	struct v4l2_fh *fh = file->private_data;
+	struct mxc_isi_frame *frame = &isi_m2m->src_f;
+	struct v4l2_pix_format_mplane *pix = &f->fmt.pix_mp;
+	struct mxc_isi_fmt *fmt;
+	struct vb2_queue *vq;
+	int bpl, i;
+	int ret;
+
+	dev_dbg(&isi_m2m->pdev->dev, "%s\n", __func__);
+
+	ret = mxc_isi_m2m_try_fmt_vid_out(file, priv, f);
+	if (ret)
+		return ret;
+
+	vq = v4l2_m2m_get_vq(fh->m2m_ctx, f->type);
+	if (!vq)
+		return -EINVAL;
+
+	if (vb2_is_busy(vq)) {
+		dev_err(&isi_m2m->pdev->dev, "queue busy\n");
+		return -EBUSY;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(mxc_isi_input_formats); i++) {
+		fmt = &mxc_isi_input_formats[i];
+		if (pix && fmt->fourcc == pix->pixelformat)
+			break;
+	}
+
+	if (i >= ARRAY_SIZE(mxc_isi_input_formats)) {
+		dev_dbg(&isi_m2m->pdev->dev, "%s, format is not support!\n", __func__);
+		return -EINVAL;
+	}
+
+	/* update out put frame size and formate */
+	if (pix->height <= 0 || pix->width <= 0)
+		return -EINVAL;
+
+	frame->fmt = fmt;
+	frame->height = pix->height;
+	frame->width = pix->width;
+
+	pix->field = V4L2_FIELD_NONE;
+	pix->num_planes = fmt->memplanes;
+	for (i = 0; i < pix->num_planes; i++) {
+		bpl = pix->plane_fmt[i].bytesperline;
+
+		if ((bpl == 0) || (bpl / (fmt->depth[i] >> 3)) < pix->width)
+			pix->plane_fmt[i].bytesperline =
+						(pix->width * fmt->depth[i]) >> 3;
+
+		if (pix->plane_fmt[i].sizeimage == 0)
+			pix->plane_fmt[i].sizeimage = (pix->width * pix->height *
+						fmt->depth[i] >> 3);
+	}
+
+	frame->bytesperline[0] = frame->width * frame->fmt->depth[0] / 8;
+	frame->sizeimage[0] = frame->height * frame->bytesperline[0];
+
+	set_frame_bounds(frame, pix->width, pix->height);
+	mxc_isi_m2m_config_src(mxc_isi, frame);
+
+	isi_m2m->colorspace = pix->colorspace;
+	isi_m2m->xfer_func = pix->xfer_func;
+	isi_m2m->ycbcr_enc = pix->ycbcr_enc;
+	isi_m2m->quant = pix->quantization;
+
+	return 0;
+}
+
+static int mxc_isi_m2m_s_fmt_vid_cap(struct file *file, void *priv,
+				 struct v4l2_format *f)
+{
+	struct mxc_isi_m2m_dev *isi_m2m = video_drvdata(file);
+	struct mxc_isi_dev *mxc_isi = mxc_isi_get_hostdata(isi_m2m->pdev);
+	struct v4l2_fh *fh = file->private_data;
+	struct mxc_isi_frame *frame = &isi_m2m->dst_f;
+	struct v4l2_pix_format_mplane *pix = &f->fmt.pix_mp;
+	struct mxc_isi_fmt *fmt;
+	struct vb2_queue *vq;
+	int bpl, i;
+	int ret;
+
+	dev_dbg(&isi_m2m->pdev->dev, "%s\n", __func__);
+
+	ret = mxc_isi_m2m_try_fmt_vid_cap(file, priv, f);
+	if (ret)
+		return ret;
+
+	vq = v4l2_m2m_get_vq(fh->m2m_ctx, f->type);
+	if (!vq)
+		return -EINVAL;
+
+	if (vb2_is_busy(vq)) {
+		dev_err(&isi_m2m->pdev->dev, "queue busy\n");
+		return -EBUSY;
+	}
+
+	for (i = 0; i < mxc_isi_out_formats_size; i++) {
+		fmt = &mxc_isi_out_formats[i];
+		if (pix && fmt->fourcc == pix->pixelformat)
+			break;
+	}
+
+	if (i >= mxc_isi_out_formats_size) {
+		dev_err(&isi_m2m->pdev->dev, "%s, format is not support!\n", __func__);
+		return -EINVAL;
+	}
+
+	/* update out put frame size and formate */
+	if (pix->height <= 0 || pix->width <= 0) {
+		dev_err(&isi_m2m->pdev->dev,
+			"Invalid width or height(w=%d, h=%d)\n",
+			pix->width, pix->height);
+		return -EINVAL;
+	}
+
+	if ((pix->pixelformat == V4L2_PIX_FMT_NV12) && ((pix->width / 4) % 2)) {
+		dev_err(&isi_m2m->pdev->dev,
+			"Invalid width or height(w=%d, h=%d) for NV12\n",
+			pix->width, pix->height);
+		return -EINVAL;
+	} else if ((pix->pixelformat != V4L2_PIX_FMT_XBGR32) && (pix->width % 2)) {
+		dev_err(&isi_m2m->pdev->dev,
+			"Invalid width or height(w=%d, h=%d) for %.4s\n",
+			pix->width, pix->height, (char *)&pix->pixelformat);
+		return -EINVAL;
+	}
+
+	frame->fmt = fmt;
+	frame->height = pix->height;
+	frame->width = pix->width;
+
+	pix->num_planes = fmt->memplanes;
+	for (i = 0; i < pix->num_planes; i++) {
+		bpl = pix->plane_fmt[i].bytesperline;
+
+		if ((bpl == 0) || (bpl / (fmt->depth[i] >> 3)) < pix->width)
+			pix->plane_fmt[i].bytesperline =
+						(pix->width * fmt->depth[i]) >> 3;
+
+		if (pix->plane_fmt[i].sizeimage == 0) {
+
+			if ((i == 1) && (pix->pixelformat == V4L2_PIX_FMT_NV12))
+				pix->plane_fmt[i].sizeimage =
+					(pix->width * (pix->height >> 1) * fmt->depth[i] >> 3);
+			else
+				pix->plane_fmt[i].sizeimage = (pix->width * pix->height *
+						fmt->depth[i] >> 3);
+		}
+	}
+
+	if (pix->num_planes > 1) {
+		for (i = 0; i < pix->num_planes; i++) {
+			frame->bytesperline[i] = pix->plane_fmt[i].bytesperline;
+			frame->sizeimage[i] = pix->plane_fmt[i].sizeimage;
+		}
+	} else {
+		frame->bytesperline[0] = frame->width * frame->fmt->depth[0] / 8;
+		frame->sizeimage[0] = frame->height * frame->bytesperline[0];
+	}
+
+	memcpy(&isi_m2m->pix, pix, sizeof(*pix));
+
+	set_frame_bounds(frame, pix->width, pix->height);
+	mxc_isi_m2m_config_dst(mxc_isi, frame);
+
+	return 0;
+}
+
+static int mxc_isi_m2m_g_fmt_vid_cap(struct file *file, void *fh,
+				 struct v4l2_format *f)
+{
+	struct mxc_isi_m2m_dev *isi_m2m = video_drvdata(file);
+	struct v4l2_pix_format_mplane *pix = &f->fmt.pix_mp;
+	struct mxc_isi_frame *frame = &isi_m2m->dst_f;
+	int i;
+
+	dev_dbg(&isi_m2m->pdev->dev, "%s\n", __func__);
+
+	if (f->type != V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)
+		return -EINVAL;
+
+	pix->width = frame->o_width;
+	pix->height = frame->o_height;
+	pix->field = V4L2_FIELD_NONE;
+	pix->pixelformat = frame->fmt->fourcc;
+	pix->colorspace = isi_m2m->colorspace;
+	pix->xfer_func = isi_m2m->xfer_func;
+	pix->ycbcr_enc = isi_m2m->ycbcr_enc;
+	pix->quantization = isi_m2m->quant;
+	pix->num_planes = frame->fmt->memplanes;
+
+	for (i = 0; i < pix->num_planes; ++i) {
+		pix->plane_fmt[i].bytesperline = frame->bytesperline[i];
+		pix->plane_fmt[i].sizeimage = frame->sizeimage[i];
+	}
+
+	return 0;
+}
+
+static int mxc_isi_m2m_g_fmt_vid_out(struct file *file, void *fh,
+				 struct v4l2_format *f)
+{
+	struct mxc_isi_m2m_dev *isi_m2m = video_drvdata(file);
+	struct v4l2_pix_format_mplane *pix = &f->fmt.pix_mp;
+	struct mxc_isi_frame *frame = &isi_m2m->src_f;
+	int i;
+
+	dev_dbg(&isi_m2m->pdev->dev, "%s\n", __func__);
+
+	if (f->type != V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)
+		return -EINVAL;
+
+	pix->width  = frame->o_width;
+	pix->height = frame->o_height;
+	pix->field  = V4L2_FIELD_NONE;
+	pix->pixelformat  = frame->fmt->fourcc;
+	pix->num_planes   = frame->fmt->memplanes;
+	pix->colorspace   = isi_m2m->colorspace;
+	pix->xfer_func    = isi_m2m->xfer_func;
+	pix->ycbcr_enc    = isi_m2m->ycbcr_enc;
+	pix->quantization = isi_m2m->quant;
+
+	for (i = 0; i < pix->num_planes; ++i) {
+		pix->plane_fmt[i].bytesperline = frame->bytesperline[i];
+		pix->plane_fmt[i].sizeimage = frame->sizeimage[i];
+	}
+
+	return 0;
+}
+
+static int mxc_isi_m2m_streamon(struct file *file, void *priv,
+			     enum v4l2_buf_type type)
+{
+	struct mxc_isi_m2m_dev *isi_m2m = video_drvdata(file);
+	struct mxc_isi_dev *mxc_isi = mxc_isi_get_hostdata(isi_m2m->pdev);
+	struct mxc_isi_frame *src_f, *dst_f;
+	int ret;
+
+	src_f = &isi_m2m->src_f;
+	dst_f = &isi_m2m->dst_f;
+
+	if ((dst_f->width  > src_f->width) ||
+		(dst_f->height > src_f->height)) {
+		dev_err(&isi_m2m->pdev->dev, "%s Not support upscale\n", __func__);
+		return -EINVAL;
+	}
+
+	if (type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {
+		isi_m2m->frame_count = 0;
+		mxc_isi_channel_config(mxc_isi, src_f, dst_f);
+	}
+
+	ret = v4l2_m2m_ioctl_streamon(file, priv, type);
+
+	return ret;
+}
+
+static int mxc_isi_m2m_streamoff(struct file *file, void *priv,
+			    enum v4l2_buf_type type)
+{
+	struct mxc_isi_m2m_dev *isi_m2m = video_drvdata(file);
+	struct mxc_isi_dev *mxc_isi =  mxc_isi_get_hostdata(isi_m2m->pdev);
+	int ret;
+
+	if (type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)
+		mxc_isi_channel_disable(mxc_isi);
+
+	ret = v4l2_m2m_ioctl_streamoff(file, priv, type);
+
+	return ret;
+}
+
+static int mxc_isi_m2m_g_selection(struct file *file, void *fh,
+				   struct v4l2_selection *s)
+{
+	struct mxc_isi_m2m_dev *isi_m2m = video_drvdata(file);
+	struct mxc_isi_frame *f = &isi_m2m->dst_f;
+
+	dev_dbg(&isi_m2m->pdev->dev, "%s\n", __func__);
+
+	if (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT &&
+	    s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)
+		return -EINVAL;
+
+	switch (s->target) {
+	case V4L2_SEL_TGT_COMPOSE_DEFAULT:
+	case V4L2_SEL_TGT_COMPOSE_BOUNDS:
+		s->r.left = 0;
+		s->r.top = 0;
+		s->r.width = f->o_width;
+		s->r.height = f->o_height;
+		return 0;
+
+	case V4L2_SEL_TGT_COMPOSE:
+		s->r.left = f->h_off;
+		s->r.top = f->v_off;
+		s->r.width = f->c_width;
+		s->r.height = f->c_height;
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+static int enclosed_rectangle(struct v4l2_rect *a, struct v4l2_rect *b)
+{
+	if (a->left < b->left || a->top < b->top)
+		return 0;
+
+	if (a->left + a->width > b->left + b->width)
+		return 0;
+
+	if (a->top + a->height > b->top + b->height)
+		return 0;
+
+	return 1;
+}
+
+static int mxc_isi_m2m_s_selection(struct file *file, void *fh,
+				   struct v4l2_selection *s)
+{
+	struct mxc_isi_m2m_dev *isi_m2m = video_drvdata(file);
+	struct mxc_isi_frame *f;
+	struct v4l2_rect rect = s->r;
+	unsigned long flags;
+
+	dev_dbg(&isi_m2m->pdev->dev, "%s\n", __func__);
+	if (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT &&
+	    s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)
+		return -EINVAL;
+
+	if (s->target == V4L2_SEL_TGT_COMPOSE)
+		f = &isi_m2m->dst_f;
+	else
+		return -EINVAL;
+
+	bounds_adjust(f, &rect);
+
+	if (s->flags & V4L2_SEL_FLAG_LE &&
+	    !enclosed_rectangle(&rect, &s->r))
+		return -ERANGE;
+
+	if (s->flags & V4L2_SEL_FLAG_GE &&
+	    !enclosed_rectangle(&s->r, &rect))
+		return -ERANGE;
+
+	if ((s->flags & V4L2_SEL_FLAG_LE) &&
+	    (s->flags & V4L2_SEL_FLAG_GE) &&
+	    (rect.width != s->r.width || rect.height != s->r.height))
+		return -ERANGE;
+
+	s->r = rect;
+	spin_lock_irqsave(&isi_m2m->slock, flags);
+	set_frame_crop(f, s->r.left, s->r.top, s->r.width,
+		       s->r.height);
+	spin_unlock_irqrestore(&isi_m2m->slock, flags);
+
+	return 0;
+}
+
+static const struct v4l2_ioctl_ops mxc_isi_m2m_ioctl_ops = {
+	.vidioc_querycap		= mxc_isi_m2m_querycap,
+
+	.vidioc_enum_fmt_vid_cap = mxc_isi_m2m_enum_fmt_vid_cap,
+	.vidioc_enum_fmt_vid_out = mxc_isi_m2m_enum_fmt_vid_out,
+
+	.vidioc_try_fmt_vid_cap_mplane = mxc_isi_m2m_try_fmt_vid_cap,
+	.vidioc_try_fmt_vid_out_mplane = mxc_isi_m2m_try_fmt_vid_out,
+
+	.vidioc_s_fmt_vid_cap_mplane = mxc_isi_m2m_s_fmt_vid_cap,
+	.vidioc_s_fmt_vid_out_mplane = mxc_isi_m2m_s_fmt_vid_out,
+
+	.vidioc_g_fmt_vid_cap_mplane = mxc_isi_m2m_g_fmt_vid_cap,
+	.vidioc_g_fmt_vid_out_mplane = mxc_isi_m2m_g_fmt_vid_out,
+
+	.vidioc_reqbufs		= v4l2_m2m_ioctl_reqbufs,
+	.vidioc_querybuf	= v4l2_m2m_ioctl_querybuf,
+	.vidioc_qbuf		= v4l2_m2m_ioctl_qbuf,
+	.vidioc_dqbuf		= v4l2_m2m_ioctl_dqbuf,
+	.vidioc_expbuf		= v4l2_m2m_ioctl_expbuf,
+	.vidioc_prepare_buf	= v4l2_m2m_ioctl_prepare_buf,
+	.vidioc_create_bufs	= v4l2_m2m_ioctl_create_bufs,
+
+	.vidioc_streamon	= mxc_isi_m2m_streamon,
+	.vidioc_streamoff	= mxc_isi_m2m_streamoff,
+
+	.vidioc_g_selection	= mxc_isi_m2m_g_selection,
+	.vidioc_s_selection	= mxc_isi_m2m_s_selection,
+
+	.vidioc_subscribe_event   =  v4l2_ctrl_subscribe_event,
+	.vidioc_unsubscribe_event =  v4l2_event_unsubscribe,
+};
+
+/*
+ * V4L2 controls handling
+ */
+#define ctrl_to_mxc_isi_m2m(__ctrl) \
+	container_of((__ctrl)->handler, struct mxc_isi_m2m_dev, ctrls.handler)
+
+static int mxc_isi_m2m_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct mxc_isi_m2m_dev *isi_m2m = ctrl_to_mxc_isi_m2m(ctrl);
+	struct mxc_isi_dev *mxc_isi = mxc_isi_get_hostdata(isi_m2m->pdev);
+	unsigned long flags;
+	int ret = 0;
+
+	dev_dbg(&isi_m2m->pdev->dev, "%s\n", __func__);
+
+	if (ctrl->flags & V4L2_CTRL_FLAG_INACTIVE)
+		return 0;
+
+	spin_lock_irqsave(&mxc_isi->slock, flags);
+
+	switch (ctrl->id) {
+	case V4L2_CID_HFLIP:
+		if (ctrl->val < 0) {
+			ret = -EINVAL;
+			goto unlock;
+		}
+		mxc_isi->hflip = (ctrl->val > 0) ? 1 : 0;
+		break;
+
+	case V4L2_CID_VFLIP:
+		if (ctrl->val < 0) {
+			ret = -EINVAL;
+			goto unlock;
+		}
+		mxc_isi->vflip = (ctrl->val > 0) ? 1 : 0;
+		break;
+
+	case V4L2_CID_ALPHA_COMPONENT:
+		if (ctrl->val < 0 || ctrl->val > 255) {
+			ret = -EINVAL;
+			goto unlock;
+		}
+		mxc_isi->alpha = ctrl->val;
+		mxc_isi->alphaen = 1;
+		break;
+
+	default:
+		dev_err(&isi_m2m->pdev->dev, "%s: Not support %d CID\n", __func__, ctrl->id);
+		ret = -EINVAL;
+	}
+
+unlock:
+	spin_unlock_irqrestore(&mxc_isi->slock, flags);
+	return ret;
+}
+
+static int mxc_isi_m2m_g_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct mxc_isi_m2m_dev *isi_m2m = ctrl_to_mxc_isi_m2m(ctrl);
+	unsigned long flags;
+	int ret = 0;
+
+	spin_lock_irqsave(&isi_m2m->slock, flags);
+
+	switch (ctrl->id) {
+	case V4L2_CID_MIN_BUFFERS_FOR_CAPTURE:
+		ctrl->val = isi_m2m->req_cap_buf_num;
+		break;
+	case V4L2_CID_MIN_BUFFERS_FOR_OUTPUT:
+		ctrl->val = isi_m2m->req_out_buf_num;
+		break;
+	default:
+		dev_err(&isi_m2m->pdev->dev, "%s: Not support %d CID\n",
+					__func__, ctrl->id);
+		ret = -EINVAL;
+	}
+
+	spin_unlock_irqrestore(&isi_m2m->slock, flags);
+	return ret;
+
+}
+
+static const struct v4l2_ctrl_ops mxc_isi_m2m_ctrl_ops = {
+	.s_ctrl = mxc_isi_m2m_s_ctrl,
+	.g_volatile_ctrl = mxc_isi_m2m_g_ctrl,
+};
+
+static int mxc_isi_m2m_ctrls_create(struct mxc_isi_m2m_dev *isi_m2m)
+{
+	struct mxc_isi_ctrls *ctrls = &isi_m2m->ctrls;
+	struct v4l2_ctrl_handler *handler = &ctrls->handler;
+
+	if (isi_m2m->ctrls.ready)
+		return 0;
+
+	v4l2_ctrl_handler_init(handler, 4);
+
+	ctrls->hflip = v4l2_ctrl_new_std(handler, &mxc_isi_m2m_ctrl_ops,
+					V4L2_CID_HFLIP, 0, 1, 1, 0);
+	ctrls->vflip = v4l2_ctrl_new_std(handler, &mxc_isi_m2m_ctrl_ops,
+					V4L2_CID_VFLIP, 0, 1, 1, 0);
+	ctrls->alpha = v4l2_ctrl_new_std(handler, &mxc_isi_m2m_ctrl_ops,
+					V4L2_CID_ALPHA_COMPONENT, 0, 0xff, 1, 0);
+	ctrls->num_cap_buf = v4l2_ctrl_new_std(handler, &mxc_isi_m2m_ctrl_ops,
+					V4L2_CID_MIN_BUFFERS_FOR_CAPTURE, 3, 16, 1, 3);
+	ctrls->num_out_buf = v4l2_ctrl_new_std(handler, &mxc_isi_m2m_ctrl_ops,
+					V4L2_CID_MIN_BUFFERS_FOR_OUTPUT, 1, 16, 1, 1);
+
+	if (!handler->error)
+		ctrls->ready = true;
+
+	return handler->error;
+
+}
+
+void mxc_isi_m2m_ctrls_delete(struct mxc_isi_m2m_dev *isi_m2m)
+{
+	struct mxc_isi_ctrls *ctrls = &isi_m2m->ctrls;
+
+	if (ctrls->ready) {
+		v4l2_ctrl_handler_free(&ctrls->handler);
+		ctrls->ready = false;
+		ctrls->alpha = NULL;
+	}
+}
+
+static int isi_m2m_probe(struct platform_device *pdev)
+{
+	struct mxc_isi_dev *mxc_isi;
+	struct mxc_isi_m2m_dev *isi_m2m;
+	struct v4l2_device *v4l2_dev;
+	struct video_device *vdev;
+	int ret = -ENOMEM;
+
+	isi_m2m = devm_kzalloc(&pdev->dev, sizeof(*isi_m2m), GFP_KERNEL);
+	if (!isi_m2m)
+		return -ENOMEM;
+	isi_m2m->pdev = pdev;
+
+	pdev->dev.parent = mxc_isi_dev_get_parent(pdev);
+	if (!pdev->dev.parent) {
+		dev_info(&pdev->dev, "deferring %s device registration\n",
+			 dev_name(&pdev->dev));
+		return -EPROBE_DEFER;
+	}
+
+	mxc_isi = mxc_isi_get_hostdata(pdev);
+	if (!mxc_isi) {
+		dev_info(&pdev->dev, "deferring %s device registration\n",
+			 dev_name(&pdev->dev));
+		return -EPROBE_DEFER;
+	}
+	mxc_isi->isi_m2m = isi_m2m;
+	isi_m2m->id = mxc_isi->id;
+	isi_m2m->refcnt = 0;
+	isi_m2m->colorspace = V4L2_COLORSPACE_SRGB;
+	isi_m2m->quant = V4L2_QUANTIZATION_FULL_RANGE;
+	isi_m2m->ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(isi_m2m->colorspace);
+	isi_m2m->xfer_func = V4L2_XFER_FUNC_SRGB;
+
+	spin_lock_init(&isi_m2m->slock);
+	mutex_init(&isi_m2m->lock);
+
+	/* m2m */
+	isi_m2m->m2m_dev = v4l2_m2m_init(&mxc_isi_m2m_ops);
+	if (IS_ERR(isi_m2m->m2m_dev)) {
+		dev_err(&pdev->dev, "%s fail to get m2m device\n", __func__);
+		return PTR_ERR(isi_m2m->m2m_dev);
+	}
+
+	/* V4L2 device */
+	v4l2_dev = &isi_m2m->v4l2_dev;
+	strlcpy(v4l2_dev->name, "mx8-isi-m2m", sizeof(v4l2_dev->name));
+
+	ret = v4l2_device_register(&pdev->dev, v4l2_dev);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Failed to register v4l2_device\n");
+		return -EINVAL;
+	}
+
+	INIT_LIST_HEAD(&isi_m2m->out_active);
+
+	/* Video device */
+	vdev = &isi_m2m->vdev;
+	memset(vdev, 0, sizeof(*vdev));
+	snprintf(vdev->name, sizeof(vdev->name), "mxc_isi.%d.m2m", isi_m2m->id);
+
+	vdev->fops	= &mxc_isi_m2m_fops;
+	vdev->ioctl_ops	= &mxc_isi_m2m_ioctl_ops;
+	vdev->v4l2_dev	= v4l2_dev;
+	vdev->minor	= -1;
+	vdev->release	= video_device_release_empty;
+	vdev->vfl_dir = VFL_DIR_M2M;
+	vdev->device_caps = V4L2_CAP_STREAMING | V4L2_CAP_VIDEO_M2M_MPLANE;
+
+	ret = mxc_isi_m2m_ctrls_create(isi_m2m);
+	if (ret)
+		goto free_m2m;
+
+	ret = video_register_device(vdev, VFL_TYPE_VIDEO, -1);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "%s fail to register video device\n", __func__);
+		goto ctrl_free;
+	}
+
+	vdev->ctrl_handler = &isi_m2m->ctrls.handler;
+	video_set_drvdata(vdev, isi_m2m);
+	platform_set_drvdata(pdev, isi_m2m);
+	pm_runtime_enable(&pdev->dev);
+
+	dev_info(&pdev->dev, "Register m2m success for ISI.%d\n", isi_m2m->id);
+
+	return 0;
+
+ctrl_free:
+	mxc_isi_m2m_ctrls_delete(isi_m2m);
+free_m2m:
+	v4l2_m2m_release(isi_m2m->m2m_dev);
+	return ret;
+
+}
+
+static int isi_m2m_remove(struct platform_device *pdev)
+{
+	struct mxc_isi_m2m_dev *isi_m2m = platform_get_drvdata(pdev);
+	struct video_device *vdev = &isi_m2m->vdev;
+
+	if (video_is_registered(vdev)) {
+		video_unregister_device(vdev);
+		mxc_isi_m2m_ctrls_delete(isi_m2m);
+		media_entity_cleanup(&vdev->entity);
+	}
+	v4l2_m2m_release(isi_m2m->m2m_dev);
+	v4l2_device_unregister(&isi_m2m->v4l2_dev);
+	pm_runtime_disable(&isi_m2m->pdev->dev);
+
+	return 0;
+}
+
+static const struct of_device_id isi_m2m_of_match[] = {
+	{.compatible = "imx-isi-m2m",},
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, isi_m2m_of_match);
+
+static struct platform_driver isi_m2m_driver = {
+	.probe  = isi_m2m_probe,
+	.remove = isi_m2m_remove,
+	.driver = {
+		.of_match_table = isi_m2m_of_match,
+		.name		= "isi-m2m",
+	},
+};
+
+static int __init mxc_isi_m2m_init(void)
+{
+	return platform_driver_register(&isi_m2m_driver);
+}
+late_initcall(mxc_isi_m2m_init);
+
+static void __exit mxc_isi_m2m_exit(void)
+{
+	platform_driver_unregister(&isi_m2m_driver);
+}
+module_exit(mxc_isi_m2m_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("IMX8 Image Sensor Interface memory to memory driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("ISI M2M");
+MODULE_VERSION("1.0");
diff --git a/drivers/staging/media/imx/imx8-media-dev.c b/drivers/staging/media/imx/imx8-media-dev.c
new file mode 100644
index 000000000..0d0355844
--- /dev/null
+++ b/drivers/staging/media/imx/imx8-media-dev.c
@@ -0,0 +1,1176 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * V4L2 Media Controller Driver for NXP IMX8QXP/QM SOC
+ *
+ * Copyright 2019-2021 NXP
+ *
+ */
+
+#include <linux/bug.h>
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/i2c.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/list.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/of_device.h>
+#include <linux/of_graph.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <media/v4l2-device.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-async.h>
+#include <media/v4l2-ctrls.h>
+#include <media/media-device.h>
+
+#include "imx8-common.h"
+
+#define MXC_MD_DRIVER_NAME	"mxc-md"
+#define ISI_OF_NODE_NAME	"isi"
+#define MIPI_CSI2_OF_NODE_NAME  "csi"
+
+#define MXC_MAX_SENSORS		3
+#define MXC_MIPI_CSI2_MAX_DEVS	2
+
+#define MXC_NAME_LENS		32
+
+/*
+ * The subdevices' group IDs.
+ */
+#define GRP_ID_MXC_SENSOR		BIT(8)
+#define GRP_ID_MXC_ISI			BIT(9)
+#define GRP_ID_MXC_MIPI_CSI2		BIT(11)
+#define GRP_ID_MXC_HDMI_RX		BIT(12)
+#define GRP_ID_MXC_MJPEG_DEC		BIT(13)
+#define GRP_ID_MXC_MJPEG_ENC		BIT(14)
+#define GRP_ID_MXC_PARALLEL_CSI		BIT(15)
+
+enum mxc_subdev_index {
+	IDX_SENSOR,
+	IDX_ISI,
+	IDX_MIPI_CSI2,
+	IDX_HDMI_RX,
+	IDX_MJPEG_ENC,
+	IDX_MJPEG_DEC,
+	IDX_PARALLEL_CSI,
+	IDX_MAX,
+};
+
+struct mxc_isi_info {
+	struct v4l2_subdev *sd;
+	struct media_entity *entity;
+	struct device_node *node;
+	u32 interface[MAX_PORTS];
+
+	char vdev_name[MXC_NAME_LENS];
+	char sd_name[MXC_NAME_LENS];
+	int id;
+};
+
+struct mxc_mipi_csi2_info {
+	struct v4l2_subdev *sd;
+	struct media_entity *entity;
+	struct device_node *node;
+
+	char sd_name[MXC_NAME_LENS];
+	int id;
+	bool vchannel;
+};
+
+struct mxc_parallel_csi_info {
+	struct v4l2_subdev *sd;
+	struct media_entity *entity;
+	struct device_node *node;
+
+	char sd_name[MXC_NAME_LENS];
+	int id;
+};
+
+struct mxc_hdmi_rx_info {
+	struct v4l2_subdev *sd;
+	struct media_entity *entity;
+	struct device_node *node;
+
+	char sd_name[MXC_NAME_LENS];
+	int id;
+};
+
+struct mxc_sensor_info {
+	int				id;
+	struct v4l2_subdev		*sd;
+	struct fwnode_handle *fwnode;
+	bool mipi_mode;
+};
+
+struct mxc_md {
+	struct mxc_isi_info		mxc_isi[MXC_ISI_MAX_DEVS];
+	struct mxc_mipi_csi2_info	mipi_csi2[MXC_MIPI_CSI2_MAX_DEVS];
+	struct mxc_parallel_csi_info	pcsidev;
+	struct mxc_hdmi_rx_info		hdmi_rx;
+	struct mxc_sensor_info		sensor[MXC_MAX_SENSORS];
+
+	int link_status;
+	int num_sensors;
+	int valid_num_sensors;
+	unsigned int nr_isi;
+	bool parallel_csi;
+
+	struct media_device media_dev;
+	struct v4l2_device v4l2_dev;
+	struct platform_device *pdev;
+
+	struct v4l2_async_notifier subdev_notifier;
+};
+
+static inline struct mxc_md *notifier_to_mxc_md(struct v4l2_async_notifier *n)
+{
+	return container_of(n, struct mxc_md, subdev_notifier);
+};
+
+static void mxc_md_unregister_entities(struct mxc_md *mxc_md)
+{
+	struct mxc_parallel_csi_info *pcsidev = &mxc_md->pcsidev;
+	struct mxc_hdmi_rx_info *hdmi_rx = &mxc_md->hdmi_rx;
+	int i;
+
+	for (i = 0; i < MXC_ISI_MAX_DEVS; i++) {
+		struct mxc_isi_info *isi = &mxc_md->mxc_isi[i];
+
+		if (!isi->sd)
+			continue;
+		v4l2_device_unregister_subdev(isi->sd);
+		memset(isi, 0, sizeof(*isi));
+	}
+
+	for (i = 0; i < MXC_MIPI_CSI2_MAX_DEVS; i++) {
+		struct mxc_mipi_csi2_info *mipi_csi2 = &mxc_md->mipi_csi2[i];
+		if (!mipi_csi2->sd)
+			continue;
+		v4l2_device_unregister_subdev(mipi_csi2->sd);
+		memset(mipi_csi2, 0, sizeof(*mipi_csi2));
+	}
+
+	if (pcsidev->sd)
+		v4l2_device_unregister_subdev(pcsidev->sd);
+
+	if (hdmi_rx->sd)
+		v4l2_device_unregister_subdev(hdmi_rx->sd);
+
+	v4l2_info(&mxc_md->v4l2_dev, "Unregistered all entities\n");
+}
+
+static struct media_entity *find_entity_by_name(struct mxc_md *mxc_md,
+						const char *name)
+{
+	struct media_entity *ent = NULL;
+
+	if (!mxc_md || !name)
+		return NULL;
+
+	media_device_for_each_entity(ent, &mxc_md->media_dev) {
+		if (!strcmp(ent->name, name)) {
+			dev_dbg(&mxc_md->pdev->dev,
+				"%s entity is found\n", ent->name);
+			return ent;
+		}
+	}
+
+	return NULL;
+}
+
+static int mxc_md_do_clean(struct mxc_md *mxc_md, struct media_pad *pad)
+{
+	struct device *dev = &mxc_md->pdev->dev;
+	struct media_pad *remote_pad;
+	struct v4l2_subdev	*subdev;
+
+	if (!pad->entity->num_links)
+		return 0;
+
+	remote_pad = media_entity_remote_pad(pad);
+	if (remote_pad == NULL) {
+		dev_err(dev, "%s get remote pad fail\n", __func__);
+		return -ENODEV;
+	}
+
+	subdev = media_entity_to_v4l2_subdev(remote_pad->entity);
+	if (subdev == NULL) {
+		dev_err(dev, "%s media entity to v4l2 subdev fail\n", __func__);
+		return -ENODEV;
+	}
+
+	v4l2_device_unregister_subdev(subdev);
+	media_entity_cleanup(&subdev->entity);
+
+	pr_info("clean ISI channel: %s\n", subdev->name);
+
+	return 0;
+}
+
+static int mxc_md_clean_channel(struct mxc_md *mxc_md, int index)
+{
+	struct mxc_sensor_info *sensor = &mxc_md->sensor[index];
+	struct mxc_mipi_csi2_info *mipi_csi2;
+	struct mxc_parallel_csi_info *pcsidev;
+	struct media_pad *local_pad;
+	struct media_entity *local_en;
+	u32 i, mipi_vc = 0;
+	int ret;
+
+	if (mxc_md->mipi_csi2[index].sd) {
+		mipi_csi2 = &mxc_md->mipi_csi2[index];
+
+		if (mipi_csi2->vchannel == true)
+			mipi_vc = 4;
+		else
+			mipi_vc = 1;
+
+		local_en = &mipi_csi2->sd->entity;
+		if (local_en == NULL)
+			return -ENODEV;
+
+		for (i = 0; i < mipi_vc; i++) {
+			local_pad = &local_en->pads[MXC_MIPI_CSI2_VC0_PAD_SOURCE + i];
+			ret = mxc_md_do_clean(mxc_md, local_pad);
+			if (ret < 0)
+				return -ENODEV;
+		}
+	} else if (mxc_md->parallel_csi && !sensor->mipi_mode) {
+		pcsidev = &mxc_md->pcsidev;
+		if (pcsidev->sd == NULL)
+			return -ENODEV;
+
+		local_en = &pcsidev->sd->entity;
+		if (local_en == NULL)
+			return -ENODEV;
+
+		local_pad = &local_en->pads[MXC_PARALLEL_CSI_PAD_SOURCE];
+		ret = mxc_md_do_clean(mxc_md, local_pad);
+		if (ret < 0)
+			return -ENODEV;
+	}
+
+	return 0;
+}
+
+static int mxc_md_clean_unlink_channels(struct mxc_md *mxc_md)
+{
+	struct mxc_sensor_info *sensor;
+	int num_subdevs = mxc_md->num_sensors;
+	int i, ret;
+
+	for (i = 0; i < num_subdevs; i++) {
+		sensor = &mxc_md->sensor[i];
+		if (sensor->sd != NULL)
+			continue;
+
+		ret = mxc_md_clean_channel(mxc_md, i);
+		if (ret < 0) {
+			pr_err("%s: clean channel fail(%d)\n", __func__, i);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static void mxc_md_unregister_all(struct mxc_md *mxc_md)
+{
+	struct mxc_isi_info *mxc_isi;
+	int i;
+
+	for (i = 0; i < MXC_ISI_MAX_DEVS; i++) {
+		mxc_isi = &mxc_md->mxc_isi[i];
+		if (!mxc_isi->sd)
+			continue;
+
+		v4l2_device_unregister_subdev(mxc_isi->sd);
+		media_entity_cleanup(&mxc_isi->sd->entity);
+
+		pr_info("unregister ISI channel: %s\n", mxc_isi->sd->name);
+	}
+}
+
+static int mxc_md_create_links(struct mxc_md *mxc_md)
+{
+	struct media_entity *source, *sink;
+	struct mxc_isi_info *mxc_isi;
+	struct mxc_sensor_info *sensor;
+	struct mxc_mipi_csi2_info *mipi_csi2;
+	struct mxc_parallel_csi_info *pcsidev;
+	struct mxc_hdmi_rx_info *hdmi_rx;
+	int num_sensors = mxc_md->num_sensors;
+	int i, j, ret = 0;
+	u16  source_pad, sink_pad;
+	u32 flags;
+	u32 mipi_vc = 0;
+
+	/* Create links between each ISI's subdev and video node */
+	flags = MEDIA_LNK_FL_ENABLED;
+	for (i = 0; i < MXC_ISI_MAX_DEVS; i++) {
+		mxc_isi = &mxc_md->mxc_isi[i];
+		if (!mxc_isi->sd)
+			continue;
+
+		/* Connect ISI source to video device */
+		source = find_entity_by_name(mxc_md, mxc_isi->sd_name);
+		sink = find_entity_by_name(mxc_md, mxc_isi->vdev_name);
+		sink_pad = 0;
+
+		switch (mxc_isi->interface[OUT_PORT]) {
+		case ISI_OUTPUT_INTERFACE_DC0:
+			source_pad = MXC_ISI_SD_PAD_SOURCE_DC0;
+			break;
+		case ISI_OUTPUT_INTERFACE_DC1:
+			source_pad = MXC_ISI_SD_PAD_SOURCE_DC1;
+			break;
+		case ISI_OUTPUT_INTERFACE_MEM:
+			source_pad = MXC_ISI_SD_PAD_SOURCE_MEM;
+			break;
+		default:
+			v4l2_err(&mxc_md->v4l2_dev, "Wrong output interface: %x\n",
+				 mxc_isi->interface[OUT_PORT]);
+			return -EINVAL;
+		}
+
+		ret = media_create_pad_link(source, source_pad,
+					    sink, sink_pad, flags);
+		if (ret) {
+			v4l2_err(&mxc_md->v4l2_dev,
+				 "Failed created link [%s] %c> [%s]\n",
+				 source->name, flags ? '=' : '-', sink->name);
+			break;
+		}
+
+		/* Notify capture subdev entity ,ISI cap link setup */
+		ret = media_entity_call(source, link_setup, &source->pads[source_pad],
+					&sink->pads[sink_pad], flags);
+		if (ret) {
+			v4l2_err(&mxc_md->v4l2_dev,
+				 "failed call link_setup [%s] %c> [%s]\n",
+				 source->name, flags ? '=' : '-', sink->name);
+			break;
+		}
+
+		v4l2_info(&mxc_md->v4l2_dev, "created link [%s] %c> [%s]\n",
+			  source->name, flags ? '=' : '-', sink->name);
+
+		/* Connect MIPI/HDMI/Mem source to ISI sink */
+		sink = find_entity_by_name(mxc_md, mxc_isi->sd_name);
+
+		switch (mxc_isi->interface[IN_PORT]) {
+		case ISI_INPUT_INTERFACE_MIPI0_CSI2:
+			mipi_csi2 = &mxc_md->mipi_csi2[0];
+			if (!mipi_csi2->sd)
+				continue;
+			source = find_entity_by_name(mxc_md, mipi_csi2->sd_name);
+
+			switch (mxc_isi->interface[SUB_IN_PORT]) {
+			case ISI_INPUT_SUB_INTERFACE_VC1:
+				source_pad = MXC_MIPI_CSI2_VC1_PAD_SOURCE;
+				sink_pad = MXC_ISI_SD_PAD_SINK_MIPI0_VC1;
+				break;
+			case ISI_INPUT_SUB_INTERFACE_VC2:
+				source_pad = MXC_MIPI_CSI2_VC2_PAD_SOURCE;
+				sink_pad = MXC_ISI_SD_PAD_SINK_MIPI0_VC2;
+				break;
+			case ISI_INPUT_SUB_INTERFACE_VC3:
+				source_pad = MXC_MIPI_CSI2_VC3_PAD_SOURCE;
+				sink_pad = MXC_ISI_SD_PAD_SINK_MIPI0_VC3;
+				break;
+			default:
+				source_pad = MXC_MIPI_CSI2_VC0_PAD_SOURCE;
+				sink_pad = MXC_ISI_SD_PAD_SINK_MIPI0_VC0;
+				break;
+			}
+			break;
+
+		case ISI_INPUT_INTERFACE_MIPI1_CSI2:
+			mipi_csi2 = &mxc_md->mipi_csi2[1];
+			if (!mipi_csi2->sd)
+				continue;
+			source = find_entity_by_name(mxc_md, mipi_csi2->sd_name);
+
+			switch (mxc_isi->interface[SUB_IN_PORT]) {
+			case ISI_INPUT_SUB_INTERFACE_VC1:
+				source_pad = MXC_MIPI_CSI2_VC1_PAD_SOURCE;
+				sink_pad = MXC_ISI_SD_PAD_SINK_MIPI1_VC1;
+				break;
+			case ISI_INPUT_SUB_INTERFACE_VC2:
+				source_pad = MXC_MIPI_CSI2_VC2_PAD_SOURCE;
+				sink_pad = MXC_ISI_SD_PAD_SINK_MIPI1_VC2;
+				break;
+			case ISI_INPUT_SUB_INTERFACE_VC3:
+				source_pad = MXC_MIPI_CSI2_VC3_PAD_SOURCE;
+				sink_pad = MXC_ISI_SD_PAD_SINK_MIPI1_VC3;
+				break;
+			default:
+				source_pad = MXC_MIPI_CSI2_VC0_PAD_SOURCE;
+				sink_pad = MXC_ISI_SD_PAD_SINK_MIPI1_VC0;
+				break;
+			}
+			break;
+
+		case ISI_INPUT_INTERFACE_PARALLEL_CSI:
+			pcsidev = &mxc_md->pcsidev;
+			if (!pcsidev->sd)
+				continue;
+			source = find_entity_by_name(mxc_md, pcsidev->sd_name);
+			source_pad = MXC_PARALLEL_CSI_PAD_SOURCE;
+			sink_pad   = MXC_ISI_SD_PAD_SINK_PARALLEL_CSI;
+			break;
+
+		case ISI_INPUT_INTERFACE_HDMI:
+			hdmi_rx = &mxc_md->hdmi_rx;
+			if (!hdmi_rx->sd)
+				continue;
+			source = find_entity_by_name(mxc_md, hdmi_rx->sd_name);
+			source_pad = MXC_HDMI_RX_PAD_SOURCE;
+			sink_pad = MXC_ISI_SD_PAD_SINK_HDMI;
+			break;
+
+		case ISI_INPUT_INTERFACE_DC0:
+		case ISI_INPUT_INTERFACE_DC1:
+		case ISI_INPUT_INTERFACE_MEM:
+		default:
+			v4l2_err(&mxc_md->v4l2_dev,
+				 "Not support input interface: %x\n",
+				 mxc_isi->interface[IN_PORT]);
+			return -EINVAL;
+		}
+
+		/* Create link MIPI/HDMI to ISI */
+		ret = media_create_pad_link(source, source_pad, sink, sink_pad, flags);
+		if (ret) {
+			v4l2_err(&mxc_md->v4l2_dev,
+				 "created link [%s] %c> [%s] fail\n",
+				 source->name, flags ? '=' : '-', sink->name);
+			break;
+		}
+
+		/* Notify ISI subdev entity */
+		ret = media_entity_call(sink, link_setup,
+					&sink->pads[sink_pad],
+					&source->pads[source_pad], 0);
+		if (ret)
+			break;
+
+		/* Notify MIPI/HDMI entity */
+		ret = media_entity_call(source, link_setup,
+					&source->pads[source_pad],
+					&sink->pads[sink_pad], 0);
+		if (ret)
+			break;
+
+		v4l2_info(&mxc_md->v4l2_dev, "created link [%s] %c> [%s]\n",
+			  source->name, flags ? '=' : '-', sink->name);
+	}
+
+	/* Connect MIPI Sensor to MIPI CSI2 */
+	for (i = 0; i < num_sensors; i++) {
+		sensor = &mxc_md->sensor[i];
+		if (!sensor || !sensor->sd)
+			continue;
+
+		if (mxc_md->parallel_csi && !sensor->mipi_mode) {
+			pcsidev = &mxc_md->pcsidev;
+			if (!pcsidev->sd)
+				continue;
+			source = &sensor->sd->entity;
+			sink = find_entity_by_name(mxc_md, pcsidev->sd_name);
+
+			source_pad = 0;
+			sink_pad = MXC_PARALLEL_CSI_PAD_SINK;
+
+			ret = media_create_pad_link(source,
+						    source_pad,
+						    sink,
+						    sink_pad,
+						    MEDIA_LNK_FL_IMMUTABLE |
+						    MEDIA_LNK_FL_ENABLED);
+			if (ret)
+				return ret;
+
+			/* Notify MIPI subdev entity */
+			ret = media_entity_call(sink, link_setup,
+						&sink->pads[sink_pad],
+						&source->pads[source_pad], 0);
+			if (ret)
+				return ret;
+
+			/* Notify MIPI sensor subdev entity */
+			ret = media_entity_call(source, link_setup,
+						&source->pads[source_pad],
+						&sink->pads[sink_pad],
+						0);
+			if (ret)
+				return ret;
+			v4l2_info(&mxc_md->v4l2_dev,
+				  "created link [%s] => [%s]\n",
+				  source->name, sink->name);
+		} else if (mxc_md->mipi_csi2[sensor->id].sd) {
+			mipi_csi2 = &mxc_md->mipi_csi2[sensor->id];
+
+			source = &sensor->sd->entity;
+			sink = find_entity_by_name(mxc_md, mipi_csi2->sd_name);
+			source_pad = 0;
+			sink_pad = source_pad;
+
+			mipi_vc = (mipi_csi2->vchannel) ? 4 : 1;
+			for (j = 0; j < mipi_vc; j++) {
+				ret = media_create_pad_link(source,
+							    source_pad + j,
+							    sink,
+							    sink_pad + j,
+							    MEDIA_LNK_FL_IMMUTABLE |
+							    MEDIA_LNK_FL_ENABLED);
+				if (ret)
+					return ret;
+
+				/* Notify MIPI subdev entity */
+				ret = media_entity_call(sink, link_setup,
+							&sink->pads[sink_pad + j],
+							&source->pads[source_pad + j],
+							0);
+				if (ret)
+					return ret;
+
+				/* Notify MIPI sensor subdev entity */
+				ret = media_entity_call(source, link_setup,
+							&source->pads[source_pad + j],
+							&sink->pads[sink_pad + j],
+							0);
+				if (ret)
+					return ret;
+			}
+			v4l2_info(&mxc_md->v4l2_dev,
+				  "created link [%s] => [%s]\n",
+				  source->name, sink->name);
+		}
+	}
+	dev_info(&mxc_md->pdev->dev, "%s\n", __func__);
+	return 0;
+}
+
+static int subdev_notifier_bound(struct v4l2_async_notifier *notifier,
+				 struct v4l2_subdev *sd,
+				 struct v4l2_async_subdev *asd)
+{
+	struct mxc_md *mxc_md = notifier_to_mxc_md(notifier);
+	struct mxc_sensor_info *sensor = NULL;
+	int i;
+
+	dev_dbg(&mxc_md->pdev->dev, "%s\n", __func__);
+
+	/* Find platform data for this sensor subdev */
+	for (i = 0; i < ARRAY_SIZE(mxc_md->sensor); i++) {
+		if (mxc_md->sensor[i].fwnode ==
+		    of_fwnode_handle(sd->dev->of_node)) {
+			sensor = &mxc_md->sensor[i];
+		}
+	}
+
+	if (!sensor)
+		return -EINVAL;
+
+	sd->grp_id = GRP_ID_MXC_SENSOR;
+	sensor->sd = sd;
+	mxc_md->valid_num_sensors++;
+
+	v4l2_info(&mxc_md->v4l2_dev, "Registered sensor subdevice: %s (%d)\n",
+		  sd->name, mxc_md->valid_num_sensors);
+
+	return 0;
+}
+
+static int subdev_notifier_complete(struct v4l2_async_notifier *notifier)
+{
+	struct mxc_md *mxc_md = notifier_to_mxc_md(notifier);
+	int ret;
+
+	dev_dbg(&mxc_md->pdev->dev, "%s\n", __func__);
+	mutex_lock(&mxc_md->media_dev.graph_mutex);
+
+	ret = mxc_md_create_links(mxc_md);
+	if (ret < 0)
+		goto unlock;
+
+	mxc_md->link_status = 1;
+
+	ret = v4l2_device_register_subdev_nodes(&mxc_md->v4l2_dev);
+unlock:
+	mutex_unlock(&mxc_md->media_dev.graph_mutex);
+	if (ret < 0) {
+		v4l2_err(&mxc_md->v4l2_dev, "%s error exit\n", __func__);
+		return ret;
+	}
+
+	if (mxc_md->media_dev.devnode)
+		return ret;
+
+	return media_device_register(&mxc_md->media_dev);
+}
+
+static const struct v4l2_async_notifier_operations sd_async_notifier_ops = {
+	.bound = subdev_notifier_bound,
+	.complete = subdev_notifier_complete,
+};
+
+void mxc_sensor_notify(struct v4l2_subdev *sd, unsigned int notification,
+		       void *arg)
+{
+}
+
+static int mxc_md_link_notify(struct media_link *link, unsigned int flags,
+			      unsigned int notification)
+{
+	return 0;
+}
+
+static const struct media_device_ops mxc_md_ops = {
+	.link_notify = mxc_md_link_notify,
+};
+
+static struct mxc_isi_info *mxc_md_parse_isi_entity(struct mxc_md *mxc_md,
+						    struct device_node *node)
+{
+	struct device *dev;
+	struct mxc_isi_info *mxc_isi;
+	struct device_node *child;
+	int ret, id = -1;
+
+	if (!mxc_md || !node)
+		return NULL;
+
+	dev = &mxc_md->pdev->dev;
+
+	id = of_alias_get_id(node, ISI_OF_NODE_NAME);
+	if (id < 0 || id >= MXC_ISI_MAX_DEVS)
+		return NULL;
+
+	mxc_isi = &mxc_md->mxc_isi[id];
+
+	child = of_get_child_by_name(node, "cap_device");
+	if (!child) {
+		dev_err(dev, "Can not get child node for %s.%d\n",
+			ISI_OF_NODE_NAME, id);
+		return NULL;
+	}
+	of_node_put(child);
+
+	mxc_isi->id = id;
+	mxc_isi->node = child;
+	sprintf(mxc_isi->sd_name, "mxc_isi.%d", mxc_isi->id);
+	sprintf(mxc_isi->vdev_name, "mxc_isi.%d.capture", mxc_isi->id);
+
+	ret = of_property_read_u32_array(node, "interface",
+					 mxc_isi->interface, 3);
+	if (ret < 0) {
+		dev_err(dev, "%s node has not interface property\n", child->name);
+		return NULL;
+	}
+
+	return mxc_isi;
+}
+
+static struct mxc_mipi_csi2_info *
+mxc_md_parse_csi_entity(struct mxc_md *mxc_md,
+			struct device_node *node)
+{
+	struct mxc_mipi_csi2_info *mipi_csi2;
+	int id = -1;
+
+	if (!mxc_md || !node)
+		return NULL;
+
+	id = of_alias_get_id(node, MIPI_CSI2_OF_NODE_NAME);
+	if (id < 0 || id >= MXC_MIPI_CSI2_MAX_DEVS)
+		return NULL;
+
+	mipi_csi2 = &mxc_md->mipi_csi2[id];
+	if (!mipi_csi2)
+		return NULL;
+
+	mipi_csi2->vchannel = of_property_read_bool(node, "virtual-channel");
+	mipi_csi2->id = id;
+	mipi_csi2->node = node;
+	sprintf(mipi_csi2->sd_name, "mxc-mipi-csi2.%d", mipi_csi2->id);
+
+	return mipi_csi2;
+}
+
+static struct mxc_parallel_csi_info*
+mxc_md_parse_pcsi_entity(struct mxc_md *mxc_md, struct device_node *node)
+{
+	struct mxc_parallel_csi_info *pcsidev;
+
+	if (!mxc_md || !node)
+		return NULL;
+
+	pcsidev = &mxc_md->pcsidev;
+	if (!pcsidev)
+		return NULL;
+
+	pcsidev->node = node;
+	sprintf(pcsidev->sd_name, "mxc-parallel-csi");
+
+	return pcsidev;
+}
+
+struct mxc_hdmi_rx_info*
+mxc_md_parse_hdmi_rx_entity(struct mxc_md *mxc_md, struct device_node *node)
+{
+	struct mxc_hdmi_rx_info *hdmi_rx;
+
+	if (!mxc_md || !node)
+		return NULL;
+
+	hdmi_rx = &mxc_md->hdmi_rx;
+	if (!hdmi_rx)
+		return NULL;
+
+	hdmi_rx->node = node;
+	sprintf(hdmi_rx->sd_name, "mxc-hdmi-rx");
+
+	return hdmi_rx;
+}
+
+static struct v4l2_subdev *get_subdev_by_node(struct device_node *node)
+{
+	struct platform_device *pdev;
+	struct v4l2_subdev *sd = NULL;
+	struct device *dev;
+	void *drvdata;
+
+	pdev = of_find_device_by_node(node);
+	if (!pdev)
+		return NULL;
+
+	dev = &pdev->dev;
+	device_lock(&pdev->dev);
+	if (!dev->driver || !try_module_get(dev->driver->owner))
+		goto dev_unlock;
+
+	drvdata = dev_get_drvdata(dev);
+	if (!drvdata)
+		goto module_put;
+
+	sd = (struct v4l2_subdev *)drvdata;
+
+module_put:
+	module_put(dev->driver->owner);
+dev_unlock:
+	device_unlock(dev);
+	return sd;
+}
+
+static int register_isi_entity(struct mxc_md *mxc_md,
+			       struct mxc_isi_info *mxc_isi)
+{
+	struct v4l2_subdev *sd;
+	int ret = 0;
+
+	sd = get_subdev_by_node(mxc_isi->node);
+	if (!sd) {
+		ret = of_device_is_available(mxc_isi->node);
+		if (!ret) {
+			dev_info(&mxc_md->pdev->dev, "%s device is disabled\n",
+				 mxc_isi->node->name);
+		} else {
+			dev_info(&mxc_md->pdev->dev,
+				 "deferring %s registration\n",
+				 mxc_isi->node->name);
+			ret = -EPROBE_DEFER;
+		}
+		return ret;
+	}
+
+	if (mxc_isi->id >= MXC_ISI_MAX_DEVS)
+		return -EBUSY;
+
+	sd->grp_id = GRP_ID_MXC_ISI;
+
+	ret = v4l2_device_register_subdev(&mxc_md->v4l2_dev, sd);
+	if (!ret)
+		mxc_isi->sd = sd;
+	else
+		v4l2_err(&mxc_md->v4l2_dev, "Failed to register ISI.%d (%d)\n",
+			 mxc_isi->id, ret);
+	return ret;
+}
+
+static int register_mipi_csi2_entity(struct mxc_md *mxc_md,
+				     struct mxc_mipi_csi2_info *mipi_csi2)
+{
+	struct v4l2_subdev *sd;
+	int ret;
+
+	sd = get_subdev_by_node(mipi_csi2->node);
+	if (!sd) {
+		dev_info(&mxc_md->pdev->dev,
+			 "deferring %s device registration\n",
+			 mipi_csi2->node->name);
+		return -EPROBE_DEFER;
+	}
+
+	if (mipi_csi2->id >= MXC_MIPI_CSI2_MAX_DEVS)
+		return -EBUSY;
+
+	sd->grp_id = GRP_ID_MXC_MIPI_CSI2;
+
+	ret = v4l2_device_register_subdev(&mxc_md->v4l2_dev, sd);
+	if (!ret)
+		mipi_csi2->sd = sd;
+	else
+		v4l2_err(&mxc_md->v4l2_dev, "Failed to register MIPI-CSI.%d (%d)\n",
+			 mipi_csi2->id, ret);
+	return ret;
+}
+
+static int register_parallel_csi_entity(struct mxc_md *mxc_md,
+					struct mxc_parallel_csi_info *pcsidev)
+{
+	struct v4l2_subdev *sd;
+	int ret;
+
+	sd = get_subdev_by_node(pcsidev->node);
+	if (!sd) {
+		dev_info(&mxc_md->pdev->dev,
+			 "deferring %s device registration\n",
+			 pcsidev->node->name);
+		return -EPROBE_DEFER;
+	}
+
+	sd->grp_id = GRP_ID_MXC_PARALLEL_CSI;
+
+	ret = v4l2_device_register_subdev(&mxc_md->v4l2_dev, sd);
+	if (!ret)
+		pcsidev->sd = sd;
+	else
+		v4l2_err(&mxc_md->v4l2_dev,
+			"Failed to register Parallel (%d)\n", ret);
+	return ret;
+}
+
+static int register_hdmi_rx_entity(struct mxc_md *mxc_md,
+			struct mxc_hdmi_rx_info *hdmi_rx)
+{
+	struct v4l2_subdev *sd;
+
+	sd = get_subdev_by_node(hdmi_rx->node);
+	if (!sd) {
+		dev_info(&mxc_md->pdev->dev,
+			 "deferring %s device registration\n",
+			 hdmi_rx->node->name);
+		return -EPROBE_DEFER;
+	}
+
+	sd->grp_id = GRP_ID_MXC_HDMI_RX;
+
+	hdmi_rx->sd = sd;
+
+	return true;
+}
+
+static int mxc_md_register_platform_entity(struct mxc_md *mxc_md,
+					   struct device_node *node,
+					   int plat_entity)
+{
+	struct device *dev = &mxc_md->pdev->dev;
+	struct mxc_isi_info *isi;
+	struct mxc_mipi_csi2_info *mipi_csi2;
+	struct mxc_parallel_csi_info *pcsidev;
+	struct mxc_hdmi_rx_info *hdmi_rx;
+	int ret = -EINVAL;
+
+	switch (plat_entity) {
+	case IDX_ISI:
+		isi = mxc_md_parse_isi_entity(mxc_md, node);
+		if (!isi)
+			return -ENODEV;
+		ret = register_isi_entity(mxc_md, isi);
+		break;
+	case IDX_MIPI_CSI2:
+		mipi_csi2 = mxc_md_parse_csi_entity(mxc_md, node);
+		if (!mipi_csi2)
+			return -ENODEV;
+		ret = register_mipi_csi2_entity(mxc_md, mipi_csi2);
+		break;
+	case IDX_PARALLEL_CSI:
+		pcsidev = mxc_md_parse_pcsi_entity(mxc_md, node);
+		if (!pcsidev)
+			return -ENODEV;
+		ret = register_parallel_csi_entity(mxc_md, pcsidev);
+		break;
+	case IDX_HDMI_RX:
+		hdmi_rx = mxc_md_parse_hdmi_rx_entity(mxc_md, node);
+		if (!hdmi_rx)
+			return -ENODEV;
+		ret = register_hdmi_rx_entity(mxc_md, hdmi_rx);
+		break;
+	default:
+		dev_err(dev, "Invalid platform entity (%d)", plat_entity);
+		return ret;
+	}
+
+	return ret;
+}
+
+static int mxc_md_register_platform_entities(struct mxc_md *mxc_md,
+					     struct device_node *parent)
+{
+	struct device_node *node;
+	int ret = 0;
+
+	for_each_available_child_of_node(parent, node) {
+		int plat_entity = -1;
+
+		if (!of_device_is_available(node))
+			continue;
+
+		/* If driver of any entity isn't ready try all again later. */
+		if (!strcmp(node->name, ISI_OF_NODE_NAME))
+			plat_entity = IDX_ISI;
+		else if (!strcmp(node->name, MIPI_CSI2_OF_NODE_NAME))
+			plat_entity = IDX_MIPI_CSI2;
+		else if (!strcmp(node->name, PARALLEL_OF_NODE_NAME))
+			plat_entity = IDX_PARALLEL_CSI;
+		else if (!strcmp(node->name, HDMI_RX_OF_NODE_NAME))
+			plat_entity = IDX_HDMI_RX;
+
+		if (plat_entity >= IDX_SENSOR && plat_entity < IDX_MAX) {
+			ret = mxc_md_register_platform_entity(mxc_md, node,
+							      plat_entity);
+			if (ret < 0)
+				break;
+		}
+	}
+
+	return ret;
+}
+
+static int register_sensor_entities(struct mxc_md *mxc_md)
+{
+	struct device_node *parent = mxc_md->pdev->dev.of_node;
+	struct device_node *node, *ep, *rem;
+	struct v4l2_fwnode_endpoint endpoint;
+	struct i2c_client *client;
+	struct v4l2_async_subdev *asd;
+	int index = 0;
+	int ret;
+
+	mxc_md->num_sensors = 0;
+
+	/* Attach sensors linked to MIPI CSI2 / paralle csi / HDMI Rx */
+	for_each_available_child_of_node(parent, node) {
+		struct device_node *port;
+
+		if (!of_node_cmp(node->name, HDMI_RX_OF_NODE_NAME)) {
+			mxc_md->sensor[index].fwnode = of_fwnode_handle(node);
+				v4l2_async_notifier_add_fwnode_subdev(
+						&mxc_md->subdev_notifier,
+						mxc_md->sensor[index].fwnode,
+						struct v4l2_async_subdev);
+			mxc_md->num_sensors++;
+			index++;
+			continue;
+		}
+
+		if (of_node_cmp(node->name, MIPI_CSI2_OF_NODE_NAME) &&
+		    of_node_cmp(node->name, PARALLEL_OF_NODE_NAME))
+			continue;
+
+		if (!of_device_is_available(node))
+			continue;
+
+		/* csi2 node have only port */
+		port = of_get_next_child(node, NULL);
+		if (!port)
+			continue;
+
+		/* port can have only endpoint */
+		ep = of_get_next_child(port, NULL);
+		if (!ep)
+			return -EINVAL;
+
+		memset(&endpoint, 0, sizeof(endpoint));
+		ret = v4l2_fwnode_endpoint_parse(of_fwnode_handle(ep), &endpoint);
+		if (WARN_ON(endpoint.base.port >= MXC_MAX_SENSORS || ret)) {
+			v4l2_err(&mxc_md->v4l2_dev,
+				 "Failed to get sensor endpoint\n");
+			return -EINVAL;
+		}
+
+		mxc_md->sensor[index].id = endpoint.base.port;
+
+		if (!of_node_cmp(node->name, MIPI_CSI2_OF_NODE_NAME))
+			mxc_md->sensor[index].mipi_mode = true;
+
+		/* remote port---sensor node */
+		rem = of_graph_get_remote_port_parent(ep);
+		of_node_put(ep);
+		if (!rem) {
+			v4l2_info(&mxc_md->v4l2_dev,
+				  "Remote device at %s not found\n",
+				  ep->full_name);
+			continue;
+		}
+
+		/*
+		 * Need to wait sensor driver probed for the first time
+		 */
+		client = of_find_i2c_device_by_node(rem);
+		if (!client) {
+			v4l2_info(&mxc_md->v4l2_dev,
+				  "Can't find i2c client device for %s\n",
+				  of_node_full_name(rem));
+			return -EPROBE_DEFER;
+		}
+
+		mxc_md->sensor[index].fwnode = of_fwnode_handle(rem);
+		asd = v4l2_async_notifier_add_fwnode_subdev(
+						&mxc_md->subdev_notifier,
+						mxc_md->sensor[index].fwnode,
+						struct v4l2_async_subdev);
+		if (IS_ERR(asd)) {
+			v4l2_info(&mxc_md->v4l2_dev, "Can't find async subdev\n");
+			return PTR_ERR(asd);
+		}
+
+		mxc_md->num_sensors++;
+
+		index++;
+	}
+
+	return 0;
+}
+
+static int mxc_md_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *nd = dev->of_node;
+	struct v4l2_device *v4l2_dev;
+	struct mxc_md *mxc_md;
+	int ret;
+
+	mxc_md = devm_kzalloc(dev, sizeof(*mxc_md), GFP_KERNEL);
+	if (!mxc_md)
+		return -ENOMEM;
+
+	mxc_md->pdev = pdev;
+	platform_set_drvdata(pdev, mxc_md);
+
+	mxc_md->parallel_csi = of_property_read_bool(nd, "parallel_csi");
+
+	/* register media device  */
+	strlcpy(mxc_md->media_dev.model, "FSL Capture Media Device",
+		sizeof(mxc_md->media_dev.model));
+	mxc_md->media_dev.ops = &mxc_md_ops;
+	mxc_md->media_dev.dev = dev;
+
+	/* register v4l2 device */
+	v4l2_dev = &mxc_md->v4l2_dev;
+	v4l2_dev->mdev = &mxc_md->media_dev;
+	v4l2_dev->notify = mxc_sensor_notify;
+	strlcpy(v4l2_dev->name, "mx8-img-md", sizeof(v4l2_dev->name));
+
+	media_device_init(&mxc_md->media_dev);
+
+	ret = v4l2_device_register(dev, &mxc_md->v4l2_dev);
+	if (ret < 0) {
+		v4l2_err(v4l2_dev, "Failed to register v4l2_device (%d)\n", ret);
+		goto clean_md;
+	}
+
+	v4l2_async_notifier_init(&mxc_md->subdev_notifier);
+	ret = mxc_md_register_platform_entities(mxc_md, dev->of_node);
+	if (ret < 0)
+		goto clean_v4l2;
+
+	ret = register_sensor_entities(mxc_md);
+	if (ret < 0)
+		goto clean_ents;
+
+	if (mxc_md->num_sensors > 0) {
+		mxc_md->subdev_notifier.ops = &sd_async_notifier_ops;
+		mxc_md->valid_num_sensors = 0;
+		mxc_md->link_status = 0;
+
+		ret = v4l2_async_notifier_register(&mxc_md->v4l2_dev,
+						   &mxc_md->subdev_notifier);
+		if (ret < 0) {
+			dev_warn(&mxc_md->pdev->dev, "Sensor register failed\n");
+			return ret;
+		}
+
+		if (!mxc_md->link_status) {
+			if (mxc_md->valid_num_sensors > 0) {
+				ret = subdev_notifier_complete(&mxc_md->subdev_notifier);
+				if (ret < 0)
+					goto clean_ents;
+
+				mxc_md_clean_unlink_channels(mxc_md);
+			} else {
+				/* no sensors connected */
+				mxc_md_unregister_all(mxc_md);
+				v4l2_async_notifier_unregister(&mxc_md->subdev_notifier);
+			}
+		}
+	}
+
+	return 0;
+
+clean_ents:
+	mxc_md_unregister_entities(mxc_md);
+clean_v4l2:
+	v4l2_device_unregister(&mxc_md->v4l2_dev);
+clean_md:
+	media_device_cleanup(&mxc_md->media_dev);
+	return ret;
+}
+
+static int mxc_md_remove(struct platform_device *pdev)
+{
+	struct mxc_md *mxc_md = platform_get_drvdata(pdev);
+
+	if (!mxc_md)
+		return 0;
+
+	v4l2_async_notifier_cleanup(&mxc_md->subdev_notifier);
+	v4l2_async_notifier_unregister(&mxc_md->subdev_notifier);
+
+	v4l2_device_unregister(&mxc_md->v4l2_dev);
+	mxc_md_unregister_entities(mxc_md);
+	media_device_unregister(&mxc_md->media_dev);
+	media_device_cleanup(&mxc_md->media_dev);
+
+	return 0;
+}
+
+static const struct of_device_id mxc_md_of_match[] = {
+	{ .compatible = "fsl,mxc-md",},
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, mxc_md_of_match);
+
+static struct platform_driver mxc_md_driver = {
+	.driver = {
+		.name = MXC_MD_DRIVER_NAME,
+		.of_match_table	= mxc_md_of_match,
+	},
+	.probe = mxc_md_probe,
+	.remove = mxc_md_remove,
+};
+
+module_platform_driver(mxc_md_driver);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("MXC Media Device driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" MXC_MD_DRIVER_NAME);
diff --git a/drivers/staging/media/imx/imx8-mipi-csi2-sam.c b/drivers/staging/media/imx/imx8-mipi-csi2-sam.c
new file mode 100644
index 000000000..1d1236552
--- /dev/null
+++ b/drivers/staging/media/imx/imx8-mipi-csi2-sam.c
@@ -0,0 +1,2119 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Freescale i.MX8MN/P SoC series MIPI-CSI V3.3 receiver driver
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2019 NXP
+ * Copyright 2020 NXP
+ *
+ * Samsung S5P/EXYNOS SoC series MIPI-CSI receiver driver
+ *
+ * Copyright (C) 2011 - 2013 Samsung Electronics Co., Ltd.
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2019 NXP
+ * Author: Sylwester Nawrocki <s.nawrocki@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/kernel.h>
+#include <linux/mfd/syscon.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_graph.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/videodev2.h>
+#include <linux/v4l2-mediabus.h>
+#include <linux/reset.h>
+#include <linux/version.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-event.h>
+
+#define CSIS_DRIVER_NAME		"mxc-mipi-csi2-sam"
+#define CSIS_SUBDEV_NAME		"mxc-mipi-csi2"
+#define CSIS_MAX_ENTITIES		2
+#define CSIS0_MAX_LANES			4
+#define CSIS1_MAX_LANES			2
+
+#define MIPI_CSIS_OF_NODE_NAME		"csi"
+
+#define MIPI_CSIS_VC0_PAD_SINK		0
+#define MIPI_CSIS_VC1_PAD_SINK		1
+#define MIPI_CSIS_VC2_PAD_SINK		2
+#define MIPI_CSIS_VC3_PAD_SINK		3
+
+#define MIPI_CSIS_VC0_PAD_SOURCE	4
+#define MIPI_CSIS_VC1_PAD_SOURCE	5
+#define MIPI_CSIS_VC2_PAD_SOURCE	6
+#define MIPI_CSIS_VC3_PAD_SOURCE	7
+#define MIPI_CSIS_VCX_PADS_NUM		8
+
+
+#define MIPI_CSIS_DEF_PIX_WIDTH		1920
+#define MIPI_CSIS_DEF_PIX_HEIGHT	1080
+
+/* Register map definition */
+
+/* CSIS version */
+#define MIPI_CSIS_VERSION			0x00
+
+/* CSIS common control */
+#define MIPI_CSIS_CMN_CTRL			0x04
+#define MIPI_CSIS_CMN_CTRL_UPDATE_SHADOW	(1 << 16)
+#define MIPI_CSIS_CMN_CTRL_HDR_MODE		(1 << 11)
+#define MIPI_CSIS_CMN_CTRL_INTER_MODE		(1 << 10)
+#define MIPI_CSIS_CMN_CTRL_LANE_NR_OFFSET	8
+#define MIPI_CSIS_CMN_CTRL_LANE_NR_MASK		(3 << 8)
+#define MIPI_CSIS_CMN_CTRL_UPDATE_SHADOW_CTRL	(1 << 2)
+#define MIPI_CSIS_CMN_CTRL_RESET		(1 << 1)
+#define MIPI_CSIS_CMN_CTRL_ENABLE		(1 << 0)
+
+/* CSIS clock control */
+#define MIPI_CSIS_CLK_CTRL			0x08
+#define MIPI_CSIS_CLK_CTRL_CLKGATE_TRAIL_CH3(x)	(x << 28)
+#define MIPI_CSIS_CLK_CTRL_CLKGATE_TRAIL_CH2(x)	(x << 24)
+#define MIPI_CSIS_CLK_CTRL_CLKGATE_TRAIL_CH1(x)	(x << 20)
+#define MIPI_CSIS_CLK_CTRL_CLKGATE_TRAIL_CH0(x)	(x << 16)
+#define MIPI_CSIS_CLK_CTRL_CLKGATE_EN_MSK	(0xf << 4)
+#define MIPI_CSIS_CLK_CTRL_WCLK_SRC		(1 << 0)
+
+/* CSIS Interrupt mask */
+#define MIPI_CSIS_INTMSK			0x10
+#define MIPI_CSIS_INTMSK_EVEN_BEFORE		(1 << 31)
+#define MIPI_CSIS_INTMSK_EVEN_AFTER		(1 << 30)
+#define MIPI_CSIS_INTMSK_ODD_BEFORE		(1 << 29)
+#define MIPI_CSIS_INTMSK_ODD_AFTER		(1 << 28)
+#define MIPI_CSIS_INTMSK_FRAME_START		(1 << 24)
+#define MIPI_CSIS_INTMSK_FRAME_END		(1 << 20)
+#define MIPI_CSIS_INTMSK_ERR_SOT_HS		(1 << 16)
+#define MIPI_CSIS_INTMSK_ERR_LOST_FS		(1 << 12)
+#define MIPI_CSIS_INTMSK_ERR_LOST_FE		(1 << 8)
+#define MIPI_CSIS_INTMSK_ERR_OVER		(1 << 4)
+#define MIPI_CSIS_INTMSK_ERR_WRONG_CFG		(1 << 3)
+#define MIPI_CSIS_INTMSK_ERR_ECC		(1 << 2)
+#define MIPI_CSIS_INTMSK_ERR_CRC		(1 << 1)
+#define MIPI_CSIS_INTMSK_ERR_UNKNOWN		(1 << 0)
+
+/* CSIS Interrupt source */
+#define MIPI_CSIS_INTSRC			0x14
+#define MIPI_CSIS_INTSRC_EVEN_BEFORE		(1 << 31)
+#define MIPI_CSIS_INTSRC_EVEN_AFTER		(1 << 30)
+#define MIPI_CSIS_INTSRC_EVEN			(0x3 << 30)
+#define MIPI_CSIS_INTSRC_ODD_BEFORE		(1 << 29)
+#define MIPI_CSIS_INTSRC_ODD_AFTER		(1 << 28)
+#define MIPI_CSIS_INTSRC_ODD			(0x3 << 28)
+#define MIPI_CSIS_INTSRC_NON_IMAGE_DATA		(0xf << 28)
+#define MIPI_CSIS_INTSRC_FRAME_START		(1 << 24)
+#define MIPI_CSIS_INTSRC_FRAME_END		(1 << 20)
+#define MIPI_CSIS_INTSRC_ERR_SOT_HS		(1 << 16)
+#define MIPI_CSIS_INTSRC_ERR_LOST_FS		(1 << 12)
+#define MIPI_CSIS_INTSRC_ERR_LOST_FE		(1 << 8)
+#define MIPI_CSIS_INTSRC_ERR_OVER		(1 << 4)
+#define MIPI_CSIS_INTSRC_ERR_WRONG_CFG		(1 << 3)
+#define MIPI_CSIS_INTSRC_ERR_ECC		(1 << 2)
+#define MIPI_CSIS_INTSRC_ERR_CRC		(1 << 1)
+#define MIPI_CSIS_INTSRC_ERR_UNKNOWN		(1 << 0)
+#define MIPI_CSIS_INTSRC_ERRORS			0xfffff
+
+/* D-PHY status control */
+#define MIPI_CSIS_DPHYSTATUS			0x20
+#define MIPI_CSIS_DPHYSTATUS_ULPS_DAT		(1 << 8)
+#define MIPI_CSIS_DPHYSTATUS_STOPSTATE_DAT	(1 << 4)
+#define MIPI_CSIS_DPHYSTATUS_ULPS_CLK		(1 << 1)
+#define MIPI_CSIS_DPHYSTATUS_STOPSTATE_CLK	(1 << 0)
+
+/* D-PHY common control */
+#define MIPI_CSIS_DPHYCTRL			0x24
+#define MIPI_CSIS_DPHYCTRL_HSS_MASK		(0xff << 24)
+#define MIPI_CSIS_DPHYCTRL_HSS_OFFSET		24
+#define MIPI_CSIS_DPHYCTRL_SCLKS_MASK		(0x3 << 22)
+#define MIPI_CSIS_DPHYCTRL_SCLKS_OFFSET		22
+#define MIPI_CSIS_DPHYCTRL_DPDN_SWAP_CLK	(1 << 6)
+#define MIPI_CSIS_DPHYCTRL_DPDN_SWAP_DAT	(1 << 5)
+#define MIPI_CSIS_DPHYCTRL_ENABLE_DAT		(1 << 1)
+#define MIPI_CSIS_DPHYCTRL_ENABLE_CLK		(1 << 0)
+#define MIPI_CSIS_DPHYCTRL_ENABLE		(0x1f << 0)
+
+/* D-PHY Master and Slave Control register Low */
+#define MIPI_CSIS_DPHYBCTRL_L		0x30
+/* D-PHY Master and Slave Control register High */
+#define MIPI_CSIS_DPHYBCTRL_H		0x34
+/* D-PHY Slave Control register Low */
+#define MIPI_CSIS_DPHYSCTRL_L		0x38
+/* D-PHY Slave Control register High */
+#define MIPI_CSIS_DPHYSCTRL_H		0x3c
+
+
+/* ISP Configuration register */
+#define MIPI_CSIS_ISPCONFIG_CH0				0x40
+#define MIPI_CSIS_ISPCONFIG_CH0_PIXEL_MODE_MASK		(0x3 << 12)
+#define MIPI_CSIS_ISPCONFIG_CH0_PIXEL_MODE_SHIFT	12
+
+#define MIPI_CSIS_ISPCONFIG_CH1				0x50
+#define MIPI_CSIS_ISPCONFIG_CH1_PIXEL_MODE_MASK		(0x3 << 12)
+#define MIPI_CSIS_ISPCONFIG_CH1_PIXEL_MODE_SHIFT	12
+
+#define MIPI_CSIS_ISPCONFIG_CH2				0x60
+#define MIPI_CSIS_ISPCONFIG_CH2_PIXEL_MODE_MASK		(0x3 << 12)
+#define MIPI_CSIS_ISPCONFIG_CH2_PIXEL_MODE_SHIFT	12
+
+#define MIPI_CSIS_ISPCONFIG_CH3				0x70
+#define MIPI_CSIS_ISPCONFIG_CH3_PIXEL_MODE_MASK		(0x3 << 12)
+#define MIPI_CSIS_ISPCONFIG_CH3_PIXEL_MODE_SHIFT	12
+
+#define PIXEL_MODE_SINGLE_PIXEL_MODE			0x0
+#define PIXEL_MODE_DUAL_PIXEL_MODE			0x1
+#define PIXEL_MODE_QUAD_PIXEL_MODE			0x2
+#define PIXEL_MODE_INVALID_PIXEL_MODE			0x3
+
+
+#define MIPI_CSIS_ISPCFG_MEM_FULL_GAP_MSK	(0xff << 24)
+#define MIPI_CSIS_ISPCFG_MEM_FULL_GAP(x)	(x << 24)
+#define MIPI_CSIS_ISPCFG_DOUBLE_CMPNT		(1 << 12)
+#define MIPI_CSIS_ISPCFG_ALIGN_32BIT		(1 << 11)
+#define MIPI_CSIS_ISPCFG_FMT_YCBCR422_8BIT	(0x1e << 2)
+#define MIPI_CSIS_ISPCFG_FMT_RAW8		(0x2a << 2)
+#define MIPI_CSIS_ISPCFG_FMT_RAW10		(0x2b << 2)
+#define MIPI_CSIS_ISPCFG_FMT_RAW12		(0x2c << 2)
+#define MIPI_CSIS_ISPCFG_FMT_RGB888		(0x24 << 2)
+#define MIPI_CSIS_ISPCFG_FMT_RGB565		(0x22 << 2)
+/* User defined formats, x = 1...4 */
+#define MIPI_CSIS_ISPCFG_FMT_USER(x)		((0x30 + x - 1) << 2)
+#define MIPI_CSIS_ISPCFG_FMT_MASK		(0x3f << 2)
+
+/* ISP Image Resolution register */
+#define MIPI_CSIS_ISPRESOL_CH0			0x44
+#define MIPI_CSIS_ISPRESOL_CH1			0x54
+#define MIPI_CSIS_ISPRESOL_CH2			0x64
+#define MIPI_CSIS_ISPRESOL_CH3			0x74
+#define CSIS_MAX_PIX_WIDTH			0xffff
+#define CSIS_MAX_PIX_HEIGHT			0xffff
+
+/* ISP SYNC register */
+#define MIPI_CSIS_ISPSYNC_CH0			0x48
+#define MIPI_CSIS_ISPSYNC_CH1			0x58
+#define MIPI_CSIS_ISPSYNC_CH2			0x68
+#define MIPI_CSIS_ISPSYNC_CH3			0x78
+
+#define MIPI_CSIS_ISPSYNC_HSYNC_LINTV_OFFSET	18
+#define MIPI_CSIS_ISPSYNC_VSYNC_SINTV_OFFSET 	12
+#define MIPI_CSIS_ISPSYNC_VSYNC_EINTV_OFFSET	0
+
+#define MIPI_CSIS_FRAME_COUNTER_CH0	0x0100
+#define MIPI_CSIS_FRAME_COUNTER_CH1	0x0104
+#define MIPI_CSIS_FRAME_COUNTER_CH2	0x0108
+#define MIPI_CSIS_FRAME_COUNTER_CH3	0x010C
+
+/* Non-image packet data buffers */
+#define MIPI_CSIS_PKTDATA_ODD		0x2000
+#define MIPI_CSIS_PKTDATA_EVEN		0x3000
+#define MIPI_CSIS_PKTDATA_SIZE		SZ_4K
+
+#define DEFAULT_SCLK_CSIS_FREQ		166000000UL
+
+/* display_mix_clk_en_csr */
+#define DISP_MIX_GASKET_0_CTRL			0x00
+#define GASKET_0_CTRL_DATA_TYPE(x)		(((x) & (0x3F)) << 8)
+#define GASKET_0_CTRL_DATA_TYPE_MASK		((0x3FUL) << (8))
+
+#define GASKET_0_CTRL_DATA_TYPE_YUV420_8	0x18
+#define GASKET_0_CTRL_DATA_TYPE_YUV420_10	0x19
+#define GASKET_0_CTRL_DATA_TYPE_LE_YUV420_8	0x1a
+#define GASKET_0_CTRL_DATA_TYPE_CS_YUV420_8	0x1c
+#define GASKET_0_CTRL_DATA_TYPE_CS_YUV420_10	0x1d
+#define GASKET_0_CTRL_DATA_TYPE_YUV422_8	0x1e
+#define GASKET_0_CTRL_DATA_TYPE_YUV422_10	0x1f
+#define GASKET_0_CTRL_DATA_TYPE_RGB565		0x22
+#define GASKET_0_CTRL_DATA_TYPE_RGB666		0x23
+#define GASKET_0_CTRL_DATA_TYPE_RGB888		0x24
+#define GASKET_0_CTRL_DATA_TYPE_RAW6		0x28
+#define GASKET_0_CTRL_DATA_TYPE_RAW7		0x29
+#define GASKET_0_CTRL_DATA_TYPE_RAW8		0x2a
+#define GASKET_0_CTRL_DATA_TYPE_RAW10		0x2b
+#define GASKET_0_CTRL_DATA_TYPE_RAW12		0x2c
+#define GASKET_0_CTRL_DATA_TYPE_RAW14		0x2d
+
+#define GASKET_0_CTRL_DUAL_COMP_ENABLE		BIT(1)
+#define GASKET_0_CTRL_ENABLE			BIT(0)
+
+#define DISP_MIX_GASKET_0_HSIZE			0x04
+#define DISP_MIX_GASKET_0_VSIZE			0x08
+
+#define ISP_DEWARP_CTRL				0x138
+#define ISP_DEWARP_CTRL_ISP_0_DISABLE		BIT(0)
+#define ISP_DEWARP_CTRL_ISP_1_DISABLE		BIT(1)
+#define ISP_DEWARP_CTRL_ISP_0_DATA_TYPE(x)	(((x) & (0x3F)) << 3)
+#define ISP_DEWARP_CTRL_ISP_0_LEFT_JUST_MODE	BIT(9)
+#define ISP_DEWARP_CTRL_ISP_1_DATA_TYPE(x)	(((x) & (0x3F)) << 13)
+#define ISP_DEWARP_CTRL_ISP_1_LEFT_JUST_MODE	BIT(19)
+#define ISP_DEWARP_CTRL_ID_MODE(x)		(((x) & (0x3)) << 23)
+#define ISP_DEWARP_CTRL_DATA_TYPE_RAW6		0x28
+#define ISP_DEWARP_CTRL_DATA_TYPE_RAW7		0x29
+#define ISP_DEWARP_CTRL_DATA_TYPE_RAW8		0x2a
+#define ISP_DEWARP_CTRL_DATA_TYPE_RAW10		0x2b
+#define ISP_DEWARP_CTRL_DATA_TYPE_RAW12		0x2c
+#define ISP_DEWARP_CTRL_DATA_TYPE_RAW14		0x2d
+#define ISP_DEWARP_CTRL_ID_MODE_DISABLE		0x0
+#define ISP_DEWARP_CTRL_ID_MODE_012		0x1
+#define ISP_DEWARP_CTRL_ID_MODE_01		0x2
+#define ISP_DEWARP_CTRL_ID_MODE_02		0x3
+
+struct csi_state;
+struct mipi_csis_event {
+	u32 mask;
+	const char * const name;
+	unsigned int counter;
+};
+
+/**
+ * struct csis_pix_format - CSIS pixel format description
+ * @pix_width_alignment: horizontal pixel alignment, width will be
+ *                       multiple of 2^pix_width_alignment
+ * @code: corresponding media bus code
+ * @fmt_reg: MIPI_CSIS_CONFIG register value
+ * @data_alignment: MIPI-CSI data alignment in bits
+ */
+struct csis_pix_format {
+	unsigned int pix_width_alignment;
+	u32 code;
+	u32 fmt_reg;
+	u8 data_alignment;
+};
+
+struct csis_pktbuf {
+	u32 *data;
+	unsigned int len;
+};
+
+struct csis_hw_reset1 {
+	struct regmap *src;
+	u8 req_src;
+	u8 rst_bit;
+};
+
+enum {
+	VVCSIOC_RESET = 0x100,
+	VVCSIOC_POWERON,
+	VVCSIOC_POWEROFF,
+	VVCSIOC_STREAMON,
+	VVCSIOC_STREAMOFF,
+	VVCSIOC_S_FMT,
+	VVCSIOC_S_HDR,
+};
+
+struct csi_sam_format {
+	int64_t format;
+	__u32 width;
+	__u32 height;
+};
+
+struct mipi_csis_rst_ops {
+	int (*parse)(struct csi_state *state);
+	int (*assert)(struct csi_state *state);
+	int (*deassert)(struct csi_state *state);
+};
+
+struct mipi_csis_gate_clk_ops {
+	int (*gclk_get)(struct csi_state *state);
+	int (*gclk_enable)(struct csi_state *state);
+	int (*gclk_disable)(struct csi_state *state);
+};
+
+struct mipi_csis_phy_ops {
+	void (*phy_reset)(struct csi_state *state);
+};
+
+struct mipi_csis_pdata {
+	struct mipi_csis_rst_ops *rst_ops;
+	struct mipi_csis_gate_clk_ops *gclk_ops;
+	struct mipi_csis_phy_ops *phy_ops;
+	bool use_mix_gpr;
+};
+
+static const struct mipi_csis_event mipi_csis_events[] = {
+	/* Errors */
+	{ MIPI_CSIS_INTSRC_ERR_SOT_HS,	"SOT Error" },
+	{ MIPI_CSIS_INTSRC_ERR_LOST_FS,	"Lost Frame Start Error" },
+	{ MIPI_CSIS_INTSRC_ERR_LOST_FE,	"Lost Frame End Error" },
+	{ MIPI_CSIS_INTSRC_ERR_OVER,	"FIFO Overflow Error" },
+	{ MIPI_CSIS_INTSRC_ERR_ECC,	"ECC Error" },
+	{ MIPI_CSIS_INTSRC_ERR_CRC,	"CRC Error" },
+	{ MIPI_CSIS_INTSRC_ERR_UNKNOWN,	"Unknown Error" },
+	/* Non-image data receive events */
+	{ MIPI_CSIS_INTSRC_EVEN_BEFORE,	"Non-image data before even frame" },
+	{ MIPI_CSIS_INTSRC_EVEN_AFTER,	"Non-image data after even frame" },
+	{ MIPI_CSIS_INTSRC_ODD_BEFORE,	"Non-image data before odd frame" },
+	{ MIPI_CSIS_INTSRC_ODD_AFTER,	"Non-image data after odd frame" },
+	/* Frame start/end */
+	{ MIPI_CSIS_INTSRC_FRAME_START,	"Frame Start" },
+	{ MIPI_CSIS_INTSRC_FRAME_END,	"Frame End" },
+};
+#define MIPI_CSIS_NUM_EVENTS ARRAY_SIZE(mipi_csis_events)
+
+/**
+ * struct csi_state - the driver's internal state data structure
+ * @lock: mutex serializing the subdev and power management operations,
+ *        protecting @format and @flags members
+ * @sd: v4l2_subdev associated with CSIS device instance
+ * @index: the hardware instance index
+ * @pdev: CSIS platform device
+ * @phy: pointer to the CSIS generic PHY
+ * @regs: mmaped I/O registers memory
+ * @supplies: CSIS regulator supplies
+ * @clock: CSIS clocks
+ * @irq: requested s5p-mipi-csis irq number
+ * @flags: the state variable for power and streaming control
+ * @clock_frequency: device bus clock frequency
+ * @hs_settle: HS-RX settle time
+ * @clk_settle: Clk settle time
+ * @num_lanes: number of MIPI-CSI data lanes used
+ * @max_num_lanes: maximum number of MIPI-CSI data lanes supported
+ * @wclk_ext: CSI wrapper clock: 0 - bus clock, 1 - external SCLK_CAM
+ * @csis_fmt: current CSIS pixel format
+ * @format: common media bus format for the source and sink pad
+ * @slock: spinlock protecting structure members below
+ * @pkt_buf: the frame embedded (non-image) data buffer
+ * @events: MIPI-CSIS event (error) counters
+ */
+struct csi_state {
+	struct v4l2_subdev	sd;
+	struct mutex lock;
+	struct device		*dev;
+	struct v4l2_device	v4l2_dev;
+
+	struct media_pad pads[MIPI_CSIS_VCX_PADS_NUM];
+
+	u8 index;
+	struct platform_device *pdev;
+	struct phy *phy;
+	void __iomem *regs;
+	struct clk *mipi_clk;
+	struct clk *disp_axi;
+	struct clk *disp_apb;
+	struct clk *csi_pclk;
+	struct clk *csi_aclk;
+	int irq;
+	u32 flags;
+
+	u32 clk_frequency;
+	u32 hs_settle;
+	u32 clk_settle;
+	u32 num_lanes;
+	u32 max_num_lanes;
+	u8 wclk_ext;
+
+	u8 vchannel;
+	const struct csis_pix_format *csis_fmt;
+	struct v4l2_mbus_framefmt format;
+
+	spinlock_t slock;
+	struct csis_pktbuf pkt_buf;
+	struct mipi_csis_event events[MIPI_CSIS_NUM_EVENTS];
+
+	struct v4l2_async_subdev    asd;
+	struct v4l2_async_notifier  subdev_notifier;
+	struct v4l2_async_subdev    *async_subdevs[2];
+
+	struct csis_hw_reset1 hw_reset;
+	struct regulator     *mipi_phy_regulator;
+
+	struct regmap *gasket;
+	struct regmap *mix_gpr;
+
+	struct reset_control *soft_resetn;
+	struct reset_control *clk_enable;
+	struct reset_control *mipi_reset;
+	struct reset_control *csi_rst_pclk;
+	struct reset_control *csi_rst_aclk;
+
+	struct mipi_csis_pdata const *pdata;
+	bool hdr;
+	u32 val;
+};
+
+static int debug;
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "Debug level (0-2)");
+
+static const struct csis_pix_format mipi_csis_formats[] = {
+	{
+		.code = MEDIA_BUS_FMT_YUYV8_2X8,
+		.fmt_reg = MIPI_CSIS_ISPCFG_FMT_YCBCR422_8BIT,
+		.data_alignment = 16,
+	}, {
+		.code = MEDIA_BUS_FMT_RGB888_1X24,
+		.fmt_reg = MIPI_CSIS_ISPCFG_FMT_RGB888,
+		.data_alignment = 24,
+	}, {
+		.code = MEDIA_BUS_FMT_UYVY8_2X8,
+		.fmt_reg = MIPI_CSIS_ISPCFG_FMT_YCBCR422_8BIT,
+		.data_alignment = 16,
+	}, {
+		.code = MEDIA_BUS_FMT_VYUY8_2X8,
+		.fmt_reg = MIPI_CSIS_ISPCFG_FMT_YCBCR422_8BIT,
+		.data_alignment = 16,
+	}, {
+		.code = MEDIA_BUS_FMT_SBGGR8_1X8,
+		.fmt_reg = MIPI_CSIS_ISPCFG_FMT_RAW8,
+		.data_alignment = 8,
+	}, {
+		.code = MEDIA_BUS_FMT_SBGGR10_1X10,
+		.fmt_reg = MIPI_CSIS_ISPCFG_FMT_RAW10,
+		.data_alignment = 16,
+	}, {
+		.code = MEDIA_BUS_FMT_SGBRG10_1X10,
+		.fmt_reg = MIPI_CSIS_ISPCFG_FMT_RAW10,
+		.data_alignment = 16,
+	}, {
+		.code = MEDIA_BUS_FMT_SGRBG10_1X10,
+		.fmt_reg = MIPI_CSIS_ISPCFG_FMT_RAW10,
+		.data_alignment = 16,
+	}, {
+		.code = MEDIA_BUS_FMT_SRGGB10_1X10,
+		.fmt_reg = MIPI_CSIS_ISPCFG_FMT_RAW10,
+		.data_alignment = 16,
+	}, {
+		.code = MEDIA_BUS_FMT_SBGGR12_1X12,
+		.fmt_reg = MIPI_CSIS_ISPCFG_FMT_RAW12,
+		.data_alignment = 16,
+	}, {
+		.code = MEDIA_BUS_FMT_SGBRG12_1X12,
+		.fmt_reg = MIPI_CSIS_ISPCFG_FMT_RAW12,
+		.data_alignment = 16,
+	}, {
+		.code = MEDIA_BUS_FMT_SGRBG12_1X12,
+		.fmt_reg = MIPI_CSIS_ISPCFG_FMT_RAW12,
+		.data_alignment = 16,
+	}, {
+		.code = MEDIA_BUS_FMT_SRGGB12_1X12,
+		.fmt_reg = MIPI_CSIS_ISPCFG_FMT_RAW12,
+		.data_alignment = 16,
+	},
+};
+
+#define mipi_csis_write(__csis, __r, __v) writel(__v, __csis->regs + __r)
+#define mipi_csis_read(__csis, __r) readl(__csis->regs + __r)
+
+static void dump_csis_regs(struct csi_state *state, const char *label)
+{
+	struct {
+		u32 offset;
+		const char * const name;
+	} registers[] = {
+		{ 0x00, "CSIS_VERSION" },
+		{ 0x04, "CSIS_CMN_CTRL" },
+		{ 0x08, "CSIS_CLK_CTRL" },
+		{ 0x10, "CSIS_INTMSK" },
+		{ 0x14, "CSIS_INTSRC" },
+		{ 0x20, "CSIS_DPHYSTATUS" },
+		{ 0x24, "CSIS_DPHYCTRL" },
+		{ 0x30, "CSIS_DPHYBCTRL_L" },
+		{ 0x34, "CSIS_DPHYBCTRL_H" },
+		{ 0x38, "CSIS_DPHYSCTRL_L" },
+		{ 0x3C, "CSIS_DPHYSCTRL_H" },
+		{ 0x40, "CSIS_ISPCONFIG_CH0" },
+		{ 0x50, "CSIS_ISPCONFIG_CH1" },
+		{ 0x60, "CSIS_ISPCONFIG_CH2" },
+		{ 0x70, "CSIS_ISPCONFIG_CH3" },
+		{ 0x44, "CSIS_ISPRESOL_CH0" },
+		{ 0x54, "CSIS_ISPRESOL_CH1" },
+		{ 0x64, "CSIS_ISPRESOL_CH2" },
+		{ 0x74, "CSIS_ISPRESOL_CH3" },
+		{ 0x48, "CSIS_ISPSYNC_CH0" },
+		{ 0x58, "CSIS_ISPSYNC_CH1" },
+		{ 0x68, "CSIS_ISPSYNC_CH2" },
+		{ 0x78, "CSIS_ISPSYNC_CH3" },
+	};
+	u32 i;
+
+	v4l2_dbg(2, debug, &state->sd, "--- %s ---\n", label);
+
+	for (i = 0; i < ARRAY_SIZE(registers); i++) {
+		u32 cfg = mipi_csis_read(state, registers[i].offset);
+		v4l2_dbg(2, debug, &state->sd, "%20s[%x]: 0x%.8x\n", registers[i].name, registers[i].offset, cfg);
+	}
+}
+
+static void dump_gasket_regs(struct csi_state *state, const char *label)
+{
+	struct {
+		u32 offset;
+		const char * const name;
+	} registers[] = {
+		{ 0x60, "GPR_GASKET_0_CTRL" },
+		{ 0x64, "GPR_GASKET_0_HSIZE" },
+		{ 0x68, "GPR_GASKET_0_VSIZE" },
+	};
+	u32 i, cfg;
+
+	v4l2_dbg(2, debug, &state->sd, "--- %s ---\n", label);
+
+	for (i = 0; i < ARRAY_SIZE(registers); i++) {
+		regmap_read(state->gasket, registers[i].offset, &cfg);
+		v4l2_dbg(2, debug, &state->sd, "%20s[%x]: 0x%.8x\n", registers[i].name, registers[i].offset, cfg);
+	}
+}
+
+static inline struct csi_state *mipi_sd_to_csi_state(struct v4l2_subdev *sdev)
+{
+	return container_of(sdev, struct csi_state, sd);
+}
+
+static inline struct csi_state *notifier_to_mipi_dev(struct v4l2_async_notifier *n)
+{
+	return container_of(n, struct csi_state, subdev_notifier);
+}
+
+static struct media_pad *csis_get_remote_sensor_pad(struct csi_state *state)
+{
+	struct v4l2_subdev *subdev = &state->sd;
+	struct media_pad *sink_pad, *source_pad;
+	int i;
+
+	while (1) {
+		source_pad = NULL;
+		for (i = 0; i < subdev->entity.num_pads; i++) {
+			sink_pad = &subdev->entity.pads[i];
+
+			if (sink_pad->flags & MEDIA_PAD_FL_SINK) {
+				source_pad = media_entity_remote_pad(sink_pad);
+				if (source_pad)
+					break;
+			}
+		}
+		/* return first pad point in the loop  */
+		return source_pad;
+	}
+
+	if (i == subdev->entity.num_pads)
+		v4l2_err(&state->sd, "%s, No remote pad found!\n", __func__);
+
+	return NULL;
+}
+
+static struct v4l2_subdev *csis_get_remote_subdev(struct csi_state *state,
+						  const char * const label)
+{
+	struct media_pad *source_pad;
+	struct v4l2_subdev *sen_sd;
+
+	/* Get remote source pad */
+	source_pad = csis_get_remote_sensor_pad(state);
+	if (!source_pad) {
+		v4l2_err(&state->sd, "%s, No remote pad found!\n", label);
+		return NULL;
+	}
+
+	/* Get remote source pad subdev */
+	sen_sd = media_entity_to_v4l2_subdev(source_pad->entity);
+	if (!sen_sd) {
+		v4l2_err(&state->sd, "%s, No remote subdev found!\n", label);
+		return NULL;
+	}
+
+	return sen_sd;
+}
+
+static const struct csis_pix_format *find_csis_format(u32 code)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(mipi_csis_formats); i++)
+		if (code == mipi_csis_formats[i].code)
+			return &mipi_csis_formats[i];
+	return NULL;
+}
+
+static void mipi_csis_clean_irq(struct csi_state *state)
+{
+	u32 status;
+
+	status = mipi_csis_read(state, MIPI_CSIS_INTSRC);
+	mipi_csis_write(state, MIPI_CSIS_INTSRC, status);
+
+	status = mipi_csis_read(state, MIPI_CSIS_INTMSK);
+	mipi_csis_write(state, MIPI_CSIS_INTMSK, status);
+}
+
+static void mipi_csis_enable_interrupts(struct csi_state *state, bool on)
+{
+	u32 val;
+
+	mipi_csis_clean_irq(state);
+
+	val = mipi_csis_read(state, MIPI_CSIS_INTMSK);
+	if (on)
+		val |= 0x0FFFFF1F;
+	else
+		val &= ~0x0FFFFF1F;
+	mipi_csis_write(state, MIPI_CSIS_INTMSK, val);
+}
+
+static void mipi_csis_sw_reset(struct csi_state *state)
+{
+	u32 val;
+
+	val = mipi_csis_read(state, MIPI_CSIS_CMN_CTRL);
+	val |= MIPI_CSIS_CMN_CTRL_RESET;
+	mipi_csis_write(state, MIPI_CSIS_CMN_CTRL, val);
+
+	udelay(20);
+}
+
+static int mipi_csis_phy_init(struct csi_state *state)
+{
+	state->mipi_phy_regulator = devm_regulator_get(state->dev, "mipi-phy");
+	if (IS_ERR(state->mipi_phy_regulator)) {
+		dev_err(state->dev, "Fail to get mipi-phy regulator\n");
+		return PTR_ERR(state->mipi_phy_regulator);
+	}
+
+	regulator_set_voltage(state->mipi_phy_regulator, 1000000, 1000000);
+	return 0;
+}
+
+static void mipi_csis_system_enable(struct csi_state *state, int on)
+{
+	u32 val, mask;
+
+	val = mipi_csis_read(state, MIPI_CSIS_CMN_CTRL);
+	if (on)
+		val |= MIPI_CSIS_CMN_CTRL_ENABLE;
+	else
+		val &= ~MIPI_CSIS_CMN_CTRL_ENABLE;
+	mipi_csis_write(state, MIPI_CSIS_CMN_CTRL, val);
+
+	val = mipi_csis_read(state, MIPI_CSIS_DPHYCTRL);
+	val &= ~MIPI_CSIS_DPHYCTRL_ENABLE;
+	if (on) {
+		mask = (1 << (state->num_lanes + 1)) - 1;
+		val |= (mask & MIPI_CSIS_DPHYCTRL_ENABLE);
+	}
+	mipi_csis_write(state, MIPI_CSIS_DPHYCTRL, val);
+}
+
+/* Called with the state.lock mutex held */
+static void __mipi_csis_set_format(struct csi_state *state)
+{
+	struct v4l2_mbus_framefmt *mf = &state->format;
+	u32 val;
+
+	v4l2_dbg(1, debug, &state->sd, "fmt: %#x, %d x %d\n",
+		 mf->code, mf->width, mf->height);
+
+	/* Color format */
+	val = mipi_csis_read(state, MIPI_CSIS_ISPCONFIG_CH0);
+	val &= ~MIPI_CSIS_ISPCFG_FMT_MASK;
+	val |= state->csis_fmt->fmt_reg;
+	mipi_csis_write(state, MIPI_CSIS_ISPCONFIG_CH0, val);
+
+	val = mipi_csis_read(state, MIPI_CSIS_ISPCONFIG_CH0);
+	val &= ~MIPI_CSIS_ISPCONFIG_CH0_PIXEL_MODE_MASK;
+	if (state->csis_fmt->fmt_reg == MIPI_CSIS_ISPCFG_FMT_YCBCR422_8BIT)
+		val |= (PIXEL_MODE_DUAL_PIXEL_MODE <<
+			MIPI_CSIS_ISPCONFIG_CH0_PIXEL_MODE_SHIFT);
+	mipi_csis_write(state, MIPI_CSIS_ISPCONFIG_CH0, val);
+
+	/* clean 32bit , with normal mode */
+	val &= ~MIPI_CSIS_ISPCFG_ALIGN_32BIT;
+
+	/* Pixel resolution */
+	val = mf->width | (mf->height << 16);
+	mipi_csis_write(state, MIPI_CSIS_ISPRESOL_CH0, val);
+
+	if (state->hdr) {
+		mipi_csis_write(state, MIPI_CSIS_ISPRESOL_CH1, val);
+		mipi_csis_write(state, MIPI_CSIS_ISPRESOL_CH2, val);
+		mipi_csis_write(state, MIPI_CSIS_ISPRESOL_CH3, val);
+		val = state->csis_fmt->fmt_reg;
+		mipi_csis_write(state, MIPI_CSIS_ISPCONFIG_CH1, val | 1);
+		mipi_csis_write(state, MIPI_CSIS_ISPCONFIG_CH2, val | 2);
+		mipi_csis_write(state, MIPI_CSIS_ISPCONFIG_CH3, val | 3);
+	}
+}
+
+static void mipi_csis_set_hsync_settle(struct csi_state *state)
+{
+	u32 val;
+
+	val = mipi_csis_read(state, MIPI_CSIS_DPHYCTRL);
+	val &= ~MIPI_CSIS_DPHYCTRL_HSS_MASK;
+	val |= (state->hs_settle << 24) | (state->clk_settle << 22);
+	mipi_csis_write(state, MIPI_CSIS_DPHYCTRL, val);
+}
+
+static void mipi_csis_set_params(struct csi_state *state)
+{
+	u32 val;
+
+	val = mipi_csis_read(state, MIPI_CSIS_CMN_CTRL);
+	val &= ~MIPI_CSIS_CMN_CTRL_LANE_NR_MASK;
+	val |= (state->num_lanes - 1) << MIPI_CSIS_CMN_CTRL_LANE_NR_OFFSET;
+	val |= MIPI_CSIS_CMN_CTRL_HDR_MODE;
+	mipi_csis_write(state, MIPI_CSIS_CMN_CTRL, val);
+
+	__mipi_csis_set_format(state);
+	mipi_csis_set_hsync_settle(state);
+
+	val = mipi_csis_read(state, MIPI_CSIS_ISPCONFIG_CH0);
+	if (state->csis_fmt->data_alignment == 32)
+		val |= MIPI_CSIS_ISPCFG_ALIGN_32BIT;
+	else /* Normal output */
+		val &= ~MIPI_CSIS_ISPCFG_ALIGN_32BIT;
+	mipi_csis_write(state, MIPI_CSIS_ISPCONFIG_CH0, val);
+
+	val = (0 << MIPI_CSIS_ISPSYNC_HSYNC_LINTV_OFFSET) |
+	      (0 << MIPI_CSIS_ISPSYNC_VSYNC_SINTV_OFFSET) |
+	      (0 << MIPI_CSIS_ISPSYNC_VSYNC_EINTV_OFFSET);
+	mipi_csis_write(state, MIPI_CSIS_ISPSYNC_CH0, val);
+
+	val = mipi_csis_read(state, MIPI_CSIS_CLK_CTRL);
+	val &= ~MIPI_CSIS_CLK_CTRL_WCLK_SRC;
+	if (state->wclk_ext)
+		val |= MIPI_CSIS_CLK_CTRL_WCLK_SRC;
+	val |= MIPI_CSIS_CLK_CTRL_CLKGATE_TRAIL_CH0(15);
+	val &= ~MIPI_CSIS_CLK_CTRL_CLKGATE_EN_MSK;
+	mipi_csis_write(state, MIPI_CSIS_CLK_CTRL, val);
+
+	mipi_csis_write(state, MIPI_CSIS_DPHYBCTRL_L, 0x1f4);
+	mipi_csis_write(state, MIPI_CSIS_DPHYBCTRL_H, 0);
+
+	/* Update the shadow register. */
+	val = mipi_csis_read(state, MIPI_CSIS_CMN_CTRL);
+	val |= (MIPI_CSIS_CMN_CTRL_UPDATE_SHADOW |
+		MIPI_CSIS_CMN_CTRL_UPDATE_SHADOW_CTRL);
+	if (state->hdr) {
+		val |= MIPI_CSIS_CMN_CTRL_HDR_MODE;
+		val |= 0xE0000;
+	}
+	mipi_csis_write(state, MIPI_CSIS_CMN_CTRL, val);
+}
+
+static int mipi_csis_clk_enable(struct csi_state *state)
+{
+	struct device *dev = state->dev;
+	int ret;
+
+	ret = clk_prepare_enable(state->mipi_clk);
+	if (ret) {
+		dev_err(dev, "enable mipi_clk failed!\n");
+		return ret;
+	}
+
+	ret = clk_prepare_enable(state->disp_axi);
+	if (ret) {
+		dev_err(dev, "enable disp_axi clk failed!\n");
+		return ret;
+	}
+
+	ret = clk_prepare_enable(state->disp_apb);
+	if (ret) {
+		dev_err(dev, "enable disp_apb clk failed!\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static void mipi_csis_clk_disable(struct csi_state *state)
+{
+	clk_disable_unprepare(state->mipi_clk);
+	clk_disable_unprepare(state->disp_axi);
+	clk_disable_unprepare(state->disp_apb);
+}
+
+static int mipi_csis_clk_get(struct csi_state *state)
+{
+	struct device *dev = &state->pdev->dev;
+	int ret = true;
+
+	state->mipi_clk = devm_clk_get(dev, "mipi_clk");
+	if (IS_ERR(state->mipi_clk)) {
+		dev_err(dev, "Could not get mipi csi clock\n");
+		return -ENODEV;
+	}
+
+	state->disp_axi = devm_clk_get(dev, "disp_axi");
+	if (IS_ERR(state->disp_axi)) {
+		dev_warn(dev, "Could not get disp_axi clock\n");
+		return -ENODEV;
+	}
+
+	state->disp_apb = devm_clk_get(dev, "disp_apb");
+	if (IS_ERR(state->disp_apb)) {
+		dev_warn(dev, "Could not get disp apb clock\n");
+		return -ENODEV;
+	}
+
+	/* Set clock rate */
+	if (state->clk_frequency) {
+		ret = clk_set_rate(state->mipi_clk, state->clk_frequency);
+		if (ret < 0) {
+			dev_err(dev, "set rate filed, rate=%d\n", state->clk_frequency);
+			return -EINVAL;
+		}
+	} else {
+		dev_WARN(dev, "No clock frequency specified!\n");
+	}
+
+	return 0;
+}
+
+static int disp_mix_sft_parse_resets(struct csi_state *state)
+{
+	struct mipi_csis_pdata const *pdata = state->pdata;
+
+	if (!pdata->rst_ops || !pdata->rst_ops->parse)
+		return -EINVAL;
+
+	return pdata->rst_ops->parse(state);
+}
+
+static int disp_mix_sft_rstn(struct csi_state *state, bool enable)
+{
+	struct mipi_csis_pdata const *pdata = state->pdata;
+	int ret;
+
+	if (!pdata->rst_ops ||
+	    !pdata->rst_ops->assert ||
+	    !pdata->rst_ops->deassert)
+		return -EINVAL;
+
+	ret = enable ? pdata->rst_ops->assert(state) :
+		       pdata->rst_ops->deassert(state);
+	return ret;
+}
+
+static int disp_mix_clks_get(struct csi_state *state)
+{
+	struct mipi_csis_pdata const *pdata = state->pdata;
+
+	if (!pdata->gclk_ops || !pdata->gclk_ops->gclk_get)
+		return -EINVAL;
+
+	return pdata->gclk_ops->gclk_get(state);
+}
+
+static int disp_mix_clks_enable(struct csi_state *state, bool enable)
+{
+	struct mipi_csis_pdata const *pdata = state->pdata;
+	int ret;
+
+	if (!pdata->gclk_ops ||
+	    !pdata->gclk_ops->gclk_enable ||
+	    !pdata->gclk_ops->gclk_disable)
+		return -EINVAL;
+
+	ret = enable ? pdata->gclk_ops->gclk_enable(state) :
+		       pdata->gclk_ops->gclk_disable(state);
+	return ret;
+}
+
+static void mipi_csis_phy_reset(struct csi_state *state)
+{
+	struct mipi_csis_pdata const *pdata = state->pdata;
+
+	if (!pdata->phy_ops || !pdata->phy_ops->phy_reset)
+		return;
+
+	pdata->phy_ops->phy_reset(state);
+}
+
+static void disp_mix_gasket_config(struct csi_state *state)
+{
+	struct regmap *gasket = state->gasket;
+	struct csis_pix_format const *fmt = state->csis_fmt;
+	struct v4l2_mbus_framefmt *mf = &state->format;
+	s32 fmt_val = -EINVAL;
+	u32 val;
+
+	switch (fmt->code) {
+	case MEDIA_BUS_FMT_RGB888_1X24:
+		fmt_val = GASKET_0_CTRL_DATA_TYPE_RGB888;
+		break;
+	case MEDIA_BUS_FMT_YUYV8_2X8:
+	case MEDIA_BUS_FMT_YVYU8_2X8:
+	case MEDIA_BUS_FMT_UYVY8_2X8:
+	case MEDIA_BUS_FMT_VYUY8_2X8:
+		fmt_val = GASKET_0_CTRL_DATA_TYPE_YUV422_8;
+		break;
+	case MEDIA_BUS_FMT_SBGGR8_1X8:
+		fmt_val = GASKET_0_CTRL_DATA_TYPE_RAW8;
+		break;
+	case MEDIA_BUS_FMT_SBGGR10_1X10:
+		fmt_val = GASKET_0_CTRL_DATA_TYPE_RAW10;
+		break;
+	case MEDIA_BUS_FMT_SGBRG10_1X10:
+		fmt_val = GASKET_0_CTRL_DATA_TYPE_RAW10;
+		break;
+	case MEDIA_BUS_FMT_SGRBG10_1X10:
+		fmt_val = GASKET_0_CTRL_DATA_TYPE_RAW10;
+		break;
+	case MEDIA_BUS_FMT_SRGGB10_1X10:
+		fmt_val = GASKET_0_CTRL_DATA_TYPE_RAW10;
+		break;
+	case MEDIA_BUS_FMT_SBGGR12_1X12:
+		fmt_val = GASKET_0_CTRL_DATA_TYPE_RAW12;
+		break;
+	case MEDIA_BUS_FMT_SGBRG12_1X12:
+		fmt_val = GASKET_0_CTRL_DATA_TYPE_RAW12;
+		break;
+	case MEDIA_BUS_FMT_SGRBG12_1X12:
+		fmt_val = GASKET_0_CTRL_DATA_TYPE_RAW12;
+		break;
+	case MEDIA_BUS_FMT_SRGGB12_1X12:
+		fmt_val = GASKET_0_CTRL_DATA_TYPE_RAW12;
+		break;
+	default:
+		pr_err("gasket not support format %d\n", fmt->code);
+		return;
+	}
+
+	regmap_read(gasket, DISP_MIX_GASKET_0_CTRL, &val);
+	if (fmt_val == GASKET_0_CTRL_DATA_TYPE_YUV422_8)
+		val |= GASKET_0_CTRL_DUAL_COMP_ENABLE;
+	val |= GASKET_0_CTRL_DATA_TYPE(fmt_val);
+	regmap_write(gasket, DISP_MIX_GASKET_0_CTRL, val);
+
+	if (WARN_ON(!mf->width || !mf->height))
+		return;
+
+	regmap_write(gasket, DISP_MIX_GASKET_0_HSIZE, mf->width);
+	regmap_write(gasket, DISP_MIX_GASKET_0_VSIZE, mf->height);
+}
+
+static void disp_mix_gasket_enable(struct csi_state *state, bool enable)
+{
+	struct regmap *gasket = state->gasket;
+
+	if (enable)
+		regmap_update_bits(gasket, DISP_MIX_GASKET_0_CTRL,
+					GASKET_0_CTRL_ENABLE,
+					GASKET_0_CTRL_ENABLE);
+	else
+		regmap_update_bits(gasket, DISP_MIX_GASKET_0_CTRL,
+					GASKET_0_CTRL_ENABLE,
+					0);
+}
+
+static void mipi_csis_start_stream(struct csi_state *state)
+{
+	mipi_csis_sw_reset(state);
+
+	disp_mix_gasket_config(state);
+	mipi_csis_set_params(state);
+
+	mipi_csis_system_enable(state, true);
+	disp_mix_gasket_enable(state, true);
+	mipi_csis_enable_interrupts(state, true);
+
+	msleep(5);
+}
+
+static void mipi_csis_stop_stream(struct csi_state *state)
+{
+	mipi_csis_enable_interrupts(state, false);
+	mipi_csis_system_enable(state, false);
+	disp_mix_gasket_enable(state, false);
+}
+
+static void mipi_csis_clear_counters(struct csi_state *state)
+{
+	unsigned long flags;
+	int i;
+
+	spin_lock_irqsave(&state->slock, flags);
+	for (i = 0; i < MIPI_CSIS_NUM_EVENTS; i++)
+		state->events[i].counter = 0;
+	spin_unlock_irqrestore(&state->slock, flags);
+}
+
+static void mipi_csis_log_counters(struct csi_state *state, bool non_errors)
+{
+	int i = non_errors ? MIPI_CSIS_NUM_EVENTS : MIPI_CSIS_NUM_EVENTS - 4;
+	unsigned long flags;
+
+	spin_lock_irqsave(&state->slock, flags);
+
+	for (i--; i >= 0; i--) {
+		if (state->events[i].counter > 0 || debug)
+			v4l2_info(&state->sd, "%s events: %d\n",
+				  state->events[i].name,
+				  state->events[i].counter);
+	}
+	spin_unlock_irqrestore(&state->slock, flags);
+}
+
+static int mipi_csi2_link_setup(struct media_entity *entity,
+			   const struct media_pad *local,
+			   const struct media_pad *remote, u32 flags)
+{
+	return 0;
+}
+
+static const struct media_entity_operations mipi_csi2_sd_media_ops = {
+	.link_setup = mipi_csi2_link_setup,
+};
+
+/*
+ * V4L2 subdev operations
+ */
+static int mipi_csis_s_power(struct v4l2_subdev *mipi_sd, int on)
+{
+	struct csi_state *state = mipi_sd_to_csi_state(mipi_sd);
+	struct v4l2_subdev *sen_sd;
+
+	/* Get remote source pad subdev */
+	sen_sd = csis_get_remote_subdev(state, __func__);
+	if (!sen_sd) {
+		v4l2_err(&state->sd, "%s, No remote subdev found!\n", __func__);
+		return -EINVAL;
+	}
+
+	return v4l2_subdev_call(sen_sd, core, s_power, on);
+}
+
+static int mipi_csis_s_stream(struct v4l2_subdev *mipi_sd, int enable)
+{
+	struct csi_state *state = mipi_sd_to_csi_state(mipi_sd);
+
+	v4l2_dbg(1, debug, mipi_sd, "%s: %d, state: 0x%x\n",
+		 __func__, enable, state->flags);
+
+	if (enable) {
+		pm_runtime_get_sync(state->dev);
+		mipi_csis_clear_counters(state);
+		mipi_csis_start_stream(state);
+		dump_csis_regs(state, __func__);
+		dump_gasket_regs(state, __func__);
+	} else {
+		mipi_csis_stop_stream(state);
+		if (debug > 0)
+			mipi_csis_log_counters(state, true);
+		pm_runtime_put(state->dev);
+	}
+
+	return 0;
+}
+
+static int mipi_csis_set_fmt(struct v4l2_subdev *mipi_sd,
+			     struct v4l2_subdev_state *sd_state,
+			     struct v4l2_subdev_format *format)
+{
+	struct csi_state *state = mipi_sd_to_csi_state(mipi_sd);
+	struct v4l2_mbus_framefmt *mf = &format->format;
+	struct csis_pix_format const *csis_fmt;
+	struct media_pad *source_pad;
+	struct v4l2_subdev *sen_sd;
+	int ret;
+
+	/* Get remote source pad */
+	source_pad = csis_get_remote_sensor_pad(state);
+	if (!source_pad) {
+		v4l2_err(&state->sd, "%s, No remote pad found!\n", __func__);
+		return -EINVAL;
+	}
+
+	/* Get remote source pad subdev */
+	sen_sd = csis_get_remote_subdev(state, __func__);
+	if (!sen_sd) {
+		v4l2_err(&state->sd, "%s, No remote subdev found!\n", __func__);
+		return -EINVAL;
+	}
+
+	format->pad = source_pad->index;
+	mf->code = MEDIA_BUS_FMT_UYVY8_2X8;
+	ret = v4l2_subdev_call(sen_sd, pad, set_fmt, NULL, format);
+	if (ret < 0) {
+		v4l2_err(&state->sd, "%s, set sensor format fail\n", __func__);
+		return -EINVAL;
+	}
+
+	csis_fmt = find_csis_format(mf->code);
+	if (!csis_fmt) {
+		csis_fmt = &mipi_csis_formats[0];
+		mf->code = csis_fmt->code;
+	}
+
+	state->csis_fmt = csis_fmt;
+
+	return 0;
+}
+
+static int mipi_csis_get_fmt(struct v4l2_subdev *mipi_sd,
+			     struct v4l2_subdev_state *sd_state,
+			     struct v4l2_subdev_format *format)
+{
+	struct csi_state *state = mipi_sd_to_csi_state(mipi_sd);
+	struct v4l2_mbus_framefmt *mf = &state->format;
+	struct media_pad *source_pad;
+	struct v4l2_subdev *sen_sd;
+	int ret;
+
+	/* Get remote source pad */
+	source_pad = csis_get_remote_sensor_pad(state);
+	if (!source_pad) {
+		v4l2_err(&state->sd, "%s, No remote pad found!\n", __func__);
+		return -EINVAL;
+	}
+
+	/* Get remote source pad subdev */
+	sen_sd = csis_get_remote_subdev(state, __func__);
+	if (!sen_sd) {
+		v4l2_err(&state->sd, "%s, No remote subdev found!\n", __func__);
+		return -EINVAL;
+	}
+
+	format->pad = source_pad->index;
+	ret = v4l2_subdev_call(sen_sd, pad, get_fmt, NULL, format);
+	if (ret < 0) {
+		v4l2_err(&state->sd, "%s, call get_fmt of subdev failed!\n", __func__);
+		return ret;
+	}
+
+	memcpy(mf, &format->format, sizeof(struct v4l2_mbus_framefmt));
+	return 0;
+}
+
+static int mipi_csis_s_rx_buffer(struct v4l2_subdev *mipi_sd, void *buf,
+			       unsigned int *size)
+{
+	struct csi_state *state = mipi_sd_to_csi_state(mipi_sd);
+	unsigned long flags;
+
+	*size = min_t(unsigned int, *size, MIPI_CSIS_PKTDATA_SIZE);
+
+	spin_lock_irqsave(&state->slock, flags);
+	state->pkt_buf.data = buf;
+	state->pkt_buf.len = *size;
+	spin_unlock_irqrestore(&state->slock, flags);
+
+	return 0;
+}
+
+static int mipi_csis_s_frame_interval(struct v4l2_subdev *mipi_sd,
+				struct v4l2_subdev_frame_interval *interval)
+{
+	struct csi_state *state = mipi_sd_to_csi_state(mipi_sd);
+	struct v4l2_subdev *sen_sd;
+
+	/* Get remote source pad subdev */
+	sen_sd = csis_get_remote_subdev(state, __func__);
+	if (!sen_sd) {
+		v4l2_err(&state->sd, "%s, No remote subdev found!\n", __func__);
+		return -EINVAL;
+	}
+
+	return v4l2_subdev_call(sen_sd, video, s_frame_interval, interval);
+}
+
+static int mipi_csis_g_frame_interval(struct v4l2_subdev *mipi_sd,
+				struct v4l2_subdev_frame_interval *interval)
+{
+	struct csi_state *state = mipi_sd_to_csi_state(mipi_sd);
+	struct v4l2_subdev *sen_sd;
+
+	/* Get remote source pad subdev */
+	sen_sd = csis_get_remote_subdev(state, __func__);
+	if (!sen_sd) {
+		v4l2_err(&state->sd, "%s, No remote subdev found!\n", __func__);
+		return -EINVAL;
+	}
+
+	return v4l2_subdev_call(sen_sd, video, g_frame_interval, interval);
+}
+
+static int mipi_csis_enum_framesizes(struct v4l2_subdev *mipi_sd,
+		struct v4l2_subdev_state *sd_state,
+		struct v4l2_subdev_frame_size_enum *fse)
+{
+	struct csi_state *state = mipi_sd_to_csi_state(mipi_sd);
+	struct v4l2_subdev *sen_sd;
+
+	/* Get remote source pad subdev */
+	sen_sd = csis_get_remote_subdev(state, __func__);
+	if (!sen_sd) {
+		v4l2_err(&state->sd, "%s, No remote subdev found!\n", __func__);
+		return -EINVAL;
+	}
+
+	return v4l2_subdev_call(sen_sd, pad, enum_frame_size, NULL, fse);
+}
+
+static int mipi_csis_enum_frameintervals(struct v4l2_subdev *mipi_sd,
+		struct v4l2_subdev_state *sd_state,
+		struct v4l2_subdev_frame_interval_enum *fie)
+{
+	struct csi_state *state = mipi_sd_to_csi_state(mipi_sd);
+	struct v4l2_subdev *sen_sd;
+
+	/* Get remote source pad subdev */
+	sen_sd = csis_get_remote_subdev(state, __func__);
+	if (!sen_sd) {
+		v4l2_err(&state->sd, "%s, No remote subdev found!\n", __func__);
+		return -EINVAL;
+	}
+
+	return v4l2_subdev_call(sen_sd, pad, enum_frame_interval, NULL, fie);
+}
+
+static int mipi_csis_log_status(struct v4l2_subdev *mipi_sd)
+{
+	struct csi_state *state = mipi_sd_to_csi_state(mipi_sd);
+
+	mutex_lock(&state->lock);
+	mipi_csis_log_counters(state, true);
+	if (debug) {
+		dump_csis_regs(state, __func__);
+		dump_gasket_regs(state, __func__);
+	}
+	mutex_unlock(&state->lock);
+	return 0;
+}
+
+static int csis_s_fmt(struct v4l2_subdev *sd, struct csi_sam_format *fmt)
+{
+	u32 code;
+	const struct csis_pix_format *csis_format;
+	struct csi_state *state = container_of(sd, struct csi_state, sd);
+
+	switch (fmt->format) {
+	case V4L2_PIX_FMT_SBGGR10:
+	    code = MEDIA_BUS_FMT_SBGGR10_1X10;
+	    break;
+	case V4L2_PIX_FMT_SGBRG10:
+	    code = MEDIA_BUS_FMT_SGBRG10_1X10;
+	    break;
+	case V4L2_PIX_FMT_SGRBG10:
+	    code = MEDIA_BUS_FMT_SGRBG10_1X10;
+	    break;
+	case V4L2_PIX_FMT_SRGGB10:
+	    code = MEDIA_BUS_FMT_SRGGB10_1X10;
+	    break;
+	case V4L2_PIX_FMT_SBGGR12:
+	    code = MEDIA_BUS_FMT_SBGGR12_1X12;
+	    break;
+	case V4L2_PIX_FMT_SGBRG12:
+	    code = MEDIA_BUS_FMT_SGBRG12_1X12;
+	    break;
+	case V4L2_PIX_FMT_SGRBG12:
+	    code = MEDIA_BUS_FMT_SGRBG12_1X12;
+	    break;
+	case V4L2_PIX_FMT_SRGGB12:
+	    code = MEDIA_BUS_FMT_SRGGB12_1X12;
+	    break;
+	default:
+		return -EINVAL;
+	}
+	csis_format = find_csis_format(code);
+	if (csis_format == NULL)
+		return -EINVAL;
+
+	state->csis_fmt = csis_format;
+	state->format.width = fmt->width;
+	state->format.height = fmt->height;
+	disp_mix_gasket_config(state);
+	mipi_csis_set_params(state);
+	return 0;
+}
+
+static int csis_s_hdr(struct v4l2_subdev *sd, bool enable)
+{
+	struct csi_state *state = container_of(sd, struct csi_state, sd);
+
+	v4l2_dbg(2, debug, &state->sd, "%s: %d\n", __func__, enable);
+	state->hdr = enable;
+	return 0;
+}
+
+static int csis_ioc_qcap(struct v4l2_subdev *dev, void *args)
+{
+	struct csi_state *state = mipi_sd_to_csi_state(dev);
+	struct v4l2_capability *cap = (struct v4l2_capability *)args;
+	strlcpy((char *)cap->driver, "csi_sam_subdev", sizeof(cap->driver));
+	cap->bus_info[0] = state->index;
+	return 0;
+}
+
+#ifdef CONFIG_HARDENED_USERCOPY
+#define USER_TO_KERNEL(TYPE) \
+	({\
+		TYPE tmp; \
+		arg = (void *)(&tmp); \
+		copy_from_user(arg, arg_user, sizeof(TYPE));\
+	})
+
+#define KERNEL_TO_USER(TYPE) \
+		copy_to_user(arg_user, arg, sizeof(TYPE));
+#else
+#define USER_TO_KERNEL(TYPE)
+#define KERNEL_TO_USER(TYPE)
+#endif
+static long csis_priv_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg_user)
+{
+	int ret = 1;
+	struct csi_state *state = container_of(sd, struct csi_state, sd);
+	void *arg = arg_user;
+
+	pm_runtime_get_sync(state->dev);
+
+	switch (cmd) {
+	case VVCSIOC_RESET:
+		mipi_csis_sw_reset(state);
+		ret = 0;
+		break;
+	case VVCSIOC_POWERON:
+		ret = mipi_csis_s_power(sd, 1);
+		break;
+	case VVCSIOC_POWEROFF:
+		ret = mipi_csis_s_power(sd, 0);
+		break;
+	case VVCSIOC_STREAMON:
+		ret = mipi_csis_s_stream(sd, 1);
+		break;
+	case VVCSIOC_STREAMOFF:
+		ret = mipi_csis_s_stream(sd, 0);
+		break;
+	case VVCSIOC_S_FMT: {
+		USER_TO_KERNEL(struct csi_sam_format);
+		ret = csis_s_fmt(sd, (struct csi_sam_format *)arg);
+		break;
+	}
+	case VVCSIOC_S_HDR: {
+		USER_TO_KERNEL(bool);
+		ret = csis_s_hdr(sd, *(bool *) arg);
+		break;
+	}
+	case VIDIOC_QUERYCAP:
+		ret = csis_ioc_qcap(sd, arg);
+		break;
+	default:
+		v4l2_err(&state->sd, "unsupported csi-sam command %d.", cmd);
+		ret = -EINVAL;
+		break;
+	}
+	pm_runtime_put(state->dev);
+
+	return ret;
+}
+
+
+static struct v4l2_subdev_core_ops mipi_csis_core_ops = {
+	.s_power = mipi_csis_s_power,
+	.log_status = mipi_csis_log_status,
+	.ioctl = csis_priv_ioctl,
+};
+
+static struct v4l2_subdev_video_ops mipi_csis_video_ops = {
+	.s_rx_buffer = mipi_csis_s_rx_buffer,
+	.s_stream = mipi_csis_s_stream,
+
+	.g_frame_interval = mipi_csis_g_frame_interval,
+	.s_frame_interval = mipi_csis_s_frame_interval,
+};
+
+static const struct v4l2_subdev_pad_ops mipi_csis_pad_ops = {
+	.enum_frame_size       = mipi_csis_enum_framesizes,
+	.enum_frame_interval   = mipi_csis_enum_frameintervals,
+	.get_fmt               = mipi_csis_get_fmt,
+	.set_fmt               = mipi_csis_set_fmt,
+};
+
+static struct v4l2_subdev_ops mipi_csis_subdev_ops = {
+	.core = &mipi_csis_core_ops,
+	.video = &mipi_csis_video_ops,
+	.pad = &mipi_csis_pad_ops,
+};
+
+static irqreturn_t mipi_csis_irq_handler(int irq, void *dev_id)
+{
+	struct csi_state *state = dev_id;
+	struct csis_pktbuf *pktbuf = &state->pkt_buf;
+	unsigned long flags;
+	u32 status;
+
+	status = mipi_csis_read(state, MIPI_CSIS_INTSRC);
+
+	spin_lock_irqsave(&state->slock, flags);
+	if ((status & MIPI_CSIS_INTSRC_NON_IMAGE_DATA) && pktbuf->data) {
+		u32 offset;
+
+		if (status & MIPI_CSIS_INTSRC_EVEN)
+			offset = MIPI_CSIS_PKTDATA_EVEN;
+		else
+			offset = MIPI_CSIS_PKTDATA_ODD;
+
+		memcpy(pktbuf->data, state->regs + offset, pktbuf->len);
+		pktbuf->data = NULL;
+		rmb();
+	}
+
+	/* Update the event/error counters */
+	if ((status & MIPI_CSIS_INTSRC_ERRORS) || debug) {
+		int i;
+		for (i = 0; i < MIPI_CSIS_NUM_EVENTS; i++) {
+			if (!(status & state->events[i].mask))
+				continue;
+			state->events[i].counter++;
+			v4l2_dbg(2, debug, &state->sd, "%s: %d\n",
+				 state->events[i].name,
+				 state->events[i].counter);
+		}
+		v4l2_dbg(2, debug, &state->sd, "status: %08x\n", status);
+	}
+	spin_unlock_irqrestore(&state->slock, flags);
+
+	mipi_csis_write(state, MIPI_CSIS_INTSRC, status);
+	return IRQ_HANDLED;
+}
+
+static int mipi_csis_parse_dt(struct platform_device *pdev,
+			    struct csi_state *state)
+{
+	struct device_node *node = pdev->dev.of_node;
+
+	state->index = of_alias_get_id(node, "csi");
+
+	if (of_property_read_u32(node, "clock-frequency", &state->clk_frequency))
+		state->clk_frequency = DEFAULT_SCLK_CSIS_FREQ;
+
+	if (of_property_read_u32(node, "bus-width", &state->max_num_lanes))
+		return -EINVAL;
+
+	node = of_graph_get_next_endpoint(node, NULL);
+	if (!node) {
+		dev_err(&pdev->dev, "No port node\n");
+		return -EINVAL;
+	}
+
+	/* Get MIPI CSI-2 bus configration from the endpoint node. */
+	of_property_read_u32(node, "csis-hs-settle", &state->hs_settle);
+	of_property_read_u32(node, "csis-clk-settle", &state->clk_settle);
+	of_property_read_u32(node, "data-lanes", &state->num_lanes);
+
+	state->wclk_ext = of_property_read_bool(node, "csis-wclk");
+
+	of_node_put(node);
+	return 0;
+}
+
+static const struct of_device_id mipi_csis_of_match[];
+
+/* init subdev */
+static int mipi_csis_subdev_init(struct v4l2_subdev *mipi_sd,
+		struct platform_device *pdev,
+		const struct v4l2_subdev_ops *ops)
+{
+	struct csi_state *state = platform_get_drvdata(pdev);
+	int ret = 0;
+
+	v4l2_subdev_init(mipi_sd, ops);
+	mipi_sd->owner = THIS_MODULE;
+	snprintf(mipi_sd->name, sizeof(mipi_sd->name), "%s.%d",
+		 CSIS_SUBDEV_NAME, state->index);
+	mipi_sd->entity.function = MEDIA_ENT_F_IO_V4L;
+	mipi_sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	mipi_sd->dev = &pdev->dev;
+
+	state->csis_fmt      = &mipi_csis_formats[0];
+	state->format.code   = mipi_csis_formats[0].code;
+	state->format.width  = MIPI_CSIS_DEF_PIX_WIDTH;
+	state->format.height = MIPI_CSIS_DEF_PIX_HEIGHT;
+
+	/* This allows to retrieve the platform device id by the host driver */
+	v4l2_set_subdevdata(mipi_sd, state);
+
+	return ret;
+}
+
+/*
+ * IMX8MN platform data
+ */
+static int mipi_csis_imx8mn_parse_resets(struct csi_state *state)
+{
+	int ret;
+	struct device *dev = state->dev;
+	struct device_node *np = dev->of_node;
+	struct device_node *parent, *child;
+	struct of_phandle_args args;
+	struct reset_control *rstc;
+	const char *compat;
+	uint32_t len, rstc_num = 0;
+
+	ret = of_parse_phandle_with_args(np, "resets", "#reset-cells",
+					 0, &args);
+	if (ret)
+		return ret;
+
+	parent = args.np;
+	for_each_child_of_node(parent, child) {
+		compat = of_get_property(child, "compatible", NULL);
+		if (!compat)
+			continue;
+
+		rstc = of_reset_control_array_get(child, false, false, true);
+		if (IS_ERR(rstc))
+			continue;
+
+		len = strlen(compat);
+		if (!of_compat_cmp("csi,soft-resetn", compat, len)) {
+			state->soft_resetn = rstc;
+			rstc_num++;
+		} else if (!of_compat_cmp("csi,clk-enable", compat, len)) {
+			state->clk_enable = rstc;
+			rstc_num++;
+		} else if (!of_compat_cmp("csi,mipi-reset", compat, len)) {
+			state->mipi_reset = rstc;
+			rstc_num++;
+		} else {
+			dev_warn(dev, "invalid csis reset node: %s\n", compat);
+		}
+	}
+
+	if (!rstc_num) {
+		dev_err(dev, "no invalid reset control exists\n");
+		return -EINVAL;
+	}
+	of_node_put(parent);
+
+	return 0;
+}
+
+static int mipi_csis_imx8mn_resets_assert(struct csi_state *state)
+{
+	if (!state->soft_resetn)
+		return -EINVAL;
+
+	return reset_control_assert(state->soft_resetn);
+}
+
+static int mipi_csis_imx8mn_resets_deassert(struct csi_state *state)
+{
+	if (!state->soft_resetn)
+		return -EINVAL;
+
+	return reset_control_deassert(state->soft_resetn);
+}
+
+static struct mipi_csis_rst_ops imx8mn_rst_ops = {
+	.parse  = mipi_csis_imx8mn_parse_resets,
+	.assert = mipi_csis_imx8mn_resets_assert,
+	.deassert = mipi_csis_imx8mn_resets_deassert,
+};
+
+static int mipi_csis_imx8mn_gclk_get(struct csi_state *state)
+{
+	if (state->clk_enable)
+		return 0;
+
+	return mipi_csis_imx8mn_parse_resets(state);
+}
+
+static int mipi_csis_imx8mn_gclk_enable(struct csi_state *state)
+{
+	if (!state->clk_enable)
+		return -EINVAL;
+
+	return reset_control_assert(state->clk_enable);
+}
+
+static int mipi_csis_imx8mn_gclk_disable(struct csi_state *state)
+{
+	if (!state->clk_enable)
+		return -EINVAL;
+
+	return reset_control_deassert(state->clk_enable);
+}
+
+static struct mipi_csis_gate_clk_ops imx8mn_gclk_ops = {
+	.gclk_get = mipi_csis_imx8mn_gclk_get,
+	.gclk_enable  = mipi_csis_imx8mn_gclk_enable,
+	.gclk_disable = mipi_csis_imx8mn_gclk_disable,
+};
+
+static void mipi_csis_imx8mn_phy_reset(struct csi_state *state)
+{
+	struct reset_control *reset = state->mipi_reset;
+
+	reset_control_assert(reset);
+	usleep_range(10, 20);
+
+	reset_control_deassert(reset);
+	usleep_range(10, 20);
+}
+
+static struct mipi_csis_phy_ops imx8mn_phy_ops = {
+	.phy_reset = mipi_csis_imx8mn_phy_reset,
+};
+
+static struct mipi_csis_pdata mipi_csis_imx8mn_pdata = {
+	.rst_ops  = &imx8mn_rst_ops,
+	.gclk_ops = &imx8mn_gclk_ops,
+	.phy_ops  = &imx8mn_phy_ops,
+	.use_mix_gpr = false,
+};
+
+/*
+ * IMX8MP platform data
+ */
+static int mipi_csis_imx8mp_parse_resets(struct csi_state *state)
+{
+	struct device *dev = state->dev;
+	struct reset_control *reset;
+
+	reset = devm_reset_control_get(dev, "csi_rst_pclk");
+	if (IS_ERR(reset)) {
+		if (PTR_ERR(reset) != -EPROBE_DEFER)
+			dev_err(dev, "Failed to get csi pclk reset control\n");
+		return PTR_ERR(reset);
+	}
+	state->csi_rst_pclk = reset;
+
+	reset = devm_reset_control_get(dev, "csi_rst_aclk");
+	if (IS_ERR(reset)) {
+		if (PTR_ERR(reset) != -EPROBE_DEFER)
+			dev_err(dev, "Failed to get csi aclk reset control\n");
+		return PTR_ERR(reset);
+	}
+	state->csi_rst_aclk = reset;
+
+	return 0;
+}
+
+static int mipi_csis_imx8mp_resets_assert(struct csi_state *state)
+{
+	struct device *dev = state->dev;
+	int ret;
+
+	if (!state->csi_rst_pclk || !state->csi_rst_aclk)
+		return -EINVAL;
+
+	ret = reset_control_assert(state->csi_rst_pclk);
+	if (ret) {
+		dev_err(dev, "Failed to assert csi pclk reset control\n");
+		return ret;
+	}
+
+	ret = reset_control_assert(state->csi_rst_aclk);
+	if (ret) {
+		dev_err(dev, "Failed to assert csi aclk reset control\n");
+		return ret;
+	}
+
+	return ret;
+}
+
+static int mipi_csis_imx8mp_resets_deassert(struct csi_state *state)
+{
+	if (!state->csi_rst_pclk || !state->csi_rst_aclk)
+		return -EINVAL;
+
+	reset_control_deassert(state->csi_rst_pclk);
+	reset_control_deassert(state->csi_rst_aclk);
+
+	return 0;
+}
+
+static struct mipi_csis_rst_ops imx8mp_rst_ops = {
+	.parse  = mipi_csis_imx8mp_parse_resets,
+	.assert = mipi_csis_imx8mp_resets_assert,
+	.deassert = mipi_csis_imx8mp_resets_deassert,
+};
+
+static int mipi_csis_imx8mp_gclk_get(struct csi_state *state)
+{
+	struct device *dev = state->dev;
+
+	state->csi_pclk = devm_clk_get(dev, "media_blk_csi_pclk");
+	if (IS_ERR(state->csi_pclk)) {
+		if (PTR_ERR(state->csi_pclk) != -EPROBE_DEFER)
+			dev_err(dev, "Failed to get media csi pclk\n");
+		return PTR_ERR(state->csi_pclk);
+	}
+
+	state->csi_aclk = devm_clk_get(dev, "media_blk_csi_aclk");
+	if (IS_ERR(state->csi_aclk)) {
+		if (PTR_ERR(state->csi_pclk) != -EPROBE_DEFER)
+			dev_err(dev, "Failed to get media csi aclk\n");
+		return PTR_ERR(state->csi_pclk);
+	}
+
+	return 0;
+}
+
+static int mipi_csis_imx8mp_gclk_enable(struct csi_state *state)
+{
+	struct device *dev = state->dev;
+	int ret;
+
+	ret = clk_prepare_enable(state->csi_pclk);
+	if (ret) {
+		dev_err(dev, "enable csi_pclk failed!\n");
+		return ret;
+	}
+
+	ret = clk_prepare_enable(state->csi_aclk);
+	if (ret) {
+		dev_err(dev, "enable csi_aclk failed!\n");
+		return ret;
+	}
+
+	return ret;
+}
+
+static int mipi_csis_imx8mp_gclk_disable(struct csi_state *state)
+{
+	clk_disable_unprepare(state->csi_pclk);
+	clk_disable_unprepare(state->csi_aclk);
+	return 0;
+}
+
+static struct mipi_csis_gate_clk_ops imx8mp_gclk_ops = {
+	.gclk_get = mipi_csis_imx8mp_gclk_get,
+	.gclk_enable  = mipi_csis_imx8mp_gclk_enable,
+	.gclk_disable = mipi_csis_imx8mp_gclk_disable,
+};
+
+static void mipi_csis_imx8mp_dewarp_ctl_data_type(struct csi_state *state,
+		int bus_width)
+{
+	switch (state->index) {
+	case 0:
+		state->val = ISP_DEWARP_CTRL_ISP_0_DATA_TYPE(bus_width);
+		break;
+	case 1:
+		state->val = ISP_DEWARP_CTRL_ISP_1_DATA_TYPE(bus_width);
+		break;
+	default:
+		v4l2_err(&state->sd, "%s :csi subdev index err!\n", __func__);
+		break;
+	}
+}
+
+static void mipi_csis_imx8mp_dewarp_ctl_left_just_mode(struct csi_state *state)
+{
+	switch (state->index) {
+	case 0:
+		state->val |= ISP_DEWARP_CTRL_ISP_0_LEFT_JUST_MODE;
+		break;
+	case 1:
+		state->val |= ISP_DEWARP_CTRL_ISP_1_LEFT_JUST_MODE;
+		break;
+	default:
+		v4l2_err(&state->sd, "%s :csi subdev index err!\n", __func__);
+		break;
+	}
+}
+
+static void mipi_csis_imx8mp_phy_reset(struct csi_state *state)
+{
+	int ret = 0;
+	struct v4l2_subdev *sen_sd;
+
+	struct v4l2_subdev_mbus_code_enum code = {
+		.which = V4L2_SUBDEV_FORMAT_ACTIVE,
+	};
+
+	mipi_csis_imx8mn_phy_reset(state);
+	sen_sd = csis_get_remote_subdev(state, __func__);
+	if (!sen_sd)
+		goto csi_phy_initial_cfg;
+
+	ret = v4l2_subdev_call(sen_sd, pad, enum_mbus_code, NULL, &code);
+	if (ret < 0 && ret != -ENOIOCTLCMD) {
+		v4l2_err(&state->sd, "enum_mbus_code error !!!\n");
+		return;
+	} else if (ret == -ENOIOCTLCMD)
+		goto csi_phy_initial_cfg;
+
+	/* temporary place */
+	if (state->mix_gpr) {
+		if ((code.code == MEDIA_BUS_FMT_SRGGB8_1X8) ||
+				(code.code == MEDIA_BUS_FMT_SGRBG8_1X8) ||
+				(code.code == MEDIA_BUS_FMT_SGBRG8_1X8) ||
+				(code.code == MEDIA_BUS_FMT_SBGGR8_1X8)) {
+			mipi_csis_imx8mp_dewarp_ctl_data_type(state,
+					 ISP_DEWARP_CTRL_DATA_TYPE_RAW8);
+			v4l2_dbg(1, debug, &state->sd,
+					"%s: bus fmt is 8 bit!\n", __func__);
+		} else if ((code.code == MEDIA_BUS_FMT_SRGGB10_1X10) ||
+				(code.code == MEDIA_BUS_FMT_SGRBG10_1X10) ||
+				(code.code == MEDIA_BUS_FMT_SGBRG10_1X10) ||
+				(code.code == MEDIA_BUS_FMT_SBGGR10_1X10)) {
+			mipi_csis_imx8mp_dewarp_ctl_data_type(state,
+					ISP_DEWARP_CTRL_DATA_TYPE_RAW10);
+			v4l2_dbg(1, debug, &state->sd,
+					"%s: bus fmt is 10 bit !\n", __func__);
+		} else {
+			mipi_csis_imx8mp_dewarp_ctl_data_type(state,
+					ISP_DEWARP_CTRL_DATA_TYPE_RAW12);
+			v4l2_dbg(1, debug, &state->sd,
+					"%s: bus fmt is 12 bit !\n", __func__);
+		}
+		goto write_regmap;
+	}
+
+csi_phy_initial_cfg:
+	mipi_csis_imx8mp_dewarp_ctl_data_type(state,
+			ISP_DEWARP_CTRL_DATA_TYPE_RAW12);
+	v4l2_dbg(1, debug, &state->sd,
+			"%s: bus fmt is 12 bit !\n", __func__);
+
+write_regmap:
+	state->val |= ISP_DEWARP_CTRL_ID_MODE(ISP_DEWARP_CTRL_ID_MODE_012);
+	mipi_csis_imx8mp_dewarp_ctl_left_just_mode(state);
+	regmap_update_bits(state->mix_gpr, ISP_DEWARP_CTRL,
+			state->val, state->val);
+
+	return;
+}
+
+static struct mipi_csis_phy_ops imx8mp_phy_ops = {
+	.phy_reset = mipi_csis_imx8mp_phy_reset,
+};
+
+static struct mipi_csis_pdata mipi_csis_imx8mp_pdata = {
+	.rst_ops  = &imx8mp_rst_ops,
+	.gclk_ops = &imx8mp_gclk_ops,
+	.phy_ops  = &imx8mp_phy_ops,
+	.use_mix_gpr = true,
+};
+
+static int mipi_csis_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct v4l2_subdev *mipi_sd;
+	struct resource *mem_res;
+	struct csi_state *state;
+	const struct of_device_id *of_id;
+	int ret = -ENOMEM;
+
+	state = devm_kzalloc(dev, sizeof(*state), GFP_KERNEL);
+	if (!state)
+		return -ENOMEM;
+
+	mutex_init(&state->lock);
+	spin_lock_init(&state->slock);
+
+	state->pdev = pdev;
+	mipi_sd = &state->sd;
+	state->dev = dev;
+	state->val = 0;
+
+	ret = mipi_csis_parse_dt(pdev, state);
+	if (ret < 0)
+		return ret;
+
+	if (state->num_lanes == 0 || state->num_lanes > state->max_num_lanes) {
+		dev_err(dev, "Unsupported number of data lanes: %d (max. %d)\n",
+			state->num_lanes, state->max_num_lanes);
+		return -EINVAL;
+	}
+
+	ret = mipi_csis_phy_init(state);
+	if (ret < 0)
+		return ret;
+
+	of_id = of_match_node(mipi_csis_of_match, dev->of_node);
+	if (!of_id || !of_id->data) {
+		dev_err(dev, "No match data for %s\n", dev_name(dev));
+		return -EINVAL;
+	}
+	state->pdata = of_id->data;
+
+	state->gasket = syscon_regmap_lookup_by_phandle(dev->of_node, "csi-gpr");
+	if (IS_ERR(state->gasket)) {
+		dev_err(dev, "failed to get csi gasket\n");
+		return PTR_ERR(state->gasket);
+	}
+
+	ret = disp_mix_sft_parse_resets(state);
+	if (ret < 0)
+		return ret;
+
+	if (state->pdata->use_mix_gpr) {
+		state->mix_gpr = syscon_regmap_lookup_by_phandle(dev->of_node, "gpr");
+		if (IS_ERR(state->mix_gpr)) {
+			dev_err(dev, "failed to get mix gpr\n");
+			return PTR_ERR(state->mix_gpr);
+		}
+	}
+
+	mem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	state->regs = devm_ioremap_resource(dev, mem_res);
+	if (IS_ERR(state->regs))
+		return PTR_ERR(state->regs);
+
+	state->irq = platform_get_irq(pdev, 0);
+	if (state->irq < 0) {
+		dev_err(dev, "Failed to get irq\n");
+		return state->irq;
+	}
+
+	ret = mipi_csis_clk_get(state);
+	if (ret < 0)
+		return ret;
+
+	ret = disp_mix_clks_get(state);
+	if (ret < 0) {
+		dev_err(dev, "Failed to get disp mix clocks");
+		return ret;
+	}
+
+	ret = mipi_csis_clk_enable(state);
+	if (ret < 0)
+		return ret;
+
+	disp_mix_clks_enable(state, true);
+	disp_mix_sft_rstn(state, false);
+	mipi_csis_phy_reset(state);
+
+	disp_mix_clks_enable(state, false);
+	mipi_csis_clk_disable(state);
+
+	ret = devm_request_irq(dev, state->irq, mipi_csis_irq_handler, 0,
+			       dev_name(dev), state);
+	if (ret) {
+		dev_err(dev, "Interrupt request failed\n");
+		return ret;
+	}
+
+	platform_set_drvdata(pdev, state);
+	ret = mipi_csis_subdev_init(&state->sd, pdev, &mipi_csis_subdev_ops);
+	if (ret < 0) {
+		dev_err(dev, "mipi csi subdev init failed\n");
+		return ret;
+	}
+
+	state->pads[MIPI_CSIS_VC0_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+	state->pads[MIPI_CSIS_VC1_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+	state->pads[MIPI_CSIS_VC2_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+	state->pads[MIPI_CSIS_VC3_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+	state->pads[MIPI_CSIS_VC0_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	state->pads[MIPI_CSIS_VC1_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	state->pads[MIPI_CSIS_VC2_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	state->pads[MIPI_CSIS_VC3_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	ret = media_entity_pads_init(&state->sd.entity, MIPI_CSIS_VCX_PADS_NUM, state->pads);
+	if (ret < 0) {
+		dev_err(dev, "mipi csi entity pad init failed\n");
+		return ret;
+	}
+
+	memcpy(state->events, mipi_csis_events, sizeof(state->events));
+	state->sd.entity.ops = &mipi_csi2_sd_media_ops;
+
+	pm_runtime_enable(dev);
+
+	dev_info(&pdev->dev, "lanes: %d, hs_settle: %d, clk_settle: %d, wclk: %d, freq: %u\n",
+		 state->num_lanes, state->hs_settle, state->clk_settle,
+		 state->wclk_ext, state->clk_frequency);
+	return 0;
+}
+
+static int mipi_csis_system_suspend(struct device *dev)
+{
+	return pm_runtime_force_suspend(dev);;
+}
+
+static int mipi_csis_system_resume(struct device *dev)
+{
+	int ret;
+
+	ret = pm_runtime_force_resume(dev);
+	if (ret < 0) {
+		dev_err(dev, "force resume %s failed!\n", dev_name(dev));
+		return ret;
+	}
+
+	return 0;
+}
+
+static int mipi_csis_runtime_suspend(struct device *dev)
+{
+	struct csi_state *state = dev_get_drvdata(dev);
+	int ret;
+
+	ret = regulator_disable(state->mipi_phy_regulator);
+	if (ret < 0)
+		return ret;
+
+	disp_mix_clks_enable(state, false);
+	mipi_csis_clk_disable(state);
+	return 0;
+}
+
+static int mipi_csis_runtime_resume(struct device *dev)
+{
+	struct csi_state *state = dev_get_drvdata(dev);
+	int ret;
+
+	ret = regulator_enable(state->mipi_phy_regulator);
+	if (ret < 0)
+		return ret;
+
+	ret = mipi_csis_clk_enable(state);
+	if (ret < 0)
+		return ret;
+
+	disp_mix_clks_enable(state, true);
+	disp_mix_sft_rstn(state, false);
+	mipi_csis_phy_reset(state);
+
+	return 0;
+}
+
+static int mipi_csis_remove(struct platform_device *pdev)
+{
+	struct csi_state *state = platform_get_drvdata(pdev);
+
+	media_entity_cleanup(&state->sd.entity);
+	pm_runtime_disable(&pdev->dev);
+
+	return 0;
+}
+
+static const struct dev_pm_ops mipi_csis_pm_ops = {
+	SET_RUNTIME_PM_OPS(mipi_csis_runtime_suspend, mipi_csis_runtime_resume, NULL)
+	SET_SYSTEM_SLEEP_PM_OPS(mipi_csis_system_suspend, mipi_csis_system_resume)
+};
+
+static const struct of_device_id mipi_csis_of_match[] = {
+	{	.compatible = "fsl,imx8mn-mipi-csi",
+		.data = (void *)&mipi_csis_imx8mn_pdata,
+	},
+	{	.compatible = "fsl,imx8mp-mipi-csi",
+		.data = (void *)&mipi_csis_imx8mp_pdata,
+	},
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, mipi_csis_of_match);
+
+static struct platform_driver mipi_csis_driver = {
+	.driver = {
+		.name  = CSIS_DRIVER_NAME,
+		.owner = THIS_MODULE,
+		.pm    = &mipi_csis_pm_ops,
+		.of_match_table = mipi_csis_of_match,
+	},
+	.probe  = mipi_csis_probe,
+	.remove = mipi_csis_remove,
+};
+module_platform_driver(mipi_csis_driver);
+
+MODULE_DESCRIPTION("Freescale MIPI-CSI2 receiver driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/staging/media/imx/imx8-mipi-csi2.c b/drivers/staging/media/imx/imx8-mipi-csi2.c
new file mode 100644
index 000000000..3c628fb1b
--- /dev/null
+++ b/drivers/staging/media/imx/imx8-mipi-csi2.c
@@ -0,0 +1,1400 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * V4L2 Capture CSI Subdev for Freescale i.MX8QM/QXP SOC
+ *
+ * Copyright 2019-2021 NXP
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/kernel.h>
+#include <linux/memory.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_graph.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/regulator/consumer.h>
+#include <linux/firmware/imx/sci.h>
+#include <dt-bindings/firmware/imx/rsrc.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/videodev2.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-device.h>
+#include <linux/pm_domain.h>
+#include <linux/pm_runtime.h>
+
+#include "imx8-common.h"
+
+#define MXC_MIPI_CSI2_DRIVER_NAME	"mxc-mipi-csi2"
+#define MXC_MIPI_CSI2_SUBDEV_NAME	MXC_MIPI_CSI2_DRIVER_NAME
+#define MXC_MIPI_CSI2_MAX_LANES		4
+
+/* Subsystem CSR */
+#define CSI2SS_BASE_OFFSET		0x0
+
+#define CSI2SS_PLM_CTRL				(CSI2SS_BASE_OFFSET + 0x0)
+#define CSI2SS_PLM_CTRL_PL_CLK_RUN		0x80000000
+#define CSI2SS_PLM_CTRL_VSYNC_OVERRIDE		0x200
+#define CSI2SS_PLM_CTRL_HSYNC_OVERRIDE		0x400
+#define CSI2SS_PLM_CTRL_VALID_OVERRIDE		0x800
+#define CSI2SS_PLM_CTRL_POLARITY_MASK		0x1000
+#define CSI2SS_PLM_CTRL_POLARITY_HIGH		0x1000
+#define CSI2SS_PLM_CTRL_POLARITY_LOW		0x0
+#define CSI2SS_PLM_CTRL_ENABLE_PL		1
+#define CSI2SS_PLM_CTRL_ENABLE_PL_OFFSET	0
+#define CSI2SS_PLM_CTRL_ENABLE_PL_MASK		1
+
+#define CSI2SS_PHY_CTRL				(CSI2SS_BASE_OFFSET + 0x4)
+#define CSI2SS_PHY_CTRL_PD			1
+#define CSI2SS_PHY_CTRL_PD_OFFSET		22
+#define CSI2SS_PHY_CTRL_PD_MASK			0x400000
+#define CSI2SS_PHY_CTRL_RTERM_SEL		1
+#define CSI2SS_PHY_CTRL_RTERM_SEL_OFFSET	21
+#define CSI2SS_PHY_CTRL_RTERM_SEL_MASK		0x200000
+#define CSI2SS_PHY_CTRL_RX_HS_SETTLE_OFFSET	4
+#define CSI2SS_PHY_CTRL_RX_HS_SETTLE_MASK	0x3F0
+#define CSI2SS_PHY_CTRL_CONT_CLK_MODE		1
+#define CSI2SS_PHY_CTRL_CONT_CLK_MODE_OFFSET	3
+#define CSI2SS_PHY_CTRL_CONT_CLK_MODE_MASK	0x8
+#define CSI2SS_PHY_CTRL_DDRCLK_EN		1
+#define CSI2SS_PHY_CTRL_DDRCLK_EN_OFFSET	2
+#define CSI2SS_PHY_CTRL_DDRCLK_EN_MASK		0x4
+#define CSI2SS_PHY_CTRL_AUTO_PD_EN		1
+#define CSI2SS_PHY_CTRL_AUTO_PD_EN_OFFSET	1
+#define CSI2SS_PHY_CTRL_AUTO_PD_EN_MASK		0x2
+#define CSI2SS_PHY_CTRL_RX_ENABLE		1
+#define CSI2SS_PHY_CTRL_RX_ENABLE_OFFSET	0
+#define CSI2SS_PHY_CTRL_RX_ENABLE_MASK		0x1
+
+#define CSI2SS_PHY_STATUS			(CSI2SS_BASE_OFFSET + 0x8)
+#define CSI2SS_PHY_TEST_STATUS			(CSI2SS_BASE_OFFSET + 0x10)
+#define CSI2SS_PHY_TEST_STATUS_D0		(CSI2SS_BASE_OFFSET + 0x14)
+#define CSI2SS_PHY_TEST_STATUS_D1		(CSI2SS_BASE_OFFSET + 0x18)
+#define CSI2SS_PHY_TEST_STATUS_D2		(CSI2SS_BASE_OFFSET + 0x1C)
+#define CSI2SS_PHY_TEST_STATUS_D3		(CSI2SS_BASE_OFFSET + 0x20)
+
+#define CSI2SS_VC_INTERLACED			(CSI2SS_BASE_OFFSET + 0x30)
+#define CSI2SS_VC_INTERLACED_VC0		1
+#define CSI2SS_VC_INTERLACED_VC1		2
+#define CSI2SS_VC_INTERLACED_VC2		4
+#define CSI2SS_VC_INTERLACED_VC3		8
+#define CSI2SS_VC_INTERLACED_OFFSET		0
+#define CSI2SS_VC_INTERLACED_MASK		0xF
+
+#define CSI2SS_DATA_TYPE			(CSI2SS_BASE_OFFSET + 0x38)
+#define CSI2SS_DATA_TYPE_LEGACY_YUV420_8BIT	BIT(2)
+#define CSI2SS_DATA_TYPE_YUV422_8BIT		BIT(6)
+#define CSI2SS_DATA_TYPE_YUV422_10BIT		BIT(7)
+#define CSI2SS_DATA_TYPE_RGB444			BIT(8)
+#define CSI2SS_DATA_TYPE_RGB555			BIT(9)
+#define CSI2SS_DATA_TYPE_RGB565			BIT(10)
+#define CSI2SS_DATA_TYPE_RGB666			BIT(11)
+#define CSI2SS_DATA_TYPE_RGB888			BIT(12)
+#define CSI2SS_DATA_TYPE_RAW6			BIT(16)
+#define CSI2SS_DATA_TYPE_RAW8			BIT(18)
+#define CSI2SS_DATA_TYPE_RAW10			BIT(19)
+#define CSI2SS_DATA_TYPE_RAW12			BIT(20)
+#define CSI2SS_DATA_TYPE_RAW14			BIT(21)
+
+#define CSI2SS_YUV420_1ST_LINE_DATA_TYPE	(CSI2SS_BASE_OFFSET + 0x40)
+#define CSI2SS_YUV420_1ST_LINE_DATA_TYPE_ODD	0
+#define CSI2SS_YUV420_1ST_LINE_DATA_TYPE_EVEN	1
+#define CSI2SS_YUV420_1ST_LINE_DATA_TYPE_OFFSET	0
+#define CSI2SS_YUV420_1ST_LINE_DATA_TYPE_MASK	1
+
+#define CSI2SS_CTRL_CLK_RESET			(CSI2SS_BASE_OFFSET + 0x44)
+#define CSI2SS_CTRL_CLK_RESET_EN		1
+#define CSI2SS_CTRL_CLK_RESET_OFFSET		0
+#define CSI2SS_CTRL_CLK_RESET_MASK		1
+#define CSI2SS_CTRL_CLK_RESET_CLK_OFF		1
+#define CSI2SS_CTRL_CLK_RESET_CLK_OFFSET	1
+#define CSI2SS_CTRL_CLK_RESET_CLK_MASK		0x1
+
+#define CSI2SS_STREAM_FENCE_CTRL		(CSI2SS_BASE_OFFSET + 0x48)
+#define CSI2SS_STREAM_FENCE_VC0			1
+#define CSI2SS_STREAM_FENCE_VC1			2
+#define CSI2SS_STREAM_FENCE_VC2			4
+#define CSI2SS_STREAM_FENCE_VC3			8
+#define CSI2SS_STREAM_FENCE_CTRL_OFFSET		0
+#define CSI2SS_STREAM_FENCE_CTRL_MASK		0xF
+
+#define CSI2SS_STREAM_FENCE_STATUS		(CSI2SS_BASE_OFFSET + 0x4C)
+
+/* CSI-2 controller CSR */
+#define CSI2RX_BASE_OFFSET			(0x100)
+
+#define CSI2RX_CFG_NUM_LANES			(CSI2RX_BASE_OFFSET + 0x0)
+#define CSI2RX_CFG_NUM_LANES_OFFSET		0
+#define CSI2RX_CFG_NUM_LANES_MASK		0x3
+
+#define CSI2RX_CFG_DISABLE_DATA_LANES		(CSI2RX_BASE_OFFSET + 0x4)
+#define CSI2RX_CFG_DISABLE_DATA_LANES_3		8
+#define CSI2RX_CFG_DISABLE_DATA_LANES_2		4
+#define CSI2RX_CFG_DISABLE_DATA_LANES_1		2
+#define CSI2RX_CFG_DISABLE_DATA_LANES_0		1
+#define CSI2RX_CFG_DISABLE_DATA_LANES_OFFSET	0
+#define CSI2RX_CFG_DISABLE_DATA_LANES_MASK	0xF
+
+#define CSI2RX_BIT_ERR				(CSI2RX_BASE_OFFSET + 0x8)
+
+#define CSI2RX_IRQ_STATUS			(CSI2RX_BASE_OFFSET + 0xC)
+#define CSI2RX_IRQ_STATUS_CRC_ERROR		0x1
+#define CSI2RX_IRQ_STATUS_1BIT_CRC_ERROR	0x2
+#define CSI2RX_IRQ_STATUS_2BIT_CRC_ERROR	0x4
+#define CSI2RX_IRQ_STATUS_ULPS_CHANGE		0x8
+#define CSI2RX_IRQ_STATUS_DPHY_ERRSOTHS		0x10
+#define CSI2RX_IRQ_STATUS_DPHY_ERRSOTSYNC_HS	0x20
+#define CSI2RX_IRQ_STATUS_DPHY_ERRESC		0x40
+#define CSI2RX_IRQ_STATUS_DPHY_ERRSYNCESC	0x80
+#define CSI2RX_IRQ_STATUS_DPHY_ERRCTRL		0x100
+
+#define CSI2RX_IRQ_MASK				(CSI2RX_BASE_OFFSET + 0x10)
+#define CSI2RX_IRQ_MASK_CRC_ERROR		0x1
+#define CSI2RX_IRQ_MASK_1BIT_CRC_ERROR		0x2
+#define CSI2RX_IRQ_MASK_2BIT_CRC_ERROR		0x4
+#define CSI2RX_IRQ_MASK_ULPS_CHANGE		0x8
+#define CSI2RX_IRQ_MASK_DPHY_ERRSOTHS		0x10
+#define CSI2RX_IRQ_MASK_DPHY_ERRSOTSYNC_HS	0x20
+#define CSI2RX_IRQ_MASK_DPHY_ERRESC		0x40
+#define CSI2RX_IRQ_MASK_DPHY_ERRSYNCESC		0x80
+#define CSI2RX_IRQ_MASK_DPHY_ERRCTRL		0x100
+
+#define CSI2RX_ULPS_STATUS			(CSI2RX_BASE_OFFSET + 0x14)
+#define CSI2RX_ULPS_STATUS_CLK_LANE_ULPS	0x1
+#define CSI2RX_ULPS_STATUS_DAT_LANE0_ULPS	0x2
+#define CSI2RX_ULPS_STATUS_DAT_LANE1_ULPS	0x4
+#define CSI2RX_ULPS_STATUS_DAT_LANE2_ULPS	0x8
+#define CSI2RX_ULPS_STATUS_DAT_LANE3_ULPS	0x10
+#define CSI2RX_ULPS_STATUS_CLK_LANE_MARK	0x20
+#define CSI2RX_ULPS_STATUS_DAT_LANE0_MARK	0x40
+#define CSI2RX_ULPS_STATUS_DAT_LANE1_MARK	0x80
+#define CSI2RX_ULPS_STATUS_DAT_LANE2_MARK	0x100
+#define CSI2RX_ULPS_STATUS_DAT_LANE3_MARK	0x200
+
+#define CSI2RX_PPI_ERRSOT_HS			(CSI2RX_BASE_OFFSET + 0x18)
+#define CSI2RX_PPI_ERRSOT_HS_DAT_LANE0		0x1
+#define CSI2RX_PPI_ERRSOT_HS_DAT_LANE1		0x2
+#define CSI2RX_PPI_ERRSOT_HS_DAT_LANE2		0x4
+#define CSI2RX_PPI_ERRSOT_HS_DAT_LANE3		0x8
+
+#define CSI2RX_PPI_ERRSOTSYNC_HS		(CSI2RX_BASE_OFFSET + 0x1C)
+#define CSI2RX_PPI_ERRSOTSYNC_HS_DAT_LANE0	0x1
+#define CSI2RX_PPI_ERRSOTSYNC_HS_DAT_LANE1	0x2
+#define CSI2RX_PPI_ERRSOTSYNC_HS_DAT_LANE2	0x4
+#define CSI2RX_PPI_ERRSOTSYNC_HS_DAT_LANE3	0x8
+
+#define CSI2RX_PPI_ERRESC			(CSI2RX_BASE_OFFSET + 0x20)
+#define CSI2RX_PPI_ERRESC_DAT_LANE0		0x1
+#define CSI2RX_PPI_ERRESC_DAT_LANE1		0x2
+#define CSI2RX_PPI_ERRESC_DAT_LANE2		0x4
+#define CSI2RX_PPI_ERRESC_DAT_LANE3		0x8
+
+#define CSI2RX_PPI_ERRSYNCESC			(CSI2RX_BASE_OFFSET + 0x24)
+#define CSI2RX_PPI_ERRSYNCESC_DAT_LANE0		0x1
+#define CSI2RX_PPI_ERRSYNCESC_DAT_LANE1		0x2
+#define CSI2RX_PPI_ERRSYNCESC_DAT_LANE2		0x4
+#define CSI2RX_PPI_ERRSYNCESC_DAT_LANE3		0x8
+
+#define CSI2RX_PPI_ERRCONTROL			(CSI2RX_BASE_OFFSET + 0x28)
+#define CSI2RX_PPI_ERRCONTROL_DAT_LANE0		0x1
+#define CSI2RX_PPI_ERRCONTROL_DAT_LANE1		0x2
+#define CSI2RX_PPI_ERRCONTROL_DAT_LANE2		0x4
+#define CSI2RX_PPI_ERRCONTROL_DAT_LANE3		0x8
+
+#define CSI2RX_CFG_DISABLE_PAYLOAD_0		(CSI2RX_BASE_OFFSET + 0x2C)
+#define CSI2RX_CFG_DISABLE_PAYLOAD_TYPE_LEGACY_YUV420_8BIT	BIT(10)
+#define CSI2RX_CFG_DISABLE_PAYLOAD_TYPE_YUV422_8BIT		BIT(14)
+#define CSI2RX_CFG_DISABLE_PAYLOAD_TYPE_YUV422_10BIT		BIT(15)
+#define CSI2RX_CFG_DISABLE_PAYLOAD_TYPE_RGB444			BIT(16)
+#define CSI2RX_CFG_DISABLE_PAYLOAD_TYPE_RGB555			BIT(17)
+#define CSI2RX_CFG_DISABLE_PAYLOAD_TYPE_RGB565			BIT(18)
+#define CSI2RX_CFG_DISABLE_PAYLOAD_TYPE_RGB666			BIT(19)
+#define CSI2RX_CFG_DISABLE_PAYLOAD_TYPE_RGB888			BIT(20)
+#define CSI2RX_CFG_DISABLE_PAYLOAD_TYPE_RAW6			BIT(24)
+#define CSI2RX_CFG_DISABLE_PAYLOAD_TYPE_RAW7			BIT(25)
+#define CSI2RX_CFG_DISABLE_PAYLOAD_TYPE_RAW8			BIT(26)
+#define CSI2RX_CFG_DISABLE_PAYLOAD_TYPE_RAW10			BIT(27)
+#define CSI2RX_CFG_DISABLE_PAYLOAD_TYPE_RAW12			BIT(28)
+#define CSI2RX_CFG_DISABLE_PAYLOAD_TYPE_RAW14			BIT(29)
+
+#define CSI2RX_CFG_DISABLE_PAYLOAD_1		(CSI2RX_BASE_OFFSET + 0x30)
+
+struct mxc_mipi_csi2_dev;
+static const struct of_device_id mipi_csi2_of_match[];
+
+struct csis_hw_reset {
+	struct regmap *src;
+	u8 req_src;
+	u8 rst_val;
+};
+
+struct csis_phy_gpr {
+	struct regmap *gpr;
+	u8 req_src;
+};
+
+struct mxc_mipi_csi2_clk_ops {
+	int (*clk_get)(struct mxc_mipi_csi2_dev *csi2dev);
+	int (*clk_enable)(struct mxc_mipi_csi2_dev *csi2dev);
+	void (*clk_disable)(struct mxc_mipi_csi2_dev *csi2dev);
+};
+
+struct mxc_mipi_csi2_pd_ops {
+	int (*attach)(struct mxc_mipi_csi2_dev *csi2dev);
+	void (*detach)(struct mxc_mipi_csi2_dev *csi2dev);
+};
+
+struct mxc_mipi_csi2_rst_ops {
+	int (*reset)(struct mxc_mipi_csi2_dev *csi2dev, int enable);
+};
+
+struct mxc_mipi_csi2_plat_data {
+	struct mxc_mipi_csi2_clk_ops *clk_ops;
+	struct mxc_mipi_csi2_pd_ops *pd_ops;
+	struct mxc_mipi_csi2_rst_ops *rst_ops;
+};
+
+struct mxc_mipi_csi2_dev {
+	struct v4l2_subdev	sd;
+	struct v4l2_device	v4l2_dev;
+	struct v4l2_subdev	*sensor_sd;
+
+	struct media_pad pads[MXC_MIPI_CSI2_VCX_PADS_NUM];
+	struct v4l2_mbus_framefmt format;
+
+	void __iomem *csr_regs;
+	void __iomem *base_regs;
+	struct platform_device *pdev;
+	u32 flags;
+	int irq;
+
+	struct clk *clk_core;
+	struct clk *clk_esc;
+	struct clk *clk_pxl;
+	struct clk *clk_regs;
+
+	const struct mxc_mipi_csi2_plat_data *pdata;
+
+	struct csis_hw_reset hw_reset;
+	struct csis_phy_gpr  phy_gpr;
+
+	struct v4l2_async_subdev    asd;
+	struct v4l2_async_notifier  subdev_notifier;
+	struct v4l2_async_subdev    *async_subdevs[2];
+
+	struct device *pd_csi;
+	struct device *pd_isi;
+	struct device_link *pd_csi_link;
+	struct device_link *pd_isi_link;
+
+	struct mutex lock;
+
+	int id;
+	u32 hs_settle;
+	u32 send_level;
+	u32 num_lanes;
+	u8  data_lanes[4];
+	u8  vchannel;
+	u8  running;
+};
+
+struct mxc_hs_info {
+	u32 width;
+	u32 height;
+	u32 frame_rate;
+	u32 val;
+};
+
+enum mxc_mipi_csi2_pm_state {
+	MXC_MIPI_CSI2_PM_POWERED	= 0x1,
+	MXC_MIPI_CSI2_PM_SUSPENDED	= 0x2,
+	MXC_MIPI_CSI2_RUNTIME_SUSPENDED	= 0x4,
+};
+
+/* 0~ 80Mbps: 0xB
+ * 80~250Mbps: 0x8
+ * 250~1.5Gbps: 0x6
+ */
+static u8 rxhs_settle[3] = {0xD, 0xA, 0x7};
+
+static struct mxc_hs_info hs_setting[] = {
+	{2592, 1944, 30, 0x0B},
+	{2592, 1944, 15, 0x10},
+
+	{1920, 1080, 30, 0x0B},
+	{1920, 1080, 15, 0x10},
+
+	{1280, 720,  30, 0x11},
+	{1280, 720,  15, 0x16},
+
+	{1024, 768,  30, 0x11},
+	{1024, 768,  15, 0x23},
+
+	{720,  576,  30, 0x1E},
+	{720,  576,  15, 0x23},
+
+	{720,  480,  30, 0x1E},
+	{720,  480,  15, 0x23},
+
+	{640,  480,  30, 0x1E},
+	{640,  480,  15, 0x23},
+
+	{320,  240,  30, 0x1E},
+	{320,  240,  15, 0x23},
+
+	{176,  144,  30, 0x1E},
+	{176,  144,  15, 0x23},
+};
+
+static struct imx_sc_ipc *pm_ipc_handle;
+
+static inline struct mxc_mipi_csi2_dev *sd_to_mxc_mipi_csi2_dev(struct v4l2_subdev *sdev)
+{
+	return container_of(sdev, struct mxc_mipi_csi2_dev, sd);
+}
+
+/****************************************
+ * rxhs-settle calculate
+ * UI = 1000 / mipi csi phy clock
+ * THS-SETTLE_mim = 85ns + 6 * UI
+ * THS-SETTLE_max = 145ns +10 * UI
+ * THS-SETTLE = (THS-SETTLE_mim + THS-SETTLE_max) / 2
+ * PRG_RXHS_SETTLE =  THS-SETTLE / (Tperiod of RxClk_ESC) + 1
+ ****************************************/
+static int calc_hs_settle(struct mxc_mipi_csi2_dev *csi2dev, u32 dphy_clk)
+{
+	u32 esc_rate;
+	u32 hs_settle;
+	u32 rxhs_settle;
+	u32 hs_settle_min;
+	u32 hs_settle_max;
+
+	esc_rate = clk_get_rate(csi2dev->clk_esc) / 1000000;
+	if (!esc_rate)
+		return 0;
+
+	hs_settle_min = 85 + 6 * 1000 / dphy_clk;
+	hs_settle_max = 145 + 10 * 1000 / dphy_clk;
+	hs_settle = (hs_settle_min + hs_settle_max) >> 1;
+	rxhs_settle = hs_settle / (1000 / esc_rate) - 1;
+	return rxhs_settle;
+}
+
+static void mxc_mipi_csi2_reg_dump(struct mxc_mipi_csi2_dev *csi2dev)
+{
+	struct device *dev = &csi2dev->pdev->dev;
+	struct {
+		u32 offset;
+		const char name[32];
+	} registers[] = {
+		{ 0x100, "MIPI CSI2 HC num of lanes" },
+		{ 0x104, "MIPI CSI2 HC dis lanes" },
+		{ 0x108, "MIPI CSI2 HC BIT ERR" },
+		{ 0x10C, "MIPI CSI2 HC IRQ STATUS" },
+		{ 0x110, "MIPI CSI2 HC IRQ MASK" },
+		{ 0x114, "MIPI CSI2 HC ULPS STATUS" },
+		{ 0x118, "MIPI CSI2 HC DPHY ErrSotHS" },
+		{ 0x11c, "MIPI CSI2 HC DPHY ErrSotSync" },
+		{ 0x120, "MIPI CSI2 HC DPHY ErrEsc" },
+		{ 0x124, "MIPI CSI2 HC DPHY ErrSyncEsc" },
+		{ 0x128, "MIPI CSI2 HC DPHY ErrControl" },
+		{ 0x12C, "MIPI CSI2 HC DISABLE_PAYLOAD" },
+		{ 0x130, "MIPI CSI2 HC DISABLE_PAYLOAD" },
+		{ 0x180, "MIPI CSI2 HC IGNORE_VC" },
+		{ 0x184, "MIPI CSI2 HC VID_VC" },
+		{ 0x188, "MIPI CSI2 HC FIFO_SEND_LEVEL" },
+		{ 0x18C, "MIPI CSI2 HC VID_VSYNC" },
+		{ 0x190, "MIPI CSI2 HC VID_SYNC_FP" },
+		{ 0x194, "MIPI CSI2 HC VID_HSYNC" },
+		{ 0x198, "MIPI CSI2 HC VID_HSYNC_BP" },
+		{ 0x000, "MIPI CSI2 CSR PLM_CTRL" },
+		{ 0x004, "MIPI CSI2 CSR PHY_CTRL" },
+		{ 0x008, "MIPI CSI2 CSR PHY_Status" },
+		{ 0x010, "MIPI CSI2 CSR PHY_Test_Status" },
+		{ 0x014, "MIPI CSI2 CSR PHY_Test_Status" },
+		{ 0x018, "MIPI CSI2 CSR PHY_Test_Status" },
+		{ 0x01C, "MIPI CSI2 CSR PHY_Test_Status" },
+		{ 0x020, "MIPI CSI2 CSR PHY_Test_Status" },
+		{ 0x030, "MIPI CSI2 CSR VC Interlaced" },
+		{ 0x038, "MIPI CSI2 CSR Data Type Dis" },
+		{ 0x040, "MIPI CSI2 CSR 420 1st type" },
+		{ 0x044, "MIPI CSI2 CSR Ctr_Ck_Rst_Ctr" },
+		{ 0x048, "MIPI CSI2 CSR Stream Fencing" },
+		{ 0x04C, "MIPI CSI2 CSR Stream Fencing" },
+	};
+	u32 i;
+
+	dev_dbg(dev, "MIPI CSI2 CSR and HC register dump, mipi csi%d\n", csi2dev->id);
+	for (i = 0; i < ARRAY_SIZE(registers); i++) {
+		u32 reg = readl(csi2dev->base_regs + registers[i].offset);
+		dev_dbg(dev, "%20s[0x%.3x]: 0x%.3x\n",
+			registers[i].name, registers[i].offset, reg);
+	}
+}
+
+static int mipi_sc_fw_init(struct mxc_mipi_csi2_dev *csi2dev, int enable)
+{
+	const struct mxc_mipi_csi2_rst_ops *ops = csi2dev->pdata->rst_ops;
+
+	if (ops && ops->reset)
+		return ops->reset(csi2dev, enable);
+
+	return 0;
+}
+
+static uint16_t find_hs_configure(struct v4l2_subdev_format *sd_fmt)
+{
+	struct v4l2_mbus_framefmt *fmt = &sd_fmt->format;
+	u32 frame_rate;
+	int i;
+
+	if (!fmt)
+		return -EINVAL;
+
+	frame_rate = fmt->reserved[1];
+
+	for (i = 0; i < ARRAY_SIZE(hs_setting); i++) {
+		if (hs_setting[i].width  == fmt->width &&
+		    hs_setting[i].height == fmt->height &&
+		    hs_setting[i].frame_rate == frame_rate)
+			return hs_setting[i].val;
+	}
+
+	if (i == ARRAY_SIZE(hs_setting))
+		pr_err("can not find HS setting for w/h@fps=(%d, %d)@%d\n",
+		       fmt->width, fmt->height, frame_rate);
+
+	return -EINVAL;
+}
+
+static void mxc_mipi_csi2_reset(struct mxc_mipi_csi2_dev *csi2dev)
+{
+	u32 val;
+
+	/* Reset MIPI CSI */
+	val = CSI2SS_CTRL_CLK_RESET_EN | CSI2SS_CTRL_CLK_RESET_CLK_OFF;
+	writel(val, csi2dev->csr_regs + CSI2SS_CTRL_CLK_RESET);
+}
+
+static void mxc_mipi_csi2_enable(struct mxc_mipi_csi2_dev *csi2dev)
+{
+	struct device *dev = &csi2dev->pdev->dev;
+	u32 val = 0;
+
+	val = readl(csi2dev->csr_regs + CSI2SS_PLM_CTRL);
+	while (val & CSI2SS_PLM_CTRL_PL_CLK_RUN) {
+		msleep(10);
+		val = readl(csi2dev->csr_regs + CSI2SS_PLM_CTRL);
+		dev_dbg(dev, "Waiting pl clk running, val=0x%x\n", val);
+	}
+
+	/* Enable Pixel link Master*/
+	val = readl(csi2dev->csr_regs + CSI2SS_PLM_CTRL);
+	val |= CSI2SS_PLM_CTRL_ENABLE_PL;
+	writel(val, csi2dev->csr_regs + CSI2SS_PLM_CTRL);
+
+	val |= CSI2SS_PLM_CTRL_VALID_OVERRIDE;
+	writel(val, csi2dev->csr_regs + CSI2SS_PLM_CTRL);
+
+	/* PHY Enable */
+	val = readl(csi2dev->csr_regs + CSI2SS_PHY_CTRL);
+	val &= ~(CSI2SS_PHY_CTRL_PD_MASK | CSI2SS_PLM_CTRL_POLARITY_MASK);
+	writel(val, csi2dev->csr_regs + CSI2SS_PHY_CTRL);
+
+	/* Deassert reset */
+	writel(1, csi2dev->csr_regs + CSI2SS_CTRL_CLK_RESET);
+}
+
+static void mxc_mipi_csi2_disable(struct mxc_mipi_csi2_dev *csi2dev)
+{
+	/* Disable Data lanes */
+	writel(0xf, csi2dev->base_regs + CSI2RX_CFG_DISABLE_DATA_LANES);
+
+	/* Disable Pixel Link */
+	writel(0, csi2dev->csr_regs + CSI2SS_PLM_CTRL);
+
+	/* Disable  PHY */
+	writel(0, csi2dev->csr_regs + CSI2SS_PHY_CTRL);
+
+	/* Reset */
+	writel(2, csi2dev->csr_regs + CSI2SS_CTRL_CLK_RESET);
+}
+
+static void mxc_mipi_csi2_csr_config(struct mxc_mipi_csi2_dev *csi2dev)
+{
+	u32 val;
+
+	/* format */
+	val = 0;
+	writel(val, csi2dev->csr_regs + CSI2SS_DATA_TYPE);
+
+	/* polarity */
+	val = readl(csi2dev->csr_regs + CSI2SS_PLM_CTRL);
+	val &= ~(CSI2SS_PLM_CTRL_VSYNC_OVERRIDE |
+		 CSI2SS_PLM_CTRL_HSYNC_OVERRIDE |
+		 CSI2SS_PLM_CTRL_VALID_OVERRIDE |
+		 CSI2SS_PLM_CTRL_POLARITY_MASK);
+
+	writel(val, csi2dev->csr_regs + CSI2SS_PLM_CTRL);
+
+	val = CSI2SS_PHY_CTRL_RX_ENABLE |
+	      CSI2SS_PHY_CTRL_DDRCLK_EN << CSI2SS_PHY_CTRL_DDRCLK_EN_OFFSET |
+	      CSI2SS_PHY_CTRL_CONT_CLK_MODE << CSI2SS_PHY_CTRL_CONT_CLK_MODE_OFFSET |
+	      csi2dev->hs_settle << CSI2SS_PHY_CTRL_RX_HS_SETTLE_OFFSET |
+	      CSI2SS_PHY_CTRL_PD << CSI2SS_PHY_CTRL_PD_OFFSET |
+	      CSI2SS_PHY_CTRL_RTERM_SEL << CSI2SS_PHY_CTRL_RTERM_SEL_OFFSET |
+	      CSI2SS_PHY_CTRL_AUTO_PD_EN << CSI2SS_PHY_CTRL_AUTO_PD_EN_OFFSET;
+
+	writel(val, csi2dev->csr_regs + CSI2SS_PHY_CTRL);
+}
+
+static void mxc_mipi_csi2_hc_config(struct mxc_mipi_csi2_dev *csi2dev)
+{
+	u32 val0, val1;
+	u32 i;
+
+	val0 = 0;
+
+	/* Lanes */
+	writel(csi2dev->num_lanes - 1, csi2dev->base_regs + CSI2RX_CFG_NUM_LANES);
+
+	for (i = 0; i < csi2dev->num_lanes; i++)
+		val0 |= (1 << (csi2dev->data_lanes[i] - 1));
+
+	val1 = 0xF & ~val0;
+	writel(val1, csi2dev->base_regs + CSI2RX_CFG_DISABLE_DATA_LANES);
+
+	/* Mask interrupt */
+	writel(0x1FF, csi2dev->base_regs + CSI2RX_IRQ_MASK);
+
+	/* vid_vc */
+	writel(3, csi2dev->base_regs + 0x184);
+}
+
+static struct media_pad *mxc_csi2_get_remote_sensor_pad(struct mxc_mipi_csi2_dev *csi2dev)
+{
+	struct v4l2_subdev *subdev = &csi2dev->sd;
+	struct media_pad *sink_pad, *source_pad;
+	int i;
+
+	while (1) {
+		source_pad = NULL;
+		for (i = 0; i < subdev->entity.num_pads; i++) {
+			sink_pad = &subdev->entity.pads[i];
+
+			if (sink_pad->flags & MEDIA_PAD_FL_SINK) {
+				source_pad = media_entity_remote_pad(sink_pad);
+				if (source_pad)
+					break;
+			}
+		}
+		/* return first pad point in the loop  */
+		return source_pad;
+	}
+
+	if (i == subdev->entity.num_pads)
+		v4l2_err(&csi2dev->sd, "%s, No remote pad found!\n", __func__);
+
+	return NULL;
+}
+
+static struct v4l2_subdev *mxc_get_remote_subdev(struct mxc_mipi_csi2_dev *csi2dev,
+						 const char * const label)
+{
+	struct media_pad *source_pad;
+	struct v4l2_subdev *sen_sd;
+
+	/* Get remote source pad */
+	source_pad = mxc_csi2_get_remote_sensor_pad(csi2dev);
+	if (!source_pad) {
+		v4l2_err(&csi2dev->sd, "%s, No remote pad found!\n", label);
+		return NULL;
+	}
+
+	/* Get remote source pad subdev */
+	sen_sd = media_entity_to_v4l2_subdev(source_pad->entity);
+	if (!sen_sd) {
+		v4l2_err(&csi2dev->sd, "%s, No remote subdev found!\n", label);
+		return NULL;
+	}
+
+	return sen_sd;
+}
+
+static int mxc_csi2_get_sensor_fmt(struct mxc_mipi_csi2_dev *csi2dev)
+{
+	struct v4l2_mbus_framefmt *mf = &csi2dev->format;
+	struct v4l2_subdev *sen_sd;
+	struct v4l2_subdev_format src_fmt;
+	struct media_pad *source_pad;
+	int ret;
+
+	/* Get remote source pad */
+	source_pad = mxc_csi2_get_remote_sensor_pad(csi2dev);
+	if (!source_pad) {
+		v4l2_err(&csi2dev->sd, "%s, No remote pad found!\n", __func__);
+		return -EINVAL;
+	}
+
+	sen_sd = mxc_get_remote_subdev(csi2dev, __func__);
+	if (!sen_sd)
+		return -EINVAL;
+
+	memset(&src_fmt, 0, sizeof(src_fmt));
+	src_fmt.pad = source_pad->index;
+	src_fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+	ret = v4l2_subdev_call(sen_sd, pad, get_fmt, NULL, &src_fmt);
+	if (ret < 0 && ret != -ENOIOCTLCMD)
+		return -EINVAL;
+
+	/* Update input frame size and formate  */
+	memcpy(mf, &src_fmt.format, sizeof(struct v4l2_mbus_framefmt));
+
+	dev_dbg(&csi2dev->pdev->dev, "width=%d, height=%d, fmt.code=0x%x\n",
+		mf->width, mf->height, mf->code);
+
+	/* Get rxhs settle */
+	if (src_fmt.format.reserved[0] != 0) {
+		csi2dev->hs_settle =
+			calc_hs_settle(csi2dev, src_fmt.format.reserved[0]);
+	} else if (src_fmt.format.reserved[1] != 0) {
+		csi2dev->hs_settle = find_hs_configure(&src_fmt);
+	} else {
+		if (src_fmt.format.height * src_fmt.format.width > 1024 * 768)
+			csi2dev->hs_settle = rxhs_settle[2];
+		else if (src_fmt.format.height * src_fmt.format.width < 480 * 320)
+			csi2dev->hs_settle = rxhs_settle[0];
+		else
+			csi2dev->hs_settle = rxhs_settle[1];
+	}
+
+	return 0;
+}
+
+static int mxc_imx8_csi2_clk_get(struct mxc_mipi_csi2_dev *csi2dev)
+{
+	struct device *dev = &csi2dev->pdev->dev;
+
+	csi2dev->clk_core = devm_clk_get(dev, "clk_core");
+	if (IS_ERR(csi2dev->clk_core)) {
+		dev_err(dev, "failed to get csi core clk\n");
+		return PTR_ERR(csi2dev->clk_core);
+	}
+
+	csi2dev->clk_esc = devm_clk_get(dev, "clk_esc");
+	if (IS_ERR(csi2dev->clk_esc)) {
+		dev_err(dev, "failed to get csi esc clk\n");
+		return PTR_ERR(csi2dev->clk_esc);
+	}
+
+	csi2dev->clk_pxl = devm_clk_get(dev, "clk_pxl");
+	if (IS_ERR(csi2dev->clk_pxl)) {
+		dev_err(dev, "failed to get csi pixel link clk\n");
+		return PTR_ERR(csi2dev->clk_pxl);
+	}
+
+	return 0;
+}
+
+static int mxc_imx8_csi2_clk_enable(struct mxc_mipi_csi2_dev *csi2dev)
+{
+	struct device *dev = &csi2dev->pdev->dev;
+	int ret;
+
+	ret = clk_prepare_enable(csi2dev->clk_core);
+	if (ret < 0) {
+		dev_err(dev, "%s, pre clk_core error\n", __func__);
+		return ret;
+	}
+	ret = clk_prepare_enable(csi2dev->clk_esc);
+	if (ret < 0) {
+		dev_err(dev, "%s, prepare clk_esc error\n", __func__);
+		return ret;
+	}
+	ret = clk_prepare_enable(csi2dev->clk_pxl);
+	if (ret < 0) {
+		dev_err(dev, "%s, prepare clk_pxl error\n", __func__);
+		return ret;
+	}
+
+	return 0;
+}
+
+static void mxc_imx8_csi2_clk_disable(struct mxc_mipi_csi2_dev *csi2dev)
+{
+	clk_disable_unprepare(csi2dev->clk_core);
+	clk_disable_unprepare(csi2dev->clk_esc);
+	clk_disable_unprepare(csi2dev->clk_pxl);
+}
+
+static struct mxc_mipi_csi2_clk_ops mxc_csi2_clk_ops = {
+	.clk_get     = mxc_imx8_csi2_clk_get,
+	.clk_enable  = mxc_imx8_csi2_clk_enable,
+	.clk_disable = mxc_imx8_csi2_clk_disable,
+};
+
+static int mxc_imx8_csi2_pd_attach(struct mxc_mipi_csi2_dev *csi2dev)
+{
+	struct device *dev = &csi2dev->pdev->dev;
+	struct device_link *link;
+
+	csi2dev->pd_csi = dev_pm_domain_attach_by_name(dev, "pd_csi");
+	if (IS_ERR(csi2dev->pd_csi)) {
+		if (PTR_ERR(csi2dev->pd_csi) != -EPROBE_DEFER) {
+			dev_err(dev, "attach pd_csi domain for csi fail\n");
+			return PTR_ERR(csi2dev->pd_csi);
+		} else {
+			return PTR_ERR(csi2dev->pd_csi);
+		}
+	}
+	link = device_link_add(dev, csi2dev->pd_csi,
+			       DL_FLAG_STATELESS |
+			       DL_FLAG_PM_RUNTIME);
+	if (IS_ERR(link))
+		return PTR_ERR(link);
+	csi2dev->pd_csi_link = link;
+
+	csi2dev->pd_isi = dev_pm_domain_attach_by_name(dev, "pd_isi_ch0");
+	if (IS_ERR(csi2dev->pd_isi)) {
+		if (PTR_ERR(csi2dev->pd_isi) != -EPROBE_DEFER) {
+			dev_err(dev, "attach pd_isi_ch0 domain for csi fail\n");
+			return PTR_ERR(csi2dev->pd_isi);
+		} else {
+			return PTR_ERR(csi2dev->pd_isi);
+		}
+	}
+	link = device_link_add(dev, csi2dev->pd_isi,
+			       DL_FLAG_STATELESS |
+			       DL_FLAG_PM_RUNTIME);
+	if (IS_ERR(link))
+		return PTR_ERR(link);
+	csi2dev->pd_isi_link = link;
+
+	return 0;
+}
+
+static void mxc_imx8_csi2_pd_detach(struct mxc_mipi_csi2_dev *csi2dev)
+{
+	device_link_del(csi2dev->pd_csi_link);
+	device_link_del(csi2dev->pd_isi_link);
+	dev_pm_domain_detach(csi2dev->pd_csi, true);
+	dev_pm_domain_detach(csi2dev->pd_isi, true);
+}
+
+static struct mxc_mipi_csi2_pd_ops mxc_csi2_pd_ops = {
+	.attach = mxc_imx8_csi2_pd_attach,
+	.detach = mxc_imx8_csi2_pd_detach,
+};
+
+static int mxc_imx8_csi2_reset(struct mxc_mipi_csi2_dev *csi2dev, int enable)
+{
+	struct device *dev = &csi2dev->pdev->dev;
+	u32 rsrc_id;
+	int ret;
+
+	ret = imx_scu_get_handle(&pm_ipc_handle);
+	if (ret) {
+		dev_err(dev, "sc_misc_MIPI get ipc handle failed! ret = (%d)\n", ret);
+		return ret;
+	}
+
+	if (csi2dev->id == 1)
+		rsrc_id = IMX_SC_R_CSI_1;
+	else
+		rsrc_id = IMX_SC_R_CSI_0;
+
+	ret = imx_sc_misc_set_control(pm_ipc_handle,
+				      rsrc_id, IMX_SC_C_MIPI_RESET, enable);
+	if (ret < 0) {
+		dev_err(dev, "sc_misc_MIPI reset failed! ret = (%d)\n", ret);
+		return ret;
+	}
+
+	msleep(10);
+	return 0;
+}
+
+static struct mxc_mipi_csi2_rst_ops mxc_csi2_rst_ops = {
+	.reset = mxc_imx8_csi2_reset,
+};
+
+static struct mxc_mipi_csi2_plat_data mxc_imx8_csi2_pdata = {
+	.clk_ops = &mxc_csi2_clk_ops,
+	.pd_ops  = &mxc_csi2_pd_ops,
+	.rst_ops = &mxc_csi2_rst_ops,
+};
+
+static int mxc_imx8ulp_csi2_clk_get(struct mxc_mipi_csi2_dev *csi2dev)
+{
+	struct device *dev = &csi2dev->pdev->dev;
+
+	csi2dev->clk_core = devm_clk_get(dev, "clk_core");
+	if (IS_ERR(csi2dev->clk_core)) {
+		dev_err(dev, "failed to get csi core clk\n");
+		return PTR_ERR(csi2dev->clk_core);
+	}
+
+	csi2dev->clk_pxl = devm_clk_get(dev, "clk_ui");
+	if (IS_ERR(csi2dev->clk_pxl)) {
+		dev_err(dev, "failed to get csi ui clk\n");
+		return PTR_ERR(csi2dev->clk_pxl);
+	}
+
+	csi2dev->clk_esc = devm_clk_get(dev, "clk_esc");
+	if (IS_ERR(csi2dev->clk_esc)) {
+		dev_err(dev, "failed to get csi esc clk\n");
+		return PTR_ERR(csi2dev->clk_esc);
+	}
+
+	csi2dev->clk_regs = devm_clk_get(dev, "clk_regs");
+	if (IS_ERR(csi2dev->clk_regs)) {
+		dev_err(dev, "failed to get csi regs clk\n");
+		return PTR_ERR(csi2dev->clk_regs);
+	}
+
+	return 0;
+}
+
+static int mxc_imx8ulp_csi2_clk_enable(struct mxc_mipi_csi2_dev *csi2dev)
+{
+	struct device *dev = &csi2dev->pdev->dev;
+	int ret;
+
+	ret = clk_prepare_enable(csi2dev->clk_core);
+	if (ret < 0) {
+		dev_err(dev, "%s, prepare clk_core error\n", __func__);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(csi2dev->clk_pxl);
+	if (ret < 0) {
+		dev_err(dev, "%s, prepare clk ui error\n", __func__);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(csi2dev->clk_esc);
+	if (ret < 0) {
+		dev_err(dev, "%s, prepare clk esc error\n", __func__);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(csi2dev->clk_regs);
+	if (ret < 0) {
+		dev_err(dev, "%s, prepare clk regs error\n", __func__);
+		return ret;
+	}
+
+	return 0;
+}
+
+static void mxc_imx8ulp_csi2_clk_disable(struct mxc_mipi_csi2_dev *csi2dev)
+{
+	clk_disable_unprepare(csi2dev->clk_core);
+	clk_disable_unprepare(csi2dev->clk_pxl);
+	clk_disable_unprepare(csi2dev->clk_esc);
+	clk_disable_unprepare(csi2dev->clk_regs);
+}
+
+static struct mxc_mipi_csi2_clk_ops mxc_imx8ulp_csi2_clk_ops = {
+	.clk_get     = mxc_imx8ulp_csi2_clk_get,
+	.clk_enable  = mxc_imx8ulp_csi2_clk_enable,
+	.clk_disable = mxc_imx8ulp_csi2_clk_disable,
+};
+
+static int mxc_imx8ulp_csi2_pd_attach(struct mxc_mipi_csi2_dev *csi2dev)
+{
+	return 0;
+}
+
+static void mxc_imx8ulp_csi2_pd_detach(struct mxc_mipi_csi2_dev *csi2dev)
+{
+}
+
+static struct mxc_mipi_csi2_pd_ops mxc_imx8ulp_csi2_pd_ops = {
+	.attach = mxc_imx8ulp_csi2_pd_attach,
+	.detach = mxc_imx8ulp_csi2_pd_detach,
+};
+
+static int mxc_imx8ulp_csi2_reset(struct mxc_mipi_csi2_dev *csi2dev, int enable)
+{
+	return 0;
+}
+
+static struct mxc_mipi_csi2_rst_ops mxc_imx8ulp_csi2_rst_ops = {
+	.reset = mxc_imx8ulp_csi2_reset,
+};
+
+static struct mxc_mipi_csi2_plat_data mxc_imx8ulp_csi2_pdata = {
+	.clk_ops = &mxc_imx8ulp_csi2_clk_ops,
+	.pd_ops  = &mxc_imx8ulp_csi2_pd_ops,
+	.rst_ops = &mxc_imx8ulp_csi2_rst_ops,
+};
+
+static int mipi_csi2_clk_init(struct mxc_mipi_csi2_dev *csi2dev)
+{
+
+	const struct mxc_mipi_csi2_clk_ops *ops = csi2dev->pdata->clk_ops;
+
+	if (!ops || !ops->clk_get)
+		return -EINVAL;
+
+	return ops->clk_get(csi2dev);
+}
+
+static int mipi_csi2_attach_pd(struct mxc_mipi_csi2_dev *csi2dev)
+{
+	const struct mxc_mipi_csi2_pd_ops *ops = csi2dev->pdata->pd_ops;
+
+	if (ops && ops->attach)
+		return ops->attach(csi2dev);
+
+	return 0;
+}
+
+static void mipi_csi2_detach_pd(struct mxc_mipi_csi2_dev *csi2dev)
+{
+	const struct mxc_mipi_csi2_pd_ops *ops = csi2dev->pdata->pd_ops;
+
+	if (ops && ops->detach)
+		ops->detach(csi2dev);
+}
+
+static int mipi_csi2_clk_enable(struct mxc_mipi_csi2_dev *csi2dev)
+{
+	const struct mxc_mipi_csi2_clk_ops *ops = csi2dev->pdata->clk_ops;
+
+	if (!ops || !ops->clk_enable)
+		return -EINVAL;
+
+	return ops->clk_enable(csi2dev);
+}
+
+static void mipi_csi2_clk_disable(struct mxc_mipi_csi2_dev *csi2dev)
+{
+	const struct mxc_mipi_csi2_clk_ops *ops = csi2dev->pdata->clk_ops;
+
+	if (!ops || !ops->clk_disable)
+		return;
+
+	ops->clk_disable(csi2dev);
+}
+
+static int mipi_csi2_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	return 0;
+}
+
+/* mipi csi2 subdev media entity operations */
+static int mipi_csi2_link_setup(struct media_entity *entity,
+				const struct media_pad *local,
+				const struct media_pad *remote, u32 flags)
+{
+	/* TODO */
+	/* Add MIPI source and sink pad link configuration */
+	if (local->flags & MEDIA_PAD_FL_SOURCE) {
+		switch (local->index) {
+		case MXC_MIPI_CSI2_VC0_PAD_SOURCE:
+		case MXC_MIPI_CSI2_VC1_PAD_SOURCE:
+		case MXC_MIPI_CSI2_VC2_PAD_SOURCE:
+		case MXC_MIPI_CSI2_VC3_PAD_SOURCE:
+			break;
+		default:
+			return 0;
+		}
+	} else if (local->flags & MEDIA_PAD_FL_SINK) {
+		switch (local->index) {
+		case MXC_MIPI_CSI2_VC0_PAD_SINK:
+		case MXC_MIPI_CSI2_VC1_PAD_SINK:
+		case MXC_MIPI_CSI2_VC2_PAD_SINK:
+		case MXC_MIPI_CSI2_VC3_PAD_SINK:
+			break;
+		default:
+			return 0;
+		}
+	}
+	return 0;
+}
+
+static const struct media_entity_operations mipi_csi2_sd_media_ops = {
+	.link_setup = mipi_csi2_link_setup,
+};
+
+/*
+ * V4L2 subdev operations
+ */
+static int mipi_csi2_s_power(struct v4l2_subdev *sd, int on)
+{
+	struct mxc_mipi_csi2_dev *csi2dev = sd_to_mxc_mipi_csi2_dev(sd);
+	struct v4l2_subdev *sen_sd;
+
+	sen_sd = mxc_get_remote_subdev(csi2dev, __func__);
+	if (!sen_sd)
+		return -EINVAL;
+
+	return v4l2_subdev_call(sen_sd, core, s_power, on);
+}
+
+static int mipi_csi2_g_frame_interval(struct v4l2_subdev *sd,
+				struct v4l2_subdev_frame_interval *interval)
+{
+	struct mxc_mipi_csi2_dev *csi2dev = sd_to_mxc_mipi_csi2_dev(sd);
+	struct v4l2_subdev *sen_sd;
+
+	sen_sd = mxc_get_remote_subdev(csi2dev, __func__);
+	if (!sen_sd)
+		return -EINVAL;
+
+	return v4l2_subdev_call(sen_sd, video, g_frame_interval, interval);
+}
+
+static int mipi_csi2_s_frame_interval(struct v4l2_subdev *sd,
+				struct v4l2_subdev_frame_interval *interval)
+{
+	struct mxc_mipi_csi2_dev *csi2dev = sd_to_mxc_mipi_csi2_dev(sd);
+	struct v4l2_subdev *sen_sd;
+
+	sen_sd = mxc_get_remote_subdev(csi2dev, __func__);
+	if (!sen_sd)
+		return -EINVAL;
+
+	return v4l2_subdev_call(sen_sd, video, s_frame_interval, interval);
+}
+
+static int mipi_csi2_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct mxc_mipi_csi2_dev *csi2dev = sd_to_mxc_mipi_csi2_dev(sd);
+	struct device *dev = &csi2dev->pdev->dev;
+	int ret = 0;
+
+	dev_dbg(&csi2dev->pdev->dev, "%s: %d, csi2dev: 0x%x\n",
+		__func__, enable, csi2dev->flags);
+
+	if (enable) {
+		pm_runtime_get_sync(dev);
+		if (!csi2dev->running++) {
+			mxc_csi2_get_sensor_fmt(csi2dev);
+			mxc_mipi_csi2_hc_config(csi2dev);
+			mxc_mipi_csi2_reset(csi2dev);
+			mxc_mipi_csi2_csr_config(csi2dev);
+			mxc_mipi_csi2_enable(csi2dev);
+			mxc_mipi_csi2_reg_dump(csi2dev);
+		}
+	} else {
+		if (!--csi2dev->running)
+			mxc_mipi_csi2_disable(csi2dev);
+
+		pm_runtime_put(dev);
+	}
+
+	return ret;
+}
+
+static int mipi_csi2_enum_framesizes(struct v4l2_subdev *sd,
+				     struct v4l2_subdev_state *sd_state,
+				     struct v4l2_subdev_frame_size_enum *fse)
+{
+	struct mxc_mipi_csi2_dev *csi2dev = sd_to_mxc_mipi_csi2_dev(sd);
+	struct v4l2_subdev *sen_sd;
+
+	sen_sd = mxc_get_remote_subdev(csi2dev, __func__);
+	if (!sen_sd)
+		return -EINVAL;
+
+	return v4l2_subdev_call(sen_sd, pad, enum_frame_size, NULL, fse);
+}
+
+static int mipi_csi2_enum_frame_interval(struct v4l2_subdev *sd,
+					 struct v4l2_subdev_state *sd_state,
+					 struct v4l2_subdev_frame_interval_enum *fie)
+{
+	struct mxc_mipi_csi2_dev *csi2dev = sd_to_mxc_mipi_csi2_dev(sd);
+	struct v4l2_subdev *sen_sd;
+
+	sen_sd = mxc_get_remote_subdev(csi2dev, __func__);
+	if (!sen_sd)
+		return -EINVAL;
+
+	return v4l2_subdev_call(sen_sd, pad, enum_frame_interval, NULL, fie);
+}
+
+static int mipi_csi2_get_fmt(struct v4l2_subdev *sd,
+			     struct v4l2_subdev_state *sd_state,
+			     struct v4l2_subdev_format *fmt)
+{
+	struct mxc_mipi_csi2_dev *csi2dev = sd_to_mxc_mipi_csi2_dev(sd);
+	struct v4l2_mbus_framefmt *mf = &fmt->format;
+
+	mxc_csi2_get_sensor_fmt(csi2dev);
+
+	memcpy(mf, &csi2dev->format, sizeof(struct v4l2_mbus_framefmt));
+	/* Source/Sink pads crop rectangle size */
+
+	return 0;
+}
+
+static int mipi_csi2_set_fmt(struct v4l2_subdev *sd,
+			     struct v4l2_subdev_state *sd_state,
+			     struct v4l2_subdev_format *fmt)
+{
+	struct mxc_mipi_csi2_dev *csi2dev = sd_to_mxc_mipi_csi2_dev(sd);
+	struct v4l2_subdev *sen_sd;
+	struct media_pad *source_pad;
+	int ret;
+
+	/* Get remote source pad */
+	source_pad = mxc_csi2_get_remote_sensor_pad(csi2dev);
+	if (!source_pad) {
+		v4l2_err(&csi2dev->sd, "%s, No remote pad found!\n", __func__);
+		return -EINVAL;
+	}
+
+	sen_sd = mxc_get_remote_subdev(csi2dev, __func__);
+	if (!sd)
+		return -EINVAL;
+
+	fmt->pad = source_pad->index;
+	ret = v4l2_subdev_call(sen_sd, pad, set_fmt, NULL, fmt);
+	if (ret < 0 && ret != -ENOIOCTLCMD)
+		return ret;
+
+	return 0;
+}
+
+static const struct v4l2_subdev_internal_ops mipi_csi2_sd_internal_ops = {
+	.open = mipi_csi2_open,
+};
+
+static struct v4l2_subdev_pad_ops mipi_csi2_pad_ops = {
+	.enum_frame_size = mipi_csi2_enum_framesizes,
+	.enum_frame_interval = mipi_csi2_enum_frame_interval,
+	.get_fmt = mipi_csi2_get_fmt,
+	.set_fmt = mipi_csi2_set_fmt,
+};
+
+static struct v4l2_subdev_core_ops mipi_csi2_core_ops = {
+	.s_power = mipi_csi2_s_power,
+};
+
+static struct v4l2_subdev_video_ops mipi_csi2_video_ops = {
+	.g_frame_interval = mipi_csi2_g_frame_interval,
+	.s_frame_interval = mipi_csi2_s_frame_interval,
+	.s_stream	  = mipi_csi2_s_stream,
+};
+
+static struct v4l2_subdev_ops mipi_csi2_subdev_ops = {
+	.core = &mipi_csi2_core_ops,
+	.video = &mipi_csi2_video_ops,
+	.pad = &mipi_csi2_pad_ops,
+};
+
+static int mipi_csi2_parse_dt(struct mxc_mipi_csi2_dev *csi2dev)
+{
+	struct device *dev = &csi2dev->pdev->dev;
+	struct device_node *node = dev->of_node;
+	struct v4l2_fwnode_endpoint endpoint;
+	u32 i;
+
+	csi2dev->id = of_alias_get_id(node, "csi");
+
+	csi2dev->vchannel = of_property_read_bool(node, "virtual-channel");
+
+	node = of_graph_get_next_endpoint(node, NULL);
+	if (!node) {
+		dev_err(dev, "No port node\n");
+		return -EINVAL;
+	}
+
+	/* Get port node */
+	memset(&endpoint, 0x0, sizeof(endpoint));
+	v4l2_fwnode_endpoint_parse(of_fwnode_handle(node), &endpoint);
+
+	csi2dev->num_lanes = endpoint.bus.mipi_csi2.num_data_lanes;
+	for (i = 0; i < 4; i++)
+		csi2dev->data_lanes[i] = endpoint.bus.mipi_csi2.data_lanes[i];
+
+	of_node_put(node);
+	return 0;
+}
+
+static int mipi_csi2_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct resource *mem_res;
+	struct mxc_mipi_csi2_dev *csi2dev;
+	const struct of_device_id *of_id;
+	int ret = -ENOMEM;
+
+	csi2dev = devm_kzalloc(dev, sizeof(*csi2dev), GFP_KERNEL);
+	if (!csi2dev)
+		return -ENOMEM;
+
+	csi2dev->pdev = pdev;
+	mutex_init(&csi2dev->lock);
+
+	ret = mipi_csi2_parse_dt(csi2dev);
+	if (ret < 0)
+		return ret;
+
+	of_id = of_match_node(mipi_csi2_of_match, dev->of_node);
+	if (!of_id)
+		return -EINVAL;
+
+	csi2dev->pdata = of_id->data;
+	if (!csi2dev->pdata) {
+		dev_err(dev, "Can't get csi platform device data\n");
+		return -EINVAL;
+	}
+
+	mem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	csi2dev->base_regs = devm_ioremap_resource(dev, mem_res);
+	if (IS_ERR(csi2dev->base_regs)) {
+		dev_err(dev, "Failed to get mipi csi2 HC register\n");
+		return PTR_ERR(csi2dev->base_regs);
+	}
+
+	mem_res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	csi2dev->csr_regs = devm_ioremap_resource(dev, mem_res);
+	if (IS_ERR(csi2dev->csr_regs)) {
+		dev_err(dev, "Failed to get mipi CSR register\n");
+		return PTR_ERR(csi2dev->csr_regs);
+	}
+
+	ret = mipi_csi2_clk_init(csi2dev);
+	if (ret < 0)
+		return ret;
+
+	ret = mipi_csi2_attach_pd(csi2dev);
+	if (ret < 0)
+		return ret;
+
+	v4l2_subdev_init(&csi2dev->sd, &mipi_csi2_subdev_ops);
+
+	csi2dev->sd.owner = THIS_MODULE;
+	snprintf(csi2dev->sd.name, sizeof(csi2dev->sd.name), "%s.%d",
+		 MXC_MIPI_CSI2_SUBDEV_NAME, csi2dev->id);
+
+	csi2dev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	csi2dev->sd.entity.function = MEDIA_ENT_F_IO_V4L;
+	csi2dev->sd.dev = dev;
+
+	csi2dev->pads[MXC_MIPI_CSI2_VC0_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+	csi2dev->pads[MXC_MIPI_CSI2_VC1_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+	csi2dev->pads[MXC_MIPI_CSI2_VC2_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+	csi2dev->pads[MXC_MIPI_CSI2_VC3_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+	csi2dev->pads[MXC_MIPI_CSI2_VC0_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	csi2dev->pads[MXC_MIPI_CSI2_VC1_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	csi2dev->pads[MXC_MIPI_CSI2_VC2_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	csi2dev->pads[MXC_MIPI_CSI2_VC3_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	ret = media_entity_pads_init(&csi2dev->sd.entity,
+				     MXC_MIPI_CSI2_VCX_PADS_NUM, csi2dev->pads);
+	if (ret < 0)
+		goto e_clkdis;
+
+	csi2dev->sd.entity.ops = &mipi_csi2_sd_media_ops;
+
+	v4l2_set_subdevdata(&csi2dev->sd, pdev);
+	platform_set_drvdata(pdev, csi2dev);
+
+	mipi_sc_fw_init(csi2dev, 1);
+
+	csi2dev->running = 0;
+	pm_runtime_enable(dev);
+
+	dev_info(&pdev->dev, "lanes: %d, name: %s\n",
+		 csi2dev->num_lanes, csi2dev->sd.name);
+
+	return 0;
+
+e_clkdis:
+	media_entity_cleanup(&csi2dev->sd.entity);
+	return ret;
+}
+
+static int mipi_csi2_remove(struct platform_device *pdev)
+{
+	struct v4l2_subdev *sd = platform_get_drvdata(pdev);
+	struct mxc_mipi_csi2_dev *csi2dev = sd_to_mxc_mipi_csi2_dev(sd);
+
+	mipi_sc_fw_init(csi2dev, 0);
+	mipi_csi2_detach_pd(csi2dev);
+	media_entity_cleanup(&csi2dev->sd.entity);
+	pm_runtime_disable(&pdev->dev);
+
+	return 0;
+}
+
+static int  mipi_csi2_pm_suspend(struct device *dev)
+{
+	struct v4l2_subdev *sd = dev_get_drvdata(dev);
+	struct mxc_mipi_csi2_dev *csi2dev = sd_to_mxc_mipi_csi2_dev(sd);
+
+	if (csi2dev->running > 0) {
+		dev_warn(dev, "running, prevent entering suspend.\n");
+		return -EAGAIN;
+	}
+
+	return pm_runtime_force_suspend(dev);
+}
+
+static int  mipi_csi2_pm_resume(struct device *dev)
+{
+	return pm_runtime_force_resume(dev);
+}
+
+static int  mipi_csi2_runtime_suspend(struct device *dev)
+{
+	struct mxc_mipi_csi2_dev *csi2dev = dev_get_drvdata(dev);
+
+	mipi_csi2_clk_disable(csi2dev);
+	return 0;
+}
+
+static int  mipi_csi2_runtime_resume(struct device *dev)
+{
+	struct mxc_mipi_csi2_dev *csi2dev = dev_get_drvdata(dev);
+	int ret;
+
+	ret = mipi_csi2_clk_enable(csi2dev);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static const struct dev_pm_ops mipi_csi_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(mipi_csi2_pm_suspend, mipi_csi2_pm_resume)
+	SET_RUNTIME_PM_OPS(mipi_csi2_runtime_suspend, mipi_csi2_runtime_resume, NULL)
+};
+
+static const struct of_device_id mipi_csi2_of_match[] = {
+	{ .compatible = "fsl,mxc-mipi-csi2", .data = &mxc_imx8_csi2_pdata },
+	{ .compatible = "fsl,imx8ulp-mipi-csi2", .data = &mxc_imx8ulp_csi2_pdata },
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, mipi_csi2_of_match);
+
+static struct platform_driver mipi_csi2_driver = {
+	.driver = {
+		.name = MXC_MIPI_CSI2_DRIVER_NAME,
+		.of_match_table = mipi_csi2_of_match,
+		.pm = &mipi_csi_pm_ops,
+	},
+	.probe = mipi_csi2_probe,
+	.remove = mipi_csi2_remove,
+};
+
+module_platform_driver(mipi_csi2_driver);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("MXC MIPI CSI2 driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" MXC_MIPI_CSI2_DRIVER_NAME);
diff --git a/drivers/staging/media/imx/imx8-parallel-csi.c b/drivers/staging/media/imx/imx8-parallel-csi.c
new file mode 100644
index 000000000..c3045c417
--- /dev/null
+++ b/drivers/staging/media/imx/imx8-parallel-csi.c
@@ -0,0 +1,837 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * V4L2 Capture CSI Subdev for Freescale i.MX8QM/QXP SOC
+ *
+ * Copyright 2019-2021 NXP
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/kernel.h>
+#include <linux/memory.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_graph.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/regulator/consumer.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/videodev2.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-device.h>
+#include <linux/firmware/imx/sci.h>
+#include <dt-bindings/pinctrl/pads-imx8qxp.h>
+#include <linux/init.h>
+#include <linux/pm_domain.h>
+
+#include "imx8-common.h"
+
+#define MXC_PARALLEL_CSI_DRIVER_NAME	"mxc-parallel-csi"
+#define MXC_PARALLEL_CSI_SUBDEV_NAME	MXC_PARALLEL_CSI_DRIVER_NAME
+
+#define BIT_U(nr)		(1U << (nr))
+#define CI_PI_BASE_OFFSET	0x0U
+
+/* CI_PI INTERFACE Control */
+#define IF_CTRL_REG                     (CI_PI_BASE_OFFSET + 0x00)
+#define IF_CTRL_REG_PL_ENABLE           BIT_U(0)
+#define IF_CTRL_REG_PL_VALID            BIT_U(1)
+#define IF_CTRL_REG_PL_ADDR(x)          (((x) & 0x7U) << 2)
+#define IF_CTRL_REG_IF_FORCE(x)         (((x) & 0x7U) << 5)
+#define IF_CTRL_REG_DATA_TYPE_SEL       BIT_U(8)
+#define IF_CTRL_REG_DATA_TYPE(x)        (((x) & 0x1FU) << 9)
+
+#define DATA_TYPE_OUT_NULL           (0x00)
+#define DATA_TYPE_OUT_RGB            (0x04)
+#define DATA_TYPE_OUT_YUV444         (0x08)
+#define DATA_TYPE_OUT_YYU420_ODD     (0x10)
+#define DATA_TYPE_OUT_YYU420_EVEN    (0x12)
+#define DATA_TYPE_OUT_YYY_ODD        (0x18)
+#define DATA_TYPE_OUT_UYVY_EVEN      (0x1A)
+#define DATA_TYPE_OUT_RAW            (0x1C)
+
+#define IF_CTRL_REG_IF_FORCE_HSYNV_OVERRIDE         0x4
+#define IF_CTRL_REG_IF_FORCE_VSYNV_OVERRIDE         0x2
+#define IF_CTRL_REG_IF_FORCE_DATA_ENABLE_OVERRIDE   0x1
+
+#define IF_CTRL_REG_SET                 (CI_PI_BASE_OFFSET + 0x04)
+#define IF_CTRL_REG_CLR                 (CI_PI_BASE_OFFSET + 0x08)
+#define IF_CTRL_REG_TOG                 (CI_PI_BASE_OFFSET + 0x0C)
+
+/* CSI INTERFACE CONTROL REG */
+#define CSI_CTRL_REG                    (CI_PI_BASE_OFFSET + 0x10)
+#define CSI_CTRL_REG_CSI_EN                     BIT_U(0)
+#define CSI_CTRL_REG_PIXEL_CLK_POL              BIT_U(1)
+#define CSI_CTRL_REG_HSYNC_POL                  BIT_U(2)
+#define CSI_CTRL_REG_VSYNC_POL                  BIT_U(3)
+#define CSI_CTRL_REG_DE_POL                     BIT_U(4)
+#define CSI_CTRL_REG_PIXEL_DATA_POL             BIT_U(5)
+#define CSI_CTRL_REG_CCIR_EXT_VSYNC_EN          BIT_U(6)
+#define CSI_CTRL_REG_CCIR_EN                    BIT_U(7)
+#define CSI_CTRL_REG_CCIR_VIDEO_MODE            BIT_U(8)
+#define CSI_CTRL_REG_CCIR_NTSC_EN               BIT_U(9)
+#define CSI_CTRL_REG_CCIR_VSYNC_RESET_EN        BIT_U(10)
+#define CSI_CTRL_REG_CCIR_ECC_ERR_CORRECT_EN    BIT_U(11)
+#define CSI_CTRL_REG_HSYNC_FORCE_EN             BIT_U(12)
+#define CSI_CTRL_REG_VSYNC_FORCE_EN             BIT_U(13)
+#define CSI_CTRL_REG_GCLK_MODE_EN               BIT_U(14)
+#define CSI_CTRL_REG_VALID_SEL                  BIT_U(15)
+#define CSI_CTRL_REG_RAW_OUT_SEL                BIT_U(16)
+#define CSI_CTRL_REG_HSYNC_OUT_SEL              BIT_U(17)
+#define CSI_CTRL_REG_HSYNC_PULSE(x)             (((x) & 0x7U) << 19)
+#define CSI_CTRL_REG_UV_SWAP_EN                 BIT_U(22)
+#define CSI_CTRL_REG_DATA_TYPE_IN(x)            (((x) & 0xFU) << 23)
+#define CSI_CTRL_REG_MASK_VSYNC_COUNTER(x)      (((x) & 0x3U) << 27)
+#define CSI_CTRL_REG_SOFTRST                    BIT_U(31)
+
+#define DATA_TYPE_IN_UYVY_BT656_8BITS     0x0
+#define DATA_TYPE_IN_UYVY_BT656_10BITS    0x1
+#define DATA_TYPE_IN_RGB_8BITS            0x2
+#define DATA_TYPE_IN_BGR_8BITS            0x3
+#define DATA_TYPE_IN_RGB_24BITS           0x4
+#define DATA_TYPE_IN_YVYU_8BITS           0x5
+#define DATA_TYPE_IN_YUV_8BITS            0x6
+#define DATA_TYPE_IN_YVYU_16BITS          0x7
+#define DATA_TYPE_IN_YUV_24BITS           0x8
+#define DATA_TYPE_IN_BAYER_8BITS          0x9
+#define DATA_TYPE_IN_BAYER_10BITS         0xA
+#define DATA_TYPE_IN_BAYER_12BITS         0xB
+#define DATA_TYPE_IN_BAYER_16BITS         0xC
+
+#define CSI_CTRL_REG_SET                (CI_PI_BASE_OFFSET + 0x14)
+#define CSI_CTRL_REG_CLR                (CI_PI_BASE_OFFSET + 0x18)
+#define CSI_CTRL_REG_TOG                (CI_PI_BASE_OFFSET + 0x1C)
+
+/* CSI interface Status */
+#define CSI_STATUS                      (CI_PI_BASE_OFFSET + 0x20)
+#define CSI_STATUS_FIELD_TOGGLE         BIT_U(0)
+#define CSI_STATUS_ECC_ERROR            BIT_U(1)
+
+#define CSI_STATUS_SET                  (CI_PI_BASE_OFFSET + 0x24)
+#define CSI_STATUS_CLR                  (CI_PI_BASE_OFFSET + 0x28)
+#define CSI_STATUS_TOG                  (CI_PI_BASE_OFFSET + 0x2C)
+
+/* CSI INTERFACE CONTROL REG1 */
+#define CSI_CTRL_REG1                   (CI_PI_BASE_OFFSET + 0x30)
+#define CSI_CTRL_REG1_PIXEL_WIDTH(v)    (((v) & 0xFFFFU) << 0)
+#define CSI_CTRL_REG1_VSYNC_PULSE(v)    (((v) & 0xFFFFU) << 16)
+
+#define CSI_CTRL_REG1_SET               (CI_PI_BASE_OFFSET + 0x34)
+#define CSI_CTRL_REG1_CLR               (CI_PI_BASE_OFFSET + 0x38)
+#define CSI_CTRL_REG1_TOG               (CI_PI_BASE_OFFSET + 0x3C)
+
+enum {
+	PI_MODE_INIT,
+	PI_GATE_CLOCK_MODE,
+	PI_CCIR_MODE,
+};
+struct mxc_parallel_csi_dev {
+	struct v4l2_subdev	sd;
+	struct v4l2_device	v4l2_dev;
+	struct v4l2_subdev	*sensor_sd;
+
+	struct media_pad	pads[MXC_PARALLEL_CSI_PADS_NUM];
+
+	void __iomem *csr_regs;
+	void __iomem *lpcg_regs;
+	struct platform_device *pdev;
+	u32 flags;
+	int irq;
+
+	struct clk *clk_ipg;
+	struct clk *clk_pixel;
+	bool clk_enable;
+
+	struct v4l2_async_subdev	asd;
+	struct v4l2_async_notifier	subdev_notifier;
+	struct v4l2_async_subdev	*async_subdevs[2];
+	struct v4l2_mbus_framefmt	format;
+
+	struct device *pd_pi;
+	struct device *pd_isi;
+	struct device_link *pd_pi_link;
+	struct device_link *pd_isi_link;
+
+	struct mutex lock;
+
+	u8 running;
+	u8 mode;
+	u8 uv_swap;
+	u8 tvdec;
+};
+
+static int debug;
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "Debug level (0-2)");
+
+static int format;
+module_param(format, int, 0644);
+MODULE_PARM_DESC(format, "Format level (0-2)");
+
+#ifdef DEBUG
+static void mxc_pcsi_regs_dump(struct mxc_parallel_csi_dev *pcsidev)
+{
+	struct device *dev = &pcsidev->pdev->dev;
+	struct {
+		u32 offset;
+		const char *const name[32];
+	} registers[] = {
+		{ 0x00, "HW_IF_CTRL_REG" },
+		{ 0x10, "HW_CSI_CTRL_REG" },
+		{ 0x20, "HW_CSI_STATUS" },
+		{ 0x30, "HW_CSI_CTRL_REG1" },
+	};
+	u32 i;
+
+	for (i = 0; i < ARRAY_SIZE(registers); i++) {
+		u32 reg = readl(pcsidev->csr_regs + registers[i].offset);
+		dev_dbg(dev, "%20s[0x%.2x]: 0x%.8x\n",
+			registers[i].name, registers[i].offset, reg);
+	}
+}
+#else
+static void mxc_pcsi_regs_dump(struct mxc_parallel_csi_dev *pcsidev) { }
+#endif
+
+static struct mxc_parallel_csi_dev *sd_to_mxc_pcsi_dev(struct v4l2_subdev *sdev)
+{
+	return container_of(sdev, struct mxc_parallel_csi_dev, sd);
+}
+
+static int mxc_pcsi_clk_get(struct mxc_parallel_csi_dev *pcsidev)
+{
+	struct device *dev = &pcsidev->pdev->dev;
+
+	pcsidev->clk_pixel = devm_clk_get(dev, "pixel");
+	if (IS_ERR(pcsidev->clk_pixel)) {
+		dev_info(dev, "failed to get parallel csi pixel clk\n");
+		return PTR_ERR(pcsidev->clk_pixel);
+	}
+
+	pcsidev->clk_ipg = devm_clk_get(dev, "ipg");
+	if (IS_ERR(pcsidev->clk_ipg)) {
+		dev_info(dev, "failed to get parallel ipg pixel clk\n");
+		return PTR_ERR(pcsidev->clk_ipg);
+	}
+
+	return 0;
+}
+
+static int mxc_pcsi_attach_pd(struct mxc_parallel_csi_dev *pcsidev)
+{
+	struct device *dev = &pcsidev->pdev->dev;
+	struct device_link *link;
+
+	pcsidev->pd_pi = dev_pm_domain_attach_by_name(dev, "pd_pi");
+	if (IS_ERR(pcsidev->pd_pi)) {
+		if (PTR_ERR(pcsidev->pd_pi) != -EPROBE_DEFER) {
+			dev_err(dev, "attach pd_pi domain for pi fail\n");
+			return PTR_ERR(pcsidev->pd_pi);
+		} else {
+			return PTR_ERR(pcsidev->pd_pi);
+		}
+	}
+	link = device_link_add(dev, pcsidev->pd_pi,
+			       DL_FLAG_STATELESS |
+			       DL_FLAG_PM_RUNTIME);
+	if (IS_ERR(link))
+		return PTR_ERR(link);
+	pcsidev->pd_pi_link = link;
+
+	pcsidev->pd_isi = dev_pm_domain_attach_by_name(dev, "pd_isi_ch0");
+	if (IS_ERR(pcsidev->pd_isi)) {
+		if (PTR_ERR(pcsidev->pd_isi) != -EPROBE_DEFER) {
+			dev_err(dev, "attach pd_isi_ch0 domain for pi fail\n");
+			return PTR_ERR(pcsidev->pd_isi);
+		} else {
+			return PTR_ERR(pcsidev->pd_isi);
+		}
+	}
+	link = device_link_add(dev, pcsidev->pd_isi,
+			       DL_FLAG_STATELESS |
+			       DL_FLAG_PM_RUNTIME);
+	if (IS_ERR(link))
+		return PTR_ERR(link);
+	pcsidev->pd_isi_link = link;
+
+	return 0;
+}
+
+static void mxc_pcsi_detach_pd(struct mxc_parallel_csi_dev *pcsidev)
+{
+	device_link_del(pcsidev->pd_pi_link);
+	device_link_del(pcsidev->pd_isi_link);
+	dev_pm_domain_detach(pcsidev->pd_pi, true);
+	dev_pm_domain_detach(pcsidev->pd_isi, true);
+}
+
+static int mxc_pcsi_clk_enable(struct mxc_parallel_csi_dev *pcsidev)
+{
+	struct device *dev = &pcsidev->pdev->dev;
+	int ret;
+
+	if (pcsidev->clk_enable)
+		return 0;
+
+	ret = clk_prepare_enable(pcsidev->clk_pixel);
+	if (ret < 0) {
+		dev_info(dev, "enable pixel clk error (%d)\n", ret);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(pcsidev->clk_ipg);
+	if (ret < 0) {
+		dev_info(dev, "enable ipg clk error (%d)\n", ret);
+		return ret;
+	}
+	pcsidev->clk_enable = true;
+
+	return 0;
+}
+
+static void mxc_pcsi_clk_disable(struct mxc_parallel_csi_dev *pcsidev)
+{
+	if (!pcsidev->clk_enable)
+		return;
+
+	clk_disable_unprepare(pcsidev->clk_pixel);
+	clk_disable_unprepare(pcsidev->clk_ipg);
+
+	pcsidev->clk_enable = false;
+}
+
+static void mxc_pcsi_sw_reset(struct mxc_parallel_csi_dev *pcsidev)
+{
+	u32 val;
+
+	/* Softwaret Reset */
+	val = CSI_CTRL_REG_SOFTRST;
+	writel(val, pcsidev->csr_regs + CSI_CTRL_REG_SET);
+
+	msleep(1);
+	writel(val, pcsidev->csr_regs + CSI_CTRL_REG_CLR);
+}
+
+static void mxc_pcsi_csr_config(struct mxc_parallel_csi_dev *pcsidev)
+{
+	u32 val;
+
+	/* Software Reset */
+	mxc_pcsi_sw_reset(pcsidev);
+
+	/* Config PL Data Type */
+	val = IF_CTRL_REG_DATA_TYPE(DATA_TYPE_OUT_YUV444);
+	writel(val, pcsidev->csr_regs + IF_CTRL_REG_SET);
+
+	/* Enable sync Force */
+	val = (CSI_CTRL_REG_HSYNC_FORCE_EN | CSI_CTRL_REG_VSYNC_FORCE_EN);
+	writel(val, pcsidev->csr_regs + CSI_CTRL_REG_SET);
+
+	/* Enable Pixel Link */
+	val = IF_CTRL_REG_PL_ENABLE;
+	writel(val, pcsidev->csr_regs + IF_CTRL_REG_SET);
+
+	/* Enable Pixel Link */
+	val = IF_CTRL_REG_PL_VALID;
+	writel(val, pcsidev->csr_regs + IF_CTRL_REG_SET);
+
+	/* Config CTRL REG */
+	val = readl(pcsidev->csr_regs + CSI_CTRL_REG);
+	val |= (CSI_CTRL_REG_DATA_TYPE_IN(DATA_TYPE_IN_UYVY_BT656_8BITS) |
+		CSI_CTRL_REG_HSYNC_POL |
+		CSI_CTRL_REG_MASK_VSYNC_COUNTER(3) |
+		CSI_CTRL_REG_HSYNC_PULSE(2));
+
+	if (pcsidev->uv_swap)
+		val |= CSI_CTRL_REG_UV_SWAP_EN;
+
+	if (pcsidev->mode & PI_GATE_CLOCK_MODE) {
+		val |= CSI_CTRL_REG_GCLK_MODE_EN;
+	} else if (pcsidev->mode & PI_CCIR_MODE) {
+		val |= (CSI_CTRL_REG_CCIR_EN |
+			CSI_CTRL_REG_CCIR_VSYNC_RESET_EN |
+			CSI_CTRL_REG_CCIR_EXT_VSYNC_EN |
+			CSI_CTRL_REG_CCIR_ECC_ERR_CORRECT_EN);
+	}
+
+	writel(val, pcsidev->csr_regs + CSI_CTRL_REG);
+}
+
+static void mxc_pcsi_config_ctrl_reg1(struct mxc_parallel_csi_dev *pcsidev)
+{
+	struct device *dev = &pcsidev->pdev->dev;
+	u32 val;
+
+	if (pcsidev->format.width <= 0 || pcsidev->format.height <= 0) {
+		dev_dbg(dev, "%s width/height invalid\n", __func__);
+		return;
+	}
+
+	/* Config Pixel Width */
+	val = (CSI_CTRL_REG1_PIXEL_WIDTH(pcsidev->format.width - 1) |
+	       CSI_CTRL_REG1_VSYNC_PULSE(pcsidev->format.width << 1));
+	writel(val, pcsidev->csr_regs + CSI_CTRL_REG1);
+}
+
+static void mxc_pcsi_enable_csi(struct mxc_parallel_csi_dev *pcsidev)
+{
+	u32 val;
+
+	/* Enable CSI */
+	val = CSI_CTRL_REG_CSI_EN;
+	writel(val, pcsidev->csr_regs + CSI_CTRL_REG_SET);
+
+	/* Disable SYNC Force */
+	val = (CSI_CTRL_REG_HSYNC_FORCE_EN | CSI_CTRL_REG_VSYNC_FORCE_EN);
+	writel(val, pcsidev->csr_regs + CSI_CTRL_REG_CLR);
+}
+
+static void mxc_pcsi_disable_csi(struct mxc_parallel_csi_dev *pcsidev)
+{
+	u32 val;
+
+	/* Enable Sync Force */
+	val = (CSI_CTRL_REG_HSYNC_FORCE_EN | CSI_CTRL_REG_VSYNC_FORCE_EN);
+	writel(val, pcsidev->csr_regs + CSI_CTRL_REG_SET);
+
+	/* Disable CSI */
+	val = CSI_CTRL_REG_CSI_EN;
+	writel(val, pcsidev->csr_regs + CSI_CTRL_REG_CLR);
+
+	/* Disable Pixel Link */
+	val = IF_CTRL_REG_PL_VALID | IF_CTRL_REG_PL_ENABLE;
+	writel(val, pcsidev->csr_regs + IF_CTRL_REG_CLR);
+}
+
+static struct media_pad *
+mxc_pcsi_get_remote_sensor_pad(struct mxc_parallel_csi_dev *pcsidev)
+{
+	struct v4l2_subdev *subdev = &pcsidev->sd;
+	struct media_pad *sink_pad, *source_pad;
+	int i;
+
+	while (1) {
+		source_pad = NULL;
+		for (i = 0; i < subdev->entity.num_pads; i++) {
+			sink_pad = &subdev->entity.pads[i];
+
+			if (sink_pad->flags & MEDIA_PAD_FL_SINK) {
+				source_pad = media_entity_remote_pad(sink_pad);
+				if (source_pad)
+					break;
+			}
+		}
+		/* return first pad point in the loop  */
+		return source_pad;
+	}
+
+	if (i == subdev->entity.num_pads)
+		v4l2_err(&pcsidev->v4l2_dev,
+			 "%s, No remote pad found!\n", __func__);
+
+	return NULL;
+}
+
+static struct v4l2_subdev *mxc_get_remote_subdev(struct mxc_parallel_csi_dev *pcsidev,
+						 const char * const label)
+{
+	struct media_pad *source_pad;
+	struct v4l2_subdev *sen_sd;
+
+	/* Get remote source pad */
+	source_pad = mxc_pcsi_get_remote_sensor_pad(pcsidev);
+	if (!source_pad) {
+		v4l2_err(&pcsidev->sd, "%s, No remote pad found!\n", label);
+		return NULL;
+	}
+
+	/* Get remote source pad subdev */
+	sen_sd = media_entity_to_v4l2_subdev(source_pad->entity);
+	if (!sen_sd) {
+		v4l2_err(&pcsidev->sd, "%s, No remote subdev found!\n", label);
+		return NULL;
+	}
+
+	return sen_sd;
+}
+
+static int mxc_pcsi_get_sensor_fmt(struct mxc_parallel_csi_dev *pcsidev)
+{
+	struct v4l2_mbus_framefmt *mf = &pcsidev->format;
+	struct v4l2_subdev *sen_sd;
+	struct media_pad *source_pad;
+	struct v4l2_subdev_format src_fmt;
+	int ret;
+
+	/* Get remote source pad */
+	source_pad = mxc_pcsi_get_remote_sensor_pad(pcsidev);
+	if (!source_pad) {
+		v4l2_err(&pcsidev->v4l2_dev, "%s, No remote pad found!\n", __func__);
+		return -EINVAL;
+	}
+
+	/* Get remote source pad subdev */
+	sen_sd = media_entity_to_v4l2_subdev(source_pad->entity);
+	if (!sen_sd) {
+		v4l2_err(&pcsidev->v4l2_dev, "%s, No remote subdev found!\n", __func__);
+		return -EINVAL;
+	}
+
+	src_fmt.pad = source_pad->index;
+	src_fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+	ret = v4l2_subdev_call(sen_sd, pad, get_fmt, NULL, &src_fmt);
+	if (ret < 0 && ret != -ENOIOCTLCMD)
+		return -EINVAL;
+
+	/* Update input frame size and formate  */
+	memcpy(mf, &src_fmt.format, sizeof(struct v4l2_mbus_framefmt));
+
+	if (mf->code == MEDIA_BUS_FMT_YUYV8_2X8 ||
+	    mf->code == MEDIA_BUS_FMT_UYVY8_2X8)
+		pcsidev->uv_swap = 1;
+
+	dev_dbg(&pcsidev->pdev->dev,
+		"width=%d, height=%d, fmt.code=0x%x\n",
+		mf->width, mf->height, mf->code);
+
+	return 0;
+}
+
+static int mxc_pcsi_enum_framesizes(struct v4l2_subdev *sd,
+				    struct v4l2_subdev_state *sd_state,
+				    struct v4l2_subdev_frame_size_enum *fse)
+{
+	struct mxc_parallel_csi_dev *pcsidev = sd_to_mxc_pcsi_dev(sd);
+	struct v4l2_subdev *sen_sd;
+
+	sen_sd = mxc_get_remote_subdev(pcsidev, __func__);
+	if (!sen_sd)
+		return -EINVAL;
+
+	return v4l2_subdev_call(sen_sd, pad, enum_frame_size, NULL, fse);
+}
+
+static int mxc_pcsi_enum_frame_interval(struct v4l2_subdev *sd,
+					struct v4l2_subdev_state *sd_state,
+					struct v4l2_subdev_frame_interval_enum *fie)
+{
+	struct mxc_parallel_csi_dev *pcsidev = sd_to_mxc_pcsi_dev(sd);
+	struct v4l2_subdev *sen_sd;
+
+	sen_sd = mxc_get_remote_subdev(pcsidev, __func__);
+	if (!sen_sd)
+		return -EINVAL;
+
+	return v4l2_subdev_call(sen_sd, pad, enum_frame_interval, NULL, fie);
+}
+
+static int mxc_pcsi_get_fmt(struct v4l2_subdev *sd,
+			    struct v4l2_subdev_state *sd_state,
+			    struct v4l2_subdev_format *fmt)
+{
+	struct mxc_parallel_csi_dev *pcsidev = sd_to_mxc_pcsi_dev(sd);
+	struct v4l2_mbus_framefmt *mf = &fmt->format;
+
+	mxc_pcsi_get_sensor_fmt(pcsidev);
+
+	memcpy(mf, &pcsidev->format, sizeof(struct v4l2_mbus_framefmt));
+	/* Source/Sink pads crop rectangle size */
+
+	return 0;
+}
+
+static int mxc_pcsi_set_fmt(struct v4l2_subdev *sd,
+			    struct v4l2_subdev_state *sd_state,
+			    struct v4l2_subdev_format *fmt)
+{
+	struct mxc_parallel_csi_dev *pcsidev = sd_to_mxc_pcsi_dev(sd);
+	struct v4l2_subdev *sen_sd;
+	struct media_pad *source_pad;
+	int ret;
+
+	/* Get remote source pad */
+	source_pad = mxc_pcsi_get_remote_sensor_pad(pcsidev);
+	if (!source_pad) {
+		v4l2_err(&pcsidev->v4l2_dev, "%s, No remote pad found!\n", __func__);
+		return -EINVAL;
+	}
+
+	/* Get remote source pad subdev */
+	sen_sd = media_entity_to_v4l2_subdev(source_pad->entity);
+	if (!sen_sd) {
+		v4l2_err(&pcsidev->v4l2_dev, "%s, No remote subdev found!\n", __func__);
+		return -EINVAL;
+	}
+
+	fmt->pad = source_pad->index;
+	ret = v4l2_subdev_call(sen_sd, pad, set_fmt, NULL, fmt);
+	if (ret < 0 && ret != -ENOIOCTLCMD)
+		return ret;
+
+	return 0;
+}
+
+static int mxc_pcsi_s_power(struct v4l2_subdev *sd, int on)
+{
+	struct mxc_parallel_csi_dev *pcsidev = sd_to_mxc_pcsi_dev(sd);
+	struct v4l2_subdev *sen_sd;
+
+	sen_sd = mxc_get_remote_subdev(pcsidev, __func__);
+	if (!sen_sd)
+		return -EINVAL;
+
+	return v4l2_subdev_call(sen_sd, core, s_power, on);
+}
+
+static int mxc_pcsi_g_frame_interval(struct v4l2_subdev *sd,
+				struct v4l2_subdev_frame_interval *interval)
+{
+	struct mxc_parallel_csi_dev *pcsidev = sd_to_mxc_pcsi_dev(sd);
+	struct v4l2_subdev *sen_sd;
+
+	sen_sd = mxc_get_remote_subdev(pcsidev, __func__);
+	if (!sen_sd)
+		return -EINVAL;
+
+	return v4l2_subdev_call(sen_sd, video, g_frame_interval, interval);
+}
+
+static int mxc_pcsi_s_frame_interval(struct v4l2_subdev *sd,
+				struct v4l2_subdev_frame_interval *interval)
+{
+	struct mxc_parallel_csi_dev *pcsidev = sd_to_mxc_pcsi_dev(sd);
+	struct v4l2_subdev *sen_sd;
+
+	sen_sd = mxc_get_remote_subdev(pcsidev, __func__);
+	if (!sen_sd)
+		return -EINVAL;
+
+	return v4l2_subdev_call(sen_sd, video, s_frame_interval, interval);
+}
+
+static int mxc_pcsi_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct mxc_parallel_csi_dev *pcsidev = sd_to_mxc_pcsi_dev(sd);
+	struct device *dev = &pcsidev->pdev->dev;
+
+	dev_dbg(dev, "%s: enable = %d\n", __func__, enable);
+
+	if (enable) {
+		pm_runtime_get_sync(dev);
+		if (!pcsidev->running) {
+			mxc_pcsi_get_sensor_fmt(pcsidev);
+			mxc_pcsi_csr_config(pcsidev);
+			mxc_pcsi_config_ctrl_reg1(pcsidev);
+			mxc_pcsi_enable_csi(pcsidev);
+			mxc_pcsi_regs_dump(pcsidev);
+		}
+		pcsidev->running++;
+	} else {
+		if (pcsidev->running)
+			mxc_pcsi_disable_csi(pcsidev);
+		pcsidev->running--;
+		pm_runtime_put(dev);
+	}
+
+	return 0;
+}
+
+static int mxc_pcsi_link_setup(struct media_entity *entity,
+			       const struct media_pad *local,
+			       const struct media_pad *remote, u32 flags)
+{
+	struct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);
+	struct platform_device *pdev = v4l2_get_subdevdata(sd);
+
+	if (local->flags & MEDIA_PAD_FL_SOURCE) {
+		switch (local->index) {
+		case MXC_PARALLEL_CSI_PAD_SOURCE:
+			break;
+		default:
+			dev_err(&pdev->dev, "%s invalid source pad\n", __func__);
+			return -EINVAL;
+		}
+	} else if (local->flags & MEDIA_PAD_FL_SINK) {
+		switch (local->index) {
+		case MXC_PARALLEL_CSI_PAD_SINK:
+			break;
+		default:
+			dev_err(&pdev->dev, "%s invalid sink pad\n", __func__);
+			return -EINVAL;
+		}
+	}
+	return 0;
+}
+
+static struct v4l2_subdev_pad_ops pcsi_pad_ops = {
+	.enum_frame_size = mxc_pcsi_enum_framesizes,
+	.enum_frame_interval = mxc_pcsi_enum_frame_interval,
+	.get_fmt = mxc_pcsi_get_fmt,
+	.set_fmt = mxc_pcsi_set_fmt,
+};
+
+static struct v4l2_subdev_core_ops pcsi_core_ops = {
+	.s_power = mxc_pcsi_s_power,
+};
+
+static struct v4l2_subdev_video_ops pcsi_video_ops = {
+	.g_frame_interval = mxc_pcsi_g_frame_interval,
+	.s_frame_interval = mxc_pcsi_s_frame_interval,
+	.s_stream	  = mxc_pcsi_s_stream,
+};
+
+static struct v4l2_subdev_ops pcsi_subdev_ops = {
+	.core = &pcsi_core_ops,
+	.video = &pcsi_video_ops,
+	.pad = &pcsi_pad_ops,
+};
+
+static const struct media_entity_operations mxc_pcsi_sd_media_ops = {
+	.link_setup = mxc_pcsi_link_setup,
+};
+
+static int mxc_parallel_csi_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct resource *mem_res;
+	struct mxc_parallel_csi_dev *pcsidev;
+	int ret;
+
+	pcsidev = devm_kzalloc(dev, sizeof(*pcsidev), GFP_KERNEL);
+	if (!pcsidev)
+		return -ENOMEM;
+
+	pcsidev->pdev = pdev;
+
+	mem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	pcsidev->csr_regs = devm_ioremap_resource(dev, mem_res);
+	if (IS_ERR(pcsidev->csr_regs)) {
+		dev_dbg(dev, "Failed to get parallel CSI CSR register\n");
+		return PTR_ERR(pcsidev->csr_regs);
+	}
+
+	ret = mxc_pcsi_clk_get(pcsidev);
+	if (ret < 0)
+		return ret;
+
+	ret = mxc_pcsi_attach_pd(pcsidev);
+	if (ret < 0)
+		return ret;
+
+	v4l2_subdev_init(&pcsidev->sd, &pcsi_subdev_ops);
+
+	pcsidev->mode = PI_GATE_CLOCK_MODE;
+
+	pcsidev->sd.owner = THIS_MODULE;
+	sprintf(pcsidev->sd.name, "%s", MXC_PARALLEL_CSI_SUBDEV_NAME);
+
+	pcsidev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	pcsidev->sd.entity.function = MEDIA_ENT_F_IO_V4L;
+
+	pcsidev->sd.dev = dev;
+
+	pcsidev->pads[MXC_PARALLEL_CSI_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+	pcsidev->pads[MXC_PARALLEL_CSI_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+
+	ret = media_entity_pads_init(&pcsidev->sd.entity,
+				     MXC_PARALLEL_CSI_PADS_NUM,
+				     pcsidev->pads);
+	if (ret < 0)
+		goto e_clkdis;
+
+	pcsidev->sd.entity.ops = &mxc_pcsi_sd_media_ops;
+
+	v4l2_set_subdevdata(&pcsidev->sd, pdev);
+	platform_set_drvdata(pdev, pcsidev);
+
+	pcsidev->running = 0;
+	pm_runtime_enable(dev);
+
+	dev_info(dev, "%s probe successfully\n", __func__);
+	return 0;
+
+e_clkdis:
+	media_entity_cleanup(&pcsidev->sd.entity);
+	return ret;
+}
+
+static int mxc_parallel_csi_remove(struct platform_device *pdev)
+{
+	struct mxc_parallel_csi_dev *pcsidev =
+			(struct mxc_parallel_csi_dev *)platform_get_drvdata(pdev);
+
+	mxc_pcsi_detach_pd(pcsidev);
+	media_entity_cleanup(&pcsidev->sd.entity);
+	pm_runtime_disable(&pdev->dev);
+
+	return 0;
+}
+
+static int parallel_csi_pm_suspend(struct device *dev)
+{
+	return pm_runtime_force_suspend(dev);
+}
+
+static int parallel_csi_pm_resume(struct device *dev)
+{
+	return pm_runtime_force_resume(dev);
+}
+
+static int parallel_csi_runtime_suspend(struct device *dev)
+{
+	struct mxc_parallel_csi_dev *pcsidev = dev_get_drvdata(dev);
+
+	mxc_pcsi_clk_disable(pcsidev);
+
+	return 0;
+}
+
+static int parallel_csi_runtime_resume(struct device *dev)
+{
+	struct mxc_parallel_csi_dev *pcsidev = dev_get_drvdata(dev);
+	int ret;
+
+	ret = mxc_pcsi_clk_enable(pcsidev);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static const struct dev_pm_ops parallel_csi_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(parallel_csi_pm_suspend, parallel_csi_pm_resume)
+	SET_RUNTIME_PM_OPS(parallel_csi_runtime_suspend,
+			   parallel_csi_runtime_resume,
+			   NULL)
+};
+
+static const struct of_device_id parallel_csi_of_match[] = {
+	{	.compatible = "fsl,mxc-parallel-csi",},
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, parallel_csi_of_match);
+
+static struct platform_driver parallel_csi_driver = {
+	.driver = {
+		.name = MXC_PARALLEL_CSI_DRIVER_NAME,
+		.of_match_table = parallel_csi_of_match,
+		.pm = &parallel_csi_pm_ops,
+	},
+	.probe = mxc_parallel_csi_probe,
+	.remove = mxc_parallel_csi_remove,
+};
+
+module_platform_driver(parallel_csi_driver);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("MXC PARALLEL CSI driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" MXC_PARALLEL_CSI_DRIVER_NAME);
diff --git a/drivers/staging/media/imx/imx8mq-mipi-csi2.c b/drivers/staging/media/imx/imx8mq-mipi-csi2.c
index 1d28313db..a6f562009 100644
--- a/drivers/staging/media/imx/imx8mq-mipi-csi2.c
+++ b/drivers/staging/media/imx/imx8mq-mipi-csi2.c
@@ -398,6 +398,9 @@ static int imx8mq_mipi_csi_s_stream(struct v4l2_subdev *sd, int enable)
 	struct csi_state *state = mipi_sd_to_csi2_state(sd);
 	int ret = 0;
 
+	imx8mq_mipi_csi_write(state, CSI2RX_IRQ_MASK,
+			      CSI2RX_IRQ_MASK_ULPS_STATUS_CHANGE);
+
 	if (enable) {
 		ret = pm_runtime_resume_and_get(state->dev);
 		if (ret < 0)
@@ -693,7 +696,7 @@ static int imx8mq_mipi_csi_async_register(struct csi_state *state)
  * Suspend/resume
  */
 
-static int imx8mq_mipi_csi_pm_suspend(struct device *dev)
+static int imx8mq_mipi_csi_pm_suspend(struct device *dev, bool runtime)
 {
 	struct v4l2_subdev *sd = dev_get_drvdata(dev);
 	struct csi_state *state = mipi_sd_to_csi2_state(sd);
@@ -705,21 +708,36 @@ static int imx8mq_mipi_csi_pm_suspend(struct device *dev)
 		imx8mq_mipi_csi_stop_stream(state);
 		imx8mq_mipi_csi_clk_disable(state);
 		state->state &= ~ST_POWERED;
+		if (!runtime)
+			state->state |= ST_SUSPENDED;
 	}
 
 	mutex_unlock(&state->lock);
 
+	ret = icc_set_bw(state->icc_path, 0, 0);
+	if (ret)
+		dev_err(dev, "icc_set_bw failed with %d\n", ret);
+
 	return ret ? -EAGAIN : 0;
 }
 
-static int imx8mq_mipi_csi_pm_resume(struct device *dev)
+static int imx8mq_mipi_csi_pm_resume(struct device *dev, bool runtime)
 {
 	struct v4l2_subdev *sd = dev_get_drvdata(dev);
 	struct csi_state *state = mipi_sd_to_csi2_state(sd);
 	int ret = 0;
 
+	ret = icc_set_bw(state->icc_path, 0, state->icc_path_bw);
+	if (ret) {
+		dev_err(dev, "icc_set_bw failed with %d\n", ret);
+		return ret;
+	}
+
 	mutex_lock(&state->lock);
 
+	if (!runtime && !(state->state & ST_SUSPENDED))
+		goto unlock;
+
 	if (!(state->state & ST_POWERED)) {
 		state->state |= ST_POWERED;
 		ret = imx8mq_mipi_csi_clk_enable(state);
@@ -740,60 +758,22 @@ static int imx8mq_mipi_csi_pm_resume(struct device *dev)
 
 static int __maybe_unused imx8mq_mipi_csi_suspend(struct device *dev)
 {
-	struct v4l2_subdev *sd = dev_get_drvdata(dev);
-	struct csi_state *state = mipi_sd_to_csi2_state(sd);
-	int ret;
-
-	ret = imx8mq_mipi_csi_pm_suspend(dev);
-	if (ret)
-		return ret;
-
-	state->state |= ST_SUSPENDED;
-
-	return ret;
+	return imx8mq_mipi_csi_pm_suspend(dev, false);
 }
 
 static int __maybe_unused imx8mq_mipi_csi_resume(struct device *dev)
 {
-	struct v4l2_subdev *sd = dev_get_drvdata(dev);
-	struct csi_state *state = mipi_sd_to_csi2_state(sd);
-
-	if (!(state->state & ST_SUSPENDED))
-		return 0;
-
-	return imx8mq_mipi_csi_pm_resume(dev);
+	return imx8mq_mipi_csi_pm_resume(dev, false);
 }
 
 static int __maybe_unused imx8mq_mipi_csi_runtime_suspend(struct device *dev)
 {
-	struct v4l2_subdev *sd = dev_get_drvdata(dev);
-	struct csi_state *state = mipi_sd_to_csi2_state(sd);
-	int ret;
-
-	ret = imx8mq_mipi_csi_pm_suspend(dev);
-	if (ret)
-		return ret;
-
-	ret = icc_set_bw(state->icc_path, 0, 0);
-	if (ret)
-		dev_err(dev, "icc_set_bw failed with %d\n", ret);
-
-	return ret;
+	return imx8mq_mipi_csi_pm_suspend(dev, true);
 }
 
 static int __maybe_unused imx8mq_mipi_csi_runtime_resume(struct device *dev)
 {
-	struct v4l2_subdev *sd = dev_get_drvdata(dev);
-	struct csi_state *state = mipi_sd_to_csi2_state(sd);
-	int ret;
-
-	ret = icc_set_bw(state->icc_path, 0, state->icc_path_bw);
-	if (ret) {
-		dev_err(dev, "icc_set_bw failed with %d\n", ret);
-		return ret;
-	}
-
-	return imx8mq_mipi_csi_pm_resume(dev);
+	return imx8mq_mipi_csi_pm_resume(dev, true);
 }
 
 static const struct dev_pm_ops imx8mq_mipi_csi_pm_ops = {
@@ -941,7 +921,7 @@ static int imx8mq_mipi_csi_probe(struct platform_device *pdev)
 	/* Enable runtime PM. */
 	pm_runtime_enable(dev);
 	if (!pm_runtime_enabled(dev)) {
-		ret = imx8mq_mipi_csi_runtime_resume(dev);
+		ret = imx8mq_mipi_csi_pm_resume(dev, true);
 		if (ret < 0)
 			goto icc;
 	}
@@ -954,7 +934,7 @@ static int imx8mq_mipi_csi_probe(struct platform_device *pdev)
 
 cleanup:
 	pm_runtime_disable(&pdev->dev);
-	imx8mq_mipi_csi_runtime_suspend(&pdev->dev);
+	imx8mq_mipi_csi_pm_suspend(&pdev->dev, true);
 
 	media_entity_cleanup(&state->sd.entity);
 	v4l2_async_notifier_unregister(&state->notifier);
@@ -978,7 +958,7 @@ static int imx8mq_mipi_csi_remove(struct platform_device *pdev)
 	v4l2_async_unregister_subdev(&state->sd);
 
 	pm_runtime_disable(&pdev->dev);
-	imx8mq_mipi_csi_runtime_suspend(&pdev->dev);
+	imx8mq_mipi_csi_pm_suspend(&pdev->dev, true);
 	media_entity_cleanup(&state->sd.entity);
 	mutex_destroy(&state->lock);
 	pm_runtime_set_suspended(&pdev->dev);
-- 
2.25.1

