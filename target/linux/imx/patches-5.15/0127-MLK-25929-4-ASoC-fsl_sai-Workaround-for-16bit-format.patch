From fb0e889287c6989ce4c3b01d3c98ffdcbd5b6b0f Mon Sep 17 00:00:00 2001
From: Yuantian Tang <andy.tang@nxp.com>
Date: Wed, 28 Sep 2022 14:35:11 +0800
Subject: [PATCH 127/274] MLK-25929-4: ASoC: fsl_sai: Workaround for 16bit
 format audio process on i.MX93

Only TCD of edma AXI that has NBYTES in a multiple of 8bytes works on
i.MX93. The maxburst of dma is set to 8 on i.MX93 which is different
from previous platform. It makes sure that NBYTES is a multiple of
8bytes. This is a workaround for 16bit format audio process.

Reviewed-by: Shengjiu Wang <shengjiu.wang@nxp.com>
Signed-off-by: Chancel Liu <chancel.liu@nxp.com>
---
 sound/soc/fsl/Kconfig           |   48 +
 sound/soc/fsl/Makefile          |   19 +-
 sound/soc/fsl/fsl-asoc-card.c   |  277 ++++-
 sound/soc/fsl/fsl_asrc.c        |   73 +-
 sound/soc/fsl/fsl_asrc.h        |  133 +--
 sound/soc/fsl/fsl_asrc_common.h |   12 +-
 sound/soc/fsl/fsl_asrc_dma.c    |   15 +
 sound/soc/fsl/fsl_asrc_m2m.c    | 1062 +++++++++++++++++++
 sound/soc/fsl/fsl_aud2htx.c     |   16 +-
 sound/soc/fsl/fsl_audmix.c      |   16 +-
 sound/soc/fsl/fsl_dsd.h         |   58 ++
 sound/soc/fsl/fsl_easrc.c       |   60 +-
 sound/soc/fsl/fsl_easrc_m2m.c   |  981 ++++++++++++++++++
 sound/soc/fsl/fsl_esai.c        |  214 ++--
 sound/soc/fsl/fsl_esai.h        |   67 ++
 sound/soc/fsl/fsl_esai_client.c |  254 +++++
 sound/soc/fsl/fsl_esai_client.h |   40 +
 sound/soc/fsl/fsl_esai_mix.c    |  479 +++++++++
 sound/soc/fsl/fsl_esai_mix.h    |   58 ++
 sound/soc/fsl/fsl_hdmi.c        |  772 ++++++++++++++
 sound/soc/fsl/fsl_micfil.c      | 1721 ++++++++++++++++++++++++++++++-
 sound/soc/fsl/fsl_micfil.h      |   53 +-
 sound/soc/fsl/fsl_rpmsg.c       |   78 +-
 sound/soc/fsl/fsl_rpmsg.h       |   13 +-
 sound/soc/fsl/fsl_sai.c         |   11 +-
 sound/soc/fsl/fsl_sai.h         |   49 +-
 sound/soc/fsl/fsl_sai_sysfs.c   |  312 ++++++
 sound/soc/fsl/fsl_spdif.c       |  466 ++++++---
 sound/soc/fsl/fsl_spdif.h       |   14 +
 sound/soc/fsl/fsl_ssi.c         |   55 +-
 sound/soc/fsl/fsl_xcvr.c        |   84 +-
 sound/soc/fsl/fsl_xcvr.h        |   54 +
 sound/soc/fsl/fsl_xcvr_sysfs.c  |  109 ++
 sound/soc/fsl/hdmi_pcm.S        |  246 +++++
 sound/soc/fsl/imx-audio-rpmsg.c |   40 +-
 sound/soc/fsl/imx-card.c        |   19 +-
 sound/soc/fsl/imx-es8328.c      |    1 -
 sound/soc/fsl/imx-hdmi-dma.c    | 1174 +++++++++++++++++++++
 sound/soc/fsl/imx-hdmi.c        |   36 +-
 sound/soc/fsl/imx-hdmi.h        |  106 ++
 sound/soc/fsl/imx-pcm-dma.c     |    3 +
 sound/soc/fsl/imx-pcm-rpmsg.c   |   44 +-
 sound/soc/fsl/imx-pcm-rpmsg.h   |   13 +
 sound/soc/fsl/imx-pcm.h         |    2 +-
 sound/soc/fsl/imx-pcm512x.c     |  576 +++++++++++
 sound/soc/fsl/imx-pdm.c         |  409 ++++++++
 sound/soc/fsl/imx-rpmsg.c       |   54 +-
 sound/soc/fsl/imx-sgtl5000.c    |   18 +-
 sound/soc/fsl/imx-spdif.c       |   75 +-
 sound/soc/fsl/imx6qdl-hdmi.c    |  117 +++
 50 files changed, 10092 insertions(+), 514 deletions(-)
 create mode 100644 sound/soc/fsl/fsl_asrc_m2m.c
 create mode 100644 sound/soc/fsl/fsl_dsd.h
 create mode 100755 sound/soc/fsl/fsl_easrc_m2m.c
 create mode 100644 sound/soc/fsl/fsl_esai_client.c
 create mode 100644 sound/soc/fsl/fsl_esai_client.h
 create mode 100644 sound/soc/fsl/fsl_esai_mix.c
 create mode 100644 sound/soc/fsl/fsl_esai_mix.h
 create mode 100644 sound/soc/fsl/fsl_hdmi.c
 create mode 100644 sound/soc/fsl/fsl_sai_sysfs.c
 create mode 100644 sound/soc/fsl/fsl_xcvr_sysfs.c
 create mode 100644 sound/soc/fsl/hdmi_pcm.S
 create mode 100644 sound/soc/fsl/imx-hdmi-dma.c
 create mode 100644 sound/soc/fsl/imx-hdmi.h
 create mode 100644 sound/soc/fsl/imx-pcm512x.c
 create mode 100644 sound/soc/fsl/imx-pdm.c
 create mode 100644 sound/soc/fsl/imx6qdl-hdmi.c

diff --git a/sound/soc/fsl/Kconfig b/sound/soc/fsl/Kconfig
index 8e05d0927..c70e9c4ee 100644
--- a/sound/soc/fsl/Kconfig
+++ b/sound/soc/fsl/Kconfig
@@ -112,6 +112,12 @@ config SND_SOC_FSL_AUD2HTX
 	help
 	  Say Y if you want to add AUDIO TO HDMI TX support for NXP.
 
+config SND_SOC_FSL_ESAI_CLIENT
+	tristate "NXP ESAI CLIENT module support"
+	select SND_SOC_IMX_PCM_DMA if SND_IMX_SOC != n
+	help
+	  Say Y if you want to add ESAI CLIENT module support for NXP.
+
 config SND_SOC_FSL_UTILS
 	tristate
 
@@ -126,6 +132,9 @@ config SND_SOC_FSL_RPMSG
 	  This option is only useful for out-of-tree drivers since
 	  in-tree drivers select it automatically.
 
+config SND_SOC_FSL_HDMI
+	tristate
+
 config SND_SOC_IMX_PCM_DMA
 	tristate
 	select SND_SOC_GENERIC_DMAENGINE_PCM
@@ -257,6 +266,11 @@ if SND_IMX_SOC
 
 comment "SoC Audio support for Freescale i.MX boards:"
 
+config SND_SOC_IMX_HDMI_DMA
+	bool
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	select SND_SOC_IMX_PCM_DMA
+
 config SND_SOC_EUKREA_TLV320
 	tristate "Eukrea TLV320"
 	depends on ARCH_MXC && !ARM64 && I2C
@@ -364,6 +378,40 @@ config SND_SOC_IMX_CARD
 	  with OF-graph DT bindings.
 	  It also support DPCM of single CPU multi Codec ststem.
 
+config SND_SOC_IMX_PDM_MIC
+	tristate "SoC Audio support for i.MX boards with PDM mic on SAI"
+	depends on OF
+	select SND_SOC_IMX_PDM_DMA
+	select SND_SOC_FSL_SAI
+	help
+	  SoC Audio support for i.MX boards with PDM microphones on SAI
+	  Say Y if you want to add support for SoC Audio support for i.MX boards
+	  with PDM microphones on SAI.
+
+config SND_SOC_IMX_PCM512X
+	tristate "SoC Audio support for i.MX boards with PCM512x and headphone amp"
+	depends on OF && I2C
+	select SND_SOC_PCM512x_I2C
+	select SND_SOC_TPA6130A2
+	select SND_SOC_IMX_PCM_DMA
+	select SND_SOC_FSL_SAI
+	select SND_SOC_FSL_UTILS
+	help
+	  SoC Audio support for i.MX boards with pcm512x
+	  Say Y if you want to add support for SoC audio on an i.MX board with
+	  an pcm512x codec.
+
+config SND_SOC_IMX6QDL_HDMI
+	tristate "SoC Audio support for i.MX6QDL boards with HDMI port"
+	depends on MFD_MXC_HDMI
+	select SND_SOC_IMX_HDMI_DMA
+	select SND_SOC_FSL_HDMI
+	select SND_SOC_HDMI_CODEC
+	help
+	  SoC Audio support for i.MX6QDL boards with HDMI audio
+	  Say Y if you want to add support for SoC audio on an i.MX board with
+	  IMX6QDL HDMI.
+
 endif # SND_IMX_SOC
 
 endmenu
diff --git a/sound/soc/fsl/Makefile b/sound/soc/fsl/Makefile
index b54beb1a6..63e691267 100644
--- a/sound/soc/fsl/Makefile
+++ b/sound/soc/fsl/Makefile
@@ -15,22 +15,24 @@ obj-$(CONFIG_SND_SOC_P1022_RDK) += snd-soc-p1022-rdk.o
 snd-soc-fsl-audmix-objs := fsl_audmix.o
 snd-soc-fsl-asoc-card-objs := fsl-asoc-card.o
 snd-soc-fsl-asrc-objs := fsl_asrc.o fsl_asrc_dma.o
-snd-soc-fsl-sai-objs := fsl_sai.o
+snd-soc-fsl-sai-objs := fsl_sai.o fsl_sai_sysfs.o
 snd-soc-fsl-ssi-y := fsl_ssi.o
 snd-soc-fsl-ssi-$(CONFIG_DEBUG_FS) += fsl_ssi_dbg.o
 snd-soc-fsl-spdif-objs := fsl_spdif.o
-snd-soc-fsl-esai-objs := fsl_esai.o
+snd-soc-fsl-esai-objs := fsl_esai.o fsl_esai_mix.o
 snd-soc-fsl-micfil-objs := fsl_micfil.o
 snd-soc-fsl-utils-objs := fsl_utils.o
 snd-soc-fsl-dma-objs := fsl_dma.o
 snd-soc-fsl-mqs-objs := fsl_mqs.o
 snd-soc-fsl-easrc-objs := fsl_easrc.o
-snd-soc-fsl-xcvr-objs := fsl_xcvr.o
+snd-soc-fsl-xcvr-objs := fsl_xcvr.o fsl_xcvr_sysfs.o
 snd-soc-fsl-aud2htx-objs := fsl_aud2htx.o
 snd-soc-fsl-rpmsg-objs := fsl_rpmsg.o
+snd-soc-fsl-esai-client-objs := fsl_esai_client.o
 
 obj-$(CONFIG_SND_SOC_FSL_AUDMIX) += snd-soc-fsl-audmix.o
 obj-$(CONFIG_SND_SOC_FSL_ASOC_CARD) += snd-soc-fsl-asoc-card.o
+snd-soc-fsl-hdmi-objs := fsl_hdmi.o
 obj-$(CONFIG_SND_SOC_FSL_ASRC) += snd-soc-fsl-asrc.o
 obj-$(CONFIG_SND_SOC_FSL_SAI) += snd-soc-fsl-sai.o
 obj-$(CONFIG_SND_SOC_FSL_SSI) += snd-soc-fsl-ssi.o
@@ -40,10 +42,12 @@ obj-$(CONFIG_SND_SOC_FSL_MICFIL) += snd-soc-fsl-micfil.o
 obj-$(CONFIG_SND_SOC_FSL_UTILS) += snd-soc-fsl-utils.o
 obj-$(CONFIG_SND_SOC_FSL_MQS) += snd-soc-fsl-mqs.o
 obj-$(CONFIG_SND_SOC_FSL_EASRC) += snd-soc-fsl-easrc.o
+obj-$(CONFIG_SND_SOC_FSL_HDMI) += snd-soc-fsl-hdmi.o
 obj-$(CONFIG_SND_SOC_POWERPC_DMA) += snd-soc-fsl-dma.o
 obj-$(CONFIG_SND_SOC_FSL_XCVR) += snd-soc-fsl-xcvr.o
 obj-$(CONFIG_SND_SOC_FSL_AUD2HTX) += snd-soc-fsl-aud2htx.o
 obj-$(CONFIG_SND_SOC_FSL_RPMSG) += snd-soc-fsl-rpmsg.o
+obj-$(CONFIG_SND_SOC_FSL_ESAI_CLIENT) += snd-soc-fsl-esai-client.o
 
 # MPC5200 Platform Support
 obj-$(CONFIG_SND_MPC52xx_DMA) += mpc5200_dma.o
@@ -62,6 +66,7 @@ obj-$(CONFIG_SND_SOC_IMX_PCM_FIQ) += imx-pcm-fiq.o
 obj-$(CONFIG_SND_SOC_IMX_PCM_DMA) += imx-pcm-dma.o
 obj-$(CONFIG_SND_SOC_IMX_AUDIO_RPMSG) += imx-audio-rpmsg.o
 obj-$(CONFIG_SND_SOC_IMX_PCM_RPMSG) += imx-pcm-rpmsg.o
+obj-$(CONFIG_SND_SOC_IMX_HDMI_DMA) += imx-hdmi-dma.o hdmi_pcm.o
 
 # i.MX Machine Support
 snd-soc-eukrea-tlv320-objs := eukrea-tlv320.o
@@ -72,6 +77,9 @@ snd-soc-imx-audmix-objs := imx-audmix.o
 snd-soc-imx-hdmi-objs := imx-hdmi.o
 snd-soc-imx-rpmsg-objs := imx-rpmsg.o
 snd-soc-imx-card-objs := imx-card.o
+snd-soc-imx-pdm-objs := imx-pdm.o
+snd-soc-imx-pcm512x-objs := imx-pcm512x.o
+snd-soc-imx6qdl-hdmi-objs := imx6qdl-hdmi.o
 
 obj-$(CONFIG_SND_SOC_EUKREA_TLV320) += snd-soc-eukrea-tlv320.o
 obj-$(CONFIG_SND_SOC_IMX_ES8328) += snd-soc-imx-es8328.o
@@ -81,3 +89,8 @@ obj-$(CONFIG_SND_SOC_IMX_AUDMIX) += snd-soc-imx-audmix.o
 obj-$(CONFIG_SND_SOC_IMX_HDMI) += snd-soc-imx-hdmi.o
 obj-$(CONFIG_SND_SOC_IMX_RPMSG) += snd-soc-imx-rpmsg.o
 obj-$(CONFIG_SND_SOC_IMX_CARD) += snd-soc-imx-card.o
+obj-$(CONFIG_SND_SOC_IMX_PDM_MIC) += snd-soc-imx-pdm.o
+obj-$(CONFIG_SND_SOC_IMX_PCM512X) += snd-soc-imx-pcm512x.o
+obj-$(CONFIG_SND_SOC_IMX6QDL_HDMI) += snd-soc-imx6qdl-hdmi.o
+
+AFLAGS_hdmi_pcm.o := -march=armv7-a -mtune=cortex-a9 -mfpu=neon -mfloat-abi=softfp
diff --git a/sound/soc/fsl/fsl-asoc-card.c b/sound/soc/fsl/fsl-asoc-card.c
index 95286c839..873203714 100644
--- a/sound/soc/fsl/fsl-asoc-card.c
+++ b/sound/soc/fsl/fsl-asoc-card.c
@@ -10,6 +10,7 @@
 #include <linux/i2c.h>
 #include <linux/module.h>
 #include <linux/of_platform.h>
+#include <linux/of_gpio.h>
 #if IS_ENABLED(CONFIG_SND_AC97_CODEC)
 #include <sound/ac97_codec.h>
 #endif
@@ -35,6 +36,20 @@
 /* Default DAI format without Master and Slave flag */
 #define DAI_FMT_BASE (SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF)
 
+enum fsl_asoc_card_type {
+	CARD_CS42888 = 1,
+	CARD_WM8960,
+	CARD_WM8962,
+	CARD_SGTL5000,
+	CARD_AC97,
+	CARD_CS427X,
+	CARD_TLV320AIC32X4,
+	CARD_MQS,
+	CARD_WM8524,
+	CARD_SI476X,
+	CARD_WM8958,
+};
+
 /**
  * struct codec_priv - CODEC private data
  * @mclk_freq: Clock rate of MCLK
@@ -99,6 +114,11 @@ struct fsl_asoc_card_priv {
 	u32 asrc_rate;
 	snd_pcm_format_t asrc_format;
 	u32 dai_fmt;
+	u32 card_type;
+	bool is_stream_tdm[2];
+	bool is_codec_master;
+	bool is_playback_only;
+	bool is_capture_only;
 	char name[32];
 };
 
@@ -141,6 +161,15 @@ static const struct snd_soc_dapm_route audio_map_rx[] = {
 	{"ASRC-Capture",  NULL, "CPU-Capture"},
 };
 
+static const struct snd_soc_dapm_route audio_map_esai[] = {
+	{"Playback",  NULL, "CPU-Playback"},/* dai route for be and fe */
+	{"CPU-Capture",  NULL, "Capture"},
+	{"CPU-Playback",  NULL, "CLIENT0-Playback"},
+	{"CLIENT0-Capture",  NULL, "CPU-Capture"},
+	{"CPU-Playback",  NULL, "CLIENT1-Playback"},
+	{"CLIENT1-Capture",  NULL, "CPU-Capture"},
+};
+
 /* Add all possible widgets into here without being redundant */
 static const struct snd_soc_dapm_widget fsl_asoc_card_dapm_widgets[] = {
 	SND_SOC_DAPM_LINE("Line Out Jack", NULL),
@@ -167,6 +196,7 @@ static int fsl_asoc_card_hw_params(struct snd_pcm_substream *substream,
 	struct cpu_priv *cpu_priv = &priv->cpu_priv;
 	struct device *dev = rtd->card->dev;
 	unsigned int pll_out;
+	u32 channels = params_channels(params);
 	int ret;
 
 	priv->sample_rate = params_rate(params);
@@ -196,7 +226,8 @@ static int fsl_asoc_card_hw_params(struct snd_pcm_substream *substream,
 
 	/* Specific configuration for PLL */
 	if (codec_priv->pll_id && codec_priv->fll_id) {
-		if (priv->sample_format == SNDRV_PCM_FORMAT_S24_LE)
+		if (priv->sample_format == SNDRV_PCM_FORMAT_S24_LE ||
+		    priv->sample_format == SNDRV_PCM_FORMAT_S20_3LE)
 			pll_out = priv->sample_rate * 384;
 		else
 			pll_out = priv->sample_rate * 256;
@@ -220,6 +251,55 @@ static int fsl_asoc_card_hw_params(struct snd_pcm_substream *substream,
 		}
 	}
 
+	if (priv->card_type == CARD_CS42888) {
+		priv->is_stream_tdm[tx] = channels > 1 && channels % 2;
+		if (asoc_rtd_to_cpu(rtd, 0)->stream_active[!substream->stream] &&
+			(priv->is_stream_tdm[tx] != priv->is_stream_tdm[!tx])) {
+			dev_err(dev, "Don't support different fmt for tx & rx\n");
+			return -EINVAL;
+		}
+
+		priv->dai_fmt &= ~SND_SOC_DAIFMT_FORMAT_MASK;
+		if (priv->is_stream_tdm[tx]) {
+			u32 max_tdm_rate;
+
+			if (priv->is_codec_master) {
+				dev_err(dev, "%d channels are not supported in codec master mode\n",
+					channels);
+				return -EINVAL;
+			}
+
+			max_tdm_rate = priv->cpu_priv.sysclk_freq[tx] / (2*8*32);
+			if (priv->sample_rate > max_tdm_rate) {
+				dev_err(dev, "maximum supported sampling rate for %d channels is %dKHz\n",
+					channels, max_tdm_rate / 1000);
+				return -EINVAL;
+			}
+
+			priv->dai_fmt |= SND_SOC_DAIFMT_DSP_A;
+			snd_soc_dai_set_tdm_slot(asoc_rtd_to_cpu(rtd, 0),
+					 BIT(channels) - 1, BIT(channels) - 1,
+					 8, cpu_priv->slot_width);
+		} else {
+			priv->dai_fmt |= SND_SOC_DAIFMT_LEFT_J;
+			snd_soc_dai_set_tdm_slot(asoc_rtd_to_cpu(rtd, 0),
+						 0x3, 0x3, 2,
+						 cpu_priv->slot_width);
+		}
+		/* set cpu DAI configuration */
+		ret = snd_soc_dai_set_fmt(asoc_rtd_to_cpu(rtd, 0), priv->dai_fmt);
+		if (ret) {
+			dev_err(dev, "failed to set cpu dai fmt: %d\n", ret);
+			return ret;
+		}
+		/* set codec DAI configuration */
+		ret = snd_soc_dai_set_fmt(asoc_rtd_to_codec(rtd, 0), priv->dai_fmt);
+		if (ret) {
+			dev_err(dev, "failed to set codec dai fmt: %d\n", ret);
+			return ret;
+		}
+	}
+
 	return 0;
 
 fail:
@@ -259,7 +339,64 @@ static int fsl_asoc_card_hw_free(struct snd_pcm_substream *substream)
 	return 0;
 }
 
+static int fsl_asoc_card_startup(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct fsl_asoc_card_priv *priv = snd_soc_card_get_drvdata(rtd->card);
+	static struct snd_pcm_hw_constraint_list constraint_rates;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct device *dev = rtd->card->dev;
+	static u32 support_rates[10];
+	int ret;
+
+	if (priv->card_type == CARD_CS42888) {
+		if (priv->codec_priv.mclk_freq % 12288000 == 0) {
+			support_rates[0] = 48000;
+			support_rates[1] = 96000;
+			support_rates[2] = 192000;
+			constraint_rates.list = support_rates;
+			constraint_rates.count = 3;
+
+			ret = snd_pcm_hw_constraint_list(runtime, 0,
+							 SNDRV_PCM_HW_PARAM_RATE,
+							 &constraint_rates);
+			if (ret)
+				return ret;
+		} else
+			dev_warn(dev, "mclk may be not supported %ld\n",
+				 priv->codec_priv.mclk_freq);
+	}
+
+	if ((priv->card_type == CARD_WM8960 ||
+	     priv->card_type == CARD_WM8962 ||
+	     priv->card_type == CARD_WM8958)
+	    && !priv->is_codec_master) {
+		support_rates[0] = 8000;
+		support_rates[1] = 16000;
+		support_rates[2] = 32000;
+		support_rates[3] = 48000;
+		support_rates[4] = 64000;
+		support_rates[5] = 96000;
+		constraint_rates.list = support_rates;
+		constraint_rates.count = 6;
+		ret = snd_pcm_hw_constraint_list(runtime, 0,
+						 SNDRV_PCM_HW_PARAM_RATE,
+						 &constraint_rates);
+		if (ret)
+			return ret;
+
+	}
+
+	return 0;
+}
+
 static const struct snd_soc_ops fsl_asoc_card_ops = {
+	.startup = fsl_asoc_card_startup,
+	.hw_params = fsl_asoc_card_hw_params,
+	.hw_free = fsl_asoc_card_hw_free,
+};
+
+static const struct snd_soc_ops fsl_asoc_card_ops_be = {
 	.hw_params = fsl_asoc_card_hw_params,
 	.hw_free = fsl_asoc_card_hw_free,
 };
@@ -281,6 +418,23 @@ static int be_hw_params_fixup(struct snd_soc_pcm_runtime *rtd,
 	return 0;
 }
 
+static int be_hw_params_fixup_esai(struct snd_soc_pcm_runtime *rtd,
+				   struct snd_pcm_hw_params *params)
+{
+	struct snd_pcm_substream *substream = snd_soc_dpcm_get_substream(rtd,
+					      SNDRV_PCM_STREAM_PLAYBACK);
+	struct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);
+	struct fsl_esai *esai = snd_soc_dai_get_drvdata(cpu_dai);
+	bool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;
+	struct fsl_esai_mix *mix = &esai->mix[tx];
+	struct snd_interval *channels;
+
+	channels = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);
+	channels->max = channels->min = mix->channels;
+
+	return 0;
+}
+
 SND_SOC_DAILINK_DEFS(hifi,
 	DAILINK_COMP_ARRAY(COMP_EMPTY()),
 	DAILINK_COMP_ARRAY(COMP_EMPTY()),
@@ -302,6 +456,7 @@ static struct snd_soc_dai_link fsl_asoc_card_dai[] = {
 		.name = "HiFi",
 		.stream_name = "HiFi",
 		.ops = &fsl_asoc_card_ops,
+		.ignore_pmdown_time = 1,
 		SND_SOC_DAILINK_REG(hifi),
 	},
 	/* DPCM Link between Front-End and Back-End (Optional) */
@@ -311,16 +466,19 @@ static struct snd_soc_dai_link fsl_asoc_card_dai[] = {
 		.dpcm_playback = 1,
 		.dpcm_capture = 1,
 		.dynamic = 1,
+		.ignore_pmdown_time = 1,
+		.dpcm_merged_chan = 1,
 		SND_SOC_DAILINK_REG(hifi_fe),
 	},
 	{
 		.name = "HiFi-ASRC-BE",
 		.stream_name = "HiFi-ASRC-BE",
 		.be_hw_params_fixup = be_hw_params_fixup,
-		.ops = &fsl_asoc_card_ops,
+		.ops = &fsl_asoc_card_ops_be,
 		.dpcm_playback = 1,
 		.dpcm_capture = 1,
 		.no_pcm = 1,
+		.ignore_pmdown_time = 1,
 		SND_SOC_DAILINK_REG(hifi_be),
 	},
 };
@@ -538,6 +696,8 @@ static int fsl_asoc_card_probe(struct platform_device *pdev)
 	struct platform_device *cpu_pdev;
 	struct fsl_asoc_card_priv *priv;
 	struct device *codec_dev = NULL;
+	struct of_phandle_args args[2];
+	struct platform_device *client_pdev[2];
 	const char *codec_dai_name;
 	const char *codec_dev_name;
 	u32 width;
@@ -618,33 +778,40 @@ static int fsl_asoc_card_probe(struct platform_device *pdev)
 		priv->cpu_priv.sysclk_dir[RX] = SND_SOC_CLOCK_OUT;
 		priv->cpu_priv.slot_width = 32;
 		priv->dai_fmt |= SND_SOC_DAIFMT_CBS_CFS;
+		priv->card_type = CARD_CS42888;
 	} else if (of_device_is_compatible(np, "fsl,imx-audio-cs427x")) {
 		codec_dai_name = "cs4271-hifi";
 		priv->codec_priv.mclk_id = CS427x_SYSCLK_MCLK;
 		priv->dai_fmt |= SND_SOC_DAIFMT_CBM_CFM;
+		priv->card_type = CARD_CS427X;
 	} else if (of_device_is_compatible(np, "fsl,imx-audio-sgtl5000")) {
 		codec_dai_name = "sgtl5000";
 		priv->codec_priv.mclk_id = SGTL5000_SYSCLK;
 		priv->dai_fmt |= SND_SOC_DAIFMT_CBM_CFM;
+		priv->card_type = CARD_SGTL5000;
 	} else if (of_device_is_compatible(np, "fsl,imx-audio-tlv320aic32x4")) {
 		codec_dai_name = "tlv320aic32x4-hifi";
 		priv->dai_fmt |= SND_SOC_DAIFMT_CBM_CFM;
+		priv->card_type = CARD_TLV320AIC32X4;
 	} else if (of_device_is_compatible(np, "fsl,imx-audio-wm8962")) {
 		codec_dai_name = "wm8962";
 		priv->codec_priv.mclk_id = WM8962_SYSCLK_MCLK;
 		priv->codec_priv.fll_id = WM8962_SYSCLK_FLL;
 		priv->codec_priv.pll_id = WM8962_FLL;
 		priv->dai_fmt |= SND_SOC_DAIFMT_CBM_CFM;
+		priv->card_type = CARD_WM8962;
 	} else if (of_device_is_compatible(np, "fsl,imx-audio-wm8960")) {
 		codec_dai_name = "wm8960-hifi";
 		priv->codec_priv.fll_id = WM8960_SYSCLK_AUTO;
 		priv->codec_priv.pll_id = WM8960_SYSCLK_AUTO;
 		priv->dai_fmt |= SND_SOC_DAIFMT_CBM_CFM;
+		priv->card_type = CARD_WM8960;
 	} else if (of_device_is_compatible(np, "fsl,imx-audio-ac97")) {
 		codec_dai_name = "ac97-hifi";
 		priv->dai_fmt = SND_SOC_DAIFMT_AC97;
 		priv->card.dapm_routes = audio_map_ac97;
 		priv->card.num_dapm_routes = ARRAY_SIZE(audio_map_ac97);
+		priv->card_type = CARD_AC97;
 	} else if (of_device_is_compatible(np, "fsl,imx-audio-mqs")) {
 		codec_dai_name = "fsl-mqs-dai";
 		priv->dai_fmt = SND_SOC_DAIFMT_LEFT_J |
@@ -654,6 +821,7 @@ static int fsl_asoc_card_probe(struct platform_device *pdev)
 		priv->dai_link[2].dpcm_capture = 0;
 		priv->card.dapm_routes = audio_map_tx;
 		priv->card.num_dapm_routes = ARRAY_SIZE(audio_map_tx);
+		priv->card_type = CARD_MQS;
 	} else if (of_device_is_compatible(np, "fsl,imx-audio-wm8524")) {
 		codec_dai_name = "wm8524-hifi";
 		priv->dai_fmt |= SND_SOC_DAIFMT_CBS_CFS;
@@ -662,11 +830,13 @@ static int fsl_asoc_card_probe(struct platform_device *pdev)
 		priv->cpu_priv.slot_width = 32;
 		priv->card.dapm_routes = audio_map_tx;
 		priv->card.num_dapm_routes = ARRAY_SIZE(audio_map_tx);
+		priv->card_type = CARD_WM8524;
 	} else if (of_device_is_compatible(np, "fsl,imx-audio-si476x")) {
 		codec_dai_name = "si476x-codec";
 		priv->dai_fmt |= SND_SOC_DAIFMT_CBS_CFS;
 		priv->card.dapm_routes = audio_map_rx;
 		priv->card.num_dapm_routes = ARRAY_SIZE(audio_map_rx);
+		priv->card_type = CARD_SI476X;
 	} else if (of_device_is_compatible(np, "fsl,imx-audio-wm8958")) {
 		codec_dai_name = "wm8994-aif1";
 		priv->dai_fmt |= SND_SOC_DAIFMT_CBM_CFM;
@@ -676,6 +846,7 @@ static int fsl_asoc_card_probe(struct platform_device *pdev)
 		priv->codec_priv.free_freq = priv->codec_priv.mclk_freq;
 		priv->card.dapm_routes = NULL;
 		priv->card.num_dapm_routes = 0;
+		priv->card_type = CARD_WM8958;
 	} else {
 		dev_err(&pdev->dev, "unknown Device Tree compatible\n");
 		ret = -EINVAL;
@@ -702,11 +873,36 @@ static int fsl_asoc_card_probe(struct platform_device *pdev)
 	if (priv->dai_fmt & SND_SOC_DAIFMT_CBM_CFM) {
 		priv->cpu_priv.sysclk_dir[TX] = SND_SOC_CLOCK_IN;
 		priv->cpu_priv.sysclk_dir[RX] = SND_SOC_CLOCK_IN;
+		priv->is_codec_master = true;
 	}
 
 	of_node_put(bitclkmaster);
 	of_node_put(framemaster);
 
+	if (of_property_read_bool(np, "capture-only"))
+		priv->is_capture_only = true;
+
+	if (of_property_read_bool(np, "playback-only"))
+		priv->is_playback_only = true;
+
+	if (priv->is_capture_only && priv->is_playback_only) {
+		ret = -EINVAL;
+		dev_err(&pdev->dev, "failed for playback only and capture only\n");
+		goto asrc_fail;
+	}
+
+	if (priv->is_capture_only) {
+		priv->dai_link[0].capture_only = true;
+		priv->dai_link[1].capture_only = true;
+		priv->dai_link[2].capture_only = true;
+	}
+
+	if (priv->is_playback_only) {
+		priv->dai_link[0].playback_only = true;
+		priv->dai_link[1].playback_only = true;
+		priv->dai_link[2].playback_only = true;
+	}
+
 	if (!fsl_asoc_card_is_ac97(priv) && !codec_dev) {
 		dev_dbg(&pdev->dev, "failed to find codec device\n");
 		ret = -EPROBE_DEFER;
@@ -836,13 +1032,88 @@ static int fsl_asoc_card_probe(struct platform_device *pdev)
 		}
 	}
 
+	/* switch to v2 if there is "client-dais" property */
+	if (of_property_read_bool(cpu_np, "client-dais")) {
+		ret = of_parse_phandle_with_args(cpu_np, "client-dais", NULL, 0,
+						 &args[0]);
+		if (ret < 0) {
+			dev_err(&pdev->dev, "of_parse_phandle_with_args failed\n");
+			goto asrc_fail;
+		}
+
+		client_pdev[0] = of_find_device_by_node(args[0].np);
+		if (!client_pdev[0]) {
+			dev_err(&pdev->dev, "failed to find SAI platform device\n");
+			ret = -EINVAL;
+			goto asrc_fail;
+		}
+
+		ret = of_parse_phandle_with_args(cpu_np, "client-dais", NULL, 1,
+						 &args[1]);
+		if (ret < 0) {
+			dev_err(&pdev->dev, "of_parse_phandle_with_args failed\n");
+			goto asrc_fail;
+		}
+
+		client_pdev[1] = of_find_device_by_node(args[1].np);
+		if (!client_pdev[1]) {
+			dev_err(&pdev->dev, "failed to find SAI platform device\n");
+			ret = -EINVAL;
+			goto asrc_fail;
+		}
+
+		priv->dai_link[0].name = "HiFi-FE1";
+		priv->dai_link[0].stream_name = "HiFi-FE1";
+		priv->dai_link[0].ops = NULL;
+		priv->dai_link[0].dynamic = 1;
+		priv->dai_link[0].dpcm_playback = 1;
+		priv->dai_link[0].dpcm_capture = 1;
+		priv->dai_link[0].dpcm_merged_chan = 1;
+		priv->dai_link[0].dpcm_merged_rate = 1;
+		priv->dai_link[0].dpcm_merged_format = 1;
+
+		priv->dai_link[1].name = "HiFi-FE2";
+		priv->dai_link[1].stream_name = "HiFi-FE2";
+		priv->dai_link[1].ops = NULL;
+		priv->dai_link[1].dynamic = 1;
+		priv->dai_link[1].dpcm_playback = 1;
+		priv->dai_link[1].dpcm_capture = 1;
+		priv->dai_link[1].dpcm_merged_chan = 1;
+		priv->dai_link[1].dpcm_merged_rate = 1;
+		priv->dai_link[1].dpcm_merged_format = 1;
+
+		priv->dai_link[2].name = "HiFi-BE";
+		priv->dai_link[2].stream_name = "HiFi-BE";
+		priv->dai_link[2].no_pcm = 1;
+		priv->dai_link[2].dpcm_playback = 1;
+		priv->dai_link[2].dpcm_capture = 1;
+		priv->dai_link[2].be_hw_params_fixup = be_hw_params_fixup_esai;
+
+		priv->dai_link[0].cpus->dai_name = dev_name(&client_pdev[0]->dev);
+		priv->dai_link[0].cpus->of_node = args[0].np;
+		priv->dai_link[0].platforms->of_node = args[0].np;
+		priv->dai_link[0].codecs->name = "snd-soc-dummy";
+		priv->dai_link[0].codecs->dai_name = "snd-soc-dummy-dai";
+		priv->dai_link[0].codecs->of_node = NULL;
+		priv->dai_link[1].cpus->dai_name = dev_name(&client_pdev[1]->dev);
+		priv->dai_link[1].cpus->of_node = args[1].np;
+		priv->dai_link[1].platforms->of_node = args[1].np;
+		priv->dai_link[2].cpus->dai_name = dev_name(&cpu_pdev->dev);
+		priv->dai_link[2].codecs->of_node = codec_np;
+
+		priv->card.num_links = 3;
+		priv->card.dapm_routes = audio_map_esai;
+		priv->card.num_dapm_routes = ARRAY_SIZE(audio_map_esai);
+	}
+
 	/* Finish card registering */
 	platform_set_drvdata(pdev, priv);
 	snd_soc_card_set_drvdata(&priv->card, priv);
 
 	ret = devm_snd_soc_register_card(&pdev->dev, &priv->card);
 	if (ret) {
-		dev_err_probe(&pdev->dev, ret, "snd_soc_register_card failed\n");
+		if (ret != -EPROBE_DEFER)
+			dev_err(&pdev->dev, "snd_soc_register_card failed (%d)\n", ret);
 		goto asrc_fail;
 	}
 
diff --git a/sound/soc/fsl/fsl_asrc.c b/sound/soc/fsl/fsl_asrc.c
index d7d1536a4..b05fdfb7d 100644
--- a/sound/soc/fsl/fsl_asrc.c
+++ b/sound/soc/fsl/fsl_asrc.c
@@ -13,6 +13,8 @@
 #include <linux/of_platform.h>
 #include <linux/platform_data/dma-imx.h>
 #include <linux/pm_runtime.h>
+#include <linux/miscdevice.h>
+#include <linux/sched/signal.h>
 #include <sound/dmaengine_pcm.h>
 #include <sound/pcm_params.h>
 
@@ -579,7 +581,7 @@ static void fsl_asrc_start_pair(struct fsl_asrc_pair *pair)
 {
 	struct fsl_asrc *asrc = pair->asrc;
 	enum asrc_pair_index index = pair->index;
-	int reg, retry = 10, i;
+	int reg, retry = 50, i;
 
 	/* Enable the current pair */
 	regmap_update_bits(asrc->regmap, REG_ASRCTR,
@@ -592,6 +594,9 @@ static void fsl_asrc_start_pair(struct fsl_asrc_pair *pair)
 		reg &= ASRCFG_INIRQi_MASK(index);
 	} while (!reg && --retry);
 
+	if (retry == 0)
+		dev_warn(&asrc->pdev->dev, "initialization is not finished\n");
+
 	/* Make the input fifo to ASRC STALL level */
 	regmap_read(asrc->regmap, REG_ASRCNCR, &reg);
 	for (i = 0; i < pair->channels * 4; i++)
@@ -759,6 +764,8 @@ static int fsl_asrc_dai_trigger(struct snd_pcm_substream *substream, int cmd,
 	case SNDRV_PCM_TRIGGER_RESUME:
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
 		fsl_asrc_start_pair(pair);
+		/* Output enough data to content the DMA burstsize of BE */
+		mdelay(1);
 		break;
 	case SNDRV_PCM_TRIGGER_STOP:
 	case SNDRV_PCM_TRIGGER_SUSPEND:
@@ -960,6 +967,8 @@ static const struct regmap_config fsl_asrc_regmap_config = {
 	.cache_type = REGCACHE_FLAT,
 };
 
+#include "fsl_asrc_m2m.c"
+
 /**
  * fsl_asrc_init - Initialize ASRC registers with a default configuration
  * @asrc: ASRC context
@@ -1141,9 +1150,13 @@ static int fsl_asrc_probe(struct platform_device *pdev)
 	if (of_device_is_compatible(np, "fsl,imx35-asrc")) {
 		asrc_priv->clk_map[IN] = input_clk_map_imx35;
 		asrc_priv->clk_map[OUT] = output_clk_map_imx35;
+		strncpy(asrc_priv->name, "mxc_asrc",
+				sizeof(asrc_priv->name) - 1);
 	} else if (of_device_is_compatible(np, "fsl,imx53-asrc")) {
 		asrc_priv->clk_map[IN] = input_clk_map_imx53;
 		asrc_priv->clk_map[OUT] = output_clk_map_imx53;
+		strncpy(asrc_priv->name, "mxc_asrc",
+				sizeof(asrc_priv->name) - 1);
 	} else if (of_device_is_compatible(np, "fsl,imx8qm-asrc") ||
 		   of_device_is_compatible(np, "fsl,imx8qxp-asrc")) {
 		ret = of_property_read_u32(np, "fsl,asrc-clk-map", &map_idx);
@@ -1163,6 +1176,14 @@ static int fsl_asrc_probe(struct platform_device *pdev)
 			asrc_priv->clk_map[IN] = clk_map_imx8qxp[map_idx];
 			asrc_priv->clk_map[OUT] = clk_map_imx8qxp[map_idx];
 		}
+
+		if (map_idx == 0) {
+			strncpy(asrc_priv->name, "mxc_asrc",
+				sizeof(asrc_priv->name) - 1);
+		} else {
+			strncpy(asrc_priv->name, "mxc_asrc1",
+				sizeof(asrc_priv->name) - 1);
+		}
 	}
 
 	asrc->channel_avail = 10;
@@ -1234,6 +1255,12 @@ static int fsl_asrc_probe(struct platform_device *pdev)
 		goto err_pm_get_sync;
 	}
 
+	ret = fsl_asrc_m2m_init(asrc);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to init m2m device %d\n", ret);
+		return ret;
+	}
+
 	return 0;
 
 err_pm_get_sync:
@@ -1246,6 +1273,8 @@ static int fsl_asrc_probe(struct platform_device *pdev)
 
 static int fsl_asrc_remove(struct platform_device *pdev)
 {
+	fsl_asrc_m2m_remove(pdev);
+
 	pm_runtime_disable(&pdev->dev);
 	if (!pm_runtime_status_suspended(&pdev->dev))
 		fsl_asrc_runtime_suspend(&pdev->dev);
@@ -1259,6 +1288,8 @@ static int fsl_asrc_runtime_resume(struct device *dev)
 	struct fsl_asrc_priv *asrc_priv = asrc->private;
 	int i, ret;
 	u32 asrctr;
+	u32 reg;
+	int retry = 50;
 
 	ret = clk_prepare_enable(asrc->mem_clk);
 	if (ret)
@@ -1295,6 +1326,16 @@ static int fsl_asrc_runtime_resume(struct device *dev)
 	regmap_update_bits(asrc->regmap, REG_ASRCTR,
 			   ASRCTR_ASRCEi_ALL_MASK, asrctr);
 
+	/* Wait for status of initialization */
+	do {
+		udelay(5);
+		regmap_read(asrc->regmap, REG_ASRCFG, &reg);
+		reg = (reg >> ASRCFG_INIRQi_SHIFT(0)) & 0x7;
+	} while (!(reg == ((asrctr & 0xE) >> 1)) && --retry);
+
+	if (retry == 0)
+		dev_warn(dev, "initialization is not finished\n");
+
 	return 0;
 
 disable_asrck_clk:
@@ -1330,10 +1371,36 @@ static int fsl_asrc_runtime_suspend(struct device *dev)
 	return 0;
 }
 
+#ifdef CONFIG_PM_SLEEP
+static int fsl_asrc_suspend(struct device *dev)
+{
+	struct fsl_asrc *asrc = dev_get_drvdata(dev);
+	int ret;
+
+	fsl_asrc_m2m_suspend(asrc);
+
+	ret = pm_runtime_force_suspend(dev);
+
+	return ret;
+}
+
+static int fsl_asrc_resume(struct device *dev)
+{
+	struct fsl_asrc *asrc = dev_get_drvdata(dev);
+	int ret;
+
+	ret = pm_runtime_force_resume(dev);
+
+	fsl_asrc_m2m_resume(asrc);
+
+	return ret;
+}
+#endif /* CONFIG_PM_SLEEP */
+
 static const struct dev_pm_ops fsl_asrc_pm = {
 	SET_RUNTIME_PM_OPS(fsl_asrc_runtime_suspend, fsl_asrc_runtime_resume, NULL)
-	SET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,
-				pm_runtime_force_resume)
+	SET_SYSTEM_SLEEP_PM_OPS(fsl_asrc_suspend,
+				fsl_asrc_resume)
 };
 
 static const struct fsl_asrc_soc_data fsl_asrc_imx35_data = {
diff --git a/sound/soc/fsl/fsl_asrc.h b/sound/soc/fsl/fsl_asrc.h
index 86d2422ad..18a9551cc 100644
--- a/sound/soc/fsl/fsl_asrc.h
+++ b/sound/soc/fsl/fsl_asrc.h
@@ -11,6 +11,7 @@
 #define _FSL_ASRC_H
 
 #include  "fsl_asrc_common.h"
+#include <sound/asound.h>
 
 #define ASRC_DMA_BUFFER_NUM		2
 #define ASRC_INPUTFIFO_THRESHOLD	32
@@ -19,7 +20,8 @@
 #define ASRC_FIFO_THRESHOLD_MAX		63
 #define ASRC_DMA_BUFFER_SIZE		(1024 * 48 * 4)
 #define ASRC_MAX_BUFFER_SIZE		(1024 * 48)
-#define ASRC_OUTPUT_LAST_SAMPLE		8
+#define ASRC_OUTPUT_LAST_SAMPLE_MAX	32
+#define ASRC_OUTPUT_LAST_SAMPLE		4
 
 #define IDEAL_RATIO_RATE		1000000
 
@@ -284,139 +286,13 @@
 
 #define ASRC_PAIR_MAX_NUM	(ASRC_PAIR_C + 1)
 
-enum asrc_inclk {
-	INCLK_NONE = 0x03,
-	INCLK_ESAI_RX = 0x00,
-	INCLK_SSI1_RX = 0x01,
-	INCLK_SSI2_RX = 0x02,
-	INCLK_SSI3_RX = 0x07,
-	INCLK_SPDIF_RX = 0x04,
-	INCLK_MLB_CLK = 0x05,
-	INCLK_PAD = 0x06,
-	INCLK_ESAI_TX = 0x08,
-	INCLK_SSI1_TX = 0x09,
-	INCLK_SSI2_TX = 0x0a,
-	INCLK_SSI3_TX = 0x0b,
-	INCLK_SPDIF_TX = 0x0c,
-	INCLK_ASRCK1_CLK = 0x0f,
-
-	/* clocks for imx8 */
-	INCLK_AUD_PLL_DIV_CLK0 = 0x10,
-	INCLK_AUD_PLL_DIV_CLK1 = 0x11,
-	INCLK_AUD_CLK0         = 0x12,
-	INCLK_AUD_CLK1         = 0x13,
-	INCLK_ESAI0_RX_CLK     = 0x14,
-	INCLK_ESAI0_TX_CLK     = 0x15,
-	INCLK_SPDIF0_RX        = 0x16,
-	INCLK_SPDIF1_RX        = 0x17,
-	INCLK_SAI0_RX_BCLK     = 0x18,
-	INCLK_SAI0_TX_BCLK     = 0x19,
-	INCLK_SAI1_RX_BCLK     = 0x1a,
-	INCLK_SAI1_TX_BCLK     = 0x1b,
-	INCLK_SAI2_RX_BCLK     = 0x1c,
-	INCLK_SAI3_RX_BCLK     = 0x1d,
-	INCLK_ASRC0_MUX_CLK    = 0x1e,
-
-	INCLK_ESAI1_RX_CLK     = 0x20,
-	INCLK_ESAI1_TX_CLK     = 0x21,
-	INCLK_SAI6_TX_BCLK     = 0x22,
-	INCLK_HDMI_RX_SAI0_RX_BCLK     = 0x24,
-	INCLK_HDMI_TX_SAI0_TX_BCLK     = 0x25,
-};
-
-enum asrc_outclk {
-	OUTCLK_NONE = 0x03,
-	OUTCLK_ESAI_TX = 0x00,
-	OUTCLK_SSI1_TX = 0x01,
-	OUTCLK_SSI2_TX = 0x02,
-	OUTCLK_SSI3_TX = 0x07,
-	OUTCLK_SPDIF_TX = 0x04,
-	OUTCLK_MLB_CLK = 0x05,
-	OUTCLK_PAD = 0x06,
-	OUTCLK_ESAI_RX = 0x08,
-	OUTCLK_SSI1_RX = 0x09,
-	OUTCLK_SSI2_RX = 0x0a,
-	OUTCLK_SSI3_RX = 0x0b,
-	OUTCLK_SPDIF_RX = 0x0c,
-	OUTCLK_ASRCK1_CLK = 0x0f,
-
-	/* clocks for imx8 */
-	OUTCLK_AUD_PLL_DIV_CLK0 = 0x10,
-	OUTCLK_AUD_PLL_DIV_CLK1 = 0x11,
-	OUTCLK_AUD_CLK0         = 0x12,
-	OUTCLK_AUD_CLK1         = 0x13,
-	OUTCLK_ESAI0_RX_CLK     = 0x14,
-	OUTCLK_ESAI0_TX_CLK     = 0x15,
-	OUTCLK_SPDIF0_RX        = 0x16,
-	OUTCLK_SPDIF1_RX        = 0x17,
-	OUTCLK_SAI0_RX_BCLK     = 0x18,
-	OUTCLK_SAI0_TX_BCLK     = 0x19,
-	OUTCLK_SAI1_RX_BCLK     = 0x1a,
-	OUTCLK_SAI1_TX_BCLK     = 0x1b,
-	OUTCLK_SAI2_RX_BCLK     = 0x1c,
-	OUTCLK_SAI3_RX_BCLK     = 0x1d,
-	OUTCLK_ASRCO_MUX_CLK    = 0x1e,
-
-	OUTCLK_ESAI1_RX_CLK     = 0x20,
-	OUTCLK_ESAI1_TX_CLK     = 0x21,
-	OUTCLK_SAI6_TX_BCLK     = 0x22,
-	OUTCLK_HDMI_RX_SAI0_RX_BCLK     = 0x24,
-	OUTCLK_HDMI_TX_SAI0_TX_BCLK     = 0x25,
-};
-
 #define ASRC_CLK_MAX_NUM	16
 #define ASRC_CLK_MAP_LEN	0x30
 
 enum asrc_word_width {
 	ASRC_WIDTH_24_BIT = 0,
 	ASRC_WIDTH_16_BIT = 1,
-	ASRC_WIDTH_8_BIT = 2,
-};
-
-struct asrc_config {
-	enum asrc_pair_index pair;
-	unsigned int channel_num;
-	unsigned int buffer_num;
-	unsigned int dma_buffer_size;
-	unsigned int input_sample_rate;
-	unsigned int output_sample_rate;
-	snd_pcm_format_t input_format;
-	snd_pcm_format_t output_format;
-	enum asrc_inclk inclk;
-	enum asrc_outclk outclk;
-};
-
-struct asrc_req {
-	unsigned int chn_num;
-	enum asrc_pair_index index;
-};
-
-struct asrc_querybuf {
-	unsigned int buffer_index;
-	unsigned int input_length;
-	unsigned int output_length;
-	unsigned long input_offset;
-	unsigned long output_offset;
-};
-
-struct asrc_convert_buffer {
-	void *input_buffer_vaddr;
-	void *output_buffer_vaddr;
-	unsigned int input_buffer_length;
-	unsigned int output_buffer_length;
-};
-
-struct asrc_status_flags {
-	enum asrc_pair_index index;
-	unsigned int overload_error;
-};
-
-enum asrc_error_status {
-	ASRC_TASK_Q_OVERLOAD		= 0x01,
-	ASRC_OUTPUT_TASK_OVERLOAD	= 0x02,
-	ASRC_INPUT_TASK_OVERLOAD	= 0x04,
-	ASRC_OUTPUT_BUFFER_OVERFLOW	= 0x08,
-	ASRC_INPUT_BUFFER_UNDERRUN	= 0x10,
+	ASRC_WIDTH_8_BIT  = 2,
 };
 
 struct dma_block {
@@ -459,6 +335,7 @@ struct fsl_asrc_priv {
 	unsigned char *clk_map[2];
 
 	u32 regcache_cfg;
+	char name[20];
 };
 
 #endif /* _FSL_ASRC_H */
diff --git a/sound/soc/fsl/fsl_asrc_common.h b/sound/soc/fsl/fsl_asrc_common.h
index 7e1c13ca3..da2e1aec0 100644
--- a/sound/soc/fsl/fsl_asrc_common.h
+++ b/sound/soc/fsl/fsl_asrc_common.h
@@ -7,18 +7,12 @@
 #ifndef _FSL_ASRC_COMMON_H
 #define _FSL_ASRC_COMMON_H
 
+#include <linux/miscdevice.h>
+#include <uapi/linux/mxc_asrc.h>
 /* directions */
 #define IN	0
 #define OUT	1
 
-enum asrc_pair_index {
-	ASRC_INVALID_PAIR = -1,
-	ASRC_PAIR_A = 0,
-	ASRC_PAIR_B = 1,
-	ASRC_PAIR_C = 2,
-	ASRC_PAIR_D = 3,
-};
-
 #define PAIR_CTX_NUM  0x4
 
 /**
@@ -49,6 +43,7 @@ struct fsl_asrc_pair {
 	bool req_dma_chan;
 
 	void *private;
+	void *private_m2m;
 };
 
 /**
@@ -86,6 +81,7 @@ struct fsl_asrc {
 	struct clk *spba_clk;
 	spinlock_t lock;      /* spin lock for resource protection */
 
+	struct miscdevice asrc_miscdev;
 	struct fsl_asrc_pair *pair[PAIR_CTX_NUM];
 	unsigned int channel_avail;
 
diff --git a/sound/soc/fsl/fsl_asrc_dma.c b/sound/soc/fsl/fsl_asrc_dma.c
index cd9b36ec0..779ee29fd 100644
--- a/sound/soc/fsl/fsl_asrc_dma.c
+++ b/sound/soc/fsl/fsl_asrc_dma.c
@@ -139,6 +139,7 @@ static int fsl_asrc_dma_hw_params(struct snd_soc_component *component,
 	struct snd_soc_component *component_be = NULL;
 	struct fsl_asrc *asrc = pair->asrc;
 	struct dma_slave_config config_fe, config_be;
+	struct sdma_audio_config audio_config;
 	enum asrc_pair_index index = pair->index;
 	struct device *dev = component->dev;
 	struct device_node *of_dma_node;
@@ -149,6 +150,7 @@ static int fsl_asrc_dma_hw_params(struct snd_soc_component *component,
 	u8 dir = tx ? OUT : IN;
 	dma_cap_mask_t mask;
 	int ret, width;
+	enum sdma_peripheral_type be_peripheral_type = IMX_DMATYPE_SSI;
 
 	/* Fetch the Back-End dma_data from DPCM */
 	for_each_dpcm_be(rtd, stream, dpcm) {
@@ -221,6 +223,7 @@ static int fsl_asrc_dma_hw_params(struct snd_soc_component *component,
 		/* Get DMA request of Back-End */
 		tmp_data = tmp_chan->private;
 		pair->dma_data.dma_request = tmp_data->dma_request;
+		be_peripheral_type = tmp_data->peripheral_type;
 		if (!be_chan)
 			dma_release_channel(tmp_chan);
 
@@ -262,12 +265,24 @@ static int fsl_asrc_dma_hw_params(struct snd_soc_component *component,
 	else
 		buswidth = DMA_SLAVE_BUSWIDTH_8_BYTES;
 
+	memset(&config_be, 0, sizeof(config_be));
 	config_be.direction = DMA_DEV_TO_DEV;
 	config_be.src_addr_width = buswidth;
 	config_be.src_maxburst = dma_params_be->maxburst;
 	config_be.dst_addr_width = buswidth;
 	config_be.dst_maxburst = dma_params_be->maxburst;
 
+	memset(&audio_config, 0, sizeof(audio_config));
+	config_be.peripheral_config = &audio_config;
+	config_be.peripheral_size  = sizeof(audio_config);
+
+	if (tx && (be_peripheral_type == IMX_DMATYPE_SSI_DUAL ||
+		   be_peripheral_type == IMX_DMATYPE_SPDIF))
+		audio_config.dst_fifo_num = 2;
+	if (!tx && (be_peripheral_type == IMX_DMATYPE_SSI_DUAL ||
+		    be_peripheral_type == IMX_DMATYPE_SPDIF))
+		audio_config.src_fifo_num = 2;
+
 	if (tx) {
 		config_be.src_addr = asrc->paddr + asrc->get_fifo_addr(OUT, index);
 		config_be.dst_addr = dma_params_be->addr;
diff --git a/sound/soc/fsl/fsl_asrc_m2m.c b/sound/soc/fsl/fsl_asrc_m2m.c
new file mode 100644
index 000000000..8c842ac1a
--- /dev/null
+++ b/sound/soc/fsl/fsl_asrc_m2m.c
@@ -0,0 +1,1062 @@
+/*
+ * Freescale ASRC Memory to Memory (M2M) driver
+ *
+ * Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#define FSL_ASRC_INPUTFIFO_WML	0x4
+#define FSL_ASRC_OUTPUTFIFO_WML	0x2
+
+#define DIR_STR(dir) dir == IN ? "in" : "out"
+
+struct fsl_asrc_m2m {
+	struct fsl_asrc_pair *pair;
+	struct completion complete[2];
+	struct dma_block dma_block[2];
+	unsigned int pair_hold;
+	unsigned int asrc_active;
+	unsigned int sg_nodes[2];
+	struct scatterlist sg[2][4];
+
+	snd_pcm_format_t word_format[2];
+	unsigned int rate[2];
+	unsigned int last_period_size;
+	u32 watermark[2];
+	spinlock_t lock;
+};
+
+static void fsl_asrc_get_status(struct fsl_asrc_pair *pair,
+				struct asrc_status_flags *flags)
+{
+	struct fsl_asrc *asrc = pair->asrc;
+	unsigned long lock_flags;
+
+	spin_lock_irqsave(&asrc->lock, lock_flags);
+
+	flags->overload_error = pair->error;
+
+	spin_unlock_irqrestore(&asrc->lock, lock_flags);
+}
+
+#define ASRC_xPUT_DMA_CALLBACK(dir) \
+	((dir == IN) ? fsl_asrc_input_dma_callback : fsl_asrc_output_dma_callback)
+
+static void fsl_asrc_input_dma_callback(void *data)
+{
+	struct fsl_asrc_pair *pair = (struct fsl_asrc_pair *)data;
+	struct fsl_asrc_m2m *m2m = pair->private_m2m;
+
+	complete(&m2m->complete[IN]);
+}
+
+static void fsl_asrc_output_dma_callback(void *data)
+{
+	struct fsl_asrc_pair *pair = (struct fsl_asrc_pair *)data;
+	struct fsl_asrc_m2m *m2m = pair->private_m2m;
+
+	complete(&m2m->complete[OUT]);
+}
+
+static unsigned int fsl_asrc_get_output_FIFO_size(struct fsl_asrc_pair *pair)
+{
+	struct fsl_asrc *asrc = pair->asrc;
+	enum asrc_pair_index index = pair->index;
+	u32 val;
+
+	regmap_read(asrc->regmap, REG_ASRFST(index), &val);
+
+	val &= ASRFSTi_OUTPUT_FIFO_MASK;
+
+	return val >> ASRFSTi_OUTPUT_FIFO_SHIFT;
+}
+
+static void fsl_asrc_read_last_FIFO(struct fsl_asrc_pair *pair)
+{
+	struct fsl_asrc_m2m *m2m = pair->private_m2m;
+	struct fsl_asrc *asrc = pair->asrc;
+	enum asrc_pair_index index = pair->index;
+	struct dma_block *output = &m2m->dma_block[OUT];
+	u32 i, reg, size, t_size = 0, width;
+	u32 *reg32 = NULL;
+	u16 *reg16 = NULL;
+	u8  *reg24 = NULL;
+
+	width = snd_pcm_format_physical_width(m2m->word_format[OUT]);
+
+	if (width == 32)
+		reg32 = output->dma_vaddr + output->length;
+	else if (width == 16)
+		reg16 = output->dma_vaddr + output->length;
+	else
+		reg24 = output->dma_vaddr + output->length;
+
+retry:
+	size = fsl_asrc_get_output_FIFO_size(pair);
+
+	for (i = 0; i < size * pair->channels; i++) {
+		regmap_read(asrc->regmap, REG_ASRDO(index), &reg);
+		if (reg32) {
+			*(reg32) = reg;
+			reg32++;
+		} else if (reg16) {
+			*(reg16) = (u16)reg;
+			reg16++;
+		} else {
+			*reg24++ = (u8)reg;
+			*reg24++ = (u8)(reg >> 8);
+			*reg24++ = (u8)(reg >> 16);
+		}
+	}
+	t_size += size;
+
+	if (size)
+		goto retry;
+
+	if (t_size > m2m->last_period_size)
+		t_size = m2m->last_period_size;
+
+	if (reg32)
+		output->length += t_size * pair->channels * 4;
+	else if (reg16)
+		output->length += t_size * pair->channels * 2;
+	else
+		output->length += t_size * pair->channels * 3;
+}
+
+static int fsl_allocate_dma_buf(struct fsl_asrc_pair *pair)
+{
+	struct fsl_asrc_m2m *m2m = pair->private_m2m;
+	struct fsl_asrc *asrc = pair->asrc;
+	struct dma_block *input = &m2m->dma_block[IN];
+	struct dma_block *output = &m2m->dma_block[OUT];
+	enum asrc_pair_index index = pair->index;
+
+	input->dma_vaddr = kzalloc(input->length, GFP_KERNEL);
+	if (!input->dma_vaddr) {
+		pair_err("failed to allocate input DMA buffer\n");
+		return -ENOMEM;
+	}
+
+	output->dma_vaddr = kzalloc(output->length, GFP_KERNEL);
+	if (!output->dma_vaddr) {
+		pair_err("failed to allocate output DMA buffer\n");
+		goto exit;
+	}
+
+	return 0;
+
+exit:
+	kfree(input->dma_vaddr);
+	input->dma_vaddr = NULL;
+	return -ENOMEM;
+}
+
+static int fsl_asrc_dmaconfig(struct fsl_asrc_pair *pair, struct dma_chan *chan,
+			      u32 dma_addr, void *buf_addr, u32 buf_len,
+			      bool dir, snd_pcm_format_t word_format)
+{
+	struct dma_async_tx_descriptor *desc = pair->desc[dir];
+	struct fsl_asrc *asrc = pair->asrc;
+	struct fsl_asrc_priv *asrc_priv = asrc->private;
+	struct fsl_asrc_m2m *m2m = pair->private_m2m;
+	unsigned int sg_nent = m2m->sg_nodes[dir];
+	enum asrc_pair_index index = pair->index;
+	struct scatterlist *sg = m2m->sg[dir];
+	struct dma_slave_config slave_config;
+	enum dma_slave_buswidth buswidth;
+	enum dma_data_direction dma_dir;
+	int ret, i;
+
+	switch (snd_pcm_format_physical_width(word_format)) {
+	case 8:
+		buswidth = DMA_SLAVE_BUSWIDTH_1_BYTE;
+		break;
+	case 16:
+		buswidth = DMA_SLAVE_BUSWIDTH_2_BYTES;
+		break;
+	case 24:
+		buswidth = DMA_SLAVE_BUSWIDTH_3_BYTES;
+		break;
+	case 32:
+		buswidth = DMA_SLAVE_BUSWIDTH_4_BYTES;
+		break;
+	default:
+		pair_err("invalid word width\n");
+		return -EINVAL;
+	}
+
+	memset(&slave_config, 0, sizeof(slave_config));
+	if (dir == IN) {
+		slave_config.direction = DMA_MEM_TO_DEV;
+		dma_dir = DMA_TO_DEVICE;
+		slave_config.dst_addr = dma_addr;
+		slave_config.dst_addr_width = buswidth;
+		if (!asrc_priv->soc->use_edma)
+			slave_config.dst_maxburst =
+				m2m->watermark[IN] * pair->channels;
+		else
+			slave_config.dst_maxburst = 1;
+	} else {
+		slave_config.direction = DMA_DEV_TO_MEM;
+		dma_dir = DMA_FROM_DEVICE;
+		slave_config.src_addr = dma_addr;
+		slave_config.src_addr_width = buswidth;
+		if (!asrc_priv->soc->use_edma)
+			slave_config.src_maxburst =
+				m2m->watermark[OUT] * pair->channels;
+		else
+			slave_config.src_maxburst = 1;
+	}
+
+	ret = dmaengine_slave_config(chan, &slave_config);
+	if (ret) {
+		pair_err("failed to config dmaengine for %sput task: %d\n",
+				DIR_STR(dir), ret);
+		return -EINVAL;
+	}
+
+	sg_init_table(sg, sg_nent);
+	switch (sg_nent) {
+	case 1:
+		sg_init_one(sg, buf_addr, buf_len);
+		break;
+	case 2:
+	case 3:
+	case 4:
+		for (i = 0; i < (sg_nent - 1); i++)
+			sg_set_buf(&sg[i], buf_addr + i * ASRC_MAX_BUFFER_SIZE,
+					ASRC_MAX_BUFFER_SIZE);
+
+		sg_set_buf(&sg[i], buf_addr + i * ASRC_MAX_BUFFER_SIZE,
+				buf_len - ASRC_MAX_BUFFER_SIZE * i);
+		break;
+	default:
+		pair_err("invalid input DMA nodes number: %d\n", sg_nent);
+		return -EINVAL;
+	}
+
+	ret = dma_map_sg(&asrc->pdev->dev, sg, sg_nent, dma_dir);
+	if (ret != sg_nent) {
+		pair_err("failed to map DMA sg for %sput task\n", DIR_STR(dir));
+		return -EINVAL;
+	}
+
+	desc = dmaengine_prep_slave_sg(chan, sg, sg_nent,
+			slave_config.direction, DMA_PREP_INTERRUPT);
+	if (!desc) {
+		pair_err("failed to prepare dmaengine for %sput task\n",
+				DIR_STR(dir));
+		return -EINVAL;
+	}
+
+	pair->desc[dir] = desc;
+	pair->desc[dir]->callback = ASRC_xPUT_DMA_CALLBACK(dir);
+
+	desc->callback = ASRC_xPUT_DMA_CALLBACK(dir);
+	desc->callback_param = pair;
+
+	return 0;
+}
+
+static int fsl_asrc_prepare_io_buffer(struct fsl_asrc_pair *pair,
+				      struct asrc_convert_buffer *pbuf, bool dir)
+{
+	struct fsl_asrc_m2m *m2m = pair->private_m2m;
+	struct fsl_asrc *asrc = pair->asrc;
+	struct fsl_asrc_priv *asrc_priv = asrc->private;
+	unsigned int *dma_len = &m2m->dma_block[dir].length;
+	void *dma_vaddr = m2m->dma_block[dir].dma_vaddr;
+	struct dma_chan *dma_chan = pair->dma_chan[dir];
+	unsigned int buf_len, wm = m2m->watermark[dir];
+	unsigned int *sg_nodes = &m2m->sg_nodes[dir];
+	unsigned int last_period_size = m2m->last_period_size;
+	enum asrc_pair_index index = pair->index;
+	u32 word_size, fifo_addr;
+	void __user *buf_vaddr;
+
+	/* Clean the DMA buffer */
+	memset(dma_vaddr, 0, ASRC_DMA_BUFFER_SIZE);
+
+	if (dir == IN) {
+		buf_vaddr = (void __user *)pbuf->input_buffer_vaddr;
+		buf_len = pbuf->input_buffer_length;
+	} else {
+		buf_vaddr = (void __user *)pbuf->output_buffer_vaddr;
+		buf_len = pbuf->output_buffer_length;
+	}
+
+	word_size = snd_pcm_format_physical_width(m2m->word_format[dir]) / 8;
+
+	if (buf_len < word_size * pair->channels * wm ||
+	    buf_len > ASRC_DMA_BUFFER_SIZE ||
+	    (dir == OUT && buf_len < word_size * pair->channels * last_period_size)) {
+		pair_err("%sput buffer size is error: [%d]\n",
+				DIR_STR(dir), buf_len);
+		return -EINVAL;
+	}
+
+	/* Copy origin data into input buffer */
+	if (dir == IN && copy_from_user(dma_vaddr, buf_vaddr, buf_len))
+		return -EFAULT;
+
+	*dma_len = buf_len;
+	if (dir == OUT) {
+		*dma_len -= last_period_size * word_size * pair->channels;
+		*dma_len = *dma_len / (word_size * pair->channels) *
+				(word_size * pair->channels);
+		if (asrc_priv->soc->use_edma)
+			*dma_len = *dma_len / (word_size * pair->channels * m2m->watermark[OUT])
+					* (word_size * pair->channels * m2m->watermark[OUT]);
+	}
+
+	*sg_nodes = *dma_len / ASRC_MAX_BUFFER_SIZE;
+	if (*dma_len % ASRC_MAX_BUFFER_SIZE)
+		*sg_nodes += 1;
+
+	fifo_addr = asrc->paddr + REG_ASRDx(dir, index);
+
+	return fsl_asrc_dmaconfig(pair, dma_chan, fifo_addr, dma_vaddr,
+				  *dma_len, dir, m2m->word_format[dir]);
+}
+
+static int fsl_asrc_prepare_buffer(struct fsl_asrc_pair *pair,
+				   struct asrc_convert_buffer *pbuf)
+{
+	struct fsl_asrc *asrc = pair->asrc;
+	enum asrc_pair_index index = pair->index;
+	int ret;
+
+	ret = fsl_asrc_prepare_io_buffer(pair, pbuf, IN);
+	if (ret) {
+		pair_err("failed to prepare input buffer: %d\n", ret);
+		return ret;
+	}
+
+	ret = fsl_asrc_prepare_io_buffer(pair, pbuf, OUT);
+	if (ret) {
+		pair_err("failed to prepare output buffer: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+int fsl_asrc_process_buffer_pre(struct completion *complete,
+				enum asrc_pair_index index, bool dir)
+{
+	if (!wait_for_completion_interruptible_timeout(complete, 10 * HZ)) {
+		pr_err("%sput DMA task timeout\n", DIR_STR(dir));
+		return -ETIME;
+	} else if (signal_pending(current)) {
+		pr_err("%sput task forcibly aborted\n", DIR_STR(dir));
+		return -ERESTARTSYS;
+	}
+
+	return 0;
+}
+
+#define mxc_asrc_dma_umap(dev, m2m) \
+	do { \
+		dma_unmap_sg(dev, m2m->sg[IN], m2m->sg_nodes[IN], \
+			     DMA_TO_DEVICE); \
+		dma_unmap_sg(dev, m2m->sg[OUT], m2m->sg_nodes[OUT], \
+			     DMA_FROM_DEVICE); \
+	} while (0)
+
+int fsl_asrc_process_buffer(struct fsl_asrc_pair *pair,
+			    struct asrc_convert_buffer *pbuf)
+{
+	struct fsl_asrc *asrc = pair->asrc;
+	struct fsl_asrc_m2m *m2m = pair->private_m2m;
+	enum asrc_pair_index index = pair->index;
+	unsigned long lock_flags;
+	int ret;
+
+	/* Check input task first */
+	ret = fsl_asrc_process_buffer_pre(&m2m->complete[IN], index, IN);
+	if (ret) {
+		mxc_asrc_dma_umap(&asrc->pdev->dev, m2m);
+		return ret;
+	}
+
+	/* ...then output task*/
+	ret = fsl_asrc_process_buffer_pre(&m2m->complete[OUT], index, OUT);
+	if (ret) {
+		mxc_asrc_dma_umap(&asrc->pdev->dev, m2m);
+		return ret;
+	}
+
+	mxc_asrc_dma_umap(&asrc->pdev->dev, m2m);
+
+	/* Fetch the remaining data */
+	spin_lock_irqsave(&m2m->lock, lock_flags);
+	if (!m2m->pair_hold) {
+		spin_unlock_irqrestore(&m2m->lock, lock_flags);
+		return -EFAULT;
+	}
+	spin_unlock_irqrestore(&m2m->lock, lock_flags);
+
+	fsl_asrc_read_last_FIFO(pair);
+
+	/* Update final lengths after getting last FIFO */
+	pbuf->input_buffer_length = m2m->dma_block[IN].length;
+	pbuf->output_buffer_length = m2m->dma_block[OUT].length;
+
+	if (copy_to_user((void __user *)pbuf->output_buffer_vaddr,
+			 m2m->dma_block[OUT].dma_vaddr,
+			 m2m->dma_block[OUT].length))
+		return -EFAULT;
+
+	return 0;
+}
+
+#ifdef ASRC_POLLING_WITHOUT_DMA
+/* THIS FUNCTION ONLY EXISTS FOR DEBUGGING AND ONLY SUPPORTS TWO CHANNELS */
+static void fsl_asrc_polling_debug(struct fsl_asrc_pair *pair)
+{
+	struct fsl_asrc_m2m *m2m = pair->private_m2m;
+	enum asrc_pair_index index = pair->index;
+	u32 *in24 = m2m->dma_block[IN].dma_vaddr;
+	u32 dma_len = m2m->dma_block[IN].length / (pair->channels * 4);
+	u32 *reg24 = m2m->dma_block[OUT].dma_vaddr;
+	u32 size, i, j, t_size, reg;
+
+	t_size = 0;
+
+	for (i = 0; i < dma_len; ) {
+		for (j = 0; j < 2; j++) {
+			regmap_write(asrc->regmap, REG_ASRDx(index), *in24);
+			in24++;
+			regmap_write(asrc->regmap, REG_ASRDx(index), *in24);
+			in24++;
+			i++;
+		}
+		udelay(50);
+		udelay(50 * m2m->rate[OUT] / m2m->rate[IN]);
+
+		size = fsl_asrc_get_output_FIFO_size(index);
+		for (j = 0; j < size; j++) {
+			regmap_read(asrc->regmap, REG_ASRDO(index), &reg);
+			*(reg24) = reg;
+			reg24++;
+			regmap_read(asrc->regmap, REG_ASRDO(index), &reg);
+			*(reg24) = reg;
+			reg24++;
+		}
+		t_size += size;
+	}
+
+	mdelay(1);
+	size = fsl_asrc_get_output_FIFO_size(index);
+	for (j = 0; j < size; j++) {
+		regmap_read(asrc->regmap, REG_ASRDO(index), &reg);
+		*(reg24) = reg;
+		reg24++;
+		regmap_read(asrc->regmap, REG_ASRDO(index), &reg);
+		*(reg24) = reg;
+		reg24++;
+	}
+	t_size += size;
+
+	m2m->dma_block[OUT].length = t_size * pair->channels * 4;
+
+	complete(&m2m->complete[OUT]);
+	complete(&m2m->complete[IN]);
+}
+#else
+static void fsl_asrc_submit_dma(struct fsl_asrc_pair *pair)
+{
+	struct fsl_asrc *asrc = pair->asrc;
+	struct fsl_asrc_m2m *m2m = pair->private_m2m;
+	enum asrc_pair_index index = pair->index;
+	u32 size = fsl_asrc_get_output_FIFO_size(pair);
+	int i;
+
+	/* Read all data in OUTPUT FIFO */
+	while (size) {
+		u32 val;
+		for (i = 0; i < size * pair->channels; i++)
+			regmap_read(asrc->regmap, REG_ASRDO(index), &val);
+		/* Fetch the data every 100us */
+		udelay(100);
+
+		size = fsl_asrc_get_output_FIFO_size(pair);
+	}
+
+	/* Submit DMA request */
+	dmaengine_submit(pair->desc[IN]);
+	dma_async_issue_pending(pair->desc[IN]->chan);
+
+	dmaengine_submit(pair->desc[OUT]);
+	dma_async_issue_pending(pair->desc[OUT]->chan);
+
+	/*
+	 * Clear DMA request during the stall state of ASRC:
+	 * During STALL state, the remaining in input fifo would never be
+	 * smaller than the input threshold while the output fifo would not
+	 * be bigger than output one. Thus the DMA request would be cleared.
+	 */
+	fsl_asrc_set_watermarks(pair, ASRC_FIFO_THRESHOLD_MIN,
+				ASRC_FIFO_THRESHOLD_MAX);
+
+	/* Update the real input threshold to raise DMA request */
+	fsl_asrc_set_watermarks(pair, m2m->watermark[IN], m2m->watermark[OUT]);
+}
+#endif /* ASRC_POLLING_WITHOUT_DMA */
+
+static long fsl_asrc_ioctl_req_pair(struct fsl_asrc_pair *pair,
+				    void __user *user)
+{
+	struct fsl_asrc *asrc = pair->asrc;
+	struct fsl_asrc_priv *asrc_priv = asrc->private;
+	struct fsl_asrc_m2m *m2m = pair->private_m2m;
+	struct device *dev = &asrc->pdev->dev;
+	struct asrc_req req;
+	unsigned long lock_flags;
+	long ret;
+
+	ret = copy_from_user(&req, user, sizeof(req));
+	if (ret) {
+		dev_err(dev, "failed to get req from user space: %ld\n", ret);
+		return ret;
+	}
+
+	ret = fsl_asrc_request_pair(req.chn_num, pair);
+	if (ret) {
+		dev_err(dev, "failed to request pair: %ld\n", ret);
+		return ret;
+	}
+
+	spin_lock_irqsave(&m2m->lock, lock_flags);
+	m2m->pair_hold = 1;
+	spin_unlock_irqrestore(&m2m->lock, lock_flags);
+	pair->channels = req.chn_num;
+
+	req.index = pair->index;
+	req.supported_in_format = FSL_ASRC_FORMATS | SNDRV_PCM_FMTBIT_S8;
+	req.supported_out_format = FSL_ASRC_FORMATS;
+	if (asrc_priv->soc->use_edma) {
+		req.supported_in_format &= ~SNDRV_PCM_FMTBIT_S24_3LE;
+		req.supported_out_format &= ~SNDRV_PCM_FMTBIT_S24_3LE;
+	}
+
+	ret = copy_to_user(user, &req, sizeof(req));
+	if (ret) {
+		dev_err(dev, "failed to send req to user space: %ld\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static long fsl_asrc_ioctl_config_pair(struct fsl_asrc_pair *pair,
+				       void __user *user)
+{
+	struct fsl_asrc *asrc = pair->asrc;
+	struct fsl_asrc_m2m *m2m = pair->private_m2m;
+	struct fsl_asrc_pair_priv *pair_priv = pair->private;
+	struct device *dev = &asrc->pdev->dev;
+	struct asrc_config config;
+	enum asrc_pair_index index;
+	long ret;
+
+	ret = copy_from_user(&config, user, sizeof(config));
+	if (ret) {
+		dev_err(dev, "failed to get config from user space: %ld\n", ret);
+		return ret;
+	}
+
+	index = config.pair;
+
+	pair_priv->config = &config;
+	ret = fsl_asrc_config_pair(pair, true);
+	if (ret) {
+		pair_err("failed to config pair: %ld\n", ret);
+		return ret;
+	}
+
+	m2m->watermark[IN] = FSL_ASRC_INPUTFIFO_WML;
+	m2m->watermark[OUT] = FSL_ASRC_OUTPUTFIFO_WML;
+
+	fsl_asrc_set_watermarks(pair, m2m->watermark[IN], m2m->watermark[OUT]);
+
+	m2m->dma_block[IN].length = ASRC_DMA_BUFFER_SIZE;
+	m2m->dma_block[OUT].length = ASRC_DMA_BUFFER_SIZE;
+
+	m2m->word_format[IN] = config.input_format;
+	m2m->word_format[OUT] = config.output_format;
+
+	m2m->rate[IN] = config.input_sample_rate;
+	m2m->rate[OUT] = config.output_sample_rate;
+
+	m2m->last_period_size = ASRC_OUTPUT_LAST_SAMPLE;
+
+	ret = fsl_allocate_dma_buf(pair);
+	if (ret) {
+		pair_err("failed to allocate DMA buffer: %ld\n", ret);
+		return ret;
+	}
+
+	/* Request DMA channel for both input and output */
+	pair->dma_chan[IN] = fsl_asrc_get_dma_channel(pair, IN);
+	if (pair->dma_chan[IN] == NULL) {
+		pair_err("failed to request input task DMA channel\n");
+		return  -EBUSY;
+	}
+
+	pair->dma_chan[OUT] = fsl_asrc_get_dma_channel(pair, OUT);
+	if (pair->dma_chan[OUT] == NULL) {
+		pair_err("failed to request output task DMA channel\n");
+		return  -EBUSY;
+	}
+
+	ret = copy_to_user(user, &config, sizeof(config));
+	if (ret) {
+		pair_err("failed to send config to user space: %ld\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static long fsl_asrc_ioctl_release_pair(struct fsl_asrc_pair *pair,
+					void __user *user)
+{
+	struct fsl_asrc_m2m *m2m = pair->private_m2m;
+	struct fsl_asrc *asrc = pair->asrc;
+	enum asrc_pair_index index;
+	unsigned long lock_flags;
+	long ret;
+
+	ret = copy_from_user(&index, user, sizeof(index));
+	if (ret) {
+		pair_err("failed to get index from user space: %ld\n", ret);
+		return ret;
+	}
+
+	/* index might be not valid due to some application failure. */
+	if (index < 0)
+		return -EINVAL;
+
+	m2m->asrc_active = 0;
+
+	spin_lock_irqsave(&m2m->lock, lock_flags);
+	m2m->pair_hold = 0;
+	spin_unlock_irqrestore(&m2m->lock, lock_flags);
+
+	if (pair->dma_chan[IN])
+		dma_release_channel(pair->dma_chan[IN]);
+	if (pair->dma_chan[OUT])
+		dma_release_channel(pair->dma_chan[OUT]);
+	kfree(m2m->dma_block[IN].dma_vaddr);
+	kfree(m2m->dma_block[OUT].dma_vaddr);
+	fsl_asrc_release_pair(pair);
+
+	return 0;
+}
+
+static long fsl_asrc_calc_last_period_size(struct fsl_asrc_pair *pair,
+					struct asrc_convert_buffer *pbuf)
+{
+	struct fsl_asrc_m2m *m2m = pair->private_m2m;
+	struct fsl_asrc *asrc = pair->asrc;
+	struct fsl_asrc_priv *asrc_priv = asrc->private;
+	unsigned int out_length;
+	unsigned int in_width, out_width;
+	unsigned int channels = pair->channels;
+	unsigned int in_samples, out_samples;
+	unsigned int last_period_size;
+	unsigned int remain;
+
+	in_width = snd_pcm_format_physical_width(m2m->word_format[IN]) / 8;
+	out_width = snd_pcm_format_physical_width(m2m->word_format[OUT]) / 8;
+
+	in_samples = pbuf->input_buffer_length / (in_width * channels);
+
+	out_samples = (m2m->rate[OUT] * in_samples / m2m->rate[IN]);
+
+	out_length = out_samples * out_width * channels;
+
+	last_period_size = pbuf->output_buffer_length / (out_width * channels)
+					- out_samples;
+
+	m2m->last_period_size = last_period_size + 1 + ASRC_OUTPUT_LAST_SAMPLE;
+
+	if (asrc_priv->soc->use_edma) {
+		remain = pbuf->output_buffer_length % (out_width * channels * m2m->watermark[OUT]);
+		if (remain)
+			m2m->last_period_size += remain / (out_width * channels);
+	}
+
+	return 0;
+}
+
+static long fsl_asrc_ioctl_convert(struct fsl_asrc_pair *pair,
+				   void __user *user)
+{
+	struct fsl_asrc_m2m *m2m = pair->private_m2m;
+	struct fsl_asrc *asrc = pair->asrc;
+	enum asrc_pair_index index = pair->index;
+	struct asrc_convert_buffer buf;
+	long ret;
+
+	ret = copy_from_user(&buf, user, sizeof(buf));
+	if (ret) {
+		pair_err("failed to get buf from user space: %ld\n", ret);
+		return ret;
+	}
+
+	fsl_asrc_calc_last_period_size(pair, &buf);
+
+	ret = fsl_asrc_prepare_buffer(pair, &buf);
+	if (ret) {
+		pair_err("failed to prepare buffer: %ld\n", ret);
+		return ret;
+	}
+
+	reinit_completion(&m2m->complete[IN]);
+	reinit_completion(&m2m->complete[OUT]);
+
+#ifdef ASRC_POLLING_WITHOUT_DMA
+	fsl_asrc_polling_debug(pair);
+#else
+	fsl_asrc_submit_dma(pair);
+#endif
+
+	ret = fsl_asrc_process_buffer(pair, &buf);
+	if (ret) {
+		if (ret != -ERESTARTSYS)
+			pair_err("failed to process buffer: %ld\n", ret);
+		return ret;
+	}
+
+	ret = copy_to_user(user, &buf, sizeof(buf));
+	if (ret) {
+		pair_err("failed to send buf to user space: %ld\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static long fsl_asrc_ioctl_start_conv(struct fsl_asrc_pair *pair,
+				      void __user *user)
+{
+	struct fsl_asrc *asrc = pair->asrc;
+	struct fsl_asrc_m2m *m2m = pair->private_m2m;
+	enum asrc_pair_index index;
+	long ret;
+
+	ret = copy_from_user(&index, user, sizeof(index));
+	if (ret) {
+		pair_err("failed to get index from user space: %ld\n", ret);
+		return ret;
+	}
+
+	m2m->asrc_active = 1;
+	fsl_asrc_start_pair(pair);
+
+	return 0;
+}
+
+static long fsl_asrc_ioctl_stop_conv(struct fsl_asrc_pair *pair,
+				     void __user *user)
+{
+	struct fsl_asrc *asrc = pair->asrc;
+	struct fsl_asrc_m2m *m2m = pair->private_m2m;
+	enum asrc_pair_index index;
+	long ret;
+
+	ret = copy_from_user(&index, user, sizeof(index));
+	if (ret) {
+		pair_err("failed to get index from user space: %ld\n", ret);
+		return ret;
+	}
+
+	dmaengine_terminate_all(pair->dma_chan[IN]);
+	dmaengine_terminate_all(pair->dma_chan[OUT]);
+
+	fsl_asrc_stop_pair(pair);
+	m2m->asrc_active = 0;
+
+	return 0;
+}
+
+static long fsl_asrc_ioctl_status(struct fsl_asrc_pair *pair, void __user *user)
+{
+	struct fsl_asrc *asrc = pair->asrc;
+	enum asrc_pair_index index = pair->index;
+	struct asrc_status_flags flags;
+	long ret;
+
+	ret = copy_from_user(&flags, user, sizeof(flags));
+	if (ret) {
+		pair_err("failed to get flags from user space: %ld\n", ret);
+		return ret;
+	}
+
+	fsl_asrc_get_status(pair, &flags);
+
+	ret = copy_to_user(user, &flags, sizeof(flags));
+	if (ret) {
+		pair_err("failed to send flags to user space: %ld\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static long fsl_asrc_ioctl_flush(struct fsl_asrc_pair *pair, void __user *user)
+{
+	struct fsl_asrc *asrc = pair->asrc;
+	enum asrc_pair_index index = pair->index;
+
+	/* Release DMA and request again */
+	dma_release_channel(pair->dma_chan[IN]);
+	dma_release_channel(pair->dma_chan[OUT]);
+
+	pair->dma_chan[IN] = fsl_asrc_get_dma_channel(pair, IN);
+	if (pair->dma_chan[IN] == NULL) {
+		pair_err("failed to request input task DMA channel\n");
+		return -EBUSY;
+	}
+
+	pair->dma_chan[OUT] = fsl_asrc_get_dma_channel(pair, OUT);
+	if (pair->dma_chan[OUT] == NULL) {
+		pair_err("failed to request output task DMA channel\n");
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+static long fsl_asrc_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	struct fsl_asrc_pair *pair = file->private_data;
+	struct fsl_asrc *asrc = pair->asrc;
+	void __user *user = (void __user *)arg;
+	long ret = 0;
+
+	switch (cmd) {
+	case ASRC_REQ_PAIR:
+		ret = fsl_asrc_ioctl_req_pair(pair, user);
+		break;
+	case ASRC_CONFIG_PAIR:
+		ret = fsl_asrc_ioctl_config_pair(pair, user);
+		break;
+	case ASRC_RELEASE_PAIR:
+		ret = fsl_asrc_ioctl_release_pair(pair, user);
+		break;
+	case ASRC_CONVERT:
+		ret = fsl_asrc_ioctl_convert(pair, user);
+		break;
+	case ASRC_START_CONV:
+		ret = fsl_asrc_ioctl_start_conv(pair, user);
+		break;
+	case ASRC_STOP_CONV:
+		ret = fsl_asrc_ioctl_stop_conv(pair, user);
+		break;
+	case ASRC_STATUS:
+		ret = fsl_asrc_ioctl_status(pair, user);
+		break;
+	case ASRC_FLUSH:
+		ret = fsl_asrc_ioctl_flush(pair, user);
+		break;
+	default:
+		dev_err(&asrc->pdev->dev, "invalid ioctl cmd!\n");
+		break;
+	}
+
+	return ret;
+}
+
+static int fsl_asrc_open(struct inode *inode, struct file *file)
+{
+	struct miscdevice *asrc_miscdev = file->private_data;
+	struct fsl_asrc *asrc = dev_get_drvdata(asrc_miscdev->parent);
+	struct device *dev = &asrc->pdev->dev;
+	struct fsl_asrc_pair *pair;
+	struct fsl_asrc_m2m *m2m;
+	int ret;
+
+	ret = signal_pending(current);
+	if (ret) {
+		dev_err(dev, "current process has a signal pending\n");
+		return ret;
+	}
+
+	pair = kzalloc(sizeof(struct fsl_asrc_pair) + asrc->pair_priv_size, GFP_KERNEL);
+	if (!pair) {
+		dev_err(dev, "failed to allocate pair\n");
+		return -ENOMEM;
+	}
+
+	pair->private = (void *)pair + sizeof(struct fsl_asrc_pair);
+
+	m2m = kzalloc(sizeof(struct fsl_asrc_m2m), GFP_KERNEL);
+	if (!m2m) {
+		dev_err(dev, "failed to allocate m2m resource\n");
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	pair->private_m2m = m2m;
+	pair->asrc = asrc;
+
+	spin_lock_init(&m2m->lock);
+	init_completion(&m2m->complete[IN]);
+	init_completion(&m2m->complete[OUT]);
+
+	file->private_data = pair;
+
+	pm_runtime_get_sync(dev);
+
+	return 0;
+out:
+	kfree(pair);
+
+	return ret;
+}
+
+static int fsl_asrc_close(struct inode *inode, struct file *file)
+{
+	struct fsl_asrc_pair *pair = file->private_data;
+	struct fsl_asrc_m2m *m2m = pair->private_m2m;
+	struct fsl_asrc *asrc = pair->asrc;
+	struct device *dev = &asrc->pdev->dev;
+	unsigned long lock_flags;
+
+	if (m2m->asrc_active) {
+		m2m->asrc_active = 0;
+
+		dmaengine_terminate_all(pair->dma_chan[IN]);
+		dmaengine_terminate_all(pair->dma_chan[OUT]);
+
+		fsl_asrc_stop_pair(pair);
+		fsl_asrc_input_dma_callback((void *)pair);
+		fsl_asrc_output_dma_callback((void *)pair);
+	}
+
+	spin_lock_irqsave(&m2m->lock, lock_flags);
+	if (m2m->pair_hold) {
+		m2m->pair_hold = 0;
+		spin_unlock_irqrestore(&m2m->lock, lock_flags);
+
+		if (pair->dma_chan[IN])
+			dma_release_channel(pair->dma_chan[IN]);
+		if (pair->dma_chan[OUT])
+			dma_release_channel(pair->dma_chan[OUT]);
+
+		kfree(m2m->dma_block[IN].dma_vaddr);
+		kfree(m2m->dma_block[OUT].dma_vaddr);
+
+		fsl_asrc_release_pair(pair);
+	} else
+		spin_unlock_irqrestore(&m2m->lock, lock_flags);
+
+	spin_lock_irqsave(&asrc->lock, lock_flags);
+	kfree(m2m);
+	kfree(pair);
+	spin_unlock_irqrestore(&asrc->lock, lock_flags);
+	file->private_data = NULL;
+
+	pm_runtime_put_sync(dev);
+
+	return 0;
+}
+
+static const struct file_operations asrc_fops = {
+	.owner		= THIS_MODULE,
+	.unlocked_ioctl	= fsl_asrc_ioctl,
+	.open		= fsl_asrc_open,
+	.release	= fsl_asrc_close,
+};
+
+static int fsl_asrc_m2m_init(struct fsl_asrc *asrc)
+{
+	struct device *dev = &asrc->pdev->dev;
+	struct fsl_asrc_priv *asrc_priv = asrc->private;
+	int ret;
+
+	asrc->asrc_miscdev.fops = &asrc_fops;
+	asrc->asrc_miscdev.parent = dev;
+	asrc->asrc_miscdev.name = asrc_priv->name;
+	asrc->asrc_miscdev.minor = MISC_DYNAMIC_MINOR;
+	ret = misc_register(&asrc->asrc_miscdev);
+	if (ret) {
+		dev_err(dev, "failed to register char device %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int fsl_asrc_m2m_remove(struct platform_device *pdev)
+{
+	struct fsl_asrc *asrc = dev_get_drvdata(&pdev->dev);
+
+	misc_deregister(&asrc->asrc_miscdev);
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static void fsl_asrc_m2m_suspend(struct fsl_asrc *asrc)
+{
+	struct fsl_asrc_pair *pair;
+	struct fsl_asrc_m2m *m2m;
+	unsigned long lock_flags;
+	int i;
+
+	for (i = 0; i < ASRC_PAIR_MAX_NUM; i++) {
+		spin_lock_irqsave(&asrc->lock, lock_flags);
+		pair = asrc->pair[i];
+		if (!pair || !pair->private_m2m) {
+			spin_unlock_irqrestore(&asrc->lock, lock_flags);
+			continue;
+		}
+		m2m = pair->private_m2m;
+
+		if (!completion_done(&m2m->complete[IN])) {
+			if (pair->dma_chan[IN])
+				dmaengine_terminate_all(pair->dma_chan[IN]);
+			fsl_asrc_input_dma_callback((void *)pair);
+		}
+		if (!completion_done(&m2m->complete[OUT])) {
+			if (pair->dma_chan[OUT])
+				dmaengine_terminate_all(pair->dma_chan[OUT]);
+			fsl_asrc_output_dma_callback((void *)pair);
+		}
+
+		spin_unlock_irqrestore(&asrc->lock, lock_flags);
+	}
+}
+
+static void fsl_asrc_m2m_resume(struct fsl_asrc *asrc)
+{
+	struct fsl_asrc_pair *pair;
+	struct fsl_asrc_m2m *m2m;
+	unsigned long lock_flags;
+	enum asrc_pair_index index;
+	int i, j;
+
+	for (i = 0; i < ASRC_PAIR_MAX_NUM; i++) {
+		spin_lock_irqsave(&asrc->lock, lock_flags);
+		pair = asrc->pair[i];
+		if (!pair || !pair->private_m2m) {
+			spin_unlock_irqrestore(&asrc->lock, lock_flags);
+			continue;
+		}
+		m2m = pair->private_m2m;
+		index = pair->index;
+
+		for (j = 0; j < pair->channels * 4; j++)
+			regmap_write(asrc->regmap, REG_ASRDI(index), 0);
+
+		spin_unlock_irqrestore(&asrc->lock, lock_flags);
+	}
+}
+#endif
diff --git a/sound/soc/fsl/fsl_aud2htx.c b/sound/soc/fsl/fsl_aud2htx.c
index 99ab7f024..38f386373 100644
--- a/sound/soc/fsl/fsl_aud2htx.c
+++ b/sound/soc/fsl/fsl_aud2htx.c
@@ -233,18 +233,26 @@ static int fsl_aud2htx_probe(struct platform_device *pdev)
 
 	regcache_cache_only(aud2htx->regmap, true);
 
+	/*
+	 * Register platform component before registering cpu dai for there
+	 * is not defer probe for platform component in snd_soc_add_pcm_runtime().
+	 */
+	ret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to pcm register\n");
+		pm_runtime_disable(&pdev->dev);
+		return ret;
+	}
+
 	ret = devm_snd_soc_register_component(&pdev->dev,
 					      &fsl_aud2htx_component,
 					      &fsl_aud2htx_dai, 1);
 	if (ret) {
 		dev_err(&pdev->dev, "failed to register ASoC DAI\n");
+		pm_runtime_disable(&pdev->dev);
 		return ret;
 	}
 
-	ret = imx_pcm_dma_init(pdev, IMX_DEFAULT_DMABUF_SIZE);
-	if (ret)
-		dev_err(&pdev->dev, "failed to init imx pcm dma: %d\n", ret);
-
 	return ret;
 }
 
diff --git a/sound/soc/fsl/fsl_audmix.c b/sound/soc/fsl/fsl_audmix.c
index f931288e2..a87278c8e 100644
--- a/sound/soc/fsl/fsl_audmix.c
+++ b/sound/soc/fsl/fsl_audmix.c
@@ -199,18 +199,10 @@ static int fsl_audmix_put_out_src(struct snd_kcontrol *kcontrol,
 
 static const struct snd_kcontrol_new fsl_audmix_snd_controls[] = {
 	/* FSL_AUDMIX_CTR controls */
-	{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
-		.name = "Mixing Clock Source",
-		.info = snd_soc_info_enum_double,
-		.access = SNDRV_CTL_ELEM_ACCESS_WRITE,
-		.put = fsl_audmix_put_mix_clk_src,
-		.private_value = (unsigned long)&fsl_audmix_enum[0] },
-	{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
-		.name = "Output Source",
-		.info = snd_soc_info_enum_double,
-		.access = SNDRV_CTL_ELEM_ACCESS_WRITE,
-		.put = fsl_audmix_put_out_src,
-		.private_value = (unsigned long)&fsl_audmix_enum[1] },
+	SOC_ENUM_EXT("Mixing Clock Source", fsl_audmix_enum[0],
+		     snd_soc_get_enum_double, fsl_audmix_put_mix_clk_src),
+	SOC_ENUM_EXT("Output Source", fsl_audmix_enum[1],
+		     snd_soc_get_enum_double, fsl_audmix_put_out_src),
 	SOC_ENUM("Output Width", fsl_audmix_enum[2]),
 	SOC_ENUM("Frame Rate Diff Error", fsl_audmix_enum[3]),
 	SOC_ENUM("Clock Freq Diff Error", fsl_audmix_enum[4]),
diff --git a/sound/soc/fsl/fsl_dsd.h b/sound/soc/fsl/fsl_dsd.h
new file mode 100644
index 000000000..a45f31422
--- /dev/null
+++ b/sound/soc/fsl/fsl_dsd.h
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2018 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __FSL_DSD_H
+#define __FSL_DSD_H
+
+#include <linux/pinctrl/consumer.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+
+static bool fsl_is_dsd(struct snd_pcm_hw_params *params)
+{
+	snd_pcm_format_t format = params_format(params);
+
+	switch (format) {
+	case SNDRV_PCM_FORMAT_DSD_U8:
+	case SNDRV_PCM_FORMAT_DSD_U16_LE:
+	case SNDRV_PCM_FORMAT_DSD_U16_BE:
+	case SNDRV_PCM_FORMAT_DSD_U32_LE:
+	case SNDRV_PCM_FORMAT_DSD_U32_BE:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static inline struct pinctrl_state *fsl_get_pins_state(struct pinctrl *pinctrl,
+	struct snd_pcm_hw_params *params, u32 bclk)
+{
+	struct pinctrl_state *state = 0;
+
+	if (fsl_is_dsd(params)) {
+		/* DSD512@44.1kHz, DSD512@48kHz */
+		if (bclk >= 22579200)
+			state = pinctrl_lookup_state(pinctrl, "dsd512");
+
+		/* Get default DSD state */
+		if (IS_ERR_OR_NULL(state))
+			state = pinctrl_lookup_state(pinctrl, "dsd");
+	} else {
+		/* 706k32b2c, 768k32b2c, etc */
+		if (bclk >= 45158400)
+			state = pinctrl_lookup_state(pinctrl, "pcm_b2m");
+	}
+
+	/* Get default state */
+	if (IS_ERR_OR_NULL(state))
+		state = pinctrl_lookup_state(pinctrl, "default");
+
+	return state;
+}
+
+#endif /* __FSL_DSD_H */
diff --git a/sound/soc/fsl/fsl_easrc.c b/sound/soc/fsl/fsl_easrc.c
index be14f8479..442015b86 100644
--- a/sound/soc/fsl/fsl_easrc.c
+++ b/sound/soc/fsl/fsl_easrc.c
@@ -1749,6 +1749,8 @@ static const struct regmap_config fsl_easrc_regmap_config = {
 	.cache_type = REGCACHE_RBTREE,
 };
 
+#include "fsl_easrc_m2m.c"
+
 #ifdef DEBUG
 static void fsl_easrc_dump_firmware(struct fsl_asrc *easrc)
 {
@@ -1874,6 +1876,7 @@ static int fsl_easrc_probe(struct platform_device *pdev)
 	struct device_node *np;
 	void __iomem *regs;
 	int ret, irq;
+	int width;
 
 	easrc = devm_kzalloc(dev, sizeof(*easrc), GFP_KERNEL);
 	if (!easrc)
@@ -1935,8 +1938,25 @@ static int fsl_easrc_probe(struct platform_device *pdev)
 
 	ret = of_property_read_u32(np, "fsl,asrc-format", &easrc->asrc_format);
 	if (ret) {
-		dev_err(dev, "failed to asrc format\n");
-		return ret;
+		ret = of_property_read_u32(np, "fsl,asrc-width", &width);
+		if (ret) {
+			dev_err(&pdev->dev, "failed to decide output format\n");
+			return ret;
+		}
+
+		switch (width) {
+		case 16:
+			easrc->asrc_format = SNDRV_PCM_FORMAT_S16_LE;
+			break;
+		case 24:
+			easrc->asrc_format = SNDRV_PCM_FORMAT_S24_LE;
+			break;
+		default:
+			dev_warn(&pdev->dev,
+				 "unsupported width, use default S24_LE\n");
+			easrc->asrc_format = SNDRV_PCM_FORMAT_S24_LE;
+			break;
+		}
 	}
 
 	if (!(FSL_EASRC_FORMATS & (1ULL << easrc->asrc_format))) {
@@ -1972,6 +1992,12 @@ static int fsl_easrc_probe(struct platform_device *pdev)
 		return ret;
 	}
 
+	ret = fsl_easrc_m2m_init(easrc);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to init m2m device %d\n", ret);
+		return ret;
+	}
+
 	return 0;
 }
 
@@ -2079,12 +2105,38 @@ static __maybe_unused int fsl_easrc_runtime_resume(struct device *dev)
 	return ret;
 }
 
+#ifdef CONFIG_PM_SLEEP
+static int fsl_easrc_suspend(struct device *dev)
+{
+	struct fsl_asrc *easrc = dev_get_drvdata(dev);
+	int ret;
+
+	fsl_easrc_m2m_suspend(easrc);
+
+	ret = pm_runtime_force_suspend(dev);
+
+	return ret;
+}
+
+static int fsl_easrc_resume(struct device *dev)
+{
+	struct fsl_asrc *easrc = dev_get_drvdata(dev);
+	int ret;
+
+	ret = pm_runtime_force_resume(dev);
+
+	fsl_easrc_m2m_resume(easrc);
+
+	return ret;
+}
+#endif /*CONFIG_PM_SLEEP*/
+
 static const struct dev_pm_ops fsl_easrc_pm_ops = {
 	SET_RUNTIME_PM_OPS(fsl_easrc_runtime_suspend,
 			   fsl_easrc_runtime_resume,
 			   NULL)
-	SET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,
-				pm_runtime_force_resume)
+	SET_SYSTEM_SLEEP_PM_OPS(fsl_easrc_suspend,
+				fsl_easrc_resume)
 };
 
 static struct platform_driver fsl_easrc_driver = {
diff --git a/sound/soc/fsl/fsl_easrc_m2m.c b/sound/soc/fsl/fsl_easrc_m2m.c
new file mode 100755
index 000000000..deed65b5c
--- /dev/null
+++ b/sound/soc/fsl/fsl_easrc_m2m.c
@@ -0,0 +1,981 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright 2019 NXP
+
+struct fsl_easrc_m2m {
+	struct fsl_asrc *asrc;
+	struct fsl_asrc_pair *ctx;
+	struct completion complete[2];
+	struct dma_block dma_block[2];
+	unsigned int ctx_hold;
+	unsigned int easrc_active;
+	unsigned int first_convert;
+	unsigned int sg_nodes[2];
+	unsigned int in_filled_len;
+	struct scatterlist sg[2][9];
+	struct dma_async_tx_descriptor *desc[2];
+	spinlock_t lock;  /* protect mem resource */
+};
+
+void fsl_easrc_get_status(struct fsl_asrc_pair *ctx,
+			  struct asrc_status_flags *flags)
+{
+	flags->overload_error = 0;
+}
+
+#define mxc_easrc_dma_umap_in(dev, m2m) \
+	dma_unmap_sg(dev, m2m->sg[IN], m2m->sg_nodes[IN], \
+					DMA_TO_DEVICE) \
+
+#define mxc_easrc_dma_umap_out(dev, m2m) \
+	dma_unmap_sg(dev, m2m->sg[OUT], m2m->sg_nodes[OUT], \
+					DMA_FROM_DEVICE) \
+
+#define EASRC_xPUT_DMA_CALLBACK(dir) \
+	((dir == IN) ? fsl_easrc_input_dma_callback \
+			: fsl_easrc_output_dma_callback)
+
+#define DIR_STR(dir) dir == IN ? "in" : "out"
+
+static void fsl_easrc_input_dma_callback(void *data)
+{
+	struct fsl_easrc_m2m *m2m = (struct fsl_easrc_m2m *)data;
+
+	complete(&m2m->complete[IN]);
+}
+
+static void fsl_easrc_output_dma_callback(void *data)
+{
+	struct fsl_easrc_m2m *m2m = (struct fsl_easrc_m2m *)data;
+
+	complete(&m2m->complete[OUT]);
+}
+
+static int fsl_allocate_dma_buf(struct fsl_easrc_m2m *m2m)
+{
+	struct dma_block *input = &m2m->dma_block[IN];
+	struct dma_block *output = &m2m->dma_block[OUT];
+
+	input->dma_vaddr = kzalloc(input->length, GFP_KERNEL);
+	if (!input->dma_vaddr)
+		return -ENOMEM;
+
+	output->dma_vaddr = kzalloc(output->length, GFP_KERNEL);
+	if (!output->dma_vaddr)
+		goto alloc_fail;
+
+	return 0;
+
+alloc_fail:
+	kfree(input->dma_vaddr);
+	input->dma_vaddr = NULL;
+	return -ENOMEM;
+}
+
+static int fsl_easrc_dmaconfig(struct fsl_easrc_m2m *m2m,
+			       struct dma_chan *chan,
+			       u32 dma_addr, void *buf_addr, u32 buf_len,
+			       bool dir, int bits)
+{
+	struct dma_async_tx_descriptor *desc = m2m->desc[dir];
+	struct fsl_asrc *asrc = m2m->asrc;
+	struct fsl_asrc_pair *ctx = m2m->ctx;
+	struct fsl_easrc_ctx_priv *ctx_priv = ctx->private;
+	struct device *dev = &asrc->pdev->dev;
+	unsigned int sg_nent = m2m->sg_nodes[dir];
+	struct scatterlist *sg = m2m->sg[dir];
+	struct dma_slave_config slave_config;
+	enum dma_slave_buswidth buswidth;
+	enum dma_data_direction dma_dir;
+	int ret, i;
+
+	switch (bits) {
+	case 16:
+		buswidth = DMA_SLAVE_BUSWIDTH_2_BYTES;
+		break;
+	case 24:
+		buswidth = DMA_SLAVE_BUSWIDTH_3_BYTES;
+		break;
+	default:
+		buswidth = DMA_SLAVE_BUSWIDTH_4_BYTES;
+	}
+
+	memset(&slave_config, 0, sizeof(slave_config));
+	if (dir == IN) {
+		slave_config.direction = DMA_MEM_TO_DEV;
+		dma_dir = DMA_TO_DEVICE;
+		slave_config.dst_addr = dma_addr;
+		slave_config.dst_addr_width = buswidth;
+		slave_config.dst_maxburst =
+			ctx_priv->in_params.fifo_wtmk * ctx->channels;
+	} else {
+		slave_config.direction = DMA_DEV_TO_MEM;
+		dma_dir = DMA_FROM_DEVICE;
+		slave_config.src_addr = dma_addr;
+		slave_config.src_addr_width = buswidth;
+		slave_config.src_maxburst =
+			ctx_priv->out_params.fifo_wtmk * ctx->channels;
+	}
+
+	ret = dmaengine_slave_config(chan, &slave_config);
+	if (ret) {
+		dev_err(dev, "failed to config dmaengine for %sput task: %d\n",
+			DIR_STR(dir), ret);
+		return -EINVAL;
+	}
+
+	sg_init_table(sg, sg_nent);
+	switch (sg_nent) {
+	case 1:
+		sg_init_one(sg, buf_addr, buf_len);
+		break;
+	case 2:
+	case 3:
+	case 4:
+	case 5:
+	case 6:
+	case 7:
+	case 8:
+	case 9:
+		for (i = 0; i < (sg_nent - 1); i++)
+			sg_set_buf(&sg[i],
+				   buf_addr + i * m2m->dma_block[dir].max_buf_size,
+				   m2m->dma_block[dir].max_buf_size);
+
+		sg_set_buf(&sg[i],
+			   buf_addr + i * m2m->dma_block[dir].max_buf_size,
+			   buf_len - i * m2m->dma_block[dir].max_buf_size);
+		break;
+	default:
+		dev_err(dev, "invalid input DMA nodes number: %d\n", sg_nent);
+		return -EINVAL;
+	}
+
+	ret = dma_map_sg(dev, sg, sg_nent, dma_dir);
+	if (ret != sg_nent) {
+		dev_err(dev, "failed to map DMA sg for %sput task\n",
+			DIR_STR(dir));
+		return -EINVAL;
+	}
+
+	desc = dmaengine_prep_slave_sg(chan, sg, sg_nent,
+				       slave_config.direction,
+				       DMA_PREP_INTERRUPT);
+	if (!desc) {
+		dev_err(dev, "failed to prepare dmaengine for %sput task\n",
+			DIR_STR(dir));
+		return -EINVAL;
+	}
+
+	m2m->desc[dir] = desc;
+	m2m->desc[dir]->callback = EASRC_xPUT_DMA_CALLBACK(dir);
+
+	desc->callback = EASRC_xPUT_DMA_CALLBACK(dir);
+	desc->callback_param = m2m;
+
+	return 0;
+}
+
+static long fsl_easrc_calc_outbuf_len(struct fsl_easrc_m2m *m2m,
+				      struct asrc_convert_buffer *pbuf)
+{
+	struct fsl_asrc_pair *ctx = m2m->ctx;
+	struct fsl_easrc_ctx_priv *ctx_priv = ctx->private;
+	unsigned int out_length;
+	unsigned int in_width, out_width;
+	unsigned int channels = ctx->channels;
+	unsigned int in_samples, out_samples;
+
+	in_width = snd_pcm_format_physical_width(ctx_priv->in_params.sample_format) / 8;
+	out_width = snd_pcm_format_physical_width(ctx_priv->out_params.sample_format) / 8;
+
+	m2m->in_filled_len += pbuf->input_buffer_length;
+	if (m2m->in_filled_len <= ctx_priv->in_filled_sample * in_width * channels) {
+		out_length = 0;
+	} else {
+		in_samples = m2m->in_filled_len / (in_width * channels) - ctx_priv->in_filled_sample;
+		out_samples = ctx_priv->out_params.sample_rate * in_samples /
+				ctx_priv->in_params.sample_rate;
+		out_length = out_samples * out_width * channels;
+		m2m->in_filled_len = ctx_priv->in_filled_sample * in_width * channels;
+	}
+
+	return out_length;
+}
+
+static long fsl_easrc_prepare_io_buffer(struct fsl_easrc_m2m *m2m,
+					struct asrc_convert_buffer *buf,
+					bool dir)
+{
+	struct fsl_asrc *asrc = m2m->asrc;
+	struct device *dev = &asrc->pdev->dev;
+	struct fsl_asrc_pair *ctx = m2m->ctx;
+	struct fsl_easrc_ctx_priv *ctx_priv = ctx->private;
+	struct dma_chan *dma_chan = ctx->dma_chan[dir];
+	unsigned int *dma_len = &m2m->dma_block[dir].length;
+	unsigned int *sg_nodes = &m2m->sg_nodes[dir];
+	void *dma_vaddr = m2m->dma_block[dir].dma_vaddr;
+	enum asrc_pair_index index = m2m->ctx->index;
+	unsigned int buf_len, bits;
+	u32 fifo_addr;
+	void __user *buf_vaddr;
+
+	if (dir == IN) {
+		buf_vaddr = (void __user *)buf->input_buffer_vaddr;
+		buf_len = buf->input_buffer_length;
+		bits = snd_pcm_format_physical_width(ctx_priv->in_params.sample_format);
+		fifo_addr = asrc->paddr + REG_EASRC_WRFIFO(index);
+	} else {
+		buf_vaddr = (void __user *)buf->output_buffer_vaddr;
+		buf_len = buf->output_buffer_length;
+		bits = snd_pcm_format_physical_width(ctx_priv->out_params.sample_format);
+		fifo_addr = asrc->paddr + REG_EASRC_RDFIFO(index);
+	}
+
+	if (buf_len > EASRC_DMA_BUFFER_SIZE ||
+	    (dir == IN && (buf_len % (bits / 8)))) {
+		dev_err(dev, "%sput buffer size is error: [%d]\n",
+			DIR_STR(dir), buf_len);
+		return -EINVAL;
+	}
+
+	if (dir == IN && copy_from_user(dma_vaddr, buf_vaddr, buf_len))
+		return -EFAULT;
+
+	*dma_len = buf_len;
+
+	if (dir == OUT)
+		*dma_len = fsl_easrc_calc_outbuf_len(m2m, buf);
+
+	if (*dma_len <= 0)
+		return 0;
+
+	*sg_nodes = *dma_len / m2m->dma_block[dir].max_buf_size;
+	if (*dma_len % m2m->dma_block[dir].max_buf_size)
+		*sg_nodes += 1;
+
+	return fsl_easrc_dmaconfig(m2m, dma_chan, fifo_addr, dma_vaddr,
+				*dma_len, dir, bits);
+}
+
+static long fsl_easrc_prepare_buffer(struct fsl_easrc_m2m *m2m,
+				     struct asrc_convert_buffer *buf)
+{
+	struct fsl_asrc *asrc = m2m->asrc;
+	struct device *dev = &asrc->pdev->dev;
+	int ret;
+
+	ret = fsl_easrc_prepare_io_buffer(m2m, buf, IN);
+	if (ret) {
+		dev_err(dev, "failed to prepare input buffer %d\n", ret);
+		return ret;
+	}
+
+	ret = fsl_easrc_prepare_io_buffer(m2m, buf, OUT);
+	if (ret) {
+		dev_err(dev, "failed to prepare output buffer %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+int fsl_easrc_process_buffer_pre(struct fsl_easrc_m2m *m2m, bool dir)
+{
+	struct fsl_asrc *asrc = m2m->asrc;
+	struct device *dev = &asrc->pdev->dev;
+
+	if (!wait_for_completion_interruptible_timeout(&m2m->complete[dir],
+						       10 * HZ)) {
+		dev_err(dev, "%sput DMA task timeout\n", DIR_STR(dir));
+		return -ETIME;
+	} else if (signal_pending(current)) {
+		dev_err(dev, "%sput task forcibly aborted\n", DIR_STR(dir));
+		return -ERESTARTSYS;
+	}
+
+	return 0;
+}
+
+static unsigned int fsl_easrc_get_output_FIFO_size(struct fsl_easrc_m2m *m2m)
+{
+	struct fsl_asrc *asrc = m2m->asrc;
+	enum asrc_pair_index index = m2m->ctx->index;
+	u32 val;
+
+	regmap_read(asrc->regmap, REG_EASRC_SFS(index), &val);
+
+	val &= EASRC_SFS_NSGO_MASK;
+
+	return val >> EASRC_SFS_NSGO_SHIFT;
+}
+
+static void fsl_easrc_read_last_FIFO(struct fsl_easrc_m2m *m2m)
+{
+	struct fsl_asrc *asrc = m2m->asrc;
+	struct dma_block *output = &m2m->dma_block[OUT];
+	struct fsl_asrc_pair *ctx = m2m->ctx;
+	struct fsl_easrc_ctx_priv *ctx_priv = ctx->private;
+	enum asrc_pair_index index = m2m->ctx->index;
+	u32 i, reg, size, t_size = 0, width;
+	u32 *reg32 = NULL;
+	u16 *reg16 = NULL;
+	u8  *reg24 = NULL;
+
+	width = snd_pcm_format_physical_width(ctx_priv->out_params.sample_format);
+
+	if (width == 32)
+		reg32 = output->dma_vaddr + output->length;
+	else if (width == 16)
+		reg16 = output->dma_vaddr + output->length;
+	else
+		reg24 = output->dma_vaddr + output->length;
+retry:
+	size = fsl_easrc_get_output_FIFO_size(m2m);
+	for (i = 0; i < size * ctx->channels; i++) {
+		regmap_read(asrc->regmap, REG_EASRC_RDFIFO(index), &reg);
+
+		if (reg32) {
+			*(reg32) = reg;
+			reg32++;
+		} else if (reg16) {
+			*(reg16) = (u16)reg;
+			reg16++;
+		} else {
+			*reg24++ = (u8)reg;
+			*reg24++ = (u8)(reg >> 8);
+			*reg24++ = (u8)(reg >> 16);
+		}
+	}
+	t_size += size;
+
+	if (size)
+		goto retry;
+
+	if (reg32)
+		output->length += t_size * ctx->channels * 4;
+	else if (reg16)
+		output->length += t_size * ctx->channels * 2;
+	else
+		output->length += t_size * ctx->channels * 3;
+}
+
+static long fsl_easrc_process_buffer(struct fsl_easrc_m2m *m2m,
+				     struct asrc_convert_buffer *buf)
+{
+	struct fsl_asrc *asrc = m2m->asrc;
+	struct device *dev = &asrc->pdev->dev;
+	unsigned long lock_flags;
+	int ret;
+
+	/* Check input task first */
+	ret = fsl_easrc_process_buffer_pre(m2m, IN);
+	if (ret) {
+		mxc_easrc_dma_umap_in(dev, m2m);
+		if (m2m->dma_block[OUT].length > 0)
+			mxc_easrc_dma_umap_out(dev, m2m);
+		return ret;
+	}
+
+	/* ...then output task*/
+	if (m2m->dma_block[OUT].length > 0) {
+		ret = fsl_easrc_process_buffer_pre(m2m, OUT);
+		if (ret) {
+			mxc_easrc_dma_umap_in(dev, m2m);
+			mxc_easrc_dma_umap_out(dev, m2m);
+			return ret;
+		}
+	}
+
+	mxc_easrc_dma_umap_in(dev, m2m);
+	if (m2m->dma_block[OUT].length > 0)
+		mxc_easrc_dma_umap_out(dev, m2m);
+
+	spin_lock_irqsave(&m2m->lock, lock_flags);
+	if (!m2m->ctx_hold) {
+		spin_unlock_irqrestore(&m2m->lock, lock_flags);
+		return -EFAULT;
+	}
+	spin_unlock_irqrestore(&m2m->lock, lock_flags);
+
+	/* Fetch the remaining data */
+	fsl_easrc_read_last_FIFO(m2m);
+
+	/* Update final lengths after getting last FIFO */
+	buf->input_buffer_length = m2m->dma_block[IN].length;
+	buf->output_buffer_length = m2m->dma_block[OUT].length;
+
+	if (copy_to_user((void __user *)buf->output_buffer_vaddr,
+			 m2m->dma_block[OUT].dma_vaddr,
+			 m2m->dma_block[OUT].length))
+		return -EFAULT;
+
+	return 0;
+}
+
+void fsl_easrc_submit_dma(struct fsl_easrc_m2m *m2m)
+{
+	/* Submit DMA request */
+	dmaengine_submit(m2m->desc[IN]);
+	dma_async_issue_pending(m2m->desc[IN]->chan);
+
+	if (m2m->dma_block[OUT].length > 0) {
+		dmaengine_submit(m2m->desc[OUT]);
+		dma_async_issue_pending(m2m->desc[OUT]->chan);
+	}
+}
+
+static long fsl_easrc_ioctl_req_context(struct fsl_easrc_m2m *m2m,
+					void __user *user)
+{
+	struct fsl_asrc *asrc = m2m->asrc;
+	struct device *dev = &asrc->pdev->dev;
+	struct asrc_req req;
+	unsigned long lock_flags;
+	long ret;
+
+	ret = copy_from_user(&req, user, sizeof(req));
+	if (ret) {
+		dev_err(dev, "failed to get req from user space:%ld\n", ret);
+		return ret;
+	}
+
+	ret = fsl_easrc_request_context(req.chn_num, m2m->ctx);
+	if (ret < 0) {
+		dev_err(dev, "failed to request context:%ld\n", ret);
+		return ret;
+	}
+
+	/* request context returns the context id in case of success */
+	spin_lock_irqsave(&m2m->lock, lock_flags);
+	m2m->ctx_hold = 1;
+	req.index = m2m->ctx->index;
+	req.supported_in_format = FSL_EASRC_FORMATS;
+	req.supported_out_format = FSL_EASRC_FORMATS |
+				   SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE;
+	spin_unlock_irqrestore(&m2m->lock, lock_flags);
+
+	ret = copy_to_user(user, &req, sizeof(req));
+	if (ret) {
+		dev_err(dev, "failed to send req to user space: %ld\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static long fsl_easrc_ioctl_config_context(struct fsl_easrc_m2m *m2m,
+					   void __user *user)
+{
+	struct fsl_asrc *asrc = m2m->asrc;
+	struct fsl_asrc_pair *ctx = m2m->ctx;
+	struct fsl_easrc_ctx_priv *ctx_priv = ctx->private;
+	enum asrc_pair_index index = m2m->ctx->index;
+	struct device *dev = &asrc->pdev->dev;
+	struct asrc_config config;
+	int ret;
+	int in_word_size, out_word_size;
+
+	ret = copy_from_user(&config, user, sizeof(config));
+	if (ret) {
+		dev_err(dev, "failed to get config from user space: %d\n", ret);
+		return ret;
+	}
+
+	/* set context configuration parameters received from userspace */
+	ctx_priv->in_params.sample_rate = config.input_sample_rate;
+	ctx_priv->out_params.sample_rate = config.output_sample_rate;
+
+	ctx_priv->in_params.fifo_wtmk = FSL_EASRC_INPUTFIFO_WML;
+	ctx_priv->out_params.fifo_wtmk = FSL_EASRC_OUTPUTFIFO_WML;
+
+	ctx_priv->in_params.sample_format = config.input_format;
+	ctx_priv->out_params.sample_format = config.output_format;
+
+	ctx->channels = config.channel_num;
+	ctx_priv->rs_init_mode = 0x2;
+	ctx_priv->pf_init_mode = 0x2;
+
+	ret = fsl_easrc_set_ctx_format(ctx,
+				       &ctx_priv->in_params.sample_format,
+				       &ctx_priv->out_params.sample_format);
+	if (ret)
+		return ret;
+
+	ret = fsl_easrc_config_context(asrc, index);
+	if (ret) {
+		dev_err(dev, "failed to config context %d\n", ret);
+		return ret;
+	}
+
+	ctx_priv->in_params.iterations = 1;
+	ctx_priv->in_params.group_len = ctx->channels;
+	ctx_priv->in_params.access_len = ctx->channels;
+	ctx_priv->out_params.iterations = 1;
+	ctx_priv->out_params.group_len = ctx->channels;
+	ctx_priv->out_params.access_len = ctx->channels;
+
+	/* You can also call fsl_easrc_set_ctx_organziation for
+	 * sample interleaving support
+	 */
+	ret = fsl_easrc_set_ctx_organziation(ctx);
+	if (ret) {
+		dev_err(dev, "failed to set fifo organization\n");
+		return ret;
+	}
+
+	in_word_size = snd_pcm_format_physical_width(config.input_format) / 8;
+	out_word_size = snd_pcm_format_physical_width(config.output_format) / 8;
+
+	/* allocate dma buffers */
+	m2m->dma_block[IN].length = EASRC_DMA_BUFFER_SIZE;
+	m2m->dma_block[IN].max_buf_size = rounddown(EASRC_MAX_BUFFER_SIZE,
+						    in_word_size * ctx->channels);
+	m2m->dma_block[OUT].length = EASRC_DMA_BUFFER_SIZE;
+	m2m->dma_block[OUT].max_buf_size = rounddown(EASRC_MAX_BUFFER_SIZE,
+						     out_word_size * ctx->channels);
+
+	ret = fsl_allocate_dma_buf(m2m);
+	if (ret) {
+		dev_err(dev, "failed to allocate DMA buffers: %d\n", ret);
+		return ret;
+	}
+
+	ctx->dma_chan[IN] = fsl_easrc_get_dma_channel(ctx, IN);
+	if (!ctx->dma_chan[IN]) {
+		dev_err(dev, "[ctx%d] failed to get input DMA channel\n",
+			m2m->ctx->index);
+		return -EBUSY;
+	}
+	ctx->dma_chan[OUT] = fsl_easrc_get_dma_channel(ctx, OUT);
+	if (!ctx->dma_chan[OUT]) {
+		dev_err(dev, "[ctx%d] failed to get output DMA channel\n",
+			m2m->ctx->index);
+		return -EBUSY;
+	}
+
+	ret = copy_to_user(user, &config, sizeof(config));
+	if (ret) {
+		dev_err(dev, "failed to send config to user: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static long fsl_easrc_ioctl_release_context(struct fsl_easrc_m2m *m2m,
+					    void __user *user)
+{
+	struct fsl_asrc *asrc = m2m->asrc;
+	struct fsl_asrc_pair *ctx = m2m->ctx;
+	struct device *dev = &asrc->pdev->dev;
+	enum asrc_pair_index index;
+	unsigned long lock_flags;
+	int ret;
+
+	ret = copy_from_user(&index, user, sizeof(index));
+	if (ret) {
+		dev_err(dev,
+			"[ctx%d] failed to get index from user space %d\n",
+			m2m->ctx->index, ret);
+		return ret;
+	}
+
+	if (index != m2m->ctx->index) {
+		dev_err(dev,
+			"[ctx%d] releasing wrong context - %d\n",
+			m2m->ctx->index, index);
+		return -EINVAL;
+	}
+
+	if (m2m->easrc_active) {
+		m2m->easrc_active = 0;
+		fsl_easrc_stop_context(ctx);
+	}
+
+	spin_lock_irqsave(&m2m->lock, lock_flags);
+	m2m->ctx_hold = 0;
+	spin_unlock_irqrestore(&m2m->lock, lock_flags);
+
+	if (ctx->dma_chan[IN])
+		dma_release_channel(ctx->dma_chan[IN]);
+	if (ctx->dma_chan[OUT])
+		dma_release_channel(ctx->dma_chan[OUT]);
+
+	ctx->dma_chan[IN] = NULL;
+	ctx->dma_chan[OUT] = NULL;
+
+	/* free buffers allocated in config context*/
+	kfree(m2m->dma_block[IN].dma_vaddr);
+	kfree(m2m->dma_block[OUT].dma_vaddr);
+
+	fsl_easrc_release_context(ctx);
+
+	return 0;
+}
+
+static long fsl_easrc_ioctl_convert(struct fsl_easrc_m2m *m2m,
+				    void __user *user)
+{
+	struct fsl_asrc *asrc = m2m->asrc;
+	struct device *dev = &asrc->pdev->dev;
+	struct fsl_asrc_pair *ctx = m2m->ctx;
+	struct asrc_convert_buffer buf;
+	int ret;
+
+	ret = copy_from_user(&buf, user, sizeof(buf));
+	if (ret) {
+		dev_err(dev, "failed to get buf from user space: %d\n", ret);
+		return ret;
+	}
+
+	/* fsl_easrc_calc_last_period_size(ctx, &buf); */
+	ret = fsl_easrc_prepare_buffer(m2m, &buf);
+	if (ret) {
+		dev_err(dev, "failed to prepare buffer\n");
+		return ret;
+	}
+
+	reinit_completion(&m2m->complete[IN]);
+	reinit_completion(&m2m->complete[OUT]);
+
+	fsl_easrc_submit_dma(m2m);
+
+	if (m2m->first_convert) {
+		fsl_easrc_start_context(ctx);
+		m2m->first_convert = 0;
+	}
+
+	ret = fsl_easrc_process_buffer(m2m, &buf);
+	if (ret) {
+		dev_err(dev, "failed to process buffer %d\n", ret);
+		return ret;
+	}
+
+	ret = copy_to_user(user, &buf, sizeof(buf));
+	if (ret) {
+		dev_err(dev, "failed to send buffer to user: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static long fsl_easrc_ioctl_start_conv(struct fsl_easrc_m2m *m2m,
+				       void __user *user)
+{
+	struct fsl_asrc *asrc = m2m->asrc;
+	struct device *dev = &asrc->pdev->dev;
+	enum asrc_pair_index index;
+	int ret;
+
+	ret = copy_from_user(&index, user, sizeof(index));
+	if (ret) {
+		dev_err(dev, "failed to get index from user space: %d\n",
+			ret);
+		return ret;
+	}
+
+	if (index != m2m->ctx->index) {
+		dev_err(dev, "[ctx%d] attempting to start wrong context%d\n",
+			m2m->ctx->index, index);
+		return -EINVAL;
+	}
+
+	m2m->easrc_active = 1;
+	m2m->first_convert = 1;
+
+	return 0;
+}
+
+static long fsl_easrc_ioctl_stop_conv(struct fsl_easrc_m2m *m2m,
+				      void __user *user)
+{
+	struct fsl_asrc *asrc = m2m->asrc;
+	struct fsl_asrc_pair *ctx = m2m->ctx;
+	struct device *dev = &asrc->pdev->dev;
+	enum asrc_pair_index index;
+	int ret;
+
+	ret = copy_from_user(&index, user, sizeof(index));
+	if (ret) {
+		dev_err(dev, "failed to get index from user space: %d\n",
+			ret);
+		return ret;
+	}
+
+	if (index != m2m->ctx->index) {
+		dev_err(dev, "[ctx%d] attempting to start wrong context%d\n",
+			m2m->ctx->index, index);
+		return -EINVAL;
+	}
+
+	dmaengine_terminate_all(ctx->dma_chan[IN]);
+	dmaengine_terminate_all(ctx->dma_chan[OUT]);
+
+	fsl_easrc_stop_context(ctx);
+	m2m->easrc_active = 0;
+
+	return 0;
+}
+
+static long fsl_easrc_ioctl_status(struct fsl_easrc_m2m *m2m,
+				   void __user *user)
+{
+	struct fsl_asrc *asrc = m2m->asrc;
+	struct device *dev = &asrc->pdev->dev;
+	struct fsl_asrc_pair *ctx = m2m->ctx;
+	struct asrc_status_flags flags;
+	int ret;
+
+	ret = copy_from_user(&flags, user, sizeof(flags));
+	if (ret) {
+		dev_err(dev,
+			"[ctx%d] failed to get flags from user space: %d\n",
+			m2m->ctx->index, ret);
+		return ret;
+	}
+
+	if (m2m->ctx->index != flags.index) {
+		dev_err(dev, "[ctx%d] getting status for other context: %d\n",
+			m2m->ctx->index, flags.index);
+		return -EINVAL;
+	}
+
+	fsl_easrc_get_status(ctx, &flags);
+
+	ret = copy_to_user(user, &flags, sizeof(flags));
+	if (ret)
+		dev_err(dev, "[ctx%d] failed to send flags to user space\n",
+			m2m->ctx->index);
+
+	return ret;
+}
+
+static long fsl_easrc_ioctl_flush(struct fsl_easrc_m2m *m2m,
+				  void __user *user)
+{
+	struct fsl_asrc *asrc = m2m->asrc;
+	struct device *dev = &asrc->pdev->dev;
+	struct fsl_asrc_pair *ctx = m2m->ctx;
+
+	/* Release DMA and request again */
+	dma_release_channel(ctx->dma_chan[IN]);
+	dma_release_channel(ctx->dma_chan[OUT]);
+
+	ctx->dma_chan[IN] = fsl_easrc_get_dma_channel(ctx, IN);
+	if (!ctx->dma_chan[IN]) {
+		dev_err(dev, "failed to request input task DMA channel\n");
+		return -EBUSY;
+	}
+
+	ctx->dma_chan[OUT] = fsl_easrc_get_dma_channel(ctx, OUT);
+	if (!ctx->dma_chan[OUT]) {
+		dev_err(dev, "failed to request output task DMA channel\n");
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+static int fsl_easrc_open(struct inode *inode, struct file *file)
+{
+	struct miscdevice *easrc_miscdev = file->private_data;
+	struct fsl_asrc *asrc = dev_get_drvdata(easrc_miscdev->parent);
+	struct fsl_easrc_m2m *m2m;
+	struct fsl_asrc_pair *ctx;
+	struct device *dev = &asrc->pdev->dev;
+	int ret;
+
+	ret = signal_pending(current);
+	if (ret) {
+		dev_err(dev, "current process has a signal pending\n");
+		return ret;
+	}
+
+	ctx = kzalloc(sizeof(*ctx) + asrc->pair_priv_size, GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->private = (void *)ctx + sizeof(struct fsl_asrc_pair);
+
+	/* set the pointer to easrc private data */
+	m2m = kzalloc(sizeof(*m2m), GFP_KERNEL);
+	if (!m2m) {
+		ret = -ENOMEM;
+		goto out;
+	}
+	/* just save the pointer to easrc private data */
+	m2m->asrc = asrc;
+	m2m->ctx = ctx;
+	ctx->asrc = asrc;
+	ctx->private_m2m = m2m;
+
+	spin_lock_init(&m2m->lock);
+	init_completion(&m2m->complete[IN]);
+	init_completion(&m2m->complete[OUT]);
+
+	/* context structs are already allocated in fsl_easrc->ctx[i] */
+	file->private_data = m2m;
+
+	pm_runtime_get_sync(dev);
+
+	return 0;
+out:
+	kfree(ctx);
+	return ret;
+}
+
+static int fsl_easrc_close(struct inode *inode, struct file *file)
+{
+	struct fsl_easrc_m2m *m2m = file->private_data;
+	struct fsl_asrc *asrc = m2m->asrc;
+	struct fsl_asrc_pair *ctx = m2m->ctx;
+	struct device *dev = &asrc->pdev->dev;
+	unsigned long lock_flags;
+
+	if (m2m->easrc_active) {
+		m2m->easrc_active = 0;
+		dmaengine_terminate_all(ctx->dma_chan[IN]);
+		dmaengine_terminate_all(ctx->dma_chan[OUT]);
+
+		fsl_easrc_stop_context(ctx);
+		fsl_easrc_input_dma_callback((void *)m2m);
+		fsl_easrc_output_dma_callback((void *)m2m);
+	}
+
+	if (!ctx)
+		goto null_ctx;
+
+	spin_lock_irqsave(&m2m->lock, lock_flags);
+	if (m2m->ctx_hold) {
+		m2m->ctx_hold = 0;
+		spin_unlock_irqrestore(&m2m->lock, lock_flags);
+
+		if (ctx->dma_chan[IN])
+			dma_release_channel(ctx->dma_chan[IN]);
+		if (ctx->dma_chan[OUT])
+			dma_release_channel(ctx->dma_chan[OUT]);
+
+		kfree(m2m->dma_block[IN].dma_vaddr);
+		kfree(m2m->dma_block[OUT].dma_vaddr);
+
+		fsl_easrc_release_context(ctx);
+	} else {
+		spin_unlock_irqrestore(&m2m->lock, lock_flags);
+	}
+
+null_ctx:
+	spin_lock_irqsave(&asrc->lock, lock_flags);
+	kfree(m2m);
+	kfree(ctx);
+	file->private_data = NULL;
+	spin_unlock_irqrestore(&asrc->lock, lock_flags);
+
+	pm_runtime_put_sync(dev);
+
+	return 0;
+}
+
+static long fsl_easrc_ioctl(struct file *file, unsigned int cmd,
+			    unsigned long arg)
+{
+	struct fsl_easrc_m2m *m2m = file->private_data;
+	struct fsl_asrc *asrc = m2m->asrc;
+	void __user *user = (void __user *)arg;
+	long ret = 0;
+
+	switch (cmd) {
+	case ASRC_REQ_PAIR:
+		ret = fsl_easrc_ioctl_req_context(m2m, user);
+		break;
+	case ASRC_CONFIG_PAIR:
+		ret = fsl_easrc_ioctl_config_context(m2m, user);
+		break;
+	case ASRC_RELEASE_PAIR:
+		ret = fsl_easrc_ioctl_release_context(m2m, user);
+		break;
+	case ASRC_CONVERT:
+		ret = fsl_easrc_ioctl_convert(m2m, user);
+		break;
+	case ASRC_START_CONV:
+		ret = fsl_easrc_ioctl_start_conv(m2m, user);
+		break;
+	case ASRC_STOP_CONV:
+		ret = fsl_easrc_ioctl_stop_conv(m2m, user);
+		break;
+	case ASRC_STATUS:
+		ret = fsl_easrc_ioctl_status(m2m, user);
+		break;
+	case ASRC_FLUSH:
+		ret = fsl_easrc_ioctl_flush(m2m, user);
+		break;
+	default:
+		dev_err(&asrc->pdev->dev, "invalid ioctl command\n");
+	}
+
+	return ret;
+}
+
+static const struct file_operations easrc_fops = {
+	.owner = THIS_MODULE,
+	.unlocked_ioctl = fsl_easrc_ioctl,
+	.open = fsl_easrc_open,
+	.release = fsl_easrc_close,
+};
+
+static int fsl_easrc_m2m_init(struct fsl_asrc *asrc)
+{
+	struct device *dev = &asrc->pdev->dev;
+	int ret;
+
+	asrc->asrc_miscdev.fops = &easrc_fops;
+	asrc->asrc_miscdev.parent = dev;
+	asrc->asrc_miscdev.name = "mxc_asrc";
+	asrc->asrc_miscdev.minor = MISC_DYNAMIC_MINOR;
+	ret = misc_register(&asrc->asrc_miscdev);
+	if (ret)
+		dev_err(dev, "failed to register char device %d\n", ret);
+
+	return ret;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static void fsl_easrc_m2m_suspend(struct fsl_asrc *asrc)
+{
+	struct fsl_asrc_pair *ctx;
+	struct fsl_easrc_m2m *m2m;
+	unsigned long lock_flags;
+	int i;
+
+	for (i = 0; i < EASRC_CTX_MAX_NUM; i++) {
+		spin_lock_irqsave(&asrc->lock, lock_flags);
+		ctx = asrc->pair[i];
+		if (!ctx || !ctx->private_m2m) {
+			spin_unlock_irqrestore(&asrc->lock, lock_flags);
+			continue;
+		}
+		m2m = ctx->private_m2m;
+
+		if (!completion_done(&m2m->complete[IN])) {
+			if (ctx->dma_chan[IN])
+				dmaengine_terminate_all(ctx->dma_chan[IN]);
+			fsl_easrc_input_dma_callback((void *)m2m);
+		}
+		if (!completion_done(&m2m->complete[OUT])) {
+			if (ctx->dma_chan[OUT])
+				dmaengine_terminate_all(ctx->dma_chan[OUT]);
+			fsl_easrc_output_dma_callback((void *)m2m);
+		}
+
+		m2m->first_convert = 1;
+		m2m->in_filled_len = 0;
+		fsl_easrc_stop_context(ctx);
+		spin_unlock_irqrestore(&asrc->lock, lock_flags);
+	}
+}
+
+static void fsl_easrc_m2m_resume(struct fsl_asrc *asrc)
+{
+	/* null */
+}
+#endif
diff --git a/sound/soc/fsl/fsl_esai.c b/sound/soc/fsl/fsl_esai.c
index bda66b30e..39c0fa08d 100644
--- a/sound/soc/fsl/fsl_esai.c
+++ b/sound/soc/fsl/fsl_esai.c
@@ -14,6 +14,7 @@
 #include <sound/pcm_params.h>
 
 #include "fsl_esai.h"
+#include "fsl_esai_mix.h"
 #include "imx-pcm.h"
 
 #define FSL_ESAI_FORMATS	(SNDRV_PCM_FMTBIT_S8 | \
@@ -21,68 +22,6 @@
 				SNDRV_PCM_FMTBIT_S20_3LE | \
 				SNDRV_PCM_FMTBIT_S24_LE)
 
-/**
- * struct fsl_esai_soc_data - soc specific data
- * @reset_at_xrun: flags for enable reset operaton
- */
-struct fsl_esai_soc_data {
-	bool reset_at_xrun;
-};
-
-/**
- * struct fsl_esai - ESAI private data
- * @dma_params_rx: DMA parameters for receive channel
- * @dma_params_tx: DMA parameters for transmit channel
- * @pdev: platform device pointer
- * @regmap: regmap handler
- * @coreclk: clock source to access register
- * @extalclk: esai clock source to derive HCK, SCK and FS
- * @fsysclk: system clock source to derive HCK, SCK and FS
- * @spbaclk: SPBA clock (optional, depending on SoC design)
- * @work: work to handle the reset operation
- * @soc: soc specific data
- * @lock: spin lock between hw_reset() and trigger()
- * @fifo_depth: depth of tx/rx FIFO
- * @slot_width: width of each DAI slot
- * @slots: number of slots
- * @tx_mask: slot mask for TX
- * @rx_mask: slot mask for RX
- * @channels: channel num for tx or rx
- * @hck_rate: clock rate of desired HCKx clock
- * @sck_rate: clock rate of desired SCKx clock
- * @hck_dir: the direction of HCKx pads
- * @sck_div: if using PSR/PM dividers for SCKx clock
- * @slave_mode: if fully using DAI slave mode
- * @synchronous: if using tx/rx synchronous mode
- * @name: driver name
- */
-struct fsl_esai {
-	struct snd_dmaengine_dai_dma_data dma_params_rx;
-	struct snd_dmaengine_dai_dma_data dma_params_tx;
-	struct platform_device *pdev;
-	struct regmap *regmap;
-	struct clk *coreclk;
-	struct clk *extalclk;
-	struct clk *fsysclk;
-	struct clk *spbaclk;
-	struct work_struct work;
-	const struct fsl_esai_soc_data *soc;
-	spinlock_t lock; /* Protect hw_reset and trigger */
-	u32 fifo_depth;
-	u32 slot_width;
-	u32 slots;
-	u32 tx_mask;
-	u32 rx_mask;
-	u32 channels[2];
-	u32 hck_rate[2];
-	u32 sck_rate[2];
-	bool hck_dir[2];
-	bool sck_div[2];
-	bool slave_mode;
-	bool synchronous;
-	char name[32];
-};
-
 static struct fsl_esai_soc_data fsl_esai_vf610 = {
 	.reset_at_xrun = true,
 };
@@ -119,10 +58,10 @@ static irqreturn_t esai_isr(int irq, void *devid)
 		dev_dbg(&pdev->dev, "isr: Transmission Initialized\n");
 
 	if (esr & ESAI_ESR_RFF_MASK)
-		dev_warn(&pdev->dev, "isr: Receiving overrun\n");
+		dev_dbg(&pdev->dev, "isr: Receiving overrun\n");
 
 	if (esr & ESAI_ESR_TFE_MASK)
-		dev_warn(&pdev->dev, "isr: Transmission underrun\n");
+		dev_dbg(&pdev->dev, "isr: Transmission underrun\n");
 
 	if (esr & ESAI_ESR_TLS_MASK)
 		dev_dbg(&pdev->dev, "isr: Just transmitted the last slot\n");
@@ -367,7 +306,7 @@ static int fsl_esai_set_bclk(struct snd_soc_dai *dai, bool tx, u32 freq)
 	int ret;
 
 	/* Don't apply for fully slave mode or unchanged bclk */
-	if (esai_priv->slave_mode || esai_priv->sck_rate[tx] == freq)
+	if (esai_priv->slave_mode[tx] || esai_priv->sck_rate[tx] == freq)
 		return 0;
 
 	if (ratio * freq > hck_rate)
@@ -476,35 +415,62 @@ static int fsl_esai_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)
 		return -EINVAL;
 	}
 
-	esai_priv->slave_mode = false;
+	if (esai_priv->slave_mode[0] == esai_priv->slave_mode[1]) {
+		/* DAI clock master masks */
+		switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+		case SND_SOC_DAIFMT_CBM_CFM:
+			esai_priv->slave_mode[0] = true;
+			esai_priv->slave_mode[1] = true;
+			break;
+		case SND_SOC_DAIFMT_CBS_CFM:
+			xccr |= ESAI_xCCR_xCKD;
+			break;
+		case SND_SOC_DAIFMT_CBM_CFS:
+			xccr |= ESAI_xCCR_xFSD;
+			break;
+		case SND_SOC_DAIFMT_CBS_CFS:
+			xccr |= ESAI_xCCR_xFSD | ESAI_xCCR_xCKD;
+			esai_priv->slave_mode[0] = false;
+			esai_priv->slave_mode[1] = false;
+			break;
+		default:
+			return -EINVAL;
+		}
 
-	/* DAI clock master masks */
-	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
-	case SND_SOC_DAIFMT_CBM_CFM:
-		esai_priv->slave_mode = true;
-		break;
-	case SND_SOC_DAIFMT_CBS_CFM:
-		xccr |= ESAI_xCCR_xCKD;
-		break;
-	case SND_SOC_DAIFMT_CBM_CFS:
-		xccr |= ESAI_xCCR_xFSD;
-		break;
-	case SND_SOC_DAIFMT_CBS_CFS:
-		xccr |= ESAI_xCCR_xFSD | ESAI_xCCR_xCKD;
-		break;
-	default:
-		return -EINVAL;
+		mask = ESAI_xCCR_xCKP | ESAI_xCCR_xHCKP | ESAI_xCCR_xFSP |
+			ESAI_xCCR_xFSD | ESAI_xCCR_xCKD;
+		regmap_update_bits(esai_priv->regmap,
+					REG_ESAI_TCCR, mask, xccr);
+		regmap_update_bits(esai_priv->regmap,
+					REG_ESAI_RCCR, mask, xccr);
+
+	} else {
+
+		mask = ESAI_xCCR_xCKP | ESAI_xCCR_xHCKP | ESAI_xCCR_xFSP |
+			ESAI_xCCR_xFSD | ESAI_xCCR_xCKD;
+		if (esai_priv->slave_mode[0])
+			regmap_update_bits(esai_priv->regmap,
+					REG_ESAI_RCCR, mask, xccr);
+		else
+			regmap_update_bits(esai_priv->regmap, REG_ESAI_RCCR,
+						mask,
+						xccr | ESAI_xCCR_xFSD |
+							ESAI_xCCR_xCKD);
+
+		if (esai_priv->slave_mode[1])
+			regmap_update_bits(esai_priv->regmap,
+						REG_ESAI_TCCR, mask, xccr);
+		else
+			regmap_update_bits(esai_priv->regmap, REG_ESAI_TCCR,
+						mask,
+						xccr | ESAI_xCCR_xFSD |
+							ESAI_xCCR_xCKD);
 	}
 
 	mask = ESAI_xCR_xFSL | ESAI_xCR_xFSR | ESAI_xCR_xWA;
 	regmap_update_bits(esai_priv->regmap, REG_ESAI_TCR, mask, xcr);
 	regmap_update_bits(esai_priv->regmap, REG_ESAI_RCR, mask, xcr);
 
-	mask = ESAI_xCCR_xCKP | ESAI_xCCR_xHCKP | ESAI_xCCR_xFSP |
-		ESAI_xCCR_xFSD | ESAI_xCCR_xCKD;
-	regmap_update_bits(esai_priv->regmap, REG_ESAI_TCCR, mask, xccr);
-	regmap_update_bits(esai_priv->regmap, REG_ESAI_RCCR, mask, xccr);
-
 	return 0;
 }
 
@@ -512,6 +478,7 @@ static int fsl_esai_startup(struct snd_pcm_substream *substream,
 			    struct snd_soc_dai *dai)
 {
 	struct fsl_esai *esai_priv = snd_soc_dai_get_drvdata(dai);
+	bool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;
 
 	if (!snd_soc_dai_active(dai)) {
 		/* Set synchronous mode */
@@ -528,10 +495,23 @@ static int fsl_esai_startup(struct snd_pcm_substream *substream,
 				   ESAI_xCCR_xDC(esai_priv->slots));
 	}
 
+	if (esai_priv->sw_mix)
+		fsl_esai_mix_open(substream, &esai_priv->mix[tx]);
+
 	return 0;
 
 }
 
+static void fsl_esai_shutdown(struct snd_pcm_substream *substream,
+			      struct snd_soc_dai *dai)
+{
+	struct fsl_esai *esai_priv = snd_soc_dai_get_drvdata(dai);
+	bool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;
+
+	if (esai_priv->sw_mix)
+		fsl_esai_mix_close(substream, &esai_priv->mix[tx]);
+}
+
 static int fsl_esai_hw_params(struct snd_pcm_substream *substream,
 			      struct snd_pcm_hw_params *params,
 			      struct snd_soc_dai *dai)
@@ -587,6 +567,10 @@ static int fsl_esai_hw_params(struct snd_pcm_substream *substream,
 			   ESAI_PRRC_PDC_MASK, ESAI_PRRC_PDC(ESAI_GPIO));
 	regmap_update_bits(esai_priv->regmap, REG_ESAI_PCRC,
 			   ESAI_PCRC_PC_MASK, ESAI_PCRC_PC(ESAI_GPIO));
+
+	if (esai_priv->sw_mix)
+		fsl_esai_mix_hw_params(substream, params, &esai_priv->mix[tx]);
+
 	return 0;
 }
 
@@ -760,13 +744,23 @@ static int fsl_esai_trigger(struct snd_pcm_substream *substream, int cmd,
 	struct fsl_esai *esai_priv = snd_soc_dai_get_drvdata(dai);
 	bool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;
 	unsigned long lock_flags;
+	u32 state;
 
-	esai_priv->channels[tx] = substream->runtime->channels;
+	if (esai_priv->sw_mix)
+		esai_priv->channels[tx] = esai_priv->mix[tx].channels;
+	else
+		esai_priv->channels[tx] = substream->runtime->channels;
 
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_RESUME:
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (esai_priv->sw_mix) {
+			state = atomic_cmpxchg(&esai_priv->mix[tx].active, 0, 1);
+			if (!state)
+				fsl_esai_mix_trigger(substream, cmd, &esai_priv->mix[tx]);
+		}
+
 		spin_lock_irqsave(&esai_priv->lock, lock_flags);
 		fsl_esai_trigger_start(esai_priv, tx);
 		spin_unlock_irqrestore(&esai_priv->lock, lock_flags);
@@ -774,6 +768,12 @@ static int fsl_esai_trigger(struct snd_pcm_substream *substream, int cmd,
 	case SNDRV_PCM_TRIGGER_SUSPEND:
 	case SNDRV_PCM_TRIGGER_STOP:
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (esai_priv->sw_mix) {
+			state = atomic_cmpxchg(&esai_priv->mix[tx].active, 1, 0);
+			if (state)
+				fsl_esai_mix_trigger(substream, cmd, &esai_priv->mix[tx]);
+		}
+
 		spin_lock_irqsave(&esai_priv->lock, lock_flags);
 		fsl_esai_trigger_stop(esai_priv, tx);
 		spin_unlock_irqrestore(&esai_priv->lock, lock_flags);
@@ -787,6 +787,7 @@ static int fsl_esai_trigger(struct snd_pcm_substream *substream, int cmd,
 
 static const struct snd_soc_dai_ops fsl_esai_dai_ops = {
 	.startup = fsl_esai_startup,
+	.shutdown = fsl_esai_shutdown,
 	.trigger = fsl_esai_trigger,
 	.hw_params = fsl_esai_hw_params,
 	.set_sysclk = fsl_esai_set_dai_sysclk,
@@ -1016,9 +1017,6 @@ static int fsl_esai_probe(struct platform_device *pdev)
 	/* Set a default slot number */
 	esai_priv->slots = 2;
 
-	/* Set a default master/slave state */
-	esai_priv->slave_mode = true;
-
 	/* Determine the FIFO depth */
 	iprop = of_get_property(np, "fsl,fifo-depth", NULL);
 	if (iprop)
@@ -1034,6 +1032,20 @@ static int fsl_esai_probe(struct platform_device *pdev)
 	esai_priv->synchronous =
 		of_property_read_bool(np, "fsl,esai-synchronous");
 
+	if (!esai_priv->synchronous) {
+		if (of_property_read_bool(pdev->dev.of_node, "fsl,txm-rxs")) {
+			/* 0 --  rx,  1 -- tx */
+			esai_priv->slave_mode[0] = true;
+			esai_priv->slave_mode[1] = false;
+		}
+
+		if (of_property_read_bool(pdev->dev.of_node, "fsl,txs-rxm")) {
+			/* 0 --  rx,  1 -- tx */
+			esai_priv->slave_mode[0] = false;
+			esai_priv->slave_mode[1] = true;
+		}
+	}
+
 	/* Implement full symmetry for synchronous mode */
 	if (esai_priv->synchronous) {
 		fsl_esai_dai.symmetric_rate = 1;
@@ -1077,10 +1089,19 @@ static int fsl_esai_probe(struct platform_device *pdev)
 	 * Register platform component before registering cpu dai for there
 	 * is not defer probe for platform component in snd_soc_add_pcm_runtime().
 	 */
-	ret = imx_pcm_dma_init(pdev, IMX_ESAI_DMABUF_SIZE);
-	if (ret) {
-		dev_err(&pdev->dev, "failed to init imx pcm dma: %d\n", ret);
-		goto err_pm_get_sync;
+	if (of_property_read_bool(pdev->dev.of_node, "client-dais")) {
+		esai_priv->sw_mix = true;
+		ret = fsl_esai_mix_probe(&pdev->dev, &esai_priv->mix[0], &esai_priv->mix[1]);
+		if (ret) {
+			dev_err(&pdev->dev, "failed to init imx pcm dma: %d\n", ret);
+			goto err_pm_get_sync;
+		}
+	} else {
+		ret = imx_pcm_dma_init(pdev, IMX_ESAI_DMABUF_SIZE);
+		if (ret) {
+			dev_err(&pdev->dev, "failed to init imx pcm dma: %d\n", ret);
+			goto err_pm_get_sync;
+		}
 	}
 
 	ret = devm_snd_soc_register_component(&pdev->dev, &fsl_esai_component,
@@ -1106,6 +1127,9 @@ static int fsl_esai_remove(struct platform_device *pdev)
 {
 	struct fsl_esai *esai_priv = platform_get_drvdata(pdev);
 
+	if (esai_priv->sw_mix)
+		fsl_esai_mix_remove(&pdev->dev, &esai_priv->mix[0], &esai_priv->mix[1]);
+
 	pm_runtime_disable(&pdev->dev);
 	if (!pm_runtime_status_suspended(&pdev->dev))
 		fsl_esai_runtime_suspend(&pdev->dev);
diff --git a/sound/soc/fsl/fsl_esai.h b/sound/soc/fsl/fsl_esai.h
index f873588d9..475c3483f 100644
--- a/sound/soc/fsl/fsl_esai.h
+++ b/sound/soc/fsl/fsl_esai.h
@@ -10,6 +10,9 @@
 #ifndef _FSL_ESAI_DAI_H
 #define _FSL_ESAI_DAI_H
 
+#include <sound/dmaengine_pcm.h>
+#include "fsl_esai_mix.h"
+
 /* ESAI Register Map */
 #define REG_ESAI_ETDR		0x00
 #define REG_ESAI_ERDR		0x04
@@ -348,4 +351,68 @@
 #define ESAI_RX_DIV_PSR		3
 #define ESAI_RX_DIV_PM		4
 #define ESAI_RX_DIV_FP		5
+
+/**
+ * struct fsl_esai_soc_data - soc specific data
+ * @reset_at_xrun: flags for enable reset operaton
+ */
+struct fsl_esai_soc_data {
+	bool reset_at_xrun;
+};
+
+/**
+ * struct fsl_esai - ESAI private data
+ * @dma_params_rx: DMA parameters for receive channel
+ * @dma_params_tx: DMA parameters for transmit channel
+ * @pdev: platform device pointer
+ * @regmap: regmap handler
+ * @coreclk: clock source to access register
+ * @extalclk: esai clock source to derive HCK, SCK and FS
+ * @fsysclk: system clock source to derive HCK, SCK and FS
+ * @spbaclk: SPBA clock (optional, depending on SoC design)
+ * @task: tasklet to handle the reset operation
+ * @soc: soc specific data
+ * @lock: spin lock between hw_reset() and trigger()
+ * @fifo_depth: depth of tx/rx FIFO
+ * @slot_width: width of each DAI slot
+ * @slots: number of slots
+ * @tx_mask: slot mask for TX
+ * @rx_mask: slot mask for RX
+ * @channels: channel num for tx or rx
+ * @hck_rate: clock rate of desired HCKx clock
+ * @sck_rate: clock rate of desired SCKx clock
+ * @hck_dir: the direction of HCKx pads
+ * @sck_div: if using PSR/PM dividers for SCKx clock
+ * @slave_mode: if fully using DAI slave mode
+ * @synchronous: if using tx/rx synchronous mode
+ * @name: driver name
+ */
+struct fsl_esai {
+	struct snd_dmaengine_dai_dma_data dma_params_rx;
+	struct snd_dmaengine_dai_dma_data dma_params_tx;
+	struct platform_device *pdev;
+	struct regmap *regmap;
+	struct clk *coreclk;
+	struct clk *extalclk;
+	struct clk *fsysclk;
+	struct clk *spbaclk;
+	struct work_struct work;
+	const struct fsl_esai_soc_data *soc;
+	struct fsl_esai_mix mix[2];
+	spinlock_t lock; /* Protect hw_reset and trigger */
+	u32 fifo_depth;
+	u32 slot_width;
+	u32 slots;
+	u32 tx_mask;
+	u32 rx_mask;
+	u32 channels[2];
+	u32 hck_rate[2];
+	u32 sck_rate[2];
+	bool hck_dir[2];
+	bool sck_div[2];
+	bool slave_mode[2];
+	bool synchronous;
+	bool sw_mix;
+	char name[32];
+};
 #endif /* _FSL_ESAI_DAI_H */
diff --git a/sound/soc/fsl/fsl_esai_client.c b/sound/soc/fsl/fsl_esai_client.c
new file mode 100644
index 000000000..e43bbb46b
--- /dev/null
+++ b/sound/soc/fsl/fsl_esai_client.c
@@ -0,0 +1,254 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright 2019 NXP
+/*
+ * Just allocate memory for FE
+ *
+ */
+#include <linux/dma-mapping.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/dmaengine_pcm.h>
+#include <sound/soc.h>
+
+#include "fsl_esai_client.h"
+#include "imx-pcm.h"
+
+static struct snd_pcm_hardware fsl_esai_client_pcm_hardware = {
+	.info = SNDRV_PCM_INFO_INTERLEAVED |
+		SNDRV_PCM_INFO_BLOCK_TRANSFER |
+		SNDRV_PCM_INFO_MMAP |
+		SNDRV_PCM_INFO_MMAP_VALID,
+	.buffer_bytes_max = IMX_SSI_DMABUF_SIZE,
+	.period_bytes_min = 2048,	/* fix period size, for alignment in FE/BE */
+	.period_bytes_max = 2048,
+	.periods_min = 8,		/* periods > 4 ( 4 buffer in BE) */
+	.periods_max = 255,
+	.fifo_size = 0,
+};
+
+static int fsl_esai_client_pcm_hw_params(struct snd_soc_component *component,
+					 struct snd_pcm_substream *substream,
+					 struct snd_pcm_hw_params *params)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);
+	struct fsl_esai_client *client = snd_soc_dai_get_drvdata(cpu_dai);
+	bool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;
+
+	snd_pcm_set_runtime_buffer(substream, &client->dma[tx].dma_buffer);
+	runtime->dma_bytes = params_buffer_bytes(params);
+
+	client->dma[tx].channels   = params_channels(params);
+	client->dma[tx].word_width = snd_pcm_format_physical_width(params_format(params)) / 8;
+
+	return 0;
+}
+
+static int fsl_esai_client_pcm_hw_free(struct snd_soc_component *component,
+				       struct snd_pcm_substream *substream)
+{
+	snd_pcm_set_runtime_buffer(substream, NULL);
+
+	return 0;
+}
+
+static snd_pcm_uframes_t fsl_esai_client_pcm_pointer(struct snd_soc_component *component,
+						     struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);
+	struct fsl_esai_client *client = snd_soc_dai_get_drvdata(cpu_dai);
+	bool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;
+
+	return bytes_to_frames(substream->runtime, client->dma[tx].buffer_offset);
+}
+
+static int fsl_esai_client_pcm_open(struct snd_soc_component *component,
+				    struct snd_pcm_substream *substream)
+{
+	int ret;
+
+	snd_soc_set_runtime_hwparams(substream, &fsl_esai_client_pcm_hardware);
+
+	ret = snd_pcm_hw_constraint_integer(substream->runtime,
+					    SNDRV_PCM_HW_PARAM_PERIODS);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+int fsl_esai_client_pcm_trigger(struct snd_soc_component *component,
+				struct snd_pcm_substream *substream, int cmd)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);
+	struct fsl_esai_client *client = snd_soc_dai_get_drvdata(cpu_dai);
+	bool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		/* These info are needed by esai mix*/
+		client->dma[tx].buffer_bytes = snd_pcm_lib_buffer_bytes(substream);
+		client->dma[tx].period_bytes = snd_pcm_lib_period_bytes(substream);
+		client->dma[tx].buffer_offset = 0;
+		client->dma[tx].active = true;
+		break;
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+	case SNDRV_PCM_TRIGGER_STOP:
+		client->dma[tx].active = false;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int fsl_esai_client_pcm_mmap(struct snd_soc_component *component,
+				    struct snd_pcm_substream *substream,
+				    struct vm_area_struct *vma)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	return dma_mmap_wc(substream->pcm->card->dev, vma,
+			   runtime->dma_area,
+			   runtime->dma_addr,
+			   runtime->dma_bytes);
+}
+
+static int fsl_esai_client_pcm_new(struct snd_soc_component *component,
+				   struct snd_soc_pcm_runtime *rtd)
+{
+	return 0;
+}
+
+static const struct snd_soc_component_driver fsl_esai_client_pcm_platform = {
+	.name           = "fsl_esai_client_pcm",
+	.pcm_construct	= fsl_esai_client_pcm_new,
+	.open		= fsl_esai_client_pcm_open,
+	.hw_params	= fsl_esai_client_pcm_hw_params,
+	.hw_free	= fsl_esai_client_pcm_hw_free,
+	.pointer	= fsl_esai_client_pcm_pointer,
+	.mmap		= fsl_esai_client_pcm_mmap,
+	.trigger        = fsl_esai_client_pcm_trigger,
+};
+
+static const struct snd_soc_component_driver fsl_esai_client_component = {
+	.name		= "fsl-esai-client",
+};
+
+/* Fix the sample rate/format/channels, for we don't support
+ * conversion when do mixing.
+ */
+#define FSL_ESAI_CLIENT_RATES	SNDRV_PCM_RATE_48000
+#define FSL_ESAI_CLIENT_FORMATS	(SNDRV_PCM_FMTBIT_S16_LE)
+
+static struct snd_soc_dai_driver fsl_esai_client_dai_template = {
+	.name = "fsl-esai-client-dai",
+	.playback = {
+		.stream_name	= "CLIENT-Playback",
+		.channels_min	= 2,
+		.channels_max	= 2,
+		.rates		= FSL_ESAI_CLIENT_RATES,
+		.formats	= FSL_ESAI_CLIENT_FORMATS,
+	},
+	.capture = {
+		.stream_name	= "CLIENT-Capture",
+		.channels_min	= 2,
+		.channels_max	= 2,
+		.rates = FSL_ESAI_CLIENT_RATES,
+		.formats = FSL_ESAI_CLIENT_FORMATS,
+	},
+};
+
+static int fsl_esai_client_probe(struct platform_device *pdev)
+{
+	struct fsl_esai_client *client;
+	int ret;
+
+	client = devm_kzalloc(&pdev->dev, sizeof(*client), GFP_KERNEL);
+	if (!client)
+		return -ENOMEM;
+
+	memcpy(&client->cpu_dai_drv, &fsl_esai_client_dai_template,
+	       sizeof(fsl_esai_client_dai_template));
+
+	platform_set_drvdata(pdev, client);
+
+	ret = of_property_read_u32(pdev->dev.of_node, "fsl,client-id", &client->id);
+	if (ret < 0)
+		return ret;
+
+	if (client->id == 0) {
+		client->cpu_dai_drv.name = "fsl-client0-dai";
+		client->cpu_dai_drv.playback.stream_name = "CLIENT0-Playback";
+		client->cpu_dai_drv.capture.stream_name = "CLIENT0-Capture";
+	}
+
+	if (client->id == 1) {
+		client->cpu_dai_drv.name = "fsl-client1-dai";
+		client->cpu_dai_drv.playback.stream_name = "CLIENT1-Playback";
+		client->cpu_dai_drv.capture.stream_name = "CLIENT1-Capture";
+	}
+
+	/* alloc memory for user read data from it. rx. */
+	ret = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV,
+				  &pdev->dev,
+				  fsl_esai_client_pcm_hardware.buffer_bytes_max,
+				  &client->dma[0].dma_buffer);
+	if (ret)
+		return ret;
+
+	/* alloc memory for user write data from it. tx. */
+	ret = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV,
+				  &pdev->dev,
+				  fsl_esai_client_pcm_hardware.buffer_bytes_max,
+				  &client->dma[1].dma_buffer);
+	if (ret)
+		return ret;
+
+	ret = devm_snd_soc_register_component(&pdev->dev,
+					      &fsl_esai_client_component, &client->cpu_dai_drv, 1);
+	if (ret < 0)
+		return ret;
+
+	return devm_snd_soc_register_component(&pdev->dev, &fsl_esai_client_pcm_platform, NULL, 0);
+}
+
+static int fsl_esai_client_remove(struct platform_device *pdev)
+{
+	struct fsl_esai_client *client = platform_get_drvdata(pdev);
+
+	snd_dma_free_pages(&client->dma[1].dma_buffer);
+	snd_dma_free_pages(&client->dma[0].dma_buffer);
+
+	return 0;
+}
+
+static const struct of_device_id fsl_esai_client_ids[] = {
+	{ .compatible = "fsl,esai-client", },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, fsl_esai_client_ids);
+
+static struct platform_driver fsl_esai_client_driver = {
+	.probe = fsl_esai_client_probe,
+	.remove = fsl_esai_client_remove,
+	.driver = {
+		.name = "fsl-esai-client",
+		.of_match_table = fsl_esai_client_ids,
+	},
+};
+module_platform_driver(fsl_esai_client_driver);
+
+MODULE_DESCRIPTION("client cpu dai Interface");
+MODULE_ALIAS("platform:fsl-esai-client");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/fsl/fsl_esai_client.h b/sound/soc/fsl/fsl_esai_client.h
new file mode 100644
index 000000000..684300383
--- /dev/null
+++ b/sound/soc/fsl/fsl_esai_client.h
@@ -0,0 +1,40 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+#ifndef __FSL_ESAI_CLIENT_H
+#define __FSL_ESAI_CLIENT_H
+
+/**
+ * fsl_esai_client_dma: esai dma client
+ * @dma_buffer: structure of dma buffer
+ * @buffer_bytes: buffer size in bytes
+ * @period_bytes: period size in bytes
+ * @period_num: period number
+ * @buffer_offset: read offset of buffer
+ * @channels: channel number
+ * @word_width: word width in bytes
+ * @active: dma transfer is active
+ */
+struct fsl_esai_client_dma {
+	struct snd_dma_buffer dma_buffer;
+	int   buffer_bytes;
+	int   period_bytes;
+	int   period_num;
+	int   buffer_offset;
+	int   channels;
+	int   word_width;
+	bool  active;
+};
+
+/**
+ * fsl_esai_client: esai client
+ * @cpu_dai_drv: CPU DAI driver for this device
+ * @dma: dma instance for playback and capture
+ * @id: client index
+ */
+struct fsl_esai_client {
+	struct snd_soc_dai_driver cpu_dai_drv;
+	struct fsl_esai_client_dma dma[2];
+	int id;
+};
+
+#endif /* __FSL_ESAI_CLIENT_H */
diff --git a/sound/soc/fsl/fsl_esai_mix.c b/sound/soc/fsl/fsl_esai_mix.c
new file mode 100644
index 000000000..e5c2c053f
--- /dev/null
+++ b/sound/soc/fsl/fsl_esai_mix.c
@@ -0,0 +1,479 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright 2019 NXP
+/*
+ * Support mix two streams for ESAI
+ *
+ */
+#include <linux/dma-mapping.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/workqueue.h>
+#include <linux/kthread.h>
+#include <linux/freezer.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/dmaengine_pcm.h>
+#include <sound/soc.h>
+
+#include "imx-pcm.h"
+#include "fsl_esai_client.h"
+#include "fsl_esai.h"
+#include "fsl_esai_mix.h"
+
+int fsl_esai_mix_hw_params(struct snd_pcm_substream *substream,
+			   struct snd_pcm_hw_params *params,
+			   struct fsl_esai_mix *mix)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_dmaengine_dai_dma_data *dma_data;
+	struct dma_slave_config config = {0};
+	int err = 0;
+
+	mix->channels   = params_channels(params);
+	mix->word_width = snd_pcm_format_physical_width(params_format(params)) / 8;
+
+	dma_data = snd_soc_dai_get_dma_data(asoc_rtd_to_cpu(rtd, 0), substream);
+	if (!dma_data)
+		return 0;
+
+	/* fills in addr_width and direction */
+	err = snd_hwparams_to_dma_slave_config(substream, params, &config);
+	if (err)
+		return err;
+
+	snd_dmaengine_pcm_set_config_from_dai_data(substream,
+						   dma_data,
+						   &config);
+
+	return dmaengine_slave_config(mix->chan, &config);
+}
+
+int fsl_esai_mix_open(struct snd_pcm_substream *substream, struct fsl_esai_mix *mix)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_dmaengine_dai_dma_data *dma_data;
+
+	dma_data = snd_soc_dai_get_dma_data(asoc_rtd_to_cpu(rtd, 0), substream);
+
+	mix->chan = dma_request_slave_channel(asoc_rtd_to_cpu(rtd, 0)->dev,
+					      dma_data->chan_name);
+
+	return 0;
+}
+
+int fsl_esai_mix_close(struct snd_pcm_substream *substream,
+		       struct fsl_esai_mix *mix)
+{
+	dmaengine_synchronize(mix->chan);
+	dma_release_channel(mix->chan);
+
+	return 0;
+}
+
+static int fsl_esai_mix_pointer(struct fsl_esai_mix *mix)
+{
+	struct dma_tx_state state;
+	enum dma_status status;
+	unsigned int buf_size;
+	unsigned int pos = 0;
+
+	status = dmaengine_tx_status(mix->chan, mix->cookie, &state);
+	if (status == DMA_IN_PROGRESS || status == DMA_PAUSED) {
+		buf_size = mix->buffer_bytes;
+		if (state.residue > 0 && state.residue <= buf_size)
+			pos = buf_size - state.residue;
+	}
+
+	return pos;
+}
+
+static int fsl_esai_tx_avail(struct fsl_esai_mix *mix)
+{
+	int avail;
+
+	mix->buffer_read_offset = fsl_esai_mix_pointer(mix);
+
+	avail = mix->buffer_bytes - mix->buffer_write_offset + mix->buffer_read_offset;
+	if (avail < 0)
+		avail += mix->buffer_bytes;
+	else if (avail > mix->buffer_bytes)
+		avail -=  mix->buffer_bytes;
+
+	return avail;
+}
+
+static int fsl_esai_rx_avail(struct fsl_esai_mix *mix)
+{
+	int avail;
+
+	mix->buffer_write_offset = fsl_esai_mix_pointer(mix);
+
+	avail = mix->buffer_bytes - mix->buffer_read_offset + mix->buffer_write_offset;
+	if (avail < 0)
+		avail += mix->buffer_bytes;
+	else if (avail > mix->buffer_bytes)
+		avail = avail -  mix->buffer_bytes;
+
+	return avail;
+}
+
+static void fsl_esai_mix_buffer_from_fe_tx(struct snd_pcm_substream *substream, bool elapse)
+{
+	bool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);
+	struct fsl_esai *esai = snd_soc_dai_get_drvdata(cpu_dai);
+	struct fsl_esai_mix *mix = &esai->mix[tx];
+	struct fsl_esai_client *client;
+	struct fsl_esai_client_dma *client_dma;
+	struct snd_soc_dpcm *dpcm;
+	unsigned long flags;
+	int sample_offset = 0;
+	int client_chn = 0;
+	int mix_chn = 0;
+	int sdo_cnt = 0;
+	int loop_cnt = 0;
+	int avail = 0;
+	int size = 0;
+	int id = 0;
+	int i = 0, j = 0;
+	int dst_idx;
+	u16 *src16;
+	u16 *dst16;
+
+	for (j = 0; j < MAX_CLIENT_NUM; j++) {
+		mix->fe_substream[j] = NULL;
+		mix->client[j] = NULL;
+	}
+
+	/* Get the active client */
+	spin_lock_irqsave(&rtd->card->dpcm_lock, flags);
+	for_each_dpcm_fe(rtd, substream->stream, dpcm) {
+		if (dpcm->be != rtd)
+			continue;
+
+		mix->fe_substream[i] = snd_soc_dpcm_get_substream(dpcm->fe, substream->stream);
+		mix->client[i] = snd_soc_dai_get_drvdata(asoc_rtd_to_cpu(dpcm->fe, 0));
+
+		i++;
+		if (i >= MAX_CLIENT_NUM)
+			break;
+	}
+	spin_unlock_irqrestore(&rtd->card->dpcm_lock, flags);
+
+	avail = fsl_esai_tx_avail(mix);
+	if (avail >= mix->buffer_bytes && elapse)
+		dev_err(asoc_rtd_to_cpu(rtd, 0)->dev, "mix underrun\n");
+
+	while (avail >= mix->period_bytes) {
+		size = mix->period_bytes;
+		/* mix->word_width == client->word_width */
+		/* Mix the internal buffer */
+		dst16 = (u16 *)(mix->dma_buffer.area + (mix->buffer_write_offset % mix->buffer_bytes));
+		memset(dst16, 0, size);
+
+		for (i = 0;  i < mix->client_cnt;  i++) {
+			if (!mix->client[i])
+				continue;
+
+			client = mix->client[i];
+			client_dma = &client->dma[tx];
+
+			/* check client is active ? */
+			if (client_dma->active) {
+				sample_offset = 0;
+				id = client->id;
+				sdo_cnt = mix->sdo_cnt;
+				client_chn = client_dma->channels;
+				mix_chn = mix->channels;
+				loop_cnt = size / mix->word_width / mix_chn;
+
+				src16 = (u16 *)(client_dma->dma_buffer.area + client_dma->buffer_offset);
+				dst16 = (u16 *)(mix->dma_buffer.area + (mix->buffer_write_offset % mix->buffer_bytes));
+				while (sample_offset < loop_cnt) {
+
+					/* mix the data and reorder it for correct pin */
+					for (j = 0; j < client_chn; j++) {
+						dst_idx = id + j * sdo_cnt;
+						dst16[dst_idx] = *src16++;
+					}
+
+					sample_offset++;
+					dst16 = dst16 + mix_chn;
+				}
+
+				sample_offset = client_dma->buffer_offset + size / mix->client_cnt;
+				sample_offset = sample_offset % client_dma->buffer_bytes;
+				client_dma->buffer_offset = sample_offset;
+
+				if (elapse && mix->fe_substream[i])
+					snd_pcm_period_elapsed(mix->fe_substream[i]);
+			}
+		}
+
+		mix->buffer_write_offset += size;
+		if (mix->buffer_write_offset >= mix->buffer_bytes)
+			mix->buffer_write_offset -= mix->buffer_bytes;
+
+		avail -= mix->period_bytes;
+	}
+}
+
+static void fsl_esai_split_buffer_from_be_rx(struct snd_pcm_substream *substream, bool elapse)
+{
+	bool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);
+	struct fsl_esai *esai = snd_soc_dai_get_drvdata(cpu_dai);
+	struct fsl_esai_mix *mix = &esai->mix[tx];
+	struct fsl_esai_client *client;
+	struct fsl_esai_client_dma *client_dma;
+	struct snd_soc_dpcm *dpcm;
+	unsigned long flags;
+	int sample_offset = 0;
+	int client_chn = 0;
+	int mix_chn = 0;
+	int sdi_cnt = 0;
+	int loop_cnt = 0;
+	int id = 0;
+	int size = 0;
+	int avail = 0;
+	int i = 0, j = 0;
+	int src_idx;
+	u16 *src16;
+	u16 *dst16;
+
+	for (j = 0; j < MAX_CLIENT_NUM; j++) {
+		mix->fe_substream[j] = NULL;
+		mix->client[j] = NULL;
+	}
+	/* Get the active client */
+	spin_lock_irqsave(&rtd->card->dpcm_lock, flags);
+	for_each_dpcm_fe(rtd, substream->stream, dpcm) {
+		if (dpcm->be != rtd)
+			continue;
+
+		mix->fe_substream[i] = snd_soc_dpcm_get_substream(dpcm->fe, substream->stream);
+		mix->client[i] = snd_soc_dai_get_drvdata(asoc_rtd_to_cpu(dpcm->fe, 0));
+
+		i++;
+		if (i >= MAX_CLIENT_NUM)
+			break;
+	}
+	spin_unlock_irqrestore(&rtd->card->dpcm_lock, flags);
+
+	avail = fsl_esai_rx_avail(mix);
+	if (avail >= mix->buffer_bytes && elapse)
+		dev_err(asoc_rtd_to_cpu(rtd, 0)->dev, "mix overrun\n");
+
+	while (avail >= mix->period_bytes) {
+		size = mix->period_bytes;
+		/* mix->word_width == client->word_width */
+		/* split the internal buffer */
+		for (i = 0;  i < mix->client_cnt;  i++) {
+			if (!mix->client[i])
+				continue;
+
+			client = mix->client[i];
+			client_dma = &client->dma[tx];
+
+			if (client_dma->active) {
+				sample_offset = 0;
+				id = client->id;
+				sdi_cnt = mix->sdi_cnt;
+				client_chn = client_dma->channels;
+				mix_chn = mix->channels;
+				loop_cnt = size / mix->word_width / mix_chn;
+
+				dst16 = (u16 *)(client_dma->dma_buffer.area + client_dma->buffer_offset);
+				src16 = (u16 *)(mix->dma_buffer.area + (mix->buffer_read_offset % mix->buffer_bytes));
+				while (sample_offset < loop_cnt) {
+
+					/* split the data to corret client*/
+					for (j = 0; j < client_chn; j++) {
+						src_idx = id + j * sdi_cnt;
+						*dst16++ = src16[src_idx];
+					}
+
+					sample_offset++;
+					src16 = src16 + mix_chn;
+				}
+				client_dma->buffer_offset += size / mix->client_cnt;
+				client_dma->buffer_offset = client_dma->buffer_offset % client_dma->buffer_bytes;
+
+				if (elapse && mix->fe_substream[i])
+					snd_pcm_period_elapsed(mix->fe_substream[i]);
+			}
+		}
+
+		mix->buffer_read_offset += size;
+		if (mix->buffer_read_offset >= mix->buffer_bytes)
+			mix->buffer_read_offset -= mix->buffer_bytes;
+
+		avail -= mix->period_bytes;
+	}
+}
+
+static void fsl_esai_mix_tx_worker(struct work_struct *work)
+{
+	struct fsl_esai_mix *mix;
+
+	mix = container_of(work, struct fsl_esai_mix, work);
+	fsl_esai_mix_buffer_from_fe_tx(mix->substream, true);
+}
+
+static void fsl_esai_mix_rx_worker(struct work_struct *work)
+{
+	struct fsl_esai_mix *mix;
+
+	mix = container_of(work, struct fsl_esai_mix, work);
+	fsl_esai_split_buffer_from_be_rx(mix->substream, true);
+}
+
+/* call back of dma event */
+static void fsl_esai_mix_dma_complete(void *arg)
+{
+	struct snd_pcm_substream *substream = arg;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);
+	struct fsl_esai *esai = snd_soc_dai_get_drvdata(cpu_dai);
+	bool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;
+	struct fsl_esai_mix *mix = &esai->mix[tx];
+
+	mix->substream = substream;
+
+	queue_work(mix->mix_wq, &mix->work);
+}
+
+static int fsl_esai_mix_prepare_and_submit(struct snd_pcm_substream *substream,
+					   struct fsl_esai_mix *mix)
+{
+	struct dma_async_tx_descriptor *desc;
+	enum dma_transfer_direction direction;
+	unsigned long flags = DMA_CTRL_ACK | DMA_PREP_INTERRUPT;
+
+	direction = snd_pcm_substream_to_dma_direction(substream);
+
+	/* ping-pong buffer for mix */
+	desc = dmaengine_prep_dma_cyclic(mix->chan,
+					 mix->dma_buffer.addr,
+					 mix->buffer_bytes,
+					 mix->period_bytes,
+					 direction, flags);
+	if (!desc)
+		return -ENOMEM;
+
+	desc->callback = fsl_esai_mix_dma_complete;
+	desc->callback_param = substream;
+	mix->cookie = dmaengine_submit(desc);
+
+	/* Mix the tx buffer */
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		mix->buffer_read_offset = 0;
+		mix->buffer_write_offset = 0;
+		fsl_esai_mix_buffer_from_fe_tx(substream, false);
+	} else {
+		mix->buffer_read_offset = 0;
+		mix->buffer_write_offset = 0;
+	}
+
+	return 0;
+}
+
+int fsl_esai_mix_trigger(struct snd_pcm_substream *substream, int cmd,
+			 struct fsl_esai_mix *mix)
+{
+	int ret;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		ret = fsl_esai_mix_prepare_and_submit(substream, mix);
+		if (ret)
+			return ret;
+		dma_async_issue_pending(mix->chan);
+		break;
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+	case SNDRV_PCM_TRIGGER_STOP:
+		dmaengine_terminate_async(mix->chan);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+int fsl_esai_mix_probe(struct device *dev, struct fsl_esai_mix *mix_rx, struct fsl_esai_mix *mix_tx)
+{
+	int ret = 0;
+
+	ret = dma_coerce_mask_and_coherent(dev, DMA_BIT_MASK(32));
+	if (ret)
+		return ret;
+
+	/**
+	 * initialize info for mixing
+	 * two clients, TX0 pin is for client 0, TX1 pin is for client 1
+	 * total supported channel is 4.
+	 */
+	mix_tx->client_cnt = 2;
+	mix_tx->sdo_cnt = 2;
+	mix_tx->sdi_cnt = 2;
+	mix_tx->channels = 4;
+	mix_tx->buffer_bytes = 2048 * mix_tx->client_cnt * 4;
+	mix_tx->period_bytes = 2048 * mix_tx->client_cnt;
+	ret = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV,
+				  dev,
+				  IMX_SSI_DMABUF_SIZE * mix_tx->client_cnt,
+				  &mix_tx->dma_buffer);
+	if (ret)
+		return ret;
+
+	mix_tx->mix_wq = alloc_ordered_workqueue("esai_mix_tx", WQ_HIGHPRI | WQ_UNBOUND | WQ_FREEZABLE);
+	if (IS_ERR(mix_tx->mix_wq))
+		dev_err(dev, "failed  create easi mix tx thread\n");
+
+	INIT_WORK(&mix_tx->work, fsl_esai_mix_tx_worker);
+
+	/**
+	 * initialize info for mixing
+	 * two clients, TX0 pin is for client 0, TX1 pin is for client 1
+	 * total supported channel is 4.
+	 */
+	mix_rx->client_cnt = 2;
+	mix_rx->sdo_cnt = 2;
+	mix_rx->sdi_cnt = 2;
+	mix_rx->channels = 4;
+	mix_rx->buffer_bytes = 2048 * mix_rx->client_cnt * 4;
+	mix_rx->period_bytes = 2048 * mix_rx->client_cnt;
+	ret = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV,
+				  dev,
+				  IMX_SSI_DMABUF_SIZE * mix_rx->client_cnt,
+				  &mix_rx->dma_buffer);
+	if (ret)
+		return ret;
+
+	mix_rx->mix_wq = alloc_ordered_workqueue("esai_mix_rx", WQ_HIGHPRI | WQ_UNBOUND | WQ_FREEZABLE);
+	if (IS_ERR(mix_rx->mix_wq))
+		dev_err(dev, "failed  create easi mix tx thread\n");
+
+	INIT_WORK(&mix_rx->work, fsl_esai_mix_rx_worker);
+
+	return ret;
+}
+
+int fsl_esai_mix_remove(struct device *dev, struct fsl_esai_mix *mix_rx, struct fsl_esai_mix *mix_tx)
+{
+	destroy_workqueue(mix_rx->mix_wq);
+	destroy_workqueue(mix_rx->mix_wq);
+
+	snd_dma_free_pages(&mix_tx->dma_buffer);
+	snd_dma_free_pages(&mix_rx->dma_buffer);
+
+	return 0;
+}
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/fsl/fsl_esai_mix.h b/sound/soc/fsl/fsl_esai_mix.h
new file mode 100644
index 000000000..c7d2c74d0
--- /dev/null
+++ b/sound/soc/fsl/fsl_esai_mix.h
@@ -0,0 +1,58 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+#ifndef _FSL_ESAI_MIX_H
+#define _FSL_ESAI_MIX_H
+
+/* maximum client number is 4; */
+#define MAX_CLIENT_NUM 4
+
+/**
+ * fsl_esai_mix: esai mix/split data
+ * @chan: dma channel
+ * @fe_substream: handler of front end substream
+ * @client: handler of client
+ * @dma_buffer: structure of dma buffer
+ * @buffer_offset: read offset of buffer
+ * @buffer_bytes: buffer size in bytes
+ * @period_bytes: period size in bytes
+ * @period_num: period number
+ * @word_width: word width in bytes
+ * @channels: channel number
+ * @client_cnt: client number, default 2.
+ * @sdo_cnt: output pin number of esai
+ * @sdi_cnt: input pin number of esai
+ * @active: mixer is enabled or not
+ */
+struct fsl_esai_mix {
+	struct dma_chan *chan;
+	struct snd_pcm_substream *fe_substream[MAX_CLIENT_NUM];
+	struct fsl_esai_client *client[MAX_CLIENT_NUM];
+	struct snd_dma_buffer dma_buffer;
+	struct workqueue_struct  *mix_wq;
+	struct work_struct       work;
+	struct snd_pcm_substream *substream;
+	dma_cookie_t cookie;
+	u32 buffer_read_offset;
+	u32 buffer_write_offset;
+	u32 buffer_bytes;
+	u32 period_bytes;
+	u32 period_num;
+	u32 word_width;
+	u32 channels;
+	u32 client_cnt;
+	u32 sdo_cnt;
+	u32 sdi_cnt;
+	atomic_t active;
+};
+
+int fsl_esai_mix_hw_params(struct snd_pcm_substream *substream,
+			   struct snd_pcm_hw_params *params,
+			   struct fsl_esai_mix *mix);
+int fsl_esai_mix_open(struct snd_pcm_substream *substream, struct fsl_esai_mix *mix);
+int fsl_esai_mix_close(struct snd_pcm_substream *substream, struct fsl_esai_mix *mix);
+int fsl_esai_mix_trigger(struct snd_pcm_substream *substream, int cmd,
+			 struct fsl_esai_mix *mix);
+int fsl_esai_mix_probe(struct device *dev, struct fsl_esai_mix *mix_rx, struct fsl_esai_mix *mix_tx);
+int fsl_esai_mix_remove(struct device *dev, struct fsl_esai_mix *mix_rx, struct fsl_esai_mix *mix_tx);
+
+#endif /* _FSL_ESAI_MIX_H */
diff --git a/sound/soc/fsl/fsl_hdmi.c b/sound/soc/fsl/fsl_hdmi.c
new file mode 100644
index 000000000..77d2a55bc
--- /dev/null
+++ b/sound/soc/fsl/fsl_hdmi.c
@@ -0,0 +1,772 @@
+/*
+ * ALSA SoC HDMI Audio Layer for Freescale i.MX
+ *
+ * Copyright (C) 2011-2014 Freescale Semiconductor, Inc.
+ *
+ * Some code from patch_hdmi.c
+ *  Copyright (c) 2008-2010 Intel Corporation. All rights reserved.
+ *  Copyright (c) 2006 ATI Technologies Inc.
+ *  Copyright (c) 2008 NVIDIA Corp.  All rights reserved.
+ *  Copyright (c) 2008 Wei Ni <wni@nvidia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/dma-mapping.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/mfd/mxc-hdmi-core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/asoundef.h>
+#include <sound/hdmi-codec.h>
+
+#include <video/mxc_hdmi.h>
+
+#include "imx-hdmi.h"
+
+
+static struct mxc_edid_cfg edid_cfg;
+
+static u32 playback_rates[HDMI_MAX_RATES];
+static u32 playback_sample_size[HDMI_MAX_SAMPLE_SIZE];
+static u32 playback_channels[HDMI_MAX_CHANNEL_CONSTRAINTS];
+
+static struct snd_pcm_hw_constraint_list playback_constraint_rates;
+static struct snd_pcm_hw_constraint_list playback_constraint_bits;
+static struct snd_pcm_hw_constraint_list playback_constraint_channels;
+
+#ifdef DEBUG
+static void dumpregs(struct snd_soc_dai *dai)
+{
+	u32 n, cts;
+
+	cts = (hdmi_readb(HDMI_AUD_CTS3) << 16) |
+		(hdmi_readb(HDMI_AUD_CTS2) << 8) |
+		hdmi_readb(HDMI_AUD_CTS1);
+
+	n = (hdmi_readb(HDMI_AUD_N3) << 16) |
+		(hdmi_readb(HDMI_AUD_N2) << 8) |
+		hdmi_readb(HDMI_AUD_N1);
+
+	dev_dbg(dai->dev, "HDMI_PHY_CONF0      0x%02x\n",
+			hdmi_readb(HDMI_PHY_CONF0));
+	dev_dbg(dai->dev, "HDMI_MC_CLKDIS      0x%02x\n",
+			hdmi_readb(HDMI_MC_CLKDIS));
+	dev_dbg(dai->dev, "HDMI_AUD_N[1-3]     0x%06x (%d)\n",
+			n, n);
+	dev_dbg(dai->dev, "HDMI_AUD_CTS[1-3]   0x%06x (%d)\n",
+			cts, cts);
+	dev_dbg(dai->dev, "HDMI_FC_AUDSCONF    0x%02x\n",
+			hdmi_readb(HDMI_FC_AUDSCONF));
+}
+#else
+static void dumpregs(struct snd_soc_dai *dai) {}
+#endif
+
+enum cea_speaker_placement {
+	FL  = (1 <<  0),	/* Front Left           */
+	FC  = (1 <<  1),	/* Front Center         */
+	FR  = (1 <<  2),	/* Front Right          */
+	FLC = (1 <<  3),	/* Front Left Center    */
+	FRC = (1 <<  4),	/* Front Right Center   */
+	RL  = (1 <<  5),	/* Rear Left            */
+	RC  = (1 <<  6),	/* Rear Center          */
+	RR  = (1 <<  7),	/* Rear Right           */
+	RLC = (1 <<  8),	/* Rear Left Center     */
+	RRC = (1 <<  9),	/* Rear Right Center    */
+	LFE = (1 << 10),	/* Low Frequency Effect */
+	FLW = (1 << 11),	/* Front Left Wide      */
+	FRW = (1 << 12),	/* Front Right Wide     */
+	FLH = (1 << 13),	/* Front Left High      */
+	FCH = (1 << 14),	/* Front Center High    */
+	FRH = (1 << 15),	/* Front Right High     */
+	TC  = (1 << 16),	/* Top Center           */
+};
+
+/*
+ * EDID SA bits in the CEA Speaker Allocation data block
+ */
+static int edid_speaker_allocation_bits[] = {
+	[0] = FL | FR,
+	[1] = LFE,
+	[2] = FC,
+	[3] = RL | RR,
+	[4] = RC,
+	[5] = FLC | FRC,
+	[6] = RLC | RRC,
+	[7] = FLW | FRW,
+	[8] = FLH | FRH,
+	[9] = TC,
+	[10] = FCH,
+};
+
+struct cea_channel_speaker_allocation {
+	int ca_index;
+	int speakers[8];
+
+	/* Derived values, just for convenience */
+	int channels;
+	int spk_mask;
+};
+
+/*
+ * This is an ordered list!
+ *
+ * The preceding ones have better chances to be selected by
+ * hdmi_channel_allocation().
+ */
+static struct cea_channel_speaker_allocation channel_allocations[] = {
+	/*			  channel:  7     6    5    4    3     2    1    0  */
+	{ .ca_index = 0x00, .speakers = {   0,    0,   0,   0,   0,    0,  FR,  FL },},
+					 /* 2.1 */
+	{ .ca_index = 0x01, .speakers = {   0,    0,   0,   0,   0,  LFE,  FR,  FL },},
+					 /* Dolby Surround */
+	{ .ca_index = 0x02, .speakers = {   0,    0,   0,   0,  FC,    0,  FR,  FL },},
+	{ .ca_index = 0x03, .speakers = {   0,    0,   0,   0,  FC,  LFE,  FR,  FL },},
+	{ .ca_index = 0x04, .speakers = {   0,    0,   0,  RC,   0,    0,  FR,  FL },},
+	{ .ca_index = 0x05, .speakers = {   0,    0,   0,  RC,   0,  LFE,  FR,  FL },},
+	{ .ca_index = 0x06, .speakers = {   0,    0,   0,  RC,  FC,    0,  FR,  FL },},
+	{ .ca_index = 0x07, .speakers = {   0,    0,   0,  RC,  FC,  LFE,  FR,  FL },},
+	{ .ca_index = 0x08, .speakers = {   0,    0,  RR,  RL,   0,    0,  FR,  FL },},
+	{ .ca_index = 0x09, .speakers = {   0,    0,  RR,  RL,   0,  LFE,  FR,  FL },},
+	{ .ca_index = 0x0a, .speakers = {   0,    0,  RR,  RL,  FC,    0,  FR,  FL },},
+					 /* surround51 */
+	{ .ca_index = 0x0b, .speakers = {   0,    0,  RR,  RL,  FC,  LFE,  FR,  FL },},
+	{ .ca_index = 0x0c, .speakers = {   0,   RC,  RR,  RL,   0,    0,  FR,  FL },},
+	{ .ca_index = 0x0d, .speakers = {   0,   RC,  RR,  RL,   0,  LFE,  FR,  FL },},
+	{ .ca_index = 0x0e, .speakers = {   0,   RC,  RR,  RL,  FC,    0,  FR,  FL },},
+					 /* 6.1 */
+	{ .ca_index = 0x0f, .speakers = {   0,   RC,  RR,  RL,  FC,  LFE,  FR,  FL },},
+	{ .ca_index = 0x10, .speakers = { RRC,  RLC,  RR,  RL,   0,    0,  FR,  FL },},
+	{ .ca_index = 0x11, .speakers = { RRC,  RLC,  RR,  RL,   0,  LFE,  FR,  FL },},
+	{ .ca_index = 0x12, .speakers = { RRC,  RLC,  RR,  RL,  FC,    0,  FR,  FL },},
+					 /* surround71 */
+	{ .ca_index = 0x13, .speakers = { RRC,  RLC,  RR,  RL,  FC,  LFE,  FR,  FL },},
+	{ .ca_index = 0x14, .speakers = { FRC,  FLC,   0,   0,   0,    0,  FR,  FL },},
+	{ .ca_index = 0x15, .speakers = { FRC,  FLC,   0,   0,   0,  LFE,  FR,  FL },},
+	{ .ca_index = 0x16, .speakers = { FRC,  FLC,   0,   0,  FC,    0,  FR,  FL },},
+	{ .ca_index = 0x17, .speakers = { FRC,  FLC,   0,   0,  FC,  LFE,  FR,  FL },},
+	{ .ca_index = 0x18, .speakers = { FRC,  FLC,   0,  RC,   0,    0,  FR,  FL },},
+	{ .ca_index = 0x19, .speakers = { FRC,  FLC,   0,  RC,   0,  LFE,  FR,  FL },},
+	{ .ca_index = 0x1a, .speakers = { FRC,  FLC,   0,  RC,  FC,    0,  FR,  FL },},
+	{ .ca_index = 0x1b, .speakers = { FRC,  FLC,   0,  RC,  FC,  LFE,  FR,  FL },},
+	{ .ca_index = 0x1c, .speakers = { FRC,  FLC,  RR,  RL,   0,    0,  FR,  FL },},
+	{ .ca_index = 0x1d, .speakers = { FRC,  FLC,  RR,  RL,   0,  LFE,  FR,  FL },},
+	{ .ca_index = 0x1e, .speakers = { FRC,  FLC,  RR,  RL,  FC,    0,  FR,  FL },},
+	{ .ca_index = 0x1f, .speakers = { FRC,  FLC,  RR,  RL,  FC,  LFE,  FR,  FL },},
+	{ .ca_index = 0x20, .speakers = {   0,  FCH,  RR,  RL,  FC,    0,  FR,  FL },},
+	{ .ca_index = 0x21, .speakers = {   0,  FCH,  RR,  RL,  FC,  LFE,  FR,  FL },},
+	{ .ca_index = 0x22, .speakers = {  TC,    0,  RR,  RL,  FC,    0,  FR,  FL },},
+	{ .ca_index = 0x23, .speakers = {  TC,    0,  RR,  RL,  FC,  LFE,  FR,  FL },},
+	{ .ca_index = 0x24, .speakers = { FRH,  FLH,  RR,  RL,   0,    0,  FR,  FL },},
+	{ .ca_index = 0x25, .speakers = { FRH,  FLH,  RR,  RL,   0,  LFE,  FR,  FL },},
+	{ .ca_index = 0x26, .speakers = { FRW,  FLW,  RR,  RL,   0,    0,  FR,  FL },},
+	{ .ca_index = 0x27, .speakers = { FRW,  FLW,  RR,  RL,   0,  LFE,  FR,  FL },},
+	{ .ca_index = 0x28, .speakers = {  TC,   RC,  RR,  RL,  FC,    0,  FR,  FL },},
+	{ .ca_index = 0x29, .speakers = {  TC,   RC,  RR,  RL,  FC,  LFE,  FR,  FL },},
+	{ .ca_index = 0x2a, .speakers = { FCH,   RC,  RR,  RL,  FC,    0,  FR,  FL },},
+	{ .ca_index = 0x2b, .speakers = { FCH,   RC,  RR,  RL,  FC,  LFE,  FR,  FL },},
+	{ .ca_index = 0x2c, .speakers = {  TC,  FCH,  RR,  RL,  FC,    0,  FR,  FL },},
+	{ .ca_index = 0x2d, .speakers = {  TC,  FCH,  RR,  RL,  FC,  LFE,  FR,  FL },},
+	{ .ca_index = 0x2e, .speakers = { FRH,  FLH,  RR,  RL,  FC,    0,  FR,  FL },},
+	{ .ca_index = 0x2f, .speakers = { FRH,  FLH,  RR,  RL,  FC,  LFE,  FR,  FL },},
+	{ .ca_index = 0x30, .speakers = { FRW,  FLW,  RR,  RL,  FC,    0,  FR,  FL },},
+	{ .ca_index = 0x31, .speakers = { FRW,  FLW,  RR,  RL,  FC,  LFE,  FR,  FL },},
+};
+
+/* Compute derived values in channel_allocations[] */
+static void init_channel_allocations(void)
+{
+	struct cea_channel_speaker_allocation *p;
+	int i, j;
+
+	for (i = 0; i < ARRAY_SIZE(channel_allocations); i++) {
+		p = channel_allocations + i;
+		p->channels = 0;
+		p->spk_mask = 0;
+		for (j = 0; j < ARRAY_SIZE(p->speakers); j++)
+			if (p->speakers[j]) {
+				p->channels++;
+				p->spk_mask |= p->speakers[j];
+			}
+	}
+}
+
+/*
+ * The transformation takes two steps:
+ *
+ * speaker_alloc => (edid_speaker_allocation_bits[]) => spk_mask
+ * spk_mask      => (channel_allocations[])         => CA
+ *
+ * TODO: it could select the wrong CA from multiple candidates.
+*/
+static int hdmi_channel_allocation(int channels)
+{
+	int spk_mask = 0, ca = 0, i, tmpchn, tmpspk;
+
+	/* CA defaults to 0 for basic stereo audio */
+	if (channels <= 2)
+		return 0;
+
+	/*
+	 * Expand EDID's speaker allocation mask
+	 *
+	 * EDID tells the speaker mask in a compact(paired) form,
+	 * expand EDID's notions to match the ones used by Audio InfoFrame.
+	 */
+	for (i = 0; i < ARRAY_SIZE(edid_speaker_allocation_bits); i++) {
+		if (edid_cfg.speaker_alloc & (1 << i))
+			spk_mask |= edid_speaker_allocation_bits[i];
+	}
+
+	/* Search for the first working match in the CA table */
+	for (i = 0; i < ARRAY_SIZE(channel_allocations); i++) {
+		tmpchn = channel_allocations[i].channels;
+		tmpspk = channel_allocations[i].spk_mask;
+
+		if (channels == tmpchn && (spk_mask & tmpspk) == tmpspk) {
+			ca = channel_allocations[i].ca_index;
+			break;
+		}
+	}
+
+	return ca;
+}
+
+static void hdmi_set_audio_infoframe(unsigned int channels)
+{
+	u8 audiconf0, audiconf2;
+
+	/*
+	 * From CEA-861-D spec:
+	 * HDMI requires the CT, SS and SF fields to be set to 0 ("Refer
+	 * to Stream Header") as these items are carried in the audio stream.
+	 *
+	 * So we only set the CC and CA fields.
+	 */
+	audiconf0 = ((channels - 1) << HDMI_FC_AUDICONF0_CC_OFFSET) &
+		HDMI_FC_AUDICONF0_CC_MASK;
+
+	audiconf2 = hdmi_channel_allocation(channels);
+
+	hdmi_writeb(audiconf0, HDMI_FC_AUDICONF0);
+	hdmi_writeb(0, HDMI_FC_AUDICONF1);
+	hdmi_writeb(audiconf2, HDMI_FC_AUDICONF2);
+	hdmi_writeb(0, HDMI_FC_AUDICONF3);
+}
+
+static int cea_audio_rates[HDMI_MAX_RATES] = {
+	32000, 44100, 48000, 88200, 96000, 176400, 192000,
+};
+
+static void fsl_hdmi_get_playback_rates(void)
+{
+	int i, count = 0;
+	u8 rates;
+
+	/* Always assume basic audio support */
+	rates = edid_cfg.sample_rates | 0x7;
+
+	for (i = 0 ; i < HDMI_MAX_RATES ; i++)
+		if ((rates & (1 << i)) != 0)
+			playback_rates[count++] = cea_audio_rates[i];
+
+	playback_constraint_rates.list = playback_rates;
+	playback_constraint_rates.count = count;
+
+	for (i = 0 ; i < playback_constraint_rates.count ; i++)
+		pr_debug("%s: constraint = %d Hz\n", __func__, playback_rates[i]);
+}
+
+static void fsl_hdmi_get_playback_sample_size(void)
+{
+	int i = 0;
+
+	/* Always assume basic audio support */
+	playback_sample_size[i++] = 16;
+
+	if (edid_cfg.sample_sizes & 0x4)
+		playback_sample_size[i++] = 24;
+
+	playback_constraint_bits.list = playback_sample_size;
+	playback_constraint_bits.count = i;
+
+	for (i = 0 ; i < playback_constraint_bits.count ; i++)
+		pr_debug("%s: constraint = %d bits\n", __func__, playback_sample_size[i]);
+}
+
+static void fsl_hdmi_get_playback_channels(void)
+{
+	int channels = 2, i = 0;
+
+	/* Always assume basic audio support */
+	playback_channels[i++] = channels;
+	channels += 2;
+
+	while ((i < HDMI_MAX_CHANNEL_CONSTRAINTS) &&
+			(channels <= edid_cfg.max_channels)) {
+		playback_channels[i++] = channels;
+		channels += 2;
+	}
+
+	playback_constraint_channels.list = playback_channels;
+	playback_constraint_channels.count = i;
+
+	for (i = 0 ; i < playback_constraint_channels.count ; i++)
+		pr_debug("%s: constraint = %d channels\n", __func__, playback_channels[i]);
+}
+
+static int fsl_hdmi_update_constraints(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int ret;
+
+	hdmi_get_edid_cfg(&edid_cfg);
+
+	fsl_hdmi_get_playback_rates();
+	ret = snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
+			&playback_constraint_rates);
+	if (ret)
+		return ret;
+
+	fsl_hdmi_get_playback_sample_size();
+	ret = snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_SAMPLE_BITS,
+			&playback_constraint_bits);
+	if (ret)
+		return ret;
+
+	fsl_hdmi_get_playback_channels();
+	ret = snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,
+			&playback_constraint_channels);
+	if (ret)
+		return ret;
+
+	ret = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int fsl_hdmi_soc_startup(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+	struct imx_hdmi *hdmi_data = snd_soc_dai_get_drvdata(dai);
+	int ret;
+
+	ret = clk_prepare_enable(hdmi_data->mipi_core_clk);
+	if (ret) {
+		dev_err(dai->dev, "failed to enable mipi_core_clk clock\n");
+		return ret;
+	}
+
+	ret = clk_prepare_enable(hdmi_data->isfr_clk);
+	if (ret) {
+		dev_err(dai->dev, "failed to enable isfr_clk clock\n");
+		goto disable_mipi_core_clk;
+	}
+
+	ret = clk_prepare_enable(hdmi_data->iahb_clk);
+	if (ret) {
+		dev_err(dai->dev, "failed to enable iahb_clk clock\n");
+		goto disable_isfr_clk;
+	}
+
+	dev_dbg(dai->dev, "%s hdmi clks: mipi_core: %d isfr:%d iahb:%d\n", __func__,
+			(int)clk_get_rate(hdmi_data->mipi_core_clk),
+			(int)clk_get_rate(hdmi_data->isfr_clk),
+			(int)clk_get_rate(hdmi_data->iahb_clk));
+
+	ret = fsl_hdmi_update_constraints(substream);
+	if (ret < 0)
+		goto disable_iahb_clk;
+
+	/* Indicates the subpacket represents a flatline sample */
+	hdmi_audio_writeb(FC_AUDSCONF, AUD_PACKET_SAMPFIT, 0x0);
+
+	return 0;
+
+disable_iahb_clk:
+	clk_disable_unprepare(hdmi_data->iahb_clk);
+disable_isfr_clk:
+	clk_disable_unprepare(hdmi_data->isfr_clk);
+disable_mipi_core_clk:
+	clk_disable_unprepare(hdmi_data->mipi_core_clk);
+	return ret;
+}
+
+static void fsl_hdmi_soc_shutdown(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+	struct imx_hdmi *hdmi_data = snd_soc_dai_get_drvdata(dai);
+
+	clk_disable_unprepare(hdmi_data->iahb_clk);
+	clk_disable_unprepare(hdmi_data->isfr_clk);
+	clk_disable_unprepare(hdmi_data->mipi_core_clk);
+}
+
+static int fsl_hdmi_soc_prepare(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *dai)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	hdmi_set_audio_infoframe(runtime->channels);
+	hdmi_audio_writeb(FC_AUDSCONF, AUD_PACKET_LAYOUT,
+			(runtime->channels > 2) ? 0x1 : 0x0);
+	hdmi_set_sample_rate(runtime->rate);
+	dumpregs(dai);
+
+	return 0;
+}
+
+static struct snd_soc_dai_ops fsl_hdmi_soc_dai_ops = {
+	.startup = fsl_hdmi_soc_startup,
+	.shutdown = fsl_hdmi_soc_shutdown,
+	.prepare = fsl_hdmi_soc_prepare,
+};
+
+/* IEC60958 status functions */
+static int fsl_hdmi_iec_info(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
+	uinfo->count = 1;
+
+	return 0;
+}
+
+
+static int fsl_hdmi_iec_get(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *uvalue)
+{
+	int i;
+
+	for (i = 0 ; i < 4 ; i++)
+		uvalue->value.iec958.status[i] = iec_header.status[i];
+
+	return 0;
+}
+
+static int fsl_hdmi_iec_put(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *uvalue)
+{
+	int i;
+
+	/* Do not allow professional mode */
+	if (uvalue->value.iec958.status[0] & IEC958_AES0_PROFESSIONAL)
+		return -EPERM;
+
+	for (i = 0 ; i < 4 ; i++) {
+		iec_header.status[i] = uvalue->value.iec958.status[i];
+		pr_debug("%s status[%d]=0x%02x\n", __func__, i, iec_header.status[i]);
+	}
+
+	return 0;
+}
+
+static int fsl_hdmi_channels_info(struct snd_kcontrol *kcontrol,
+			     struct snd_ctl_elem_info *uinfo)
+{
+	hdmi_get_edid_cfg(&edid_cfg);
+	fsl_hdmi_get_playback_channels();
+
+	uinfo->type  = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = playback_constraint_channels.count;
+
+	return 0;
+}
+
+
+static int fsl_hdmi_channels_get(struct snd_kcontrol *kcontrol,
+			    struct snd_ctl_elem_value *uvalue)
+{
+	int i;
+	hdmi_get_edid_cfg(&edid_cfg);
+	fsl_hdmi_get_playback_channels();
+
+	for (i = 0 ; i < playback_constraint_channels.count ; i++)
+		uvalue->value.integer.value[i] = playback_channels[i];
+
+	return 0;
+}
+
+static int fsl_hdmi_rates_info(struct snd_kcontrol *kcontrol,
+			     struct snd_ctl_elem_info *uinfo)
+{
+	hdmi_get_edid_cfg(&edid_cfg);
+	fsl_hdmi_get_playback_rates();
+
+	uinfo->type  = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = playback_constraint_rates.count;
+
+	return 0;
+}
+
+static int fsl_hdmi_rates_get(struct snd_kcontrol *kcontrol,
+			    struct snd_ctl_elem_value *uvalue)
+{
+	int i;
+	hdmi_get_edid_cfg(&edid_cfg);
+	fsl_hdmi_get_playback_rates();
+
+	for (i = 0 ; i < playback_constraint_rates.count ; i++)
+		uvalue->value.integer.value[i] = playback_rates[i];
+
+	return 0;
+}
+
+static int fsl_hdmi_formats_info(struct snd_kcontrol *kcontrol,
+			     struct snd_ctl_elem_info *uinfo)
+{
+	hdmi_get_edid_cfg(&edid_cfg);
+	fsl_hdmi_get_playback_sample_size();
+
+	uinfo->type  = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = playback_constraint_bits.count;
+
+	return 0;
+}
+
+static int fsl_hdmi_formats_get(struct snd_kcontrol *kcontrol,
+			    struct snd_ctl_elem_value *uvalue)
+{
+	int i;
+	hdmi_get_edid_cfg(&edid_cfg);
+	fsl_hdmi_get_playback_sample_size();
+
+	for (i = 0 ; i < playback_constraint_bits.count ; i++)
+		uvalue->value.integer.value[i] = playback_sample_size[i];
+
+	return 0;
+}
+
+static struct snd_kcontrol_new fsl_hdmi_ctrls[] = {
+	/* Status cchanel controller */
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = SNDRV_CTL_NAME_IEC958("", PLAYBACK, DEFAULT),
+		.access = SNDRV_CTL_ELEM_ACCESS_READ |
+			SNDRV_CTL_ELEM_ACCESS_WRITE |
+			SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+		.info = fsl_hdmi_iec_info,
+		.get = fsl_hdmi_iec_get,
+		.put = fsl_hdmi_iec_put,
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "HDMI Support Channels",
+		.access = SNDRV_CTL_ELEM_ACCESS_READ |
+			SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+		.info = fsl_hdmi_channels_info,
+		.get = fsl_hdmi_channels_get,
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "HDMI Support Rates",
+		.access = SNDRV_CTL_ELEM_ACCESS_READ |
+			SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+		.info = fsl_hdmi_rates_info,
+		.get = fsl_hdmi_rates_get,
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "HDMI Support Formats",
+		.access = SNDRV_CTL_ELEM_ACCESS_READ |
+			SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+		.info = fsl_hdmi_formats_info,
+		.get = fsl_hdmi_formats_get,
+	},
+};
+
+static int fsl_hdmi_soc_dai_probe(struct snd_soc_dai *dai)
+{
+	int ret;
+
+	init_channel_allocations();
+
+	ret = snd_soc_add_dai_controls(dai, fsl_hdmi_ctrls,
+			ARRAY_SIZE(fsl_hdmi_ctrls));
+	if (ret)
+		dev_warn(dai->dev, "failed to add dai controls\n");
+
+	return 0;
+}
+
+static struct snd_soc_dai_driver fsl_hdmi_dai = {
+	.probe = &fsl_hdmi_soc_dai_probe,
+	.playback = {
+		.channels_min = 2,
+		.channels_max = 8,
+		.rates = MXC_HDMI_RATES_PLAYBACK,
+		.formats = MXC_HDMI_FORMATS_PLAYBACK,
+	},
+	.ops = &fsl_hdmi_soc_dai_ops,
+};
+
+static const struct snd_soc_component_driver fsl_hdmi_component = {
+	.name		= "fsl-hdmi",
+};
+
+/* HDMI audio codec callbacks */
+static int fsl_hdmi_audio_hw_params(struct device *dev, void *data,
+			 struct hdmi_codec_daifmt *fmt,
+			 struct hdmi_codec_params *hparms)
+{
+	dev_dbg(dev, "[%s]: %u Hz, %d bit, %d channels\n", __func__,
+			hparms->sample_rate, hparms->sample_width, hparms->cea.channels);
+
+	return 0;
+}
+
+static void fsl_hdmi_audio_shutdown(struct device *dev, void *data)
+{
+	dev_dbg(dev, "[%s]\n", __func__);
+}
+
+static const struct hdmi_codec_ops fsl_hdmi_audio_codec_ops = {
+	.hw_params = fsl_hdmi_audio_hw_params,
+	.audio_shutdown = fsl_hdmi_audio_shutdown,
+};
+
+static struct hdmi_codec_pdata codec_data = {
+	.ops = &fsl_hdmi_audio_codec_ops,
+	.i2s = 1,
+	.max_i2s_channels = 8,
+};
+
+static int fsl_hdmi_dai_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct imx_hdmi *hdmi_data;
+	int ret = 0;
+
+	if (!np)
+		return -ENODEV;
+
+	if (!hdmi_get_registered()) {
+		dev_err(&pdev->dev, "failed to probe. Load HDMI-video first.\n");
+		return -ENOMEM;
+	}
+
+	hdmi_data = devm_kzalloc(&pdev->dev, sizeof(*hdmi_data), GFP_KERNEL);
+	if (!hdmi_data) {
+		dev_err(&pdev->dev, "failed to alloc hdmi_data\n");
+		return -ENOMEM;
+	}
+
+	hdmi_data->pdev = pdev;
+
+	memcpy(&hdmi_data->cpu_dai_drv, &fsl_hdmi_dai, sizeof(fsl_hdmi_dai));
+	hdmi_data->cpu_dai_drv.name = np->name;
+
+	hdmi_data->mipi_core_clk = devm_clk_get(&pdev->dev, "mipi_core");
+	if (IS_ERR(hdmi_data->mipi_core_clk)) {
+		ret = PTR_ERR(hdmi_data->mipi_core_clk);
+		dev_err(&pdev->dev, "failed to get mipi core clk: %d\n", ret);
+		return -EINVAL;
+	}
+
+	hdmi_data->isfr_clk = devm_clk_get(&pdev->dev, "hdmi_isfr");
+	if (IS_ERR(hdmi_data->isfr_clk)) {
+		ret = PTR_ERR(hdmi_data->isfr_clk);
+		dev_err(&pdev->dev, "failed to get HDMI isfr clk: %d\n", ret);
+		return -EINVAL;
+	}
+
+	hdmi_data->iahb_clk = devm_clk_get(&pdev->dev, "hdmi_iahb");
+	if (IS_ERR(hdmi_data->iahb_clk)) {
+		ret = PTR_ERR(hdmi_data->iahb_clk);
+		dev_err(&pdev->dev, "failed to get HDMI ahb clk: %d\n", ret);
+		return -EINVAL;
+	}
+
+	dev_set_drvdata(&pdev->dev, hdmi_data);
+	ret = snd_soc_register_component(&pdev->dev, &fsl_hdmi_component,
+					&hdmi_data->cpu_dai_drv, 1);
+	if (ret) {
+		dev_err(&pdev->dev, "register DAI failed\n");
+		return ret;
+	}
+
+	hdmi_data->codec_dev = platform_device_register_data(&pdev->dev,
+			HDMI_CODEC_DRV_NAME, PLATFORM_DEVID_NONE,
+			&codec_data, sizeof(codec_data));
+	if (IS_ERR(hdmi_data->codec_dev)) {
+		dev_err(&pdev->dev, "failed to register HDMI audio codec\n");
+		ret = PTR_ERR(hdmi_data->codec_dev);
+		goto fail;
+	}
+
+	hdmi_data->dma_dev = platform_device_alloc("imx-hdmi-audio", -1);
+	if (!hdmi_data->dma_dev) {
+		ret = -ENOMEM;
+		goto fail_dma;
+	}
+
+	platform_set_drvdata(hdmi_data->dma_dev, hdmi_data);
+
+	ret = platform_device_add(hdmi_data->dma_dev);
+	if (ret) {
+		platform_device_put(hdmi_data->dma_dev);
+		goto fail_dma;
+	}
+
+	return 0;
+
+fail_dma:
+	platform_device_unregister(hdmi_data->codec_dev);
+fail:
+	snd_soc_unregister_component(&pdev->dev);
+
+	return ret;
+}
+
+static int fsl_hdmi_dai_remove(struct platform_device *pdev)
+{
+	struct imx_hdmi *hdmi_data = platform_get_drvdata(pdev);
+
+	platform_device_unregister(hdmi_data->dma_dev);
+	platform_device_unregister(hdmi_data->codec_dev);
+	snd_soc_unregister_component(&pdev->dev);
+
+	return 0;
+}
+
+static const struct of_device_id fsl_hdmi_dai_dt_ids[] = {
+	{ .compatible = "fsl,imx6dl-hdmi-audio", },
+	{ .compatible = "fsl,imx6q-hdmi-audio", },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, fsl_hdmi_dai_dt_ids);
+
+static struct platform_driver fsl_hdmi_driver = {
+	.probe = fsl_hdmi_dai_probe,
+	.remove = fsl_hdmi_dai_remove,
+	.driver = {
+		.name = "fsl-hdmi-dai",
+		.owner = THIS_MODULE,
+		.of_match_table = fsl_hdmi_dai_dt_ids,
+	},
+};
+module_platform_driver(fsl_hdmi_driver);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("IMX HDMI TX DAI");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:fsl-hdmi-dai");
diff --git a/sound/soc/fsl/fsl_micfil.c b/sound/soc/fsl/fsl_micfil.c
index 9f90989ac..a5d4dc612 100644
--- a/sound/soc/fsl/fsl_micfil.c
+++ b/sound/soc/fsl/fsl_micfil.c
@@ -1,6 +1,7 @@
 // SPDX-License-Identifier: GPL-2.0
 // Copyright 2018 NXP
 
+#include <linux/atomic.h>
 #include <linux/clk.h>
 #include <linux/device.h>
 #include <linux/interrupt.h>
@@ -33,7 +34,11 @@ struct fsl_micfil {
 	const struct fsl_micfil_soc_data *soc;
 	struct clk *busclk;
 	struct clk *mclk;
+	struct clk *clk_src[MICFIL_CLK_SRC_NUM];
 	struct snd_dmaengine_dai_dma_data dma_params_rx;
+	struct kobject *hwvad_kobject;
+	struct sdma_audio_config audio_config;
+	unsigned int vad_channel;
 	unsigned int dataline;
 	char name[32];
 	int irq[MICFIL_IRQ_LINES];
@@ -41,6 +46,25 @@ struct fsl_micfil {
 	int quality;	/*QUALITY 2-0 bits */
 	bool slave_mode;
 	int channel_gain[8];
+	int clk_src_id;
+	int dc_remover;
+	int vad_sound_gain;
+	int vad_noise_gain;
+	int vad_input_gain;
+	int vad_frame_time;
+	int vad_init_time;
+	int vad_init_mode;
+	int vad_nfil_adjust;
+	int vad_hpf;
+	int vad_zcd_th;
+	int vad_zcd_auto;
+	int vad_zcd_en;
+	int vad_zcd_adj;
+	int vad_rate_index;
+	atomic_t recording_state;
+	atomic_t hwvad_state;
+	/* spinlock to control HWVAD enable/disable */
+	spinlock_t hwvad_lock;
 };
 
 struct fsl_micfil_soc_data {
@@ -48,6 +72,12 @@ struct fsl_micfil_soc_data {
 	unsigned int fifo_depth;
 	unsigned int dataline;
 	bool imx;
+	u64  formats;
+};
+
+static char *envp[] = {
+	"EVENT=PDM_VOICE_DETECT",
+	NULL,
 };
 
 static struct fsl_micfil_soc_data fsl_micfil_imx8mm = {
@@ -55,10 +85,20 @@ static struct fsl_micfil_soc_data fsl_micfil_imx8mm = {
 	.fifos = 8,
 	.fifo_depth = 8,
 	.dataline =  0xf,
+	.formats = SNDRV_PCM_FMTBIT_S16_LE,
+};
+
+static struct fsl_micfil_soc_data fsl_micfil_imx8mp = {
+	.imx = true,
+	.fifos = 8,
+	.fifo_depth = 32,
+	.dataline =  0xf,
+	.formats = SNDRV_PCM_FMTBIT_S32_LE,
 };
 
 static const struct of_device_id fsl_micfil_dt_ids[] = {
 	{ .compatible = "fsl,imx8mm-micfil", .data = &fsl_micfil_imx8mm },
+	{ .compatible = "fsl,imx8mp-micfil", .data = &fsl_micfil_imx8mp },
 	{}
 };
 MODULE_DEVICE_TABLE(of, fsl_micfil_dt_ids);
@@ -78,11 +118,525 @@ static const char * const micfil_quality_select_texts[] = {
 	"VLow0", "Low",
 };
 
+static const char * const micfil_hwvad_init_mode[] = {
+	"Envelope mode", "Energy mode",
+};
+
+static const char * const micfil_hwvad_hpf_texts[] = {
+	"Filter bypass",
+	"Cut-off @1750Hz",
+	"Cut-off @215Hz",
+	"Cut-off @102Hz",
+};
+
+static const char * const micfil_hwvad_zcd_enable[] = {
+	"OFF", "ON",
+};
+
+static const char * const micfil_hwvad_zcdauto_enable[] = {
+	"OFF", "ON",
+};
+
+static const char * const micfil_hwvad_noise_decimation[] = {
+	"Disabled", "Enabled",
+};
+
+/* when adding new rate text, also add it to the
+ * micfil_hwvad_rate_ints
+ */
+static const char * const micfil_hwvad_rate[] = {
+	"48KHz", "44.1KHz",
+};
+
+static const int micfil_hwvad_rate_ints[] = {
+	48000, 44100,
+};
+
+static const char * const micfil_clk_src_texts[] = {
+	"Auto", "AudioPLL1", "AudioPLL2", "ExtClk3",
+};
+
+/* DC Remover Control
+ * Filter Bypassed	1 1
+ * Cut-off @21Hz	0 0
+ * Cut-off @83Hz	0 1
+ * Cut-off @152HZ	1 0
+ */
+static const char * const micfil_dc_remover_texts[] = {
+	"Cut-off @21Hz", "Cut-off @83Hz",
+	"Cut-off @152Hz", "Bypass",
+};
+
 static const struct soc_enum fsl_micfil_quality_enum =
 	SOC_ENUM_SINGLE(REG_MICFIL_CTRL2,
 			MICFIL_CTRL2_QSEL_SHIFT,
 			ARRAY_SIZE(micfil_quality_select_texts),
 			micfil_quality_select_texts);
+static const struct soc_enum fsl_micfil_hwvad_init_mode_enum =
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(micfil_hwvad_init_mode),
+			    micfil_hwvad_init_mode);
+static const struct soc_enum fsl_micfil_hwvad_hpf_enum =
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(micfil_hwvad_hpf_texts),
+			    micfil_hwvad_hpf_texts);
+static const struct soc_enum fsl_micfil_hwvad_zcd_enum =
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(micfil_hwvad_zcd_enable),
+			    micfil_hwvad_zcd_enable);
+static const struct soc_enum fsl_micfil_hwvad_zcdauto_enum =
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(micfil_hwvad_zcdauto_enable),
+			    micfil_hwvad_zcdauto_enable);
+static const struct soc_enum fsl_micfil_hwvad_ndec_enum =
+	SOC_ENUM_SINGLE(REG_MICFIL_VAD0_NCONFIG,
+			MICFIL_VAD0_NCONFIG_NOREN_SHIFT,
+			ARRAY_SIZE(micfil_hwvad_noise_decimation),
+			micfil_hwvad_noise_decimation);
+static const struct soc_enum fsl_micfil_hwvad_rate_enum =
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(micfil_hwvad_rate),
+			    micfil_hwvad_rate);
+static const struct soc_enum fsl_micfil_clk_src_enum =
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(micfil_clk_src_texts),
+			    micfil_clk_src_texts);
+static const struct soc_enum fsl_micfil_dc_remover_enum =
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(micfil_dc_remover_texts),
+			    micfil_dc_remover_texts);
+
+static int micfil_put_clk_src(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *comp = snd_kcontrol_chip(kcontrol);
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+	unsigned int *item = ucontrol->value.enumerated.item;
+	struct fsl_micfil *micfil = snd_soc_component_get_drvdata(comp);
+	int val = snd_soc_enum_item_to_val(e, item[0]);
+
+	micfil->clk_src_id = val;
+
+	return 0;
+}
+
+static int micfil_get_clk_src(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *comp = snd_kcontrol_chip(kcontrol);
+	struct fsl_micfil *micfil = snd_soc_component_get_drvdata(comp);
+
+	ucontrol->value.enumerated.item[0] = micfil->clk_src_id;
+
+	return 0;
+}
+
+static int micfil_put_dc_remover_state(struct snd_kcontrol *kcontrol,
+				       struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *comp = snd_kcontrol_chip(kcontrol);
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+	struct fsl_micfil *micfil = snd_soc_component_get_drvdata(comp);
+	unsigned int *item = ucontrol->value.enumerated.item;
+	int val = snd_soc_enum_item_to_val(e, item[0]);
+	int i = 0, ret = 0;
+	u32 reg_val = 0;
+
+	if (val < 0 || val > 3)
+		return -EINVAL;
+
+	micfil->dc_remover = val;
+
+	/* Calculate total value for all channels */
+	for (i = 0; i < 8; i++)
+		reg_val |= MICFIL_DC_MODE(val, i);
+
+	/* Update DC Remover mode for all channels */
+	ret = snd_soc_component_update_bits(comp, REG_MICFIL_DC_CTRL,
+					    MICFIL_DC_CTRL_MASK, reg_val);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int micfil_get_dc_remover_state(struct snd_kcontrol *kcontrol,
+				       struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *comp = snd_kcontrol_chip(kcontrol);
+	struct fsl_micfil *micfil = snd_soc_component_get_drvdata(comp);
+
+	ucontrol->value.enumerated.item[0] = micfil->dc_remover;
+
+	return 0;
+}
+
+static int hwvad_put_init_mode(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *comp = snd_kcontrol_chip(kcontrol);
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+	unsigned int *item = ucontrol->value.enumerated.item;
+	struct fsl_micfil *micfil = snd_soc_component_get_drvdata(comp);
+	int val = snd_soc_enum_item_to_val(e, item[0]);
+
+	/* 0 - Envelope-based Mode
+	 * 1 - Energy-based Mode
+	 */
+	micfil->vad_init_mode = val;
+	return 0;
+}
+
+static int hwvad_get_init_mode(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *comp = snd_kcontrol_chip(kcontrol);
+	struct fsl_micfil *micfil = snd_soc_component_get_drvdata(comp);
+
+	ucontrol->value.enumerated.item[0] = micfil->vad_init_mode;
+
+	return 0;
+}
+
+static int hwvad_put_hpf(struct snd_kcontrol *kcontrol,
+			 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *comp = snd_kcontrol_chip(kcontrol);
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+	unsigned int *item = ucontrol->value.enumerated.item;
+	struct fsl_micfil *micfil = snd_soc_component_get_drvdata(comp);
+	int val = snd_soc_enum_item_to_val(e, item[0]);
+
+	/* 00 - HPF Bypass
+	 * 01 - Cut-off frequency 1750Hz
+	 * 10 - Cut-off frequency 215Hz
+	 * 11 - Cut-off frequency 102Hz
+	 */
+	micfil->vad_hpf = val;
+
+	return 0;
+}
+
+static int hwvad_get_hpf(struct snd_kcontrol *kcontrol,
+			 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *comp = snd_kcontrol_chip(kcontrol);
+	struct fsl_micfil *micfil = snd_soc_component_get_drvdata(comp);
+
+	ucontrol->value.enumerated.item[0] = micfil->vad_hpf;
+
+	return 0;
+}
+
+static int hwvad_put_zcd_en(struct snd_kcontrol *kcontrol,
+			    struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *comp = snd_kcontrol_chip(kcontrol);
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+	unsigned int *item = ucontrol->value.enumerated.item;
+	struct fsl_micfil *micfil = snd_soc_component_get_drvdata(comp);
+	int val = snd_soc_enum_item_to_val(e, item[0]);
+
+	micfil->vad_zcd_en = val;
+
+	return 0;
+}
+
+static int hwvad_get_zcd_en(struct snd_kcontrol *kcontrol,
+			    struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *comp = snd_kcontrol_chip(kcontrol);
+	struct fsl_micfil *micfil = snd_soc_component_get_drvdata(comp);
+
+	ucontrol->value.enumerated.item[0] = micfil->vad_zcd_en;
+
+	return 0;
+}
+
+static int hwvad_put_rate(struct snd_kcontrol *kcontrol,
+			  struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *comp = snd_kcontrol_chip(kcontrol);
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+	unsigned int *item = ucontrol->value.enumerated.item;
+	struct fsl_micfil *micfil = snd_soc_component_get_drvdata(comp);
+	int val = snd_soc_enum_item_to_val(e, item[0]);
+
+	micfil->vad_rate_index = val;
+
+	return 0;
+}
+
+static int hwvad_get_rate(struct snd_kcontrol *kcontrol,
+			  struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *comp = snd_kcontrol_chip(kcontrol);
+	struct fsl_micfil *micfil = snd_soc_component_get_drvdata(comp);
+
+	ucontrol->value.enumerated.item[0] = micfil->vad_rate_index;
+
+	return 0;
+}
+
+static int hwvad_put_zcd_auto(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *comp = snd_kcontrol_chip(kcontrol);
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+	unsigned int *item = ucontrol->value.enumerated.item;
+	struct fsl_micfil *micfil = snd_soc_component_get_drvdata(comp);
+	int val = snd_soc_enum_item_to_val(e, item[0]);
+
+	micfil->vad_zcd_auto = val;
+
+	return 0;
+}
+
+static int hwvad_get_zcd_auto(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *comp = snd_kcontrol_chip(kcontrol);
+	struct fsl_micfil *micfil = snd_soc_component_get_drvdata(comp);
+
+	ucontrol->value.enumerated.item[0] = micfil->vad_zcd_auto;
+
+	return 0;
+}
+
+static int gain_info(struct snd_kcontrol *kcontrol,
+		     struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 0xf;
+
+	return 0;
+}
+
+static int hwvad_put_input_gain(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *comp = snd_kcontrol_chip(kcontrol);
+	struct fsl_micfil *micfil = snd_soc_component_get_drvdata(comp);
+
+	micfil->vad_input_gain = ucontrol->value.integer.value[0];
+
+	return 0;
+}
+
+static int hwvad_get_input_gain(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *comp = snd_kcontrol_chip(kcontrol);
+	struct fsl_micfil *micfil = snd_soc_component_get_drvdata(comp);
+
+	ucontrol->value.enumerated.item[0] = micfil->vad_input_gain;
+
+	return 0;
+}
+
+static int hwvad_put_sound_gain(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *comp = snd_kcontrol_chip(kcontrol);
+	struct fsl_micfil *micfil = snd_soc_component_get_drvdata(comp);
+
+	micfil->vad_sound_gain = ucontrol->value.integer.value[0];
+
+	return 0;
+}
+
+static int hwvad_get_sound_gain(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *comp = snd_kcontrol_chip(kcontrol);
+	struct fsl_micfil *micfil = snd_soc_component_get_drvdata(comp);
+
+	ucontrol->value.enumerated.item[0] = micfil->vad_sound_gain;
+
+	return 0;
+}
+
+static int hwvad_put_noise_gain(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *comp = snd_kcontrol_chip(kcontrol);
+	struct fsl_micfil *micfil = snd_soc_component_get_drvdata(comp);
+
+	micfil->vad_noise_gain = ucontrol->value.integer.value[0];
+
+	return 0;
+}
+
+static int hwvad_get_noise_gain(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *comp = snd_kcontrol_chip(kcontrol);
+	struct fsl_micfil *micfil = snd_soc_component_get_drvdata(comp);
+
+	ucontrol->value.enumerated.item[0] = micfil->vad_noise_gain;
+
+	return 0;
+}
+
+static int hwvad_framet_info(struct snd_kcontrol *kcontrol,
+			     struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 1;
+	uinfo->value.integer.max = 64;
+
+	return 0;
+}
+
+static int hwvad_put_frame_time(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *comp = snd_kcontrol_chip(kcontrol);
+	struct fsl_micfil *micfil = snd_soc_component_get_drvdata(comp);
+
+	micfil->vad_frame_time = ucontrol->value.integer.value[0];
+
+	return 0;
+}
+
+static int hwvad_get_frame_time(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *comp = snd_kcontrol_chip(kcontrol);
+	struct fsl_micfil *micfil = snd_soc_component_get_drvdata(comp);
+
+	ucontrol->value.enumerated.item[0] = micfil->vad_frame_time;
+
+	return 0;
+}
+
+static int hwvad_initt_info(struct snd_kcontrol *kcontrol,
+			    struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 1;
+	uinfo->value.integer.max = 32;
+
+	return 0;
+}
+
+static int hwvad_put_init_time(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *comp = snd_kcontrol_chip(kcontrol);
+	struct fsl_micfil *micfil = snd_soc_component_get_drvdata(comp);
+
+	micfil->vad_init_time = ucontrol->value.integer.value[0];
+
+	return 0;
+}
+
+static int hwvad_get_init_time(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *comp = snd_kcontrol_chip(kcontrol);
+	struct fsl_micfil *micfil = snd_soc_component_get_drvdata(comp);
+
+	ucontrol->value.enumerated.item[0] = micfil->vad_init_time;
+
+	return 0;
+}
+
+static int hwvad_nfiladj_info(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 1;
+	uinfo->value.integer.max = 32;
+
+	return 0;
+}
+
+static int hwvad_put_nfil_adjust(struct snd_kcontrol *kcontrol,
+				 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *comp = snd_kcontrol_chip(kcontrol);
+	struct fsl_micfil *micfil = snd_soc_component_get_drvdata(comp);
+
+	micfil->vad_nfil_adjust = ucontrol->value.integer.value[0];
+
+	return 0;
+}
+
+static int hwvad_get_nfil_adjust(struct snd_kcontrol *kcontrol,
+				 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *comp = snd_kcontrol_chip(kcontrol);
+	struct fsl_micfil *micfil = snd_soc_component_get_drvdata(comp);
+
+	ucontrol->value.enumerated.item[0] = micfil->vad_nfil_adjust;
+
+	return 0;
+}
+
+static int hwvad_zcdth_info(struct snd_kcontrol *kcontrol,
+			    struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 1;
+	uinfo->value.integer.max = 1024;
+
+	return 0;
+}
+
+static int hwvad_put_zcd_th(struct snd_kcontrol *kcontrol,
+			    struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *comp = snd_kcontrol_chip(kcontrol);
+	struct fsl_micfil *micfil = snd_soc_component_get_drvdata(comp);
+
+	micfil->vad_zcd_th = ucontrol->value.integer.value[0];
+
+	return 0;
+}
+
+static int hwvad_get_zcd_th(struct snd_kcontrol *kcontrol,
+			    struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *comp = snd_kcontrol_chip(kcontrol);
+	struct fsl_micfil *micfil = snd_soc_component_get_drvdata(comp);
+
+	ucontrol->value.enumerated.item[0] = micfil->vad_zcd_th;
+
+	return 0;
+}
+
+static int hwvad_zcdadj_info(struct snd_kcontrol *kcontrol,
+			     struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 1;
+	uinfo->value.integer.max = 16;
+
+	return 0;
+}
+
+static int hwvad_put_zcd_adj(struct snd_kcontrol *kcontrol,
+			     struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *comp = snd_kcontrol_chip(kcontrol);
+	struct fsl_micfil *micfil = snd_soc_component_get_drvdata(comp);
+
+	micfil->vad_zcd_adj = ucontrol->value.integer.value[0];
+
+	return 0;
+}
+
+static int hwvad_get_zcd_adj(struct snd_kcontrol *kcontrol,
+			     struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *comp = snd_kcontrol_chip(kcontrol);
+	struct fsl_micfil *micfil = snd_soc_component_get_drvdata(comp);
+
+	ucontrol->value.enumerated.item[0] = micfil->vad_zcd_adj;
+
+	return 0;
+}
 
 static DECLARE_TLV_DB_SCALE(gain_tlv, 0, 100, 0);
 
@@ -106,8 +660,107 @@ static const struct snd_kcontrol_new fsl_micfil_snd_controls[] = {
 	SOC_ENUM_EXT("MICFIL Quality Select",
 		     fsl_micfil_quality_enum,
 		     snd_soc_get_enum_double, snd_soc_put_enum_double),
+	SOC_ENUM_EXT("HWVAD Initialization Mode",
+		     fsl_micfil_hwvad_init_mode_enum,
+		     hwvad_get_init_mode, hwvad_put_init_mode),
+	SOC_ENUM_EXT("HWVAD High-Pass Filter",
+		     fsl_micfil_hwvad_hpf_enum,
+		     hwvad_get_hpf, hwvad_put_hpf),
+	SOC_ENUM_EXT("HWVAD Zero-Crossing Detector Enable",
+		     fsl_micfil_hwvad_zcd_enum,
+		     hwvad_get_zcd_en, hwvad_put_zcd_en),
+	SOC_ENUM_EXT("HWVAD Zero-Crossing Detector Auto Threshold",
+		     fsl_micfil_hwvad_zcdauto_enum,
+		     hwvad_get_zcd_auto, hwvad_put_zcd_auto),
+	SOC_ENUM_EXT("HWVAD Noise OR Enable",
+		     fsl_micfil_hwvad_ndec_enum,
+		     snd_soc_get_enum_double, snd_soc_put_enum_double),
+	SOC_ENUM_EXT("HWVAD Sampling Rate",
+		     fsl_micfil_hwvad_rate_enum,
+		     hwvad_get_rate, hwvad_put_rate),
+	SOC_ENUM_EXT("Clock Source",
+		     fsl_micfil_clk_src_enum,
+		     micfil_get_clk_src, micfil_put_clk_src),
+	SOC_ENUM_EXT("MICFIL DC Remover Control", fsl_micfil_dc_remover_enum,
+		     micfil_get_dc_remover_state, micfil_put_dc_remover_state),
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "HWVAD Input Gain",
+		.access = SNDRV_CTL_ELEM_ACCESS_READ |
+			  SNDRV_CTL_ELEM_ACCESS_WRITE,
+		.info = gain_info,
+		.get = hwvad_get_input_gain,
+		.put = hwvad_put_input_gain,
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "HWVAD Sound Gain",
+		.access = SNDRV_CTL_ELEM_ACCESS_READ |
+			  SNDRV_CTL_ELEM_ACCESS_WRITE,
+		.info = gain_info,
+		.get = hwvad_get_sound_gain,
+		.put = hwvad_put_sound_gain,
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "HWVAD Noise Gain",
+		.access = SNDRV_CTL_ELEM_ACCESS_READ |
+			  SNDRV_CTL_ELEM_ACCESS_WRITE,
+		.info = gain_info,
+		.get = hwvad_get_noise_gain,
+		.put = hwvad_put_noise_gain,
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "HWVAD Detector Frame Time",
+		.access = SNDRV_CTL_ELEM_ACCESS_READ |
+			  SNDRV_CTL_ELEM_ACCESS_WRITE,
+		.info = hwvad_framet_info,
+		.get = hwvad_get_frame_time,
+		.put = hwvad_put_frame_time,
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "HWVAD Detector Initialization Time",
+		.access = SNDRV_CTL_ELEM_ACCESS_READ |
+			  SNDRV_CTL_ELEM_ACCESS_WRITE,
+		.info = hwvad_initt_info,
+		.get = hwvad_get_init_time,
+		.put = hwvad_put_init_time,
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "HWVAD Noise Filter Adjustment",
+		.access = SNDRV_CTL_ELEM_ACCESS_READ |
+			  SNDRV_CTL_ELEM_ACCESS_WRITE,
+		.info = hwvad_nfiladj_info,
+		.get = hwvad_get_nfil_adjust,
+		.put = hwvad_put_nfil_adjust,
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "HWVAD Zero-Crossing Detector Threshold",
+		.access = SNDRV_CTL_ELEM_ACCESS_READ |
+			  SNDRV_CTL_ELEM_ACCESS_WRITE,
+		.info = hwvad_zcdth_info,
+		.get = hwvad_get_zcd_th,
+		.put = hwvad_put_zcd_th,
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "HWVAD Zero-Crossing Detector Adjustment",
+		.access = SNDRV_CTL_ELEM_ACCESS_READ |
+			  SNDRV_CTL_ELEM_ACCESS_WRITE,
+		.info = hwvad_zcdadj_info,
+		.get = hwvad_get_zcd_adj,
+		.put = hwvad_put_zcd_adj,
+	},
+
 };
 
+static int disable_hwvad(struct device *dev, bool sync);
+
+
 static inline int get_pdm_clk(struct fsl_micfil *micfil,
 			      unsigned int rate)
 {
@@ -160,53 +813,620 @@ static inline int get_clk_div(struct fsl_micfil *micfil,
 
 	clk_div = mclk_rate / (get_pdm_clk(micfil, rate) * 2);
 
-	return clk_div;
+	return clk_div;
+}
+
+/* The SRES is a self-negated bit which provides the CPU with the
+ * capability to initialize the PDM Interface module through the
+ * slave-bus interface. This bit always reads as zero, and this
+ * bit is only effective when MDIS is cleared
+ */
+static int fsl_micfil_reset(struct device *dev)
+{
+	struct fsl_micfil *micfil = dev_get_drvdata(dev);
+	int ret;
+
+	ret = regmap_update_bits(micfil->regmap,
+				 REG_MICFIL_CTRL1,
+				 MICFIL_CTRL1_MDIS_MASK,
+				 0);
+	if (ret) {
+		dev_err(dev, "failed to clear MDIS bit %d\n", ret);
+		return ret;
+	}
+
+	ret = regmap_update_bits(micfil->regmap,
+				 REG_MICFIL_CTRL1,
+				 MICFIL_CTRL1_SRES_MASK,
+				 MICFIL_CTRL1_SRES);
+	if (ret) {
+		dev_err(dev, "failed to reset MICFIL: %d\n", ret);
+		return ret;
+	}
+
+	/* w1c */
+	regmap_write_bits(micfil->regmap, REG_MICFIL_STAT, 0xFF, 0xFF);
+
+	return 0;
+}
+
+/* enable/disable hwvad interrupts */
+static int configure_hwvad_interrupts(struct device *dev,
+				      int enable)
+{
+	struct fsl_micfil *micfil = dev_get_drvdata(dev);
+	int ret;
+	u32 vadie_reg = enable ? MICFIL_VAD0_CTRL1_IE : 0;
+	u32 vaderie_reg = enable ? MICFIL_VAD0_CTRL1_ERIE : 0;
+
+	/* Voice Activity Detector Error Interruption Enable */
+	ret = regmap_update_bits(micfil->regmap, REG_MICFIL_VAD0_CTRL1,
+				 MICFIL_VAD0_CTRL1_ERIE_MASK,
+				 vaderie_reg);
+	if (ret) {
+		dev_err(dev,
+			"Failed to set/clear VADERIE in CTRL1_VAD0 [%d]\n",
+			ret);
+		return ret;
+	}
+
+	/* Voice Activity Detector Interruption Enable */
+	ret = regmap_update_bits(micfil->regmap, REG_MICFIL_VAD0_CTRL1,
+				 MICFIL_VAD0_CTRL1_IE_MASK,
+				 vadie_reg);
+	if (ret) {
+		dev_err(dev,
+			"Failed to set/clear VADIE in CTRL1_VAD0 [%d]\n",
+			ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int init_hwvad_internal_filters(struct device *dev)
+{
+	struct fsl_micfil *micfil = dev_get_drvdata(dev);
+	int ret;
+
+	/* Voice Activity Detector Internal Filters Initialization*/
+	ret = regmap_update_bits(micfil->regmap, REG_MICFIL_VAD0_CTRL1,
+				 MICFIL_VAD0_CTRL1_ST10_MASK,
+				 MICFIL_VAD0_CTRL1_ST10);
+	if (ret) {
+		dev_err(dev,
+			"Failed to set VADST10 in CTRL1_VAD0 [%d]\n",
+			ret);
+		return ret;
+	}
+
+	/* sleep for 100ms - it should be enough for bit to stay
+	 * pulsed for more than 2 cycles
+	 */
+	mdelay(MICFIL_SLEEP);
+
+	/* Voice Activity Detector Enabled */
+	ret = regmap_update_bits(micfil->regmap, REG_MICFIL_VAD0_CTRL1,
+				 MICFIL_VAD0_CTRL1_ST10_MASK,
+				 0);
+	if (ret) {
+		dev_err(dev,
+			"Failed to clear VADST10 in CTRL1_VAD0 [%d]\n",
+			ret);
+		return ret;
+	}
+	return 0;
+}
+
+/* Zero-Crossing Detector Initialization
+ * Optionally a Zero-Crossing Detection block (ZCD) could
+ * be enabled to avoid low energy voiced speech be missed,
+ * improving the voice detection performance.
+ * See Section 8.4.3
+ */
+static int __maybe_unused init_zcd(struct device *dev)
+{
+	struct fsl_micfil *micfil = dev_get_drvdata(dev);
+	int ret;
+
+	/* exit if zcd is not enabled from userspace */
+	if (!micfil->vad_zcd_en)
+		return 0;
+
+	if (micfil->vad_zcd_auto) {
+		/* Zero-Crossing Detector Adjustment */
+		ret = regmap_update_bits(micfil->regmap, REG_MICFIL_VAD0_ZCD,
+					 MICFIL_VAD0_ZCD_ZCDADJ_MASK,
+					 micfil->vad_zcd_adj);
+		if (ret) {
+			dev_err(dev,
+				"Failed to set ZCDADJ in ZCD_VAD0 [%d]\n",
+				ret);
+			return ret;
+		}
+	}
+
+	/* Zero-Crossing Detector Threshold */
+	ret = regmap_update_bits(micfil->regmap, REG_MICFIL_VAD0_ZCD,
+				 MICFIL_VAD0_ZCD_ZCDTH_MASK,
+				 MICFIL_VAD0_ZCD_ZCDTH(micfil->vad_zcd_th));
+	if (ret) {
+		dev_err(dev, "Failed to set ZCDTH in ZCD_VAD0 [%d]\n", ret);
+		return ret;
+	}
+
+	/* Zero-Crossing Detector AND Behavior */
+	ret = regmap_update_bits(micfil->regmap, REG_MICFIL_VAD0_ZCD,
+				 MICFIL_VAD0_ZCD_ZCDAND_MASK,
+				 MICFIL_HWVAD_ZCDAND);
+	if (ret) {
+		dev_err(dev, "Failed to set ZCDAND in ZCD_VAD0 [%d]\n", ret);
+		return ret;
+	}
+
+	/* Zero-Crossing Detector Automatic Threshold */
+	ret = regmap_update_bits(micfil->regmap, REG_MICFIL_VAD0_ZCD,
+				 MICFIL_VAD0_ZCD_ZCDAUT_MASK,
+				 micfil->vad_zcd_auto);
+	if (ret) {
+		dev_err(dev,
+			"Failed to set/clear ZCDAUT in ZCD_VAD0 [%d]\n",
+			ret);
+		return ret;
+	}
+
+	/* Zero-Crossing Detector Enable */
+	ret = regmap_update_bits(micfil->regmap, REG_MICFIL_VAD0_ZCD,
+				 MICFIL_VAD0_ZCD_ZCDEN_MASK,
+				 MICFIL_VAD0_ZCD_ZCDEN);
+	if (ret) {
+		dev_err(dev, "Failed to set ZCDEN in ZCD_VAD0 [%d]\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+/* Configuration done only in energy-based initialization mode */
+static int init_hwvad_energy_mode(struct device *dev)
+{
+	struct fsl_micfil *micfil = dev_get_drvdata(dev);
+	int ret, i;
+	u32 stat;
+	u32 flag;
+
+	dev_info(dev, "Energy-based mode initialization\n");
+
+	/* Voice Activity Detector Reset */
+	ret = regmap_update_bits(micfil->regmap, REG_MICFIL_VAD0_CTRL1,
+				 MICFIL_VAD0_CTRL1_RST_SHIFT,
+				 MICFIL_VAD0_CTRL1_RST);
+	if (ret) {
+		dev_err(dev, "Failed to set VADRST in CTRL1_VAD0 [%d]\n", ret);
+		return ret;
+	}
+
+	/* Voice Activity Detector Enabled */
+	ret = regmap_update_bits(micfil->regmap, REG_MICFIL_VAD0_CTRL1,
+				 MICFIL_VAD0_CTRL1_EN_MASK,
+				 MICFIL_VAD0_CTRL1_EN);
+	if (ret) {
+		dev_err(dev, "Failed to set VADEN in CTRL1_VAD0 [%d]\n", ret);
+		return ret;
+	}
+
+	/* it would be a good idea to wait some time before VADEN
+	 * is set
+	 */
+	mdelay(5 * MICFIL_SLEEP);
+
+	/* Enable Interrupts */
+	ret = configure_hwvad_interrupts(dev, 1);
+
+	/* Initialize Zero Crossing Detector */
+	ret = init_zcd(dev);
+	if (ret)
+		return ret;
+
+	/* Enable MICFIL module */
+	ret = regmap_update_bits(micfil->regmap, REG_MICFIL_CTRL1,
+				 MICFIL_CTRL1_PDMIEN_MASK,
+				 MICFIL_CTRL1_PDMIEN);
+	if (ret) {
+		dev_err(dev, "failed to enable the module\n");
+		return ret;
+	}
+
+	/* Wait for INITF to be asserted */
+	for (i = 0; i < MICFIL_MAX_RETRY; i++) {
+		ret = regmap_read(micfil->regmap, REG_MICFIL_VAD0_STAT, &stat);
+		if (ret) {
+			dev_err(dev, "failed to read register %d\n",
+				REG_MICFIL_VAD0_STAT);
+			return ret;
+		}
+
+		flag = (stat & MICFIL_VAD0_STAT_INITF_MASK);
+		if (flag == 0)
+			break;
+
+		mdelay(MICFIL_SLEEP);
+	}
+
+	if (i == MICFIL_MAX_RETRY) {
+		dev_err(dev, "initf not asserted. Failed to init hwvad\n");
+		return -EBUSY;
+	}
+
+	/* Initialize Internal Filters */
+	ret = init_hwvad_internal_filters(dev);
+	if (ret)
+		return ret;
+
+	return ret;
+}
+
+/* Configuration done only in envelope-based initialization mode */
+static int init_hwvad_envelope_mode(struct device *dev)
+{
+	struct fsl_micfil *micfil = dev_get_drvdata(dev);
+	int ret, i;
+	u32 stat;
+	u32 flag;
+
+	/* Frame energy disable */
+	ret = regmap_update_bits(micfil->regmap, REG_MICFIL_VAD0_CTRL2,
+				 MICFIL_VAD0_CTRL2_FRENDIS_MASK,
+				 MICFIL_VAD0_CTRL2_FRENDIS);
+	if (ret) {
+		dev_err(dev, "Failed to set FRENDIS in CTRL2_VAD0 [%d]\n", ret);
+		return ret;
+	}
+
+	/* Enable pre-filter Noise & Signal */
+	ret = regmap_update_bits(micfil->regmap, REG_MICFIL_VAD0_CTRL2,
+				 MICFIL_VAD0_CTRL2_PREFEN_MASK,
+				 MICFIL_VAD0_CTRL2_PREFEN);
+	if (ret) {
+		dev_err(dev, "Failed to set PREFEN in CTRL2_VAD0 [%d]\n", ret);
+		return ret;
+	}
+
+	/* Enable Signal Filter */
+	ret = regmap_update_bits(micfil->regmap, REG_MICFIL_VAD0_SCONFIG,
+				 MICFIL_VAD0_SCONFIG_SFILEN_MASK,
+				 MICFIL_VAD0_SCONFIG_SFILEN);
+	if (ret) {
+		dev_err(dev,
+			"Failed to set SFILEN in SCONFIG_VAD0 [%d]\n",
+			ret);
+		return ret;
+	}
+
+	/* Signal Maximum Enable */
+	ret = regmap_update_bits(micfil->regmap, REG_MICFIL_VAD0_SCONFIG,
+				 MICFIL_VAD0_SCONFIG_SMAXEN_MASK,
+				 MICFIL_VAD0_SCONFIG_SMAXEN);
+	if (ret) {
+		dev_err(dev,
+			"Failed to set SMAXEN in SCONFIG_VAD0 [%d]\n",
+			ret);
+		return ret;
+	}
+
+	/* Allways enable noise filter, not based on voice activity
+	 * information
+	 */
+	ret = regmap_update_bits(micfil->regmap, REG_MICFIL_VAD0_NCONFIG,
+				 MICFIL_VAD0_NCONFIG_NFILAUT_MASK,
+				 0);
+	if (ret) {
+		dev_err(dev,
+			"Failed to set NFILAUT in NCONFIG_VAD0 [%d]\n",
+			ret);
+		return ret;
+	}
+
+	/* Noise Minimum Enable */
+	ret = regmap_update_bits(micfil->regmap, REG_MICFIL_VAD0_NCONFIG,
+				 MICFIL_VAD0_NCONFIG_NMINEN_MASK,
+				 MICFIL_VAD0_NCONFIG_NMINEN);
+	if (ret) {
+		dev_err(dev,
+			"Failed to set NMINEN in NCONFIG_VAD0 [%d]\n",
+			ret);
+		return ret;
+	}
+
+	/* Noise Decimation Enable */
+	ret = regmap_update_bits(micfil->regmap, REG_MICFIL_VAD0_NCONFIG,
+				 MICFIL_VAD0_NCONFIG_NDECEN_MASK,
+				 MICFIL_VAD0_NCONFIG_NDECEN);
+	if (ret) {
+		dev_err(dev,
+			"Failed to set NDECEN in NCONFIG_VAD0 [%d]\n",
+			ret);
+		return ret;
+	}
+
+	/* Voice Activity Detector Reset */
+	ret = regmap_update_bits(micfil->regmap, REG_MICFIL_VAD0_CTRL1,
+				 MICFIL_VAD0_CTRL1_RST_MASK,
+				 MICFIL_VAD0_CTRL1_RST);
+	if (ret) {
+		dev_err(dev, "Failed to set VADRST in CTRL1_VAD0 [%d]\n", ret);
+		return ret;
+	}
+
+	/* Initialize Zero Crossing Detector */
+	ret = init_zcd(dev);
+	if (ret)
+		return ret;
+
+	/* Voice Activity Detector Enabled */
+	ret = regmap_update_bits(micfil->regmap, REG_MICFIL_VAD0_CTRL1,
+				 MICFIL_VAD0_CTRL1_EN_MASK,
+				 MICFIL_VAD0_CTRL1_EN);
+	if (ret) {
+		dev_err(dev, "Failed to set VADEN in CTRL1_VAD0 [%d]\n", ret);
+		return ret;
+	}
+
+	/* Enable MICFIL module */
+	ret = regmap_update_bits(micfil->regmap, REG_MICFIL_CTRL1,
+				 MICFIL_CTRL1_PDMIEN_MASK,
+				 MICFIL_CTRL1_PDMIEN);
+	if (ret) {
+		dev_err(dev, "failed to enable the module\n");
+		return ret;
+	}
+
+	/* it would be a good idea to wait some time before VADEN
+	 * is set
+	 */
+	mdelay(3 * MICFIL_SLEEP);
+
+	/* Wait for INITF to be asserted */
+	for (i = 0; i < MICFIL_MAX_RETRY; i++) {
+		ret = regmap_read(micfil->regmap, REG_MICFIL_VAD0_STAT, &stat);
+		if (ret) {
+			dev_err(dev, "failed to read register %d\n",
+				REG_MICFIL_VAD0_STAT);
+			return ret;
+		}
+
+		flag = (stat & MICFIL_VAD0_STAT_INITF_MASK);
+		if (flag == 0)
+			break;
+
+		mdelay(MICFIL_SLEEP);
+	}
+
+	if (i == MICFIL_MAX_RETRY) {
+		dev_err(dev, "initf not asserted. Failed to init hwvad\n");
+		return -EBUSY;
+	}
+
+	/* Initialize Internal Filters */
+	ret = init_hwvad_internal_filters(dev);
+	if (ret)
+		return ret;
+
+	/* Enable interrupts */
+	ret = configure_hwvad_interrupts(dev, 1);
+	if (ret)
+		return ret;
+
+	return ret;
 }
 
-/* The SRES is a self-negated bit which provides the CPU with the
- * capability to initialize the PDM Interface module through the
- * slave-bus interface. This bit always reads as zero, and this
- * bit is only effective when MDIS is cleared
+/* Hardware Voice Active Detection: The HWVAD takes data from the input
+ * of a selected PDM microphone to detect if there is any
+ * voice activity. When a voice activity is detected, an interrupt could
+ * be delivered to the system. Initialization in section 8.4:
+ * Can work in two modes:
+ *  -> Eneveope-based mode (section 8.4.1)
+ *  -> Energy-based mode (section 8.4.2)
+ *
+ * It is important to remark that the HWVAD detector could be enabled
+ * or reset only when the MICFIL isn't running i.e. when the BSY_FIL
+ * bit in STAT register is cleared
  */
-static int fsl_micfil_reset(struct device *dev)
+static int __maybe_unused init_hwvad(struct device *dev)
 {
 	struct fsl_micfil *micfil = dev_get_drvdata(dev);
 	int ret;
+	u32 reg_val;
 
-	ret = regmap_update_bits(micfil->regmap,
-				 REG_MICFIL_CTRL1,
-				 MICFIL_CTRL1_MDIS_MASK,
-				 0);
+	/* configure CIC OSR in VADCICOSR */
+	ret = regmap_update_bits(micfil->regmap, REG_MICFIL_VAD0_CTRL1,
+				 MICFIL_VAD0_CTRL1_CICOSR_MASK,
+				 MICFIL_CTRL2_OSR_DEFAULT);
 	if (ret) {
-		dev_err(dev, "failed to clear MDIS bit %d\n", ret);
+		dev_err(dev, "Failed to set CICOSR in CTRL1_VAD0i [%d]\n", ret);
 		return ret;
 	}
 
-	ret = regmap_update_bits(micfil->regmap,
-				 REG_MICFIL_CTRL1,
-				 MICFIL_CTRL1_SRES_MASK,
-				 MICFIL_CTRL1_SRES);
+	/* configure source channel in VADCHSEL */
+	reg_val = MICFIL_VAD0_CTRL1_CHSEL(micfil->vad_channel);
+	ret = regmap_update_bits(micfil->regmap, REG_MICFIL_VAD0_CTRL1,
+				 MICFIL_VAD0_CTRL1_CHSEL_MASK,
+				 reg_val);
 	if (ret) {
-		dev_err(dev, "failed to reset MICFIL: %d\n", ret);
+		dev_err(dev, "Failed to set CHSEL in CTRL1_VAD0 [%d]\n", ret);
+		return ret;
+	}
+
+	/* configure detector frame time VADFRAMET */
+	reg_val = MICFIL_VAD0_CTRL2_FRAMET(micfil->vad_frame_time);
+	ret = regmap_update_bits(micfil->regmap, REG_MICFIL_VAD0_CTRL2,
+				 MICFIL_VAD0_CTRL2_FRAMET_MASK,
+				 reg_val);
+	if (ret) {
+		dev_err(dev, "Failed to set FRAMET in CTRL2_VAD0 [%d]\n", ret);
+		return ret;
+	}
+
+	/* configure initialization time in VADINITT */
+	reg_val = MICFIL_VAD0_CTRL1_INITT(micfil->vad_init_time);
+	ret = regmap_update_bits(micfil->regmap, REG_MICFIL_VAD0_CTRL1,
+				 MICFIL_VAD0_CTRL1_INITT_MASK,
+				 reg_val);
+	if (ret) {
+		dev_err(dev, "Failed to set INITT in CTRL1_VAD0 [%d]\n", ret);
+		return ret;
+	}
+
+	/* configure input gain in VADINPGAIN */
+	reg_val = MICFIL_VAD0_CTRL2_INPGAIN(micfil->vad_input_gain);
+	ret = regmap_update_bits(micfil->regmap, REG_MICFIL_VAD0_CTRL2,
+				 MICFIL_VAD0_CTRL2_INPGAIN_MASK,
+				 reg_val);
+	if (ret) {
+		dev_err(dev, "Failed to set INPGAIN in CTRL2_VAD0 [%d]\n", ret);
 		return ret;
 	}
 
+	/* configure sound gain in SGAIN */
+	reg_val = MICFIL_VAD0_SCONFIG_SGAIN(micfil->vad_sound_gain);
+	ret = regmap_update_bits(micfil->regmap, REG_MICFIL_VAD0_SCONFIG,
+				 MICFIL_VAD0_SCONFIG_SGAIN_MASK,
+				 reg_val);
+	if (ret) {
+		dev_err(dev, "Failed to set SGAIN in SCONFIG_VAD0 [%d]\n", ret);
+		return ret;
+	}
+
+	/* configure noise gain in NGAIN */
+	reg_val = MICFIL_VAD0_NCONFIG_NGAIN(micfil->vad_noise_gain);
+	ret = regmap_update_bits(micfil->regmap, REG_MICFIL_VAD0_NCONFIG,
+				 MICFIL_VAD0_NCONFIG_NGAIN_MASK,
+				 reg_val);
+	if (ret) {
+		dev_err(dev, "Failed to set NGAIN in NCONFIG_VAD0 [%d]\n", ret);
+		return ret;
+	}
+
+	/* configure or clear the VADNFILADJ based on mode */
+	reg_val = MICFIL_VAD0_NCONFIG_NFILADJ(micfil->vad_nfil_adjust);
+	ret = regmap_update_bits(micfil->regmap, REG_MICFIL_VAD0_NCONFIG,
+				 MICFIL_VAD0_NCONFIG_NFILADJ_MASK,
+				 reg_val);
+	if (ret) {
+		dev_err(dev,
+			"Failed to set VADNFILADJ in NCONFIG_VAD0 [%d]\n",
+			ret);
+		return ret;
+	}
+
+	/* enable the high-pass filter in VADHPF */
+	reg_val = MICFIL_VAD0_CTRL2_HPF(micfil->vad_hpf);
+	ret = regmap_update_bits(micfil->regmap, REG_MICFIL_VAD0_CTRL2,
+				 MICFIL_VAD0_CTRL2_HPF_MASK,
+				 reg_val);
+	if (ret) {
+		dev_err(dev, "Failed to set HPF in CTRL2_VAD0 [%d]\n", ret);
+		return ret;
+	}
+
+	/* envelope-based specific initialization */
+	if (micfil->vad_init_mode == MICFIL_HWVAD_ENVELOPE_MODE) {
+		ret = init_hwvad_envelope_mode(dev);
+		if (ret)
+			return ret;
+	} else {
+		ret = init_hwvad_energy_mode(dev);
+		if (ret)
+			return ret;
+	}
+
 	return 0;
 }
 
-static int fsl_micfil_set_mclk_rate(struct fsl_micfil *micfil,
+static inline bool clk_in_list(struct clk *p, struct clk *clk_src[])
+{
+	int i;
+
+	for (i = 0; i < MICFIL_CLK_SRC_NUM; i++)
+		if (clk_is_match(p, clk_src[i]))
+			return true;
+
+	return false;
+}
+
+#define CLK_8K_FREQ    24576000
+#define CLK_11K_FREQ   22579200
+
+static int fsl_micfil_set_mclk_rate(struct fsl_micfil *micfil, int clk_id,
 				    unsigned int freq)
 {
+	struct clk *p = micfil->mclk, *pll = 0, *npll = 0;
 	struct device *dev = &micfil->pdev->dev;
+	u64 ratio = freq;
+	u64 clk_rate;
 	int ret;
+	int i;
+
+	/* Do not touch the clock if hwvad is already enabled
+	 * since you can record only at hwvad rate and clock
+	 * has already been set to the required frequency
+	 */
+	if (atomic_read(&micfil->hwvad_state) == MICFIL_HWVAD_ON)
+		return 0;
+
+	while (p) {
+		struct clk *pp = clk_get_parent(p);
+
+		if (clk_in_list(pp, micfil->clk_src)) {
+			pll = pp;
+			break;
+		}
+		p = pp;
+	}
+
+	if (!pll) {
+		dev_err(dev, "reached a null clock\n");
+		return -EINVAL;
+	}
+
+	if (micfil->clk_src_id == MICFIL_CLK_AUTO) {
+		for (i = 0; i < MICFIL_CLK_SRC_NUM; i++) {
+			clk_rate = clk_get_rate(micfil->clk_src[i]);
+			/* This is an workaround since audio_pll2 clock
+			 * has 722534399 rate and this will never divide
+			 * to any known frequency ???
+			 */
+			clk_rate = round_up(clk_rate, 10);
+			if (do_div(clk_rate, ratio) == 0) {
+				npll = micfil->clk_src[i];
+				break;
+			}
+		}
+	} else {
+		/* clock id is offseted by 1 since ID=0 means
+		 * auto clock selection
+		 */
+		npll = micfil->clk_src[micfil->clk_src_id - 1];
+	}
+
+	if (!npll) {
+		dev_err(dev,
+			"failed to find a suitable clock source\n");
+		return -EINVAL;
+	}
 
 	clk_disable_unprepare(micfil->mclk);
+	if (!clk_is_match(pll, npll)) {
+		ret = clk_set_parent(p, npll);
+		if (ret < 0)
+			dev_warn(dev,
+				 "failed to set parrent %d\n", ret);
+	}
 
-	ret = clk_set_rate(micfil->mclk, freq * 1024);
+	clk_rate = freq % 8000 == 0 ? CLK_8K_FREQ : CLK_11K_FREQ;
+	ret = clk_set_rate(micfil->mclk, clk_rate);
 	if (ret)
-		dev_warn(dev, "failed to set rate (%u): %d\n",
-			 freq * 1024, ret);
-
+		dev_warn(dev, "failed to set rate (%llu): %d\n", clk_rate, ret);
 	clk_prepare_enable(micfil->mclk);
 
 	return ret;
@@ -298,7 +1518,7 @@ static int fsl_set_clock_params(struct device *dev, unsigned int rate)
 	int clk_div;
 	int ret;
 
-	ret = fsl_micfil_set_mclk_rate(micfil, rate);
+	ret = fsl_micfil_set_mclk_rate(micfil, 0, rate);
 	if (ret < 0)
 		dev_err(dev, "failed to set mclk[%lu] to rate %u\n",
 			clk_get_rate(micfil->mclk), rate);
@@ -333,14 +1553,32 @@ static int fsl_micfil_hw_params(struct snd_pcm_substream *substream,
 	unsigned int channels = params_channels(params);
 	unsigned int rate = params_rate(params);
 	struct device *dev = &micfil->pdev->dev;
+	unsigned int hwvad_rate;
 	int ret;
+	u32 hwvad_state;
 
-	/* 1. Disable the module */
-	ret = regmap_update_bits(micfil->regmap, REG_MICFIL_CTRL1,
-				 MICFIL_CTRL1_PDMIEN_MASK, 0);
-	if (ret) {
-		dev_err(dev, "failed to disable the module\n");
-		return ret;
+	hwvad_rate = micfil_hwvad_rate_ints[micfil->vad_rate_index];
+	hwvad_state = atomic_read(&micfil->hwvad_state);
+
+	/* if hwvad is enabled, make sure you are recording at
+	 * the same rate the hwvad is on or reject it to avoid
+	 * changing the clock rate.
+	 */
+	if (hwvad_state == MICFIL_HWVAD_ON && rate != hwvad_rate) {
+		dev_err(dev, "Record at hwvad rate %u\n", hwvad_rate);
+		return -EINVAL;
+	}
+
+	atomic_set(&micfil->recording_state, MICFIL_RECORDING_ON);
+
+	if (hwvad_state == MICFIL_HWVAD_OFF) {
+		/* 1. Disable the module */
+		ret = regmap_update_bits(micfil->regmap, REG_MICFIL_CTRL1,
+					 MICFIL_CTRL1_PDMIEN_MASK, 0);
+		if (ret) {
+			dev_err(dev, "failed to disable the module\n");
+			return ret;
+		}
 	}
 
 	/* enable channels */
@@ -358,11 +1596,25 @@ static int fsl_micfil_hw_params(struct snd_pcm_substream *substream,
 		return ret;
 	}
 
+	micfil->audio_config.src_fifo_num = channels;
+	micfil->audio_config.sw_done_sel = BIT(31);
+	micfil->dma_params_rx.peripheral_config  = &micfil->audio_config;
+	micfil->dma_params_rx.peripheral_size    = sizeof(micfil->audio_config);
 	micfil->dma_params_rx.maxburst = channels * MICFIL_DMA_MAXBURST_RX;
 
 	return 0;
 }
 
+static int fsl_micfil_hw_free(struct snd_pcm_substream *substream,
+			      struct snd_soc_dai *dai)
+{
+	struct fsl_micfil *micfil = snd_soc_dai_get_drvdata(dai);
+
+	atomic_set(&micfil->recording_state, MICFIL_RECORDING_OFF);
+
+	return 0;
+}
+
 static int fsl_micfil_set_dai_sysclk(struct snd_soc_dai *dai, int clk_id,
 				     unsigned int freq, int dir)
 {
@@ -374,7 +1626,7 @@ static int fsl_micfil_set_dai_sysclk(struct snd_soc_dai *dai, int clk_id,
 	if (!freq)
 		return 0;
 
-	ret = fsl_micfil_set_mclk_rate(micfil, freq);
+	ret = fsl_micfil_set_mclk_rate(micfil, clk_id, freq);
 	if (ret < 0)
 		dev_err(dev, "failed to set mclk[%lu] to rate %u\n",
 			clk_get_rate(micfil->mclk), freq);
@@ -382,11 +1634,38 @@ static int fsl_micfil_set_dai_sysclk(struct snd_soc_dai *dai, int clk_id,
 	return ret;
 }
 
+static int fsl_micfil_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)
+{
+	struct fsl_micfil *micfil = snd_soc_dai_get_drvdata(dai);
+
+	/* DAI MODE */
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* DAI CLK INVERSION */
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	micfil->slave_mode = false;
+
+	return 0;
+}
+
 static const struct snd_soc_dai_ops fsl_micfil_dai_ops = {
 	.startup = fsl_micfil_startup,
 	.trigger = fsl_micfil_trigger,
 	.hw_params = fsl_micfil_hw_params,
+	.hw_free = fsl_micfil_hw_free,
 	.set_sysclk = fsl_micfil_set_dai_sysclk,
+	.set_fmt = fsl_micfil_set_dai_fmt,
 };
 
 static int fsl_micfil_dai_probe(struct snd_soc_dai *cpu_dai)
@@ -399,17 +1678,30 @@ static int fsl_micfil_dai_probe(struct snd_soc_dai *cpu_dai)
 
 	/* set qsel to medium */
 	ret = regmap_update_bits(micfil->regmap, REG_MICFIL_CTRL2,
-				 MICFIL_CTRL2_QSEL_MASK, MICFIL_MEDIUM_QUALITY);
+				 MICFIL_CTRL2_QSEL_MASK, MICFIL_VLOW0_QUALITY);
 	if (ret) {
 		dev_err(dev, "failed to set quality mode bits, reg 0x%X\n",
 			REG_MICFIL_CTRL2);
 		return ret;
 	}
 
-	/* set default gain to max_gain */
-	regmap_write(micfil->regmap, REG_MICFIL_OUT_CTRL, 0x77777777);
-	for (i = 0; i < 8; i++)
-		micfil->channel_gain[i] = 0xF;
+	/* set default gain to 2 */
+	regmap_write(micfil->regmap, REG_MICFIL_OUT_CTRL, 0x22222222);
+	for (i = 0; i < MICFIL_OUTPUT_CHANNELS; i++)
+		micfil->channel_gain[i] = 0xA;
+
+	/* set DC Remover in bypass mode*/
+	val = 0;
+	for (i = 0; i < MICFIL_OUTPUT_CHANNELS; i++)
+		val |= MICFIL_DC_MODE(MICFIL_DC_BYPASS, i);
+	ret = regmap_update_bits(micfil->regmap, REG_MICFIL_DC_CTRL,
+				MICFIL_DC_CTRL_MASK, val);
+	if (ret) {
+		dev_err(dev, "failed to set DC Remover mode bits, reg 0x%X\n",
+			REG_MICFIL_DC_CTRL);
+		return ret;
+	}
+	micfil->dc_remover = MICFIL_DC_BYPASS;
 
 	snd_soc_dai_init_dma_data(cpu_dai, NULL,
 				  &micfil->dma_params_rx);
@@ -564,6 +1856,72 @@ static const struct regmap_config fsl_micfil_regmap_config = {
 
 /* END OF REGMAP */
 
+static irqreturn_t voice_detected_fn(int irq, void *devid)
+{
+	struct fsl_micfil *micfil = (struct fsl_micfil *)devid;
+	struct device *dev = &micfil->pdev->dev;
+	int ret;
+
+	/* disable hwvad */
+	spin_lock(&micfil->hwvad_lock);
+	ret = disable_hwvad(dev, true);
+	spin_unlock(&micfil->hwvad_lock);
+
+	if (ret)
+		dev_err(dev, "Failed to disable HWVAD module: %d\n", ret);
+
+	/* notify userspace that voice was detected */
+	kobject_uevent_env(&dev->kobj, KOBJ_CHANGE, envp);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t hwvad_isr(int irq, void *devid)
+{
+	struct fsl_micfil *micfil = (struct fsl_micfil *)devid;
+	struct device *dev = &micfil->pdev->dev;
+	int ret;
+	u32 vad0_reg;
+
+	regmap_read(micfil->regmap, REG_MICFIL_VAD0_STAT, &vad0_reg);
+
+	/* The only difference between MICFIL_VAD0_STAT_EF and
+	 * MICFIL_VAD0_STAT_IF is that the former requires Write
+	 * 1 to Clear. Since both flags are set, it is enough
+	 * to only read one of them
+	 */
+	if (vad0_reg & MICFIL_VAD0_STAT_IF_MASK) {
+		/* Write 1 to clear */
+		regmap_write_bits(micfil->regmap, REG_MICFIL_VAD0_STAT,
+				  MICFIL_VAD0_STAT_IF_MASK,
+				  MICFIL_VAD0_STAT_IF);
+
+		/* disable hwvad interrupts */
+		ret = configure_hwvad_interrupts(dev, 0);
+		if (ret)
+			dev_err(dev, "Failed to disable interrupts\n");
+	}
+
+	return IRQ_WAKE_THREAD;
+}
+
+static irqreturn_t hwvad_err_isr(int irq, void *devid)
+{
+	struct fsl_micfil *micfil = (struct fsl_micfil *)devid;
+	struct device *dev = &micfil->pdev->dev;
+	u32 vad0_reg;
+
+	regmap_read(micfil->regmap, REG_MICFIL_VAD0_STAT, &vad0_reg);
+
+	if (vad0_reg & MICFIL_VAD0_STAT_INSATF_MASK)
+		dev_dbg(dev, "voice activity input overflow/underflow detected\n");
+
+	if (vad0_reg & MICFIL_VAD0_STAT_INITF_MASK)
+		dev_dbg(dev, "voice activity dectector is initializing\n");
+
+	return IRQ_HANDLED;
+}
+
 static irqreturn_t micfil_isr(int irq, void *devid)
 {
 	struct fsl_micfil *micfil = (struct fsl_micfil *)devid;
@@ -633,6 +1991,196 @@ static irqreturn_t micfil_err_isr(int irq, void *devid)
 	return IRQ_HANDLED;
 }
 
+static int fsl_set_clock_params(struct device *, unsigned int);
+
+static int enable_hwvad(struct device *dev, bool sync)
+{
+	struct fsl_micfil *micfil = dev_get_drvdata(dev);
+	int ret;
+	int rate;
+	u32 state;
+
+	if (sync)
+		pm_runtime_get_sync(dev);
+
+	state = atomic_cmpxchg(&micfil->hwvad_state,
+			       MICFIL_HWVAD_OFF,
+			       MICFIL_HWVAD_ON);
+
+	/* we should not reenable when sync = true because
+	 * this means enable was called for second time by
+	 * user. However state = ON and sync = false can only
+	 * occur when enable is called from system_resume. In
+	 * this case we should enable the hwvad
+	 */
+	if (sync && state == MICFIL_HWVAD_ON) {
+		dev_err(dev, "hwvad already on\n");
+		ret = -EBUSY;
+		goto enable_error;
+	}
+
+	if (micfil->vad_rate_index >= ARRAY_SIZE(micfil_hwvad_rate_ints)) {
+		dev_err(dev, "There are more select texts than rates\n");
+		ret = -EINVAL;
+		goto enable_error;
+	}
+
+	rate = micfil_hwvad_rate_ints[micfil->vad_rate_index];
+
+	/* This is required because if an arecord was done,
+	 * suspend function will mark regmap as cache only
+	 * and reads/writes in volatile regs will fail
+	 */
+	regcache_cache_only(micfil->regmap, false);
+	regcache_mark_dirty(micfil->regmap);
+	regcache_sync(micfil->regmap);
+
+	ret = fsl_set_clock_params(dev, rate);
+	if (ret)
+		goto enable_error;
+
+	ret = fsl_micfil_reset(dev);
+	if (ret)
+		goto enable_error;
+
+	/* Initialize Hardware Voice Activity */
+	ret = init_hwvad(dev);
+	if (ret == 0)
+		return 0;
+
+enable_error:
+	if (state == MICFIL_HWVAD_OFF)
+		atomic_cmpxchg(&micfil->hwvad_state,
+			       MICFIL_HWVAD_ON, MICFIL_HWVAD_OFF);
+	if (sync)
+		pm_runtime_put_sync(dev);
+	return ret;
+}
+
+static int disable_hwvad(struct device *dev, bool sync)
+{
+	struct fsl_micfil *micfil = dev_get_drvdata(dev);
+	int ret = 0;
+	u32 state;
+
+	/* disable is called with sync = false only from
+	 * system suspend and in this case, you should not
+	 * change the hwvad_state so we know at system_resume
+	 * to reenable hwvad
+	 */
+	if (sync)
+		state = atomic_cmpxchg(&micfil->hwvad_state,
+				       MICFIL_HWVAD_ON,
+				       MICFIL_HWVAD_OFF);
+	else
+		state = atomic_read(&micfil->hwvad_state);
+
+	if (state == MICFIL_HWVAD_ON) {
+		/* This is required because if an arecord was done,
+		 * suspend function will mark regmap as cache only
+		 * and reads/writes in volatile regs will fail
+		 */
+		regcache_cache_only(micfil->regmap, false);
+		regcache_mark_dirty(micfil->regmap);
+		regcache_sync(micfil->regmap);
+
+		/* Voice Activity Detector Reset */
+		ret |= regmap_update_bits(micfil->regmap,
+					  REG_MICFIL_VAD0_CTRL1,
+					  MICFIL_VAD0_CTRL1_RST_SHIFT,
+					  MICFIL_VAD0_CTRL1_RST);
+
+		/* Disable HWVAD */
+		ret |= regmap_update_bits(micfil->regmap,
+					  REG_MICFIL_VAD0_CTRL1,
+					  MICFIL_VAD0_CTRL1_EN_MASK,
+					  0);
+
+		/* Disable Signal Filter */
+		ret |= regmap_update_bits(micfil->regmap,
+					  REG_MICFIL_VAD0_SCONFIG,
+					  MICFIL_VAD0_SCONFIG_SFILEN_MASK,
+					  0);
+
+		/* Signal Maximum Enable */
+		ret |= regmap_update_bits(micfil->regmap,
+					  REG_MICFIL_VAD0_SCONFIG,
+					  MICFIL_VAD0_SCONFIG_SMAXEN_MASK,
+					  0);
+
+		/* Enable pre-filter Noise & Signal */
+		ret |= regmap_update_bits(micfil->regmap,
+					  REG_MICFIL_VAD0_CTRL2,
+					  MICFIL_VAD0_CTRL2_PREFEN_MASK,
+					  0);
+
+		/* Noise Decimation Enable */
+		ret |= regmap_update_bits(micfil->regmap,
+					  REG_MICFIL_VAD0_NCONFIG,
+					  MICFIL_VAD0_NCONFIG_NDECEN_MASK,
+					  0);
+
+		/* disable the module and clock only if recording
+		 * is not done in parallel
+		 */
+		state = atomic_read(&micfil->recording_state);
+		if (state == MICFIL_RECORDING_OFF) {
+		/* Disable MICFIL module */
+			ret |= regmap_update_bits(micfil->regmap,
+						  REG_MICFIL_CTRL1,
+						  MICFIL_CTRL1_PDMIEN_MASK,
+						  0);
+		}
+
+		if (sync)
+			pm_runtime_put_sync(dev);
+	} else {
+		ret = -EPERM;
+		dev_err(dev, "HWVAD is not enabled %d\n", ret);
+	}
+
+	return ret;
+}
+
+static ssize_t micfil_hwvad_handler(struct kobject *kobj,
+				    struct kobj_attribute *attr,
+				    const char *buf,
+				    size_t count)
+{
+	struct kobject *nand_kobj = kobj->parent;
+	struct device *dev = container_of(nand_kobj, struct device, kobj);
+	struct fsl_micfil *micfil = dev_get_drvdata(dev);
+	unsigned long vad_channel;
+	int ret;
+
+	ret = kstrtoul(buf, 16, &vad_channel);
+	if (ret < 0)
+		return -EINVAL;
+
+	spin_lock(&micfil->hwvad_lock);
+	if (vad_channel <= 7) {
+		micfil->vad_channel = vad_channel;
+		ret = enable_hwvad(dev, true);
+	} else {
+		micfil->vad_channel = -1;
+		ret = disable_hwvad(dev, true);
+	}
+	spin_unlock(&micfil->hwvad_lock);
+
+	if (ret) {
+		dev_err(dev, "Failed to %s hwvad: %d\n",
+			vad_channel <= 7 ? "enable" : "disable", ret);
+		return ret;
+	}
+
+	return count;
+}
+
+static struct kobj_attribute hwvad_en_attr = __ATTR(enable,
+						   0660,
+						   NULL,
+						   micfil_hwvad_handler);
+
 static int fsl_micfil_probe(struct platform_device *pdev)
 {
 	struct device_node *np = pdev->dev.of_node;
@@ -668,6 +2216,19 @@ static int fsl_micfil_probe(struct platform_device *pdev)
 		return PTR_ERR(micfil->busclk);
 	}
 
+	/* get audio pll1 and pll2 */
+	micfil->clk_src[MICFIL_AUDIO_PLL1] = devm_clk_get(&pdev->dev, "pll8k");
+	if (IS_ERR(micfil->clk_src[MICFIL_AUDIO_PLL1]))
+		micfil->clk_src[MICFIL_AUDIO_PLL1] = NULL;
+
+	micfil->clk_src[MICFIL_AUDIO_PLL2] = devm_clk_get(&pdev->dev, "pll11k");
+	if (IS_ERR(micfil->clk_src[MICFIL_AUDIO_PLL2]))
+		micfil->clk_src[MICFIL_AUDIO_PLL2] = NULL;
+
+	micfil->clk_src[MICFIL_CLK_EXT3] = devm_clk_get(&pdev->dev, "clkext3");
+	if (IS_ERR(micfil->clk_src[MICFIL_CLK_EXT3]))
+		micfil->clk_src[MICFIL_CLK_EXT3] = NULL;
+
 	/* init regmap */
 	regs = devm_platform_get_and_ioremap_resource(pdev, 0, &res);
 	if (IS_ERR(regs))
@@ -707,7 +2268,31 @@ static int fsl_micfil_probe(struct platform_device *pdev)
 	if (of_property_read_bool(np, "fsl,shared-interrupt"))
 		irqflag = IRQF_SHARED;
 
-	/* Digital Microphone interface interrupt */
+	/* Digital Microphone interface voice activity detector event
+	 * interrupt - IRQ 44
+	 */
+	ret = devm_request_threaded_irq(&pdev->dev, micfil->irq[2],
+					hwvad_isr, voice_detected_fn,
+					irqflag, micfil->name, micfil);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to claim hwvad event irq %u\n",
+			micfil->irq[0]);
+		return ret;
+	}
+
+	/* Digital Microphone interface voice activity detector error
+	 * interrupt - IRQ 45
+	 */
+	ret = devm_request_irq(&pdev->dev, micfil->irq[3],
+			       hwvad_err_isr, irqflag,
+			       micfil->name, micfil);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to claim hwvad error irq %u\n",
+			micfil->irq[1]);
+		return ret;
+	}
+
+	/* Digital Microphone interface interrupt - IRQ 109 */
 	ret = devm_request_irq(&pdev->dev, micfil->irq[0],
 			       micfil_isr, irqflag,
 			       micfil->name, micfil);
@@ -727,10 +2312,16 @@ static int fsl_micfil_probe(struct platform_device *pdev)
 		return ret;
 	}
 
+	micfil->slave_mode = false;
+
 	micfil->dma_params_rx.chan_name = "rx";
 	micfil->dma_params_rx.addr = res->start + REG_MICFIL_DATACH0;
 	micfil->dma_params_rx.maxburst = MICFIL_DMA_MAXBURST_RX;
 
+	/* set default rate to first value in available vad rates */
+	micfil->vad_rate_index = 0;
+	/* init HWVAD enable/disable spinlock */
+	spin_lock_init(&micfil->hwvad_lock);
 
 	platform_set_drvdata(pdev, micfil);
 
@@ -747,19 +2338,41 @@ static int fsl_micfil_probe(struct platform_device *pdev)
 		return ret;
 	}
 
+	fsl_micfil_dai.capture.formats = micfil->soc->formats;
+
 	ret = devm_snd_soc_register_component(&pdev->dev, &fsl_micfil_component,
 					      &fsl_micfil_dai, 1);
 	if (ret) {
 		dev_err(&pdev->dev, "failed to register component %s\n",
 			fsl_micfil_component.name);
+		return ret;
 	}
 
-	return ret;
+	/* create sysfs entry used to enable hwvad from userspace */
+	micfil->hwvad_kobject = kobject_create_and_add("hwvad",
+						       &pdev->dev.kobj);
+	if (!micfil->hwvad_kobject)
+		return -ENOMEM;
+
+	ret = sysfs_create_file(micfil->hwvad_kobject,
+				&hwvad_en_attr.attr);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to create file for hwvad_enable\n");
+		kobject_put(micfil->hwvad_kobject);
+		return -ENOMEM;
+	}
+
+	return 0;
 }
 
 static int __maybe_unused fsl_micfil_runtime_suspend(struct device *dev)
 {
 	struct fsl_micfil *micfil = dev_get_drvdata(dev);
+	u32 state;
+
+	state = atomic_read(&micfil->hwvad_state);
+	if (state == MICFIL_HWVAD_ON)
+		return 0;
 
 	regcache_cache_only(micfil->regmap, true);
 
@@ -773,6 +2386,17 @@ static int __maybe_unused fsl_micfil_runtime_resume(struct device *dev)
 {
 	struct fsl_micfil *micfil = dev_get_drvdata(dev);
 	int ret;
+	u32 state;
+
+	state = atomic_read(&micfil->hwvad_state);
+
+	/* enable mclk only if the hwvad is not enabled
+	 * When hwvad is enabled, clock won't be disabled
+	 * in suspend since hwvad and recording share the
+	 * same clock
+	 */
+	if (state == MICFIL_HWVAD_ON)
+		return 0;
 
 	ret = clk_prepare_enable(micfil->busclk);
 	if (ret < 0)
@@ -793,6 +2417,19 @@ static int __maybe_unused fsl_micfil_runtime_resume(struct device *dev)
 
 static int __maybe_unused fsl_micfil_suspend(struct device *dev)
 {
+	struct fsl_micfil *micfil = dev_get_drvdata(dev);
+	int ret;
+	u32 state;
+
+	state = atomic_read(&micfil->hwvad_state);
+
+	if (state == MICFIL_HWVAD_ON) {
+		dev_err(dev, "Disabling hwvad on suspend");
+		ret = disable_hwvad(dev, false);
+		if (ret)
+			dev_warn(dev, "Failed to disable hwvad");
+	}
+
 	pm_runtime_force_suspend(dev);
 
 	return 0;
@@ -800,8 +2437,20 @@ static int __maybe_unused fsl_micfil_suspend(struct device *dev)
 
 static int __maybe_unused fsl_micfil_resume(struct device *dev)
 {
+	struct fsl_micfil *micfil = dev_get_drvdata(dev);
+	int ret;
+	u32 state;
+
 	pm_runtime_force_resume(dev);
 
+	state = atomic_read(&micfil->hwvad_state);
+	if (state == MICFIL_HWVAD_ON) {
+		dev_err(dev, "Enabling hwvad on resume");
+		ret = enable_hwvad(dev, false);
+		if (ret)
+			dev_warn(dev, "Failed to re-enable hwvad");
+	}
+
 	return 0;
 }
 
diff --git a/sound/soc/fsl/fsl_micfil.h b/sound/soc/fsl/fsl_micfil.h
index bac825c31..14ad08b6b 100644
--- a/sound/soc/fsl/fsl_micfil.h
+++ b/sound/soc/fsl/fsl_micfil.h
@@ -258,6 +258,40 @@
 #define MICFIL_VAD0_STAT_IF_MASK	BIT(MICFIL_VAD0_STAT_IF_SHIFT)
 #define MICFIL_VAD0_STAT_IF		BIT(MICFIL_VAD0_STAT_IF_SHIFT)
 
+/* HWVAD Constants */
+#define MICFIL_HWVAD_ENVELOPE_MODE	0
+#define MICFIL_HWVAD_ENERGY_MODE	1
+#define MICFIL_HWVAD_INIT_FRAMES	10
+#define MICFIL_HWVAD_INPGAIN		0
+#define MICFIL_HWVAD_SGAIN		6
+#define MICFIL_HWVAD_NGAIN		3
+#define MICFIL_HWVAD_NFILADJ		0
+#define MICFIL_HWVAD_ZCDADJ		(1 << (MICFIL_VAD0_ZCD_ZCDADJ_WIDTH - 2))
+#define MICFIL_HWVAD_ZCDTH		10	/* initial threshold value */
+#define MICFIL_HWVAD_ZCDOR		0
+#define MICFIL_HWVAD_ZCDAND		1
+#define MICFIL_HWVAD_ZCD_MANUAL		0
+#define MICFIL_HWVAD_ZCD_AUTO		1
+#define MICFIL_HWVAD_HPF_BYPASS		0
+#define MICFIL_HWVAD_HPF_1750HZ		1
+#define MICFIL_HWVAD_HPF_215HZ		2
+#define MICFIL_HWVAD_HPF_102HZ		3
+#define MICFIL_HWVAD_FRAMET_DEFAULT	10
+
+/* MICFIL DC Remover Control Register -- REG_MICFIL_DC_CTRL */
+#define MICFIL_DC_CTRL_SHIFT		0
+#define MICFIL_DC_CTRL_MASK		0xFFFF
+#define MICFIL_DC_CTRL_WIDTH		2
+#define MICFIL_DC_CHX_SHIFT(v)		(2 * (v))
+#define MICFIL_DC_CHX_MASK(v)		((BIT(MICFIL_DC_CTRL_WIDTH) - 1) \
+					 << MICFIL_DC_CHX_SHIFT(v))
+#define MICFIL_DC_MODE(v1, v2)		(((v1) << MICFIL_DC_CHX_SHIFT(v2)) \
+					 & MICFIL_DC_CHX_MASK(v2))
+#define MICFIL_DC_CUTOFF_21HZ		0
+#define MICFIL_DC_CUTOFF_83HZ		1
+#define MICFIL_DC_CUTOFF_152Hz		2
+#define MICFIL_DC_BYPASS			3
+
 /* MICFIL Output Control Register */
 #define MICFIL_OUTGAIN_CHX_SHIFT(v)	(4 * (v))
 
@@ -273,11 +307,24 @@
 #define FIFO_PTRWID			3
 #define FIFO_LEN			BIT(FIFO_PTRWID)
 
-#define MICFIL_IRQ_LINES		2
+#define MICFIL_IRQ_LINES		4
 #define MICFIL_MAX_RETRY		25
-#define MICFIL_SLEEP_MIN		90000 /* in us */
-#define MICFIL_SLEEP_MAX		100000 /* in us */
+#define MICFIL_SLEEP			100 /* in ms */
 #define MICFIL_DMA_MAXBURST_RX		6
 #define MICFIL_CTRL2_OSR_DEFAULT	(0 << MICFIL_CTRL2_CICOSR_SHIFT)
+#define MICFIL_DEFAULT_RATE		48000
+#define MICFIL_CLK_SRC_NUM		3
+#define MICFIL_CLK_AUTO			0
+
+/* clock source ids */
+#define MICFIL_AUDIO_PLL1		0
+#define MICFIL_AUDIO_PLL2		1
+#define MICFIL_CLK_EXT3			2
+
+/* States of micfil */
+#define MICFIL_HWVAD_OFF		0
+#define MICFIL_HWVAD_ON			1
+#define MICFIL_RECORDING_OFF		0
+#define MICFIL_RECORDING_ON		1
 
 #endif /* _FSL_MICFIL_H */
diff --git a/sound/soc/fsl/fsl_rpmsg.c b/sound/soc/fsl/fsl_rpmsg.c
index d60f4dac6..061516ea4 100644
--- a/sound/soc/fsl/fsl_rpmsg.c
+++ b/sound/soc/fsl/fsl_rpmsg.c
@@ -25,6 +25,8 @@
 
 /* 192kHz/32bit/2ch/60s size is 0x574e00 */
 #define LPA_LARGE_BUFFER_SIZE  (0x6000000)
+/* 16kHz/32bit/8ch/1s size is 0x7D000 */
+#define RPMSG_CAPTURE_BUFFER_SIZE (0x100000)
 
 static const unsigned int fsl_rpmsg_rates[] = {
 	8000, 11025, 16000, 22050, 44100,
@@ -138,11 +140,43 @@ static const struct snd_soc_component_driver fsl_component = {
 	.name           = "fsl-rpmsg",
 };
 
+static const struct fsl_rpmsg_soc_data imx7ulp_data = {
+	.rates = SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000 |
+		 SNDRV_PCM_RATE_48000,
+	.formats = SNDRV_PCM_FMTBIT_S16_LE,
+};
+
+static const struct fsl_rpmsg_soc_data imx8mm_data = {
+	.rates = SNDRV_PCM_RATE_KNOT,
+	.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE |
+		   SNDRV_PCM_FMTBIT_S32_LE | SNDRV_PCM_FMTBIT_DSD_U8 |
+		   SNDRV_PCM_FMTBIT_DSD_U16_LE | SNDRV_PCM_FMTBIT_DSD_U32_LE,
+};
+
+static const struct fsl_rpmsg_soc_data imx8mn_data = {
+	.rates = SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 |
+		 SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 |
+		 SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_176400 |
+		 SNDRV_PCM_RATE_192000,
+	.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE |
+		   SNDRV_PCM_FMTBIT_S32_LE,
+};
+
+static const struct fsl_rpmsg_soc_data imx8mp_data = {
+	.rates = SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 |
+		 SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 |
+		 SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_176400 |
+		 SNDRV_PCM_RATE_192000,
+	.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE |
+		   SNDRV_PCM_FMTBIT_S32_LE,
+};
+
 static const struct of_device_id fsl_rpmsg_ids[] = {
-	{ .compatible = "fsl,imx7ulp-rpmsg-audio"},
-	{ .compatible = "fsl,imx8mm-rpmsg-audio"},
-	{ .compatible = "fsl,imx8mn-rpmsg-audio"},
-	{ .compatible = "fsl,imx8mp-rpmsg-audio"},
+	{ .compatible = "fsl,imx7ulp-rpmsg-audio", .data = &imx7ulp_data},
+	{ .compatible = "fsl,imx8mm-rpmsg-audio", .data = &imx8mm_data},
+	{ .compatible = "fsl,imx8mn-rpmsg-audio", .data = &imx8mn_data},
+	{ .compatible = "fsl,imx8mp-rpmsg-audio", .data = &imx8mp_data},
+	{ .compatible = "fsl,imx8ulp-rpmsg-audio", .data = &imx7ulp_data},
 	{ /* sentinel */ }
 };
 MODULE_DEVICE_TABLE(of, fsl_rpmsg_ids);
@@ -150,18 +184,44 @@ MODULE_DEVICE_TABLE(of, fsl_rpmsg_ids);
 static int fsl_rpmsg_probe(struct platform_device *pdev)
 {
 	struct device_node *np = pdev->dev.of_node;
+	struct snd_soc_dai_driver *dai_drv;
 	struct fsl_rpmsg *rpmsg;
 	int ret;
 
+	dai_drv = devm_kzalloc(&pdev->dev, sizeof(struct snd_soc_dai_driver), GFP_KERNEL);
+	if (!dai_drv)
+		return -ENOMEM;
+	memcpy(dai_drv, &fsl_rpmsg_dai, sizeof(fsl_rpmsg_dai));
+
 	rpmsg = devm_kzalloc(&pdev->dev, sizeof(struct fsl_rpmsg), GFP_KERNEL);
 	if (!rpmsg)
 		return -ENOMEM;
 
+	rpmsg->soc_data = of_device_get_match_data(&pdev->dev);
+	if (rpmsg->soc_data) {
+		dai_drv->playback.rates = rpmsg->soc_data->rates;
+		dai_drv->capture.rates = rpmsg->soc_data->rates;
+		dai_drv->playback.formats = rpmsg->soc_data->formats;
+		dai_drv->capture.formats = rpmsg->soc_data->formats;
+
+		/* setup rpmsg-micfil channels and rates */
+		if (of_node_name_eq(np, "rpmsg_micfil")) {
+			rpmsg->buffer_size[SNDRV_PCM_STREAM_CAPTURE] = RPMSG_CAPTURE_BUFFER_SIZE;
+			dai_drv->capture.channels_min = 1;
+			dai_drv->capture.channels_max = 8;
+			dai_drv->capture.rates = SNDRV_PCM_RATE_8000_48000;
+			dai_drv->capture.formats = SNDRV_PCM_FMTBIT_S32_LE;
+			if (of_device_is_compatible(np, "fsl,imx8mm-rpmsg-audio"))
+				dai_drv->capture.formats = SNDRV_PCM_FMTBIT_S16_LE;
+		}
+	}
 	if (of_property_read_bool(np, "fsl,enable-lpa")) {
 		rpmsg->enable_lpa = 1;
-		rpmsg->buffer_size = LPA_LARGE_BUFFER_SIZE;
+		rpmsg->buffer_size[SNDRV_PCM_STREAM_PLAYBACK] = LPA_LARGE_BUFFER_SIZE;
+		rpmsg->buffer_size[SNDRV_PCM_STREAM_CAPTURE] = RPMSG_CAPTURE_BUFFER_SIZE;
 	} else {
-		rpmsg->buffer_size = IMX_DEFAULT_DMABUF_SIZE;
+		rpmsg->buffer_size[SNDRV_PCM_STREAM_PLAYBACK] = IMX_DEFAULT_DMABUF_SIZE;
+		rpmsg->buffer_size[SNDRV_PCM_STREAM_CAPTURE] = IMX_DEFAULT_DMABUF_SIZE;
 	}
 
 	/* Get the optional clocks */
@@ -189,13 +249,13 @@ static int fsl_rpmsg_probe(struct platform_device *pdev)
 	pm_runtime_enable(&pdev->dev);
 
 	ret = devm_snd_soc_register_component(&pdev->dev, &fsl_component,
-					      &fsl_rpmsg_dai, 1);
+					      dai_drv, 1);
 	if (ret)
 		return ret;
 
 	rpmsg->card_pdev = platform_device_register_data(&pdev->dev,
 							 "imx-audio-rpmsg",
-							 PLATFORM_DEVID_NONE,
+							 PLATFORM_DEVID_AUTO,
 							 NULL,
 							 0);
 	if (IS_ERR(rpmsg->card_pdev)) {
@@ -258,8 +318,6 @@ static const struct dev_pm_ops fsl_rpmsg_pm_ops = {
 	SET_RUNTIME_PM_OPS(fsl_rpmsg_runtime_suspend,
 			   fsl_rpmsg_runtime_resume,
 			   NULL)
-	SET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,
-				pm_runtime_force_resume)
 };
 
 static struct platform_driver fsl_rpmsg_driver = {
diff --git a/sound/soc/fsl/fsl_rpmsg.h b/sound/soc/fsl/fsl_rpmsg.h
index 4f5b49eb1..3c3e7faf8 100644
--- a/sound/soc/fsl/fsl_rpmsg.h
+++ b/sound/soc/fsl/fsl_rpmsg.h
@@ -6,6 +6,15 @@
 #ifndef __FSL_RPMSG_H
 #define __FSL_RPMSG_H
 
+/* struct fsl_rpmsg_soc_data
+ * @rates: supported rates
+ * @formats: supported formats
+ */
+struct fsl_rpmsg_soc_data {
+	int rates;
+	u64 formats;
+};
+
 /*
  * struct fsl_rpmsg - rpmsg private data
  *
@@ -15,6 +24,7 @@
  * @pll8k: parent clock for multiple of 8kHz frequency
  * @pll11k: parent clock for multiple of 11kHz frequency
  * @card_pdev: Platform_device pointer to register a sound card
+ * @soc_data: soc specific data
  * @mclk_streams: Active streams that are using baudclk
  * @force_lpa: force enable low power audio routine if condition satisfy
  * @enable_lpa: enable low power audio routine according to dts setting
@@ -27,9 +37,10 @@ struct fsl_rpmsg {
 	struct clk *pll8k;
 	struct clk *pll11k;
 	struct platform_device *card_pdev;
+	const struct fsl_rpmsg_soc_data *soc_data;
 	unsigned int mclk_streams;
 	int force_lpa;
 	int enable_lpa;
-	int buffer_size;
+	int buffer_size[2];
 };
 #endif /* __FSL_RPMSG_H */
diff --git a/sound/soc/fsl/fsl_sai.c b/sound/soc/fsl/fsl_sai.c
index 635d26f51..e50ff8a39 100644
--- a/sound/soc/fsl/fsl_sai.c
+++ b/sound/soc/fsl/fsl_sai.c
@@ -893,10 +893,10 @@ static int fsl_sai_dai_probe(struct snd_soc_dai *cpu_dai)
 
 	regmap_update_bits(sai->regmap, FSL_SAI_TCR1(ofs),
 			   FSL_SAI_CR1_RFW_MASK(sai->soc_data->fifo_depth),
-			   sai->soc_data->fifo_depth - FSL_SAI_MAXBURST_TX);
+			   sai->soc_data->fifo_depth - sai->dma_params_tx.maxburst);
 	regmap_update_bits(sai->regmap, FSL_SAI_RCR1(ofs),
 			   FSL_SAI_CR1_RFW_MASK(sai->soc_data->fifo_depth),
-			   FSL_SAI_MAXBURST_RX - 1);
+			   sai->dma_params_rx.maxburst - 1);
 
 	snd_soc_dai_init_dma_data(cpu_dai, &sai->dma_params_tx,
 				&sai->dma_params_rx);
@@ -1433,8 +1433,10 @@ static int fsl_sai_probe(struct platform_device *pdev)
 
 	sai->dma_params_rx.addr = sai->res->start + FSL_SAI_RDR0;
 	sai->dma_params_tx.addr = sai->res->start + FSL_SAI_TDR0;
-	sai->dma_params_rx.maxburst = FSL_SAI_MAXBURST_RX;
-	sai->dma_params_tx.maxburst = FSL_SAI_MAXBURST_TX;
+	sai->dma_params_rx.maxburst =
+		sai->soc_data->max_burst[RX] ? sai->soc_data->max_burst[RX] : FSL_SAI_MAXBURST_RX;
+	sai->dma_params_tx.maxburst =
+		sai->soc_data->max_burst[TX] ? sai->soc_data->max_burst[TX] : FSL_SAI_MAXBURST_TX;
 
 	sai->pinctrl = devm_pinctrl_get(&pdev->dev);
 
@@ -1644,6 +1646,7 @@ static const struct fsl_sai_soc_data fsl_sai_imx93_data = {
 	.fifos = 4,
 	.flags = 0,
 	.max_register = FSL_SAI_MCTL,
+	.max_burst = {8, 8},
 };
 
 static const struct of_device_id fsl_sai_ids[] = {
diff --git a/sound/soc/fsl/fsl_sai.h b/sound/soc/fsl/fsl_sai.h
index f471467df..768252cf1 100644
--- a/sound/soc/fsl/fsl_sai.h
+++ b/sound/soc/fsl/fsl_sai.h
@@ -1,17 +1,21 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright 2012-2013 Freescale Semiconductor, Inc.
+ * Copyright 2012-2016 Freescale Semiconductor, Inc.
  */
 
 #ifndef __FSL_SAI_H
 #define __FSL_SAI_H
 
+#include <linux/pm_qos.h>
+#include <linux/platform_data/dma-imx.h>
 #include <sound/dmaengine_pcm.h>
 
 #define FSL_SAI_FORMATS (SNDRV_PCM_FMTBIT_S16_LE |\
-			 SNDRV_PCM_FMTBIT_S20_3LE |\
 			 SNDRV_PCM_FMTBIT_S24_LE |\
-			 SNDRV_PCM_FMTBIT_S32_LE)
+			 SNDRV_PCM_FMTBIT_S32_LE |\
+			 SNDRV_PCM_FMTBIT_DSD_U8 |\
+			 SNDRV_PCM_FMTBIT_DSD_U16_LE |\
+			 SNDRV_PCM_FMTBIT_DSD_U32_LE)
 
 /* SAI Register Map Register */
 #define FSL_SAI_VERID	0x00 /* SAI Version ID Register */
@@ -80,8 +84,8 @@
 #define FSL_SAI_xCR3(tx, ofs)	(tx ? FSL_SAI_TCR3(ofs) : FSL_SAI_RCR3(ofs))
 #define FSL_SAI_xCR4(tx, ofs)	(tx ? FSL_SAI_TCR4(ofs) : FSL_SAI_RCR4(ofs))
 #define FSL_SAI_xCR5(tx, ofs)	(tx ? FSL_SAI_TCR5(ofs) : FSL_SAI_RCR5(ofs))
-#define FSL_SAI_xDR0(tx)	(tx ? FSL_SAI_TDR0 : FSL_SAI_RDR0)
-#define FSL_SAI_xFR0(tx)	(tx ? FSL_SAI_TFR0 : FSL_SAI_RFR0)
+#define FSL_SAI_xDR(tx, ofs)	(tx ? FSL_SAI_TDR(ofs) : FSL_SAI_RDR(ofs))
+#define FSL_SAI_xFR(tx, ofs)	(tx ? FSL_SAI_TFR(ofs) : FSL_SAI_RFR(ofs))
 #define FSL_SAI_xMR(tx)		(tx ? FSL_SAI_TMR : FSL_SAI_RMR)
 
 /* SAI Transmit/Receive Control Register */
@@ -211,6 +215,7 @@
 #define FSL_SAI_CLK_MAST3	3
 
 #define FSL_SAI_MCLK_MAX	4
+#define FSL_SAI_CLK_BIT		5
 
 /* SAI data transfer numbers per DMA request */
 #define FSL_SAI_MAXBURST_TX 6
@@ -224,7 +229,11 @@ struct fsl_sai_soc_data {
 	bool mclk0_is_mclk1;
 	unsigned int fifo_depth;
 	unsigned int reg_offset;
+	unsigned int fifos;
+	unsigned int dataline;
 	unsigned int flags;
+	unsigned int max_register;
+	unsigned int max_burst[2];
 };
 
 /**
@@ -253,16 +262,39 @@ struct fsl_sai_param {
 	u32 dataline;
 };
 
+struct fsl_sai_dl_cfg {
+	unsigned int pins;
+	unsigned int mask[2];
+	unsigned int start_off[2];
+	unsigned int next_off[2];
+};
+
 struct fsl_sai {
 	struct platform_device *pdev;
 	struct regmap *regmap;
+	struct regmap *regmap_gpr;
 	struct clk *bus_clk;
 	struct clk *mclk_clk[FSL_SAI_MCLK_MAX];
+	struct clk *pll8k_clk;
+	struct clk *pll11k_clk;
+	struct resource *res;
 
-	bool is_slave_mode;
+	bool slave_mode[2];
 	bool is_lsb_first;
 	bool is_dsp_mode;
+	bool is_multi_lane;
 	bool synchronous[2];
+	bool is_dsd;
+	bool monitor_spdif;
+	bool monitor_spdif_start;
+
+	int gpr_idx;
+	int pcm_dl_cfg_cnt;
+	int dsd_dl_cfg_cnt;
+	struct fsl_sai_dl_cfg *pcm_dl_cfg;
+	struct fsl_sai_dl_cfg *dsd_dl_cfg;
+
+	unsigned int masterflag[2];
 
 	unsigned int mclk_id[2];
 	unsigned int mclk_streams;
@@ -277,8 +309,13 @@ struct fsl_sai {
 	struct fsl_sai_verid verid;
 	struct fsl_sai_param param;
 	struct pm_qos_request pm_qos_req;
+	struct sdma_audio_config audio_config[2];
+	struct pinctrl *pinctrl;
+	struct pinctrl_state *pins_state;
 };
 
+const struct attribute_group *fsl_sai_get_dev_attribute_group(bool monitor_spdif);
+
 #define TX 1
 #define RX 0
 
diff --git a/sound/soc/fsl/fsl_sai_sysfs.c b/sound/soc/fsl/fsl_sai_sysfs.c
new file mode 100644
index 000000000..609227e00
--- /dev/null
+++ b/sound/soc/fsl/fsl_sai_sysfs.c
@@ -0,0 +1,312 @@
+// SPDX-License-Identifier: GPL-2.0+
+// Copyright 2020 NXP
+
+#include <linux/clk.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/kdev_t.h>
+#include <linux/pm_runtime.h>
+#include <linux/mfd/syscon/imx7-iomuxc-gpr.h>
+
+#include "fsl_sai.h"
+
+static ssize_t tx_bitcnt_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct fsl_sai *sai = dev_get_drvdata(dev);
+	unsigned int val = 0;
+
+	/* read bitcounter */
+	regmap_read(sai->regmap, FSL_SAI_TBCTN, &val);
+
+	return sprintf(buf, "%u\n", val);
+}
+static DEVICE_ATTR_RO(tx_bitcnt);
+
+static ssize_t tx_timestamp_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct fsl_sai *sai = dev_get_drvdata(dev);
+	unsigned int val = 0;
+
+	/* read timestamp */
+	regmap_read(sai->regmap, FSL_SAI_TTCTN, &val);
+
+	return sprintf(buf, "%u\n", val);
+}
+static DEVICE_ATTR_RO(tx_timestamp);
+
+static ssize_t tx_bitcnt_latched_timestamp_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct fsl_sai *sai = dev_get_drvdata(dev);
+	unsigned int val = 0;
+
+	/* read timestamp */
+	regmap_read(sai->regmap, FSL_SAI_TTCAP, &val);
+
+	return sprintf(buf, "%u\n", val);
+}
+static DEVICE_ATTR_RO(tx_bitcnt_latched_timestamp);
+
+static ssize_t
+tx_timestamp_enable_store(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t n)
+{
+	struct fsl_sai *sai = dev_get_drvdata(dev);
+	unsigned int val = 0;
+
+	if (kstrtouint(buf, 0, &val))
+		return -EINVAL;
+
+	if (val != 0)
+		val = FSL_SAI_xTCTL_TSEN;
+	regmap_update_bits(sai->regmap, FSL_SAI_TTCTL, FSL_SAI_xTCTL_TSEN, val);
+	return n;
+}
+static DEVICE_ATTR_WO(tx_timestamp_enable);
+
+static ssize_t
+tx_timestamp_increment_store(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t n)
+{
+	struct fsl_sai *sai = dev_get_drvdata(dev);
+	unsigned int val = 0;
+
+	if (kstrtouint(buf, 0, &val))
+		return -EINVAL;
+
+	if (val != 0)
+		val = FSL_SAI_xTCTL_TSINC;
+	regmap_update_bits(sai->regmap, FSL_SAI_TTCTL, FSL_SAI_xTCTL_TSINC, val);
+	return n;
+}
+static DEVICE_ATTR_WO(tx_timestamp_increment);
+
+static ssize_t
+tx_bitcnt_reset_store(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t n)
+{
+	struct fsl_sai *sai = dev_get_drvdata(dev);
+	unsigned int val = 0;
+
+	if (kstrtouint(buf, 0, &val))
+		return -EINVAL;
+
+	if (val != 0)
+		val = FSL_SAI_xTCTL_RBC;
+	regmap_update_bits(sai->regmap, FSL_SAI_TTCTL, FSL_SAI_xTCTL_RBC, val);
+	return n;
+}
+static DEVICE_ATTR_WO(tx_bitcnt_reset);
+
+static ssize_t
+tx_timestamp_reset_store(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t n)
+{
+	struct fsl_sai *sai = dev_get_drvdata(dev);
+	unsigned int val = 0;
+
+	if (kstrtouint(buf, 0, &val))
+		return -EINVAL;
+
+	if (val != 0)
+		val = FSL_SAI_xTCTL_RTSC;
+	regmap_update_bits(sai->regmap, FSL_SAI_TTCTL, FSL_SAI_xTCTL_RTSC, val);
+	return n;
+}
+static DEVICE_ATTR_WO(tx_timestamp_reset);
+
+
+static ssize_t rx_bitcnt_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct fsl_sai *sai = dev_get_drvdata(dev);
+	unsigned int val = 0;
+
+	/* read bitcounter */
+	regmap_read(sai->regmap, FSL_SAI_RBCTN, &val);
+
+	return sprintf(buf, "%u\n", val);
+}
+static DEVICE_ATTR_RO(rx_bitcnt);
+
+static ssize_t rx_timestamp_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct fsl_sai *sai = dev_get_drvdata(dev);
+	unsigned int val = 0;
+
+	/* read timestamp */
+	regmap_read(sai->regmap, FSL_SAI_RTCTN, &val);
+
+	return sprintf(buf, "%u\n", val);
+}
+static DEVICE_ATTR_RO(rx_timestamp);
+
+static ssize_t rx_bitcnt_latched_timestamp_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct fsl_sai *sai = dev_get_drvdata(dev);
+	unsigned int val = 0;
+
+	/* read timestamp */
+	regmap_read(sai->regmap, FSL_SAI_RTCAP, &val);
+
+	return sprintf(buf, "%u\n", val);
+}
+static DEVICE_ATTR_RO(rx_bitcnt_latched_timestamp);
+
+static ssize_t
+rx_timestamp_enable_store(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t n)
+{
+	struct fsl_sai *sai = dev_get_drvdata(dev);
+	unsigned int val = 0;
+
+	if (kstrtouint(buf, 0, &val))
+		return -EINVAL;
+
+	if (val != 0)
+		val = FSL_SAI_xTCTL_TSEN;
+	regmap_update_bits(sai->regmap, FSL_SAI_RTCTL, FSL_SAI_xTCTL_TSEN, val);
+	return n;
+}
+static DEVICE_ATTR_WO(rx_timestamp_enable);
+
+static ssize_t
+rx_timestamp_increment_store(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t n)
+{
+	struct fsl_sai *sai = dev_get_drvdata(dev);
+	unsigned int val = 0;
+
+	if (kstrtouint(buf, 0, &val))
+		return -EINVAL;
+
+	if (val != 0)
+		val = FSL_SAI_xTCTL_TSINC;
+	regmap_update_bits(sai->regmap, FSL_SAI_RTCTL, FSL_SAI_xTCTL_TSINC, val);
+	return n;
+}
+static DEVICE_ATTR_WO(rx_timestamp_increment);
+
+static ssize_t
+rx_bitcnt_reset_store(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t n)
+{
+	struct fsl_sai *sai = dev_get_drvdata(dev);
+	unsigned int val = 0;
+
+	if (kstrtouint(buf, 0, &val))
+		return -EINVAL;
+
+	if (val != 0)
+		val = FSL_SAI_xTCTL_RBC;
+	regmap_update_bits(sai->regmap, FSL_SAI_RTCTL, FSL_SAI_xTCTL_RBC, val);
+	return n;
+}
+static DEVICE_ATTR_WO(rx_bitcnt_reset);
+
+static ssize_t
+rx_timestamp_reset_store(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t n)
+{
+	struct fsl_sai *sai = dev_get_drvdata(dev);
+	unsigned int val = 0;
+
+	if (kstrtouint(buf, 0, &val))
+		return -EINVAL;
+
+	if (val != 0)
+		val = FSL_SAI_xTCTL_RTSC;
+	regmap_update_bits(sai->regmap, FSL_SAI_RTCTL, FSL_SAI_xTCTL_RTSC, val);
+	return n;
+}
+static DEVICE_ATTR_WO(rx_timestamp_reset);
+
+static ssize_t
+rx_monitor_spdif_store(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t n)
+{
+	struct fsl_sai *sai = dev_get_drvdata(dev);
+	unsigned char offset = sai->soc_data->reg_offset;
+	unsigned int val = 0;
+	bool enable = false;
+	unsigned int reg;
+	unsigned int shift;
+	unsigned int mask;
+
+	if (kstrtouint(buf, 0, &val))
+		return -EINVAL;
+
+	if (val != 0)
+		enable = true;
+
+	if (pm_runtime_active(&sai->pdev->dev) && enable) {
+		dev_err(dev, "device is busy\n");
+		return -EBUSY;
+	}
+
+	reg = IOMUXC_GPR6 + (sai->gpr_idx - 1) / 2 * 4;
+	shift = ((sai->gpr_idx - 1) % 2) * 16;
+	mask = 0x1F << shift;
+
+	if (enable) {
+		pm_runtime_get_sync(&sai->pdev->dev);
+		/* Fix to MCLK3 */
+		regmap_update_bits(sai->regmap_gpr, reg, mask, 0xF << shift);
+		regmap_update_bits(sai->regmap, FSL_SAI_xCR2(false, offset),
+				   FSL_SAI_CR2_MSEL_MASK, FSL_SAI_CR2_MSEL(0x3));
+		regmap_update_bits(sai->regmap, FSL_SAI_xCR2(false, offset),
+				   FSL_SAI_CR2_DIV_MASK, 0x0);
+		regmap_update_bits(sai->regmap, FSL_SAI_xCR2(false, offset),
+				   FSL_SAI_CR2_BCD_MSTR, FSL_SAI_CR2_BCD_MSTR);
+		regmap_update_bits(sai->regmap, FSL_SAI_xCR4(false, offset),
+				   FSL_SAI_CR4_FSD_MSTR, FSL_SAI_CR4_FSD_MSTR);
+		regmap_update_bits(sai->regmap, FSL_SAI_xCSR(false, offset),
+				   FSL_SAI_CSR_TERE, FSL_SAI_CSR_TERE);
+		sai->monitor_spdif_start = true;
+	} else {
+		if (sai->monitor_spdif_start) {
+			regmap_update_bits(sai->regmap, FSL_SAI_xCSR(false, offset),
+					   FSL_SAI_CSR_TERE, 0);
+			pm_runtime_put_sync(&sai->pdev->dev);
+			sai->monitor_spdif_start = false;
+		}
+	}
+
+	return n;
+}
+static DEVICE_ATTR_WO(rx_monitor_spdif);
+
+static struct attribute *fsl_sai_attrs[] = {
+	&dev_attr_tx_bitcnt.attr,
+	&dev_attr_rx_bitcnt.attr,
+	&dev_attr_tx_timestamp.attr,
+	&dev_attr_rx_timestamp.attr,
+	&dev_attr_tx_bitcnt_latched_timestamp.attr,
+	&dev_attr_rx_bitcnt_latched_timestamp.attr,
+	&dev_attr_tx_timestamp_enable.attr,
+	&dev_attr_rx_timestamp_enable.attr,
+	&dev_attr_tx_timestamp_increment.attr,
+	&dev_attr_rx_timestamp_increment.attr,
+	&dev_attr_tx_bitcnt_reset.attr,
+	&dev_attr_rx_bitcnt_reset.attr,
+	&dev_attr_tx_timestamp_reset.attr,
+	&dev_attr_rx_timestamp_reset.attr,
+	NULL,
+	NULL,
+};
+
+static struct attribute_group fsl_sai_attr_group = {
+	.attrs = fsl_sai_attrs,
+};
+
+const struct attribute_group *fsl_sai_get_dev_attribute_group(bool monitor_spdif)
+{
+	if (monitor_spdif)
+		fsl_sai_attrs[ARRAY_SIZE(fsl_sai_attrs) - 2] = &dev_attr_rx_monitor_spdif.attr;
+
+	return &fsl_sai_attr_group;
+}
diff --git a/sound/soc/fsl/fsl_spdif.c b/sound/soc/fsl/fsl_spdif.c
index 8b5c3ba48..7d9790950 100644
--- a/sound/soc/fsl/fsl_spdif.c
+++ b/sound/soc/fsl/fsl_spdif.c
@@ -11,12 +11,14 @@
 
 #include <linux/bitrev.h>
 #include <linux/clk.h>
+#include <linux/clk-provider.h>
 #include <linux/module.h>
 #include <linux/of_address.h>
 #include <linux/of_device.h>
 #include <linux/of_irq.h>
 #include <linux/regmap.h>
 #include <linux/pm_runtime.h>
+#include <linux/busfreq-imx.h>
 
 #include <sound/asoundef.h>
 #include <sound/dmaengine_pcm.h>
@@ -59,6 +61,7 @@ struct fsl_spdif_soc_data {
 	bool imx;
 	bool shared_root_clock;
 	bool raw_capture_mode;
+	bool cchannel_192b;
 	u32 interrupts;
 	u32 tx_burst;
 	u32 rx_burst;
@@ -124,7 +127,7 @@ struct fsl_spdif_priv {
 	u16 sysclk_df[SPDIF_TXRATE_MAX];
 	u8 txclk_src[SPDIF_TXRATE_MAX];
 	u8 rxclk_src;
-	struct clk *txclk[SPDIF_TXRATE_MAX];
+	struct clk *txclk[STC_TXCLK_SRC_MAX];
 	struct clk *rxclk;
 	struct clk *coreclk;
 	struct clk *sysclk;
@@ -133,6 +136,9 @@ struct fsl_spdif_priv {
 	struct snd_dmaengine_dai_dma_data dma_params_rx;
 	/* regcache for SRPC */
 	u32 regcache_srpc;
+	struct clk *pll8k_clk;
+	struct clk *pll11k_clk;
+	bool bypass;
 };
 
 static struct fsl_spdif_soc_data fsl_spdif_vf610 = {
@@ -186,6 +192,17 @@ static struct fsl_spdif_soc_data fsl_spdif_imx8mm = {
 	.tx_formats = FSL_SPDIF_FORMATS_PLAYBACK,
 };
 
+static struct fsl_spdif_soc_data fsl_spdif_imx8ulp = {
+	.imx = true,
+	.shared_root_clock = true,
+	.raw_capture_mode = false,
+	.tx_burst = 2,
+	.rx_burst = 2,
+	.interrupts = 1,
+	.tx_formats = SNDRV_PCM_FMTBIT_S24_LE,
+	.cchannel_192b = true,
+};
+
 /* Check if clk is a root clock that does not share clock source with others */
 static inline bool fsl_spdif_can_set_clk_rate(struct fsl_spdif_priv *spdif, int clk)
 {
@@ -429,6 +446,24 @@ static void spdif_write_channel_status(struct fsl_spdif_priv *spdif_priv)
 	regmap_write(regmap, REG_SPDIF_STCSCL, ch_status);
 
 	dev_dbg(&pdev->dev, "STCSCL: 0x%06x\n", ch_status);
+
+	if (spdif_priv->soc->cchannel_192b) {
+		ch_status = (bitrev8(ctrl->ch_status[0]) << 24) |
+			    (bitrev8(ctrl->ch_status[1]) << 16) |
+			    (bitrev8(ctrl->ch_status[2]) << 8) |
+			    bitrev8(ctrl->ch_status[3]);
+
+		regmap_update_bits(regmap, REG_SPDIF_SCR, 0x1000000, 0x1000000);
+
+		/*
+		 * FIXME: In theory, the first 32bit should be in
+		 * REG_SPDIF_STCCA_31_0 register, but here we need to
+		 * set REG_SPDIF_STCCA_191_160 on 8ULP then get correct
+		 * result with HDMI analyzer capture. suspect there is
+		 * a hardware bug here.
+		 */
+		regmap_write(regmap, REG_SPDIF_STCCA_191_160, ch_status);
+	}
 }
 
 /* Set SPDIF PhaseConfig register for rx clock */
@@ -514,7 +549,7 @@ static int spdif_set_sample_rate(struct snd_pcm_substream *substream,
 		goto clk_set_bypass;
 
 	/* The S/PDIF block needs a clock of 64 * fs * txclk_df */
-	ret = clk_set_rate(spdif_priv->txclk[rate],
+	ret = clk_set_rate(spdif_priv->txclk[clk],
 			   64 * sample_rate * txclk_df);
 	if (ret) {
 		dev_err(&pdev->dev, "failed to set tx clock rate\n");
@@ -525,7 +560,7 @@ static int spdif_set_sample_rate(struct snd_pcm_substream *substream,
 	dev_dbg(&pdev->dev, "expected clock rate = %d\n",
 			(64 * sample_rate * txclk_df * sysclk_df));
 	dev_dbg(&pdev->dev, "actual clock rate = %ld\n",
-			clk_get_rate(spdif_priv->txclk[rate]));
+			clk_get_rate(spdif_priv->txclk[clk]));
 
 	/* set fs field in consumer channel status */
 	spdif_set_cstatus(ctrl, IEC958_AES3_CON_FS, csfs);
@@ -598,8 +633,6 @@ static void fsl_spdif_shutdown(struct snd_pcm_substream *substream,
 		mask = SCR_TXFIFO_AUTOSYNC_MASK | SCR_TXFIFO_CTRL_MASK |
 			SCR_TXSEL_MASK | SCR_USRC_SEL_MASK |
 			SCR_TXFIFO_FSEL_MASK;
-		/* Disable TX clock */
-		regmap_update_bits(regmap, REG_SPDIF_STC, STC_TXCLK_ALL_EN_MASK, 0);
 	} else {
 		scr = SCR_RXFIFO_OFF | SCR_RXFIFO_CTL_ZERO;
 		mask = SCR_RXFIFO_FSEL_MASK | SCR_RXFIFO_AUTOSYNC_MASK|
@@ -674,14 +707,183 @@ static int fsl_spdif_trigger(struct snd_pcm_substream *substream,
 	return 0;
 }
 
+static u32 fsl_spdif_txclk_caldiv(struct fsl_spdif_priv *spdif_priv,
+				struct clk *clk, u64 savesub,
+				enum spdif_txrate index, bool round)
+{
+	static const u32 rate[] = { 32000, 44100, 48000, 88200, 96000, 176400,
+				    192000, };
+	bool is_sysclk = clk_is_match(clk, spdif_priv->sysclk);
+	u64 rate_ideal, rate_actual, sub;
+	u32 arate;
+	u16 sysclk_dfmin, sysclk_dfmax, sysclk_df;
+	u8 txclk_df;
+
+	/* The sysclk has an extra divisor [2, 512] */
+	sysclk_dfmin = is_sysclk ? 2 : 1;
+	sysclk_dfmax = is_sysclk ? 512 : 1;
+
+	for (sysclk_df = sysclk_dfmin; sysclk_df <= sysclk_dfmax; sysclk_df++) {
+		for (txclk_df = 1; txclk_df <= 128; txclk_df++) {
+			rate_ideal = rate[index] * txclk_df * 64ULL;
+			if (round)
+				rate_actual = clk_round_rate(clk, rate_ideal);
+			else
+				rate_actual = clk_get_rate(clk);
+
+			arate = rate_actual / 64;
+			arate /= txclk_df * sysclk_df;
+
+			if (arate == rate[index]) {
+				/* We are lucky */
+				savesub = 0;
+				spdif_priv->txclk_df[index] = txclk_df;
+				spdif_priv->sysclk_df[index] = sysclk_df;
+				spdif_priv->txrate[index] = arate;
+				goto out;
+			} else if (arate / rate[index] == 1) {
+				/* A little bigger than expect */
+				sub = (u64)(arate - rate[index]) * 100000;
+				do_div(sub, rate[index]);
+				if (sub >= savesub)
+					continue;
+				savesub = sub;
+				spdif_priv->txclk_df[index] = txclk_df;
+				spdif_priv->sysclk_df[index] = sysclk_df;
+				spdif_priv->txrate[index] = arate;
+			} else if (rate[index] / arate == 1) {
+				/* A little smaller than expect */
+				sub = (u64)(rate[index] - arate) * 100000;
+				do_div(sub, rate[index]);
+				if (sub >= savesub)
+					continue;
+				savesub = sub;
+				spdif_priv->txclk_df[index] = txclk_df;
+				spdif_priv->sysclk_df[index] = sysclk_df;
+				spdif_priv->txrate[index] = arate;
+			}
+		}
+	}
+
+out:
+	return savesub;
+}
+
+static int fsl_spdif_probe_txclk(struct fsl_spdif_priv *spdif_priv,
+				enum spdif_txrate index)
+{
+	static const u32 rate[] = { 32000, 44100, 48000, 88200, 96000, 176400,
+				    192000, };
+	struct platform_device *pdev = spdif_priv->pdev;
+	struct device *dev = &pdev->dev;
+	u64 savesub = 100000, ret;
+	struct clk *clk;
+	int i;
+
+	for (i = 0; i < STC_TXCLK_SRC_MAX; i++) {
+		clk = spdif_priv->txclk[i];
+		if (IS_ERR(clk)) {
+			dev_err(dev, "no rxtx%d clock in devicetree\n", i);
+			return PTR_ERR(clk);
+		}
+		if (!clk_get_rate(clk))
+			continue;
+
+		ret = fsl_spdif_txclk_caldiv(spdif_priv, clk, savesub, index,
+					     fsl_spdif_can_set_clk_rate(spdif_priv, i));
+		if (savesub == ret)
+			continue;
+
+		savesub = ret;
+		spdif_priv->txclk_src[index] = i;
+
+		/* To quick catch a divisor, we allow a 0.1% deviation */
+		if (savesub < 100)
+			break;
+	}
+
+	dev_dbg(&pdev->dev, "use rxtx%d as tx clock source for %dHz sample rate\n",
+			spdif_priv->txclk_src[index], rate[index]);
+	dev_dbg(&pdev->dev, "use txclk df %d for %dHz sample rate\n",
+			spdif_priv->txclk_df[index], rate[index]);
+	if (clk_is_match(spdif_priv->txclk[spdif_priv->txclk_src[index]], spdif_priv->sysclk))
+		dev_dbg(&pdev->dev, "use sysclk df %d for %dHz sample rate\n",
+				spdif_priv->sysclk_df[index], rate[index]);
+	dev_dbg(&pdev->dev, "the best rate for %dHz sample rate is %dHz\n",
+			rate[index], spdif_priv->txrate[index]);
+
+	return 0;
+}
+
+static int fsl_spdif_set_dai_sysclk(struct snd_soc_dai *cpu_dai,
+		int clk_id, unsigned int freq, int dir)
+{
+	struct fsl_spdif_priv *data = snd_soc_dai_get_drvdata(cpu_dai);
+	struct platform_device *pdev = data->pdev;
+	struct device *dev = &pdev->dev;
+	struct clk *clk, *p, *pll = 0, *npll = 0;
+	u64 ratio = freq;
+	int ret, i;
+	bool reparent = false;
+
+	if (dir != SND_SOC_CLOCK_OUT || freq == 0 || clk_id != STC_TXCLK_SPDIF_ROOT)
+		return 0;
+
+	if (data->pll8k_clk == NULL || data->pll11k_clk == NULL)
+		return 0;
+
+	clk = data->txclk[clk_id];
+	if (IS_ERR_OR_NULL(clk)) {
+		dev_err(dev, "no rxtx%d clock in devicetree\n", clk_id);
+		return PTR_ERR(clk);
+	}
+
+	p = clk;
+	while (p && data->pll8k_clk && data->pll11k_clk) {
+		struct clk *pp = clk_get_parent(p);
+
+		if (clk_is_match(pp, data->pll8k_clk) ||
+		    clk_is_match(pp, data->pll11k_clk)) {
+			pll = pp;
+			break;
+		}
+		p = pp;
+	}
+
+	npll = (do_div(ratio, 8000) ? data->pll11k_clk : data->pll8k_clk);
+	reparent = (pll && !clk_is_match(pll, npll));
+
+	clk_disable_unprepare(clk);
+	if (reparent) {
+		ret = clk_set_parent(p, npll);
+		if (ret < 0)
+			dev_warn(cpu_dai->dev, "failed to set parent %s: %d\n",
+				 __clk_get_name(npll), ret);
+	}
+
+	ret = clk_set_rate(clk, freq);
+	if (ret < 0)
+		dev_warn(cpu_dai->dev, "failed to set clock rate (%u): %d\n",
+			 freq, ret);
+	clk_prepare_enable(clk);
+
+	for (i = 0; i < SPDIF_TXRATE_MAX; i++) {
+		ret = fsl_spdif_probe_txclk(data, i);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
 static const struct snd_soc_dai_ops fsl_spdif_dai_ops = {
 	.startup = fsl_spdif_startup,
+	.set_sysclk = fsl_spdif_set_dai_sysclk,
 	.hw_params = fsl_spdif_hw_params,
 	.trigger = fsl_spdif_trigger,
 	.shutdown = fsl_spdif_shutdown,
 };
 
-
 /*
  * FSL SPDIF IEC958 controller(mixer) functions
  *
@@ -897,6 +1099,69 @@ static int fsl_spdif_rx_rcm_put(struct snd_kcontrol *kcontrol,
 	return 0;
 }
 
+static int fsl_spdif_bypass_get(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);
+	struct fsl_spdif_priv *priv = snd_soc_dai_get_drvdata(dai);
+
+	ucontrol->value.integer.value[0] = priv->bypass ? 1 : 0;
+
+	return 0;
+}
+
+static int fsl_spdif_bypass_put(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);
+	struct fsl_spdif_priv *priv = snd_soc_dai_get_drvdata(dai);
+	struct snd_soc_card *card = dai->component->card;
+	struct snd_soc_pcm_runtime *rtd;
+	struct regmap *regmap = priv->regmap;
+	bool set = (ucontrol->value.integer.value[0] != 0);
+	int stream;
+	u32 scr, mask;
+
+	rtd = snd_soc_get_pcm_runtime(card, card->dai_link);
+
+	if (priv->bypass == set)
+		return 0; /* nothing to do */
+
+	if (snd_soc_dai_active(dai)) {
+		dev_err(dai->dev, "Cannot change BYPASS mode while stream is running.\n");
+		return -EBUSY;
+	}
+
+	pm_runtime_get_sync(dai->dev);
+
+	if (set) {
+		/* Disable interrupts */
+		regmap_update_bits(regmap, REG_SPDIF_SIE, 0xffffff, 0);
+
+		/* Configure BYPASS mode */
+		scr = SCR_TXSEL_RX | SCR_RXFIFO_OFF;
+		mask = SCR_RXFIFO_FSEL_MASK | SCR_RXFIFO_AUTOSYNC_MASK |
+			SCR_RXFIFO_CTL_MASK | SCR_RXFIFO_OFF_MASK | SCR_TXSEL_MASK;
+		/* Power up SPDIF module */
+		mask |= SCR_LOW_POWER;
+	} else {
+		/* Power down SPDIF module, disable TX */
+		scr = SCR_LOW_POWER | SCR_TXSEL_OFF;
+		mask = SCR_LOW_POWER | SCR_TXSEL_MASK;
+	}
+
+	regmap_update_bits(regmap, REG_SPDIF_SCR, mask, scr);
+
+	/* Disable playback & capture if BYPASS mode is enabled, enable otherwise */
+	for_each_pcm_streams(stream)
+		rtd->pcm->streams[stream].substream_count = (set ? 0 : 1);
+
+	priv->bypass = set;
+	pm_runtime_put_sync(dai->dev);
+
+	return 0;
+}
+
 /* DPLL lock information */
 static int fsl_spdif_rxrate_info(struct snd_kcontrol *kcontrol,
 				struct snd_ctl_elem_info *uinfo)
@@ -1067,6 +1332,15 @@ static struct snd_kcontrol_new fsl_spdif_ctrls[] = {
 		.info = fsl_spdif_rxrate_info,
 		.get = fsl_spdif_rxrate_get,
 	},
+	/* RX bypass controller */
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
+		.name = "Bypass Mode",
+		.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,
+		.info = snd_ctl_boolean_mono_info,
+		.get = fsl_spdif_bypass_get,
+		.put = fsl_spdif_bypass_put,
+	},
 	/* User bit sync mode set/get controller */
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
@@ -1145,6 +1419,8 @@ static const struct reg_default fsl_spdif_reg_defaults[] = {
 	{REG_SPDIF_STR,	   0x00000000},
 	{REG_SPDIF_STCSCH, 0x00000000},
 	{REG_SPDIF_STCSCL, 0x00000000},
+	{REG_SPDIF_STCSPH, 0x00000000},
+	{REG_SPDIF_STCSPL, 0x00000000},
 	{REG_SPDIF_STC,	   0x00020f00},
 };
 
@@ -1164,8 +1440,22 @@ static bool fsl_spdif_readable_reg(struct device *dev, unsigned int reg)
 	case REG_SPDIF_SRQ:
 	case REG_SPDIF_STCSCH:
 	case REG_SPDIF_STCSCL:
+	case REG_SPDIF_STCSPH:
+	case REG_SPDIF_STCSPL:
 	case REG_SPDIF_SRFM:
 	case REG_SPDIF_STC:
+	case REG_SPDIF_SRCCA_31_0:
+	case REG_SPDIF_SRCCA_63_32:
+	case REG_SPDIF_SRCCA_95_64:
+	case REG_SPDIF_SRCCA_127_96:
+	case REG_SPDIF_SRCCA_159_128:
+	case REG_SPDIF_SRCCA_191_160:
+	case REG_SPDIF_STCCA_31_0:
+	case REG_SPDIF_STCCA_63_32:
+	case REG_SPDIF_STCCA_95_64:
+	case REG_SPDIF_STCCA_127_96:
+	case REG_SPDIF_STCCA_159_128:
+	case REG_SPDIF_STCCA_191_160:
 		return true;
 	default:
 		return false;
@@ -1184,6 +1474,12 @@ static bool fsl_spdif_volatile_reg(struct device *dev, unsigned int reg)
 	case REG_SPDIF_SRU:
 	case REG_SPDIF_SRQ:
 	case REG_SPDIF_SRFM:
+	case REG_SPDIF_SRCCA_31_0:
+	case REG_SPDIF_SRCCA_63_32:
+	case REG_SPDIF_SRCCA_95_64:
+	case REG_SPDIF_SRCCA_127_96:
+	case REG_SPDIF_SRCCA_159_128:
+	case REG_SPDIF_SRCCA_191_160:
 		return true;
 	default:
 		return false;
@@ -1202,7 +1498,15 @@ static bool fsl_spdif_writeable_reg(struct device *dev, unsigned int reg)
 	case REG_SPDIF_STR:
 	case REG_SPDIF_STCSCH:
 	case REG_SPDIF_STCSCL:
+	case REG_SPDIF_STCSPH:
+	case REG_SPDIF_STCSPL:
 	case REG_SPDIF_STC:
+	case REG_SPDIF_STCCA_31_0:
+	case REG_SPDIF_STCCA_63_32:
+	case REG_SPDIF_STCCA_95_64:
+	case REG_SPDIF_STCCA_127_96:
+	case REG_SPDIF_STCCA_159_128:
+	case REG_SPDIF_STCCA_191_160:
 		return true;
 	default:
 		return false;
@@ -1214,7 +1518,7 @@ static const struct regmap_config fsl_spdif_regmap_config = {
 	.reg_stride = 4,
 	.val_bits = 32,
 
-	.max_register = REG_SPDIF_STC,
+	.max_register = REG_SPDIF_STCCA_191_160,
 	.reg_defaults = fsl_spdif_reg_defaults,
 	.num_reg_defaults = ARRAY_SIZE(fsl_spdif_reg_defaults),
 	.readable_reg = fsl_spdif_readable_reg,
@@ -1223,117 +1527,6 @@ static const struct regmap_config fsl_spdif_regmap_config = {
 	.cache_type = REGCACHE_FLAT,
 };
 
-static u32 fsl_spdif_txclk_caldiv(struct fsl_spdif_priv *spdif_priv,
-				struct clk *clk, u64 savesub,
-				enum spdif_txrate index, bool round)
-{
-	static const u32 rate[] = { 32000, 44100, 48000, 88200, 96000, 176400,
-				    192000, };
-	bool is_sysclk = clk_is_match(clk, spdif_priv->sysclk);
-	u64 rate_ideal, rate_actual, sub;
-	u32 arate;
-	u16 sysclk_dfmin, sysclk_dfmax, sysclk_df;
-	u8 txclk_df;
-
-	/* The sysclk has an extra divisor [2, 512] */
-	sysclk_dfmin = is_sysclk ? 2 : 1;
-	sysclk_dfmax = is_sysclk ? 512 : 1;
-
-	for (sysclk_df = sysclk_dfmin; sysclk_df <= sysclk_dfmax; sysclk_df++) {
-		for (txclk_df = 1; txclk_df <= 128; txclk_df++) {
-			rate_ideal = rate[index] * txclk_df * 64ULL;
-			if (round)
-				rate_actual = clk_round_rate(clk, rate_ideal);
-			else
-				rate_actual = clk_get_rate(clk);
-
-			arate = rate_actual / 64;
-			arate /= txclk_df * sysclk_df;
-
-			if (arate == rate[index]) {
-				/* We are lucky */
-				savesub = 0;
-				spdif_priv->txclk_df[index] = txclk_df;
-				spdif_priv->sysclk_df[index] = sysclk_df;
-				spdif_priv->txrate[index] = arate;
-				goto out;
-			} else if (arate / rate[index] == 1) {
-				/* A little bigger than expect */
-				sub = (u64)(arate - rate[index]) * 100000;
-				do_div(sub, rate[index]);
-				if (sub >= savesub)
-					continue;
-				savesub = sub;
-				spdif_priv->txclk_df[index] = txclk_df;
-				spdif_priv->sysclk_df[index] = sysclk_df;
-				spdif_priv->txrate[index] = arate;
-			} else if (rate[index] / arate == 1) {
-				/* A little smaller than expect */
-				sub = (u64)(rate[index] - arate) * 100000;
-				do_div(sub, rate[index]);
-				if (sub >= savesub)
-					continue;
-				savesub = sub;
-				spdif_priv->txclk_df[index] = txclk_df;
-				spdif_priv->sysclk_df[index] = sysclk_df;
-				spdif_priv->txrate[index] = arate;
-			}
-		}
-	}
-
-out:
-	return savesub;
-}
-
-static int fsl_spdif_probe_txclk(struct fsl_spdif_priv *spdif_priv,
-				enum spdif_txrate index)
-{
-	static const u32 rate[] = { 32000, 44100, 48000, 88200, 96000, 176400,
-				    192000, };
-	struct platform_device *pdev = spdif_priv->pdev;
-	struct device *dev = &pdev->dev;
-	u64 savesub = 100000, ret;
-	struct clk *clk;
-	char tmp[16];
-	int i;
-
-	for (i = 0; i < STC_TXCLK_SRC_MAX; i++) {
-		sprintf(tmp, "rxtx%d", i);
-		clk = devm_clk_get(dev, tmp);
-		if (IS_ERR(clk)) {
-			dev_err(dev, "no rxtx%d clock in devicetree\n", i);
-			return PTR_ERR(clk);
-		}
-		if (!clk_get_rate(clk))
-			continue;
-
-		ret = fsl_spdif_txclk_caldiv(spdif_priv, clk, savesub, index,
-					     fsl_spdif_can_set_clk_rate(spdif_priv, i));
-		if (savesub == ret)
-			continue;
-
-		savesub = ret;
-		spdif_priv->txclk[index] = clk;
-		spdif_priv->txclk_src[index] = i;
-
-		/* To quick catch a divisor, we allow a 0.1% deviation */
-		if (savesub < 100)
-			break;
-	}
-
-	dev_dbg(dev, "use rxtx%d as tx clock source for %dHz sample rate\n",
-			spdif_priv->txclk_src[index], rate[index]);
-	dev_dbg(dev, "use txclk df %d for %dHz sample rate\n",
-			spdif_priv->txclk_df[index], rate[index]);
-	if (clk_is_match(spdif_priv->txclk[index], spdif_priv->sysclk))
-		dev_dbg(dev, "use sysclk df %d for %dHz sample rate\n",
-				spdif_priv->sysclk_df[index], rate[index]);
-	dev_dbg(dev, "the best rate for %dHz sample rate is %dHz\n",
-			rate[index], spdif_priv->txrate[index]);
-
-	return 0;
-}
-
 static int fsl_spdif_probe(struct platform_device *pdev)
 {
 	struct fsl_spdif_priv *spdif_priv;
@@ -1341,6 +1534,7 @@ static int fsl_spdif_probe(struct platform_device *pdev)
 	struct resource *res;
 	void __iomem *regs;
 	int irq, ret, i;
+	char tmp[16];
 
 	spdif_priv = devm_kzalloc(&pdev->dev, sizeof(*spdif_priv), GFP_KERNEL);
 	if (!spdif_priv)
@@ -1380,8 +1574,17 @@ static int fsl_spdif_probe(struct platform_device *pdev)
 		}
 	}
 
+	for (i = 0; i < STC_TXCLK_SRC_MAX; i++) {
+		sprintf(tmp, "rxtx%d", i);
+		spdif_priv->txclk[i] = devm_clk_get(&pdev->dev, tmp);
+		if (IS_ERR(spdif_priv->txclk[i])) {
+			dev_err(&pdev->dev, "no rxtx%d clock in devicetree\n", i);
+			return PTR_ERR(spdif_priv->txclk[i]);
+		}
+	}
+
 	/* Get system clock for rx clock rate calculation */
-	spdif_priv->sysclk = devm_clk_get(&pdev->dev, "rxtx5");
+	spdif_priv->sysclk = spdif_priv->txclk[5];
 	if (IS_ERR(spdif_priv->sysclk)) {
 		dev_err(&pdev->dev, "no sys clock (rxtx5) in devicetree\n");
 		return PTR_ERR(spdif_priv->sysclk);
@@ -1399,13 +1602,21 @@ static int fsl_spdif_probe(struct platform_device *pdev)
 		dev_warn(&pdev->dev, "no spba clock in devicetree\n");
 
 	/* Select clock source for rx/tx clock */
-	spdif_priv->rxclk = devm_clk_get(&pdev->dev, "rxtx1");
+	spdif_priv->rxclk = spdif_priv->txclk[1];
 	if (IS_ERR(spdif_priv->rxclk)) {
 		dev_err(&pdev->dev, "no rxtx1 clock in devicetree\n");
 		return PTR_ERR(spdif_priv->rxclk);
 	}
 	spdif_priv->rxclk_src = DEFAULT_RXCLK_SRC;
 
+	spdif_priv->pll8k_clk = devm_clk_get(&pdev->dev, "pll8k");
+	if (IS_ERR(spdif_priv->pll8k_clk))
+		spdif_priv->pll8k_clk = NULL;
+
+	spdif_priv->pll11k_clk = devm_clk_get(&pdev->dev, "pll11k");
+	if (IS_ERR(spdif_priv->pll11k_clk))
+		spdif_priv->pll11k_clk = NULL;
+
 	for (i = 0; i < SPDIF_TXRATE_MAX; i++) {
 		ret = fsl_spdif_probe_txclk(spdif_priv, i);
 		if (ret)
@@ -1480,9 +1691,9 @@ static int fsl_spdif_runtime_suspend(struct device *dev)
 			&spdif_priv->regcache_srpc);
 	regcache_cache_only(spdif_priv->regmap, true);
 
-	clk_disable_unprepare(spdif_priv->rxclk);
+	release_bus_freq(BUS_FREQ_HIGH);
 
-	for (i = 0; i < SPDIF_TXRATE_MAX; i++)
+	for (i = 0; i < STC_TXCLK_SRC_MAX; i++)
 		clk_disable_unprepare(spdif_priv->txclk[i]);
 
 	if (!IS_ERR(spdif_priv->spbaclk))
@@ -1512,15 +1723,13 @@ static int fsl_spdif_runtime_resume(struct device *dev)
 		}
 	}
 
-	for (i = 0; i < SPDIF_TXRATE_MAX; i++) {
+	for (i = 0; i < STC_TXCLK_SRC_MAX; i++) {
 		ret = clk_prepare_enable(spdif_priv->txclk[i]);
 		if (ret)
 			goto disable_tx_clk;
 	}
 
-	ret = clk_prepare_enable(spdif_priv->rxclk);
-	if (ret)
-		goto disable_tx_clk;
+	request_bus_freq(BUS_FREQ_HIGH);
 
 	regcache_cache_only(spdif_priv->regmap, false);
 	regcache_mark_dirty(spdif_priv->regmap);
@@ -1531,12 +1740,10 @@ static int fsl_spdif_runtime_resume(struct device *dev)
 
 	ret = regcache_sync(spdif_priv->regmap);
 	if (ret)
-		goto disable_rx_clk;
+		goto disable_tx_clk;
 
 	return 0;
 
-disable_rx_clk:
-	clk_disable_unprepare(spdif_priv->rxclk);
 disable_tx_clk:
 	for (i--; i >= 0; i--)
 		clk_disable_unprepare(spdif_priv->txclk[i]);
@@ -1562,6 +1769,7 @@ static const struct of_device_id fsl_spdif_dt_ids[] = {
 	{ .compatible = "fsl,imx6sx-spdif", .data = &fsl_spdif_imx6sx, },
 	{ .compatible = "fsl,imx8qm-spdif", .data = &fsl_spdif_imx8qm, },
 	{ .compatible = "fsl,imx8mm-spdif", .data = &fsl_spdif_imx8mm, },
+	{ .compatible = "fsl,imx8ulp-spdif", .data = &fsl_spdif_imx8ulp, },
 	{}
 };
 MODULE_DEVICE_TABLE(of, fsl_spdif_dt_ids);
diff --git a/sound/soc/fsl/fsl_spdif.h b/sound/soc/fsl/fsl_spdif.h
index bff8290e7..5ac575ef4 100644
--- a/sound/soc/fsl/fsl_spdif.h
+++ b/sound/soc/fsl/fsl_spdif.h
@@ -31,9 +31,23 @@
 #define REG_SPDIF_STR			0x30	/* SPDIFTxRight Register */
 #define REG_SPDIF_STCSCH		0x34	/* SPDIFTxCChannelCons_h Register */
 #define REG_SPDIF_STCSCL		0x38	/* SPDIFTxCChannelCons_l Register */
+#define REG_SPDIF_STCSPH		0x3C	/* SPDIFTxCChannel_Prof_h Register */
+#define REG_SPDIF_STCSPL		0x40	/* SPDIFTxCChannel_Prof_l Register */
 #define REG_SPDIF_SRFM			0x44	/* FreqMeas Register */
 #define REG_SPDIF_STC			0x50	/* SPDIFTxClk Register */
 
+#define REG_SPDIF_SRCCA_31_0		0x60
+#define REG_SPDIF_SRCCA_63_32		0x64
+#define REG_SPDIF_SRCCA_95_64		0x68
+#define REG_SPDIF_SRCCA_127_96		0x6C
+#define REG_SPDIF_SRCCA_159_128		0x70
+#define REG_SPDIF_SRCCA_191_160		0x74
+#define REG_SPDIF_STCCA_31_0		0x78
+#define REG_SPDIF_STCCA_63_32		0x7C
+#define REG_SPDIF_STCCA_95_64		0x80
+#define REG_SPDIF_STCCA_127_96		0x84
+#define REG_SPDIF_STCCA_159_128		0x88
+#define REG_SPDIF_STCCA_191_160		0x8C
 
 /* SPDIF Configuration register */
 #define SCR_RXFIFO_CTL_OFFSET		23
diff --git a/sound/soc/fsl/fsl_ssi.c b/sound/soc/fsl/fsl_ssi.c
index ecbc1c365..da5df36a3 100644
--- a/sound/soc/fsl/fsl_ssi.c
+++ b/sound/soc/fsl/fsl_ssi.c
@@ -40,6 +40,9 @@
 #include <linux/of_address.h>
 #include <linux/of_irq.h>
 #include <linux/of_platform.h>
+#include <linux/pm_runtime.h>
+#include <linux/busfreq-imx.h>
+#include <linux/platform_data/dma-imx.h>
 
 #include <sound/core.h>
 #include <sound/pcm.h>
@@ -255,6 +258,7 @@ struct fsl_ssi {
 	bool synchronous;
 	bool use_dma;
 	bool use_dual_fifo;
+	bool use_dyna_fifo;
 	bool has_ipg_clk_name;
 	unsigned int fifo_depth;
 	unsigned int slot_width;
@@ -287,6 +291,7 @@ struct fsl_ssi {
 	u32 dma_maxburst;
 
 	struct mutex ac97_reg_lock;
+	struct sdma_audio_config audio_config[2];
 };
 
 /*
@@ -643,7 +648,7 @@ static int fsl_ssi_startup(struct snd_pcm_substream *substream,
 	 * task from fifo0, fifo1 would be neglected at the end of each
 	 * period. But SSI would still access fifo1 with an invalid data.
 	 */
-	if (ssi->use_dual_fifo)
+	if (ssi->use_dual_fifo || ssi->use_dyna_fifo)
 		snd_pcm_hw_constraint_step(substream->runtime, 0,
 					   SNDRV_PCM_HW_PARAM_PERIOD_SIZE, 2);
 
@@ -807,6 +812,7 @@ static int fsl_ssi_hw_params(struct snd_pcm_substream *substream,
 	unsigned int sample_size = params_width(hw_params);
 	u32 wl = SSI_SxCCR_WL(sample_size);
 	int ret;
+	struct fsl_ssi_regvals *vals = ssi->regvals;
 
 	if (fsl_ssi_is_i2s_master(ssi)) {
 		ret = fsl_ssi_set_bclk(substream, dai, hw_params);
@@ -856,6 +862,32 @@ static int fsl_ssi_hw_params(struct snd_pcm_substream *substream,
 	tx2 = tx || ssi->synchronous;
 	regmap_update_bits(regs, REG_SSI_SxCCR(tx2), SSI_SxCCR_WL_MASK, wl);
 
+	if (ssi->use_dyna_fifo) {
+		if (channels == 1) {
+			ssi->audio_config[0].dst_fifo_num = 1;
+			ssi->audio_config[1].src_fifo_num = 1;
+			ssi->dma_params_tx.peripheral_config = &ssi->audio_config[0];
+			ssi->dma_params_tx.peripheral_size = sizeof(ssi->audio_config[0]);
+			ssi->dma_params_rx.peripheral_config = &ssi->audio_config[1];
+			ssi->dma_params_rx.peripheral_size = sizeof(ssi->audio_config[1]);
+			vals[RX].srcr &= ~SSI_SRCR_RFEN1;
+			vals[TX].stcr &= ~SSI_STCR_TFEN1;
+			vals[RX].scr  &= ~SSI_SCR_TCH_EN;
+			vals[TX].scr  &= ~SSI_SCR_TCH_EN;
+		} else {
+			ssi->audio_config[0].dst_fifo_num = 2;
+			ssi->audio_config[1].src_fifo_num = 2;
+			ssi->dma_params_tx.peripheral_config = &ssi->audio_config[0];
+			ssi->dma_params_tx.peripheral_size = sizeof(ssi->audio_config[0]);
+			ssi->dma_params_rx.peripheral_config = &ssi->audio_config[1];
+			ssi->dma_params_rx.peripheral_size = sizeof(ssi->audio_config[1]);
+			vals[RX].srcr |= SSI_SRCR_RFEN1;
+			vals[TX].stcr |= SSI_STCR_TFEN1;
+			vals[RX].scr  |= SSI_SCR_TCH_EN;
+			vals[TX].scr  |= SSI_SCR_TCH_EN;
+		}
+	}
+
 	return 0;
 }
 
@@ -1347,6 +1379,8 @@ static int fsl_ssi_imx_probe(struct platform_device *pdev,
 		dev_dbg(dev, "failed to get baud clock: %ld\n",
 			 PTR_ERR(ssi->baudclk));
 
+	ssi->dma_params_rx.chan_name = "rx";
+	ssi->dma_params_tx.chan_name = "tx";
 	ssi->dma_params_tx.maxburst = ssi->dma_maxburst;
 	ssi->dma_params_rx.maxburst = ssi->dma_maxburst;
 	ssi->dma_params_tx.addr = ssi->ssi_phys + REG_SSI_STX0;
@@ -1446,6 +1480,8 @@ static int fsl_ssi_probe_from_dt(struct fsl_ssi *ssi)
 	if (ssi->use_dma && !ret && dmas[2] == IMX_DMATYPE_SSI_DUAL)
 		ssi->use_dual_fifo = true;
 
+	if (ssi->use_dma && !ret && dmas[2] == IMX_DMATYPE_MULTI_SAI)
+		ssi->use_dyna_fifo = true;
 	/*
 	 * Backward compatible for older bindings by manually triggering the
 	 * machine driver's probe(). Use /compatible property, including the
@@ -1564,6 +1600,7 @@ static int fsl_ssi_probe(struct platform_device *pdev)
 	}
 
 	dev_set_drvdata(dev, ssi);
+	pm_runtime_enable(&pdev->dev);
 
 	if (ssi->soc->imx) {
 		ret = fsl_ssi_imx_probe(pdev, ssi, iomem);
@@ -1663,6 +1700,20 @@ static int fsl_ssi_remove(struct platform_device *pdev)
 	return 0;
 }
 
+#ifdef CONFIG_PM
+static int fsl_ssi_runtime_resume(struct device *dev)
+{
+	request_bus_freq(BUS_FREQ_AUDIO);
+	return 0;
+}
+
+static int fsl_ssi_runtime_suspend(struct device *dev)
+{
+	release_bus_freq(BUS_FREQ_AUDIO);
+	return 0;
+}
+#endif
+
 #ifdef CONFIG_PM_SLEEP
 static int fsl_ssi_suspend(struct device *dev)
 {
@@ -1697,6 +1748,8 @@ static int fsl_ssi_resume(struct device *dev)
 
 static const struct dev_pm_ops fsl_ssi_pm = {
 	SET_SYSTEM_SLEEP_PM_OPS(fsl_ssi_suspend, fsl_ssi_resume)
+	SET_RUNTIME_PM_OPS(fsl_ssi_runtime_suspend, fsl_ssi_runtime_resume,
+			   NULL)
 };
 
 static struct platform_driver fsl_ssi_driver = {
diff --git a/sound/soc/fsl/fsl_xcvr.c b/sound/soc/fsl/fsl_xcvr.c
index d0556c79f..b0f654fff 100644
--- a/sound/soc/fsl/fsl_xcvr.c
+++ b/sound/soc/fsl/fsl_xcvr.c
@@ -8,41 +8,11 @@
 #include <linux/module.h>
 #include <linux/of_platform.h>
 #include <linux/pm_runtime.h>
-#include <linux/regmap.h>
-#include <linux/reset.h>
-#include <sound/dmaengine_pcm.h>
-#include <sound/pcm_iec958.h>
 #include <sound/pcm_params.h>
 
 #include "fsl_xcvr.h"
 #include "imx-pcm.h"
 
-#define FSL_XCVR_CAPDS_SIZE	256
-
-struct fsl_xcvr_soc_data {
-	const char *fw_name;
-};
-
-struct fsl_xcvr {
-	const struct fsl_xcvr_soc_data *soc_data;
-	struct platform_device *pdev;
-	struct regmap *regmap;
-	struct clk *ipg_clk;
-	struct clk *pll_ipg_clk;
-	struct clk *phy_clk;
-	struct clk *spba_clk;
-	struct reset_control *reset;
-	u8 streams;
-	u32 mode;
-	u32 arc_mode;
-	void __iomem *ram_addr;
-	struct snd_dmaengine_dai_dma_data dma_prms_rx;
-	struct snd_dmaengine_dai_dma_data dma_prms_tx;
-	struct snd_aes_iec958 rx_iec958;
-	struct snd_aes_iec958 tx_iec958;
-	u8 cap_ds[FSL_XCVR_CAPDS_SIZE];
-};
-
 static const struct fsl_xcvr_pll_conf {
 	u8 mfi;   /* min=0x18, max=0x38 */
 	u32 mfn;  /* signed int, 2's compl., min=0x3FFF0000, max=0x00010000 */
@@ -933,6 +903,14 @@ static const struct reg_default fsl_xcvr_reg_defaults[] = {
 	{ FSL_XCVR_RX_DPTH_CTRL_SET,	0x00002C89 },
 	{ FSL_XCVR_RX_DPTH_CTRL_CLR,	0x00002C89 },
 	{ FSL_XCVR_RX_DPTH_CTRL_TOG,	0x00002C89 },
+	{ FSL_XCVR_RX_DPTH_CNTR_CTRL,	0x00000000 },
+	{ FSL_XCVR_RX_DPTH_CNTR_CTRL_SET, 0x00000000 },
+	{ FSL_XCVR_RX_DPTH_CNTR_CTRL_CLR, 0x00000000 },
+	{ FSL_XCVR_RX_DPTH_CNTR_CTRL_TOG, 0x00000000 },
+	{ FSL_XCVR_RX_DPTH_TSCR, 0x00000000 },
+	{ FSL_XCVR_RX_DPTH_BCR,  0x00000000 },
+	{ FSL_XCVR_RX_DPTH_BCTR, 0x00000000 },
+	{ FSL_XCVR_RX_DPTH_BCRR, 0x00000000 },
 	{ FSL_XCVR_TX_DPTH_CTRL,	0x00000000 },
 	{ FSL_XCVR_TX_DPTH_CTRL_SET,	0x00000000 },
 	{ FSL_XCVR_TX_DPTH_CTRL_CLR,	0x00000000 },
@@ -943,6 +921,14 @@ static const struct reg_default fsl_xcvr_reg_defaults[] = {
 	{ FSL_XCVR_TX_CS_DATA_3,	0x00000000 },
 	{ FSL_XCVR_TX_CS_DATA_4,	0x00000000 },
 	{ FSL_XCVR_TX_CS_DATA_5,	0x00000000 },
+	{ FSL_XCVR_TX_DPTH_CNTR_CTRL,	0x00000000 },
+	{ FSL_XCVR_TX_DPTH_CNTR_CTRL_SET, 0x00000000 },
+	{ FSL_XCVR_TX_DPTH_CNTR_CTRL_CLR, 0x00000000 },
+	{ FSL_XCVR_TX_DPTH_CNTR_CTRL_TOG, 0x00000000 },
+	{ FSL_XCVR_TX_DPTH_TSCR, 0x00000000 },
+	{ FSL_XCVR_TX_DPTH_BCR,	 0x00000000 },
+	{ FSL_XCVR_TX_DPTH_BCTR, 0x00000000 },
+	{ FSL_XCVR_TX_DPTH_BCRR, 0x00000000 },
 	{ FSL_XCVR_DEBUG_REG_0,		0x00000000 },
 	{ FSL_XCVR_DEBUG_REG_1,		0x00000000 },
 };
@@ -974,6 +960,14 @@ static bool fsl_xcvr_readable_reg(struct device *dev, unsigned int reg)
 	case FSL_XCVR_RX_DPTH_CTRL_SET:
 	case FSL_XCVR_RX_DPTH_CTRL_CLR:
 	case FSL_XCVR_RX_DPTH_CTRL_TOG:
+	case FSL_XCVR_RX_DPTH_CNTR_CTRL:
+	case FSL_XCVR_RX_DPTH_CNTR_CTRL_SET:
+	case FSL_XCVR_RX_DPTH_CNTR_CTRL_CLR:
+	case FSL_XCVR_RX_DPTH_CNTR_CTRL_TOG:
+	case FSL_XCVR_RX_DPTH_TSCR:
+	case FSL_XCVR_RX_DPTH_BCR:
+	case FSL_XCVR_RX_DPTH_BCTR:
+	case FSL_XCVR_RX_DPTH_BCRR:
 	case FSL_XCVR_TX_DPTH_CTRL:
 	case FSL_XCVR_TX_DPTH_CTRL_SET:
 	case FSL_XCVR_TX_DPTH_CTRL_CLR:
@@ -984,6 +978,14 @@ static bool fsl_xcvr_readable_reg(struct device *dev, unsigned int reg)
 	case FSL_XCVR_TX_CS_DATA_3:
 	case FSL_XCVR_TX_CS_DATA_4:
 	case FSL_XCVR_TX_CS_DATA_5:
+	case FSL_XCVR_TX_DPTH_CNTR_CTRL:
+	case FSL_XCVR_TX_DPTH_CNTR_CTRL_SET:
+	case FSL_XCVR_TX_DPTH_CNTR_CTRL_CLR:
+	case FSL_XCVR_TX_DPTH_CNTR_CTRL_TOG:
+	case FSL_XCVR_TX_DPTH_TSCR:
+	case FSL_XCVR_TX_DPTH_BCR:
+	case FSL_XCVR_TX_DPTH_BCTR:
+	case FSL_XCVR_TX_DPTH_BCRR:
 	case FSL_XCVR_DEBUG_REG_0:
 	case FSL_XCVR_DEBUG_REG_1:
 		return true;
@@ -1016,6 +1018,10 @@ static bool fsl_xcvr_writeable_reg(struct device *dev, unsigned int reg)
 	case FSL_XCVR_RX_DPTH_CTRL_SET:
 	case FSL_XCVR_RX_DPTH_CTRL_CLR:
 	case FSL_XCVR_RX_DPTH_CTRL_TOG:
+	case FSL_XCVR_RX_DPTH_CNTR_CTRL:
+	case FSL_XCVR_RX_DPTH_CNTR_CTRL_SET:
+	case FSL_XCVR_RX_DPTH_CNTR_CTRL_CLR:
+	case FSL_XCVR_RX_DPTH_CNTR_CTRL_TOG:
 	case FSL_XCVR_TX_DPTH_CTRL_SET:
 	case FSL_XCVR_TX_DPTH_CTRL_CLR:
 	case FSL_XCVR_TX_DPTH_CTRL_TOG:
@@ -1025,6 +1031,10 @@ static bool fsl_xcvr_writeable_reg(struct device *dev, unsigned int reg)
 	case FSL_XCVR_TX_CS_DATA_3:
 	case FSL_XCVR_TX_CS_DATA_4:
 	case FSL_XCVR_TX_CS_DATA_5:
+	case FSL_XCVR_TX_DPTH_CNTR_CTRL:
+	case FSL_XCVR_TX_DPTH_CNTR_CTRL_SET:
+	case FSL_XCVR_TX_DPTH_CNTR_CTRL_CLR:
+	case FSL_XCVR_TX_DPTH_CNTR_CTRL_TOG:
 		return true;
 	default:
 		return false;
@@ -1237,11 +1247,24 @@ static int fsl_xcvr_probe(struct platform_device *pdev)
 	if (ret) {
 		dev_err(dev, "failed to register component %s\n",
 			fsl_xcvr_comp.name);
+		return ret;
 	}
 
+	ret = sysfs_create_group(&pdev->dev.kobj, fsl_xcvr_get_attr_grp());
+	if (ret)
+		dev_err(&pdev->dev, "fail to create sys group\n");
+
 	return ret;
 }
 
+static int fsl_xcvr_remove(struct platform_device *pdev)
+{
+	sysfs_remove_group(&pdev->dev.kobj, fsl_xcvr_get_attr_grp());
+	pm_runtime_disable(&pdev->dev);
+
+	return 0;
+}
+
 static __maybe_unused int fsl_xcvr_runtime_suspend(struct device *dev)
 {
 	struct fsl_xcvr *xcvr = dev_get_drvdata(dev);
@@ -1365,6 +1388,7 @@ static const struct dev_pm_ops fsl_xcvr_pm_ops = {
 
 static struct platform_driver fsl_xcvr_driver = {
 	.probe = fsl_xcvr_probe,
+	.remove = fsl_xcvr_remove,
 	.driver = {
 		.name = "fsl,imx8mp-audio-xcvr",
 		.pm = &fsl_xcvr_pm_ops,
diff --git a/sound/soc/fsl/fsl_xcvr.h b/sound/soc/fsl/fsl_xcvr.h
index 7f2853c60..022fddc03 100644
--- a/sound/soc/fsl/fsl_xcvr.h
+++ b/sound/soc/fsl/fsl_xcvr.h
@@ -8,6 +8,11 @@
 #ifndef __FSL_XCVR_H
 #define __FSL_XCVR_H
 
+#include <linux/regmap.h>
+#include <linux/reset.h>
+#include <sound/dmaengine_pcm.h>
+#include <sound/pcm_iec958.h>
+
 #define FSL_XCVR_MODE_SPDIF	0
 #define FSL_XCVR_MODE_ARC	1
 #define FSL_XCVR_MODE_EARC	2
@@ -49,6 +54,16 @@
 #define FSL_XCVR_RX_DPTH_CTRL_CLR	0x188
 #define FSL_XCVR_RX_DPTH_CTRL_TOG	0x18c
 
+#define FSL_XCVR_RX_DPTH_CNTR_CTRL	0x1C0
+#define FSL_XCVR_RX_DPTH_CNTR_CTRL_SET	0x1C4
+#define FSL_XCVR_RX_DPTH_CNTR_CTRL_CLR	0x1C8
+#define FSL_XCVR_RX_DPTH_CNTR_CTRL_TOG	0x1CC
+
+#define FSL_XCVR_RX_DPTH_TSCR		0x1D0
+#define FSL_XCVR_RX_DPTH_BCR		0x1D4
+#define FSL_XCVR_RX_DPTH_BCTR		0x1D8
+#define FSL_XCVR_RX_DPTH_BCRR		0x1DC
+
 #define FSL_XCVR_TX_DPTH_CTRL		0x220 /* TX datapath ctrl reg */
 #define FSL_XCVR_TX_DPTH_CTRL_SET	0x224
 #define FSL_XCVR_TX_DPTH_CTRL_CLR	0x228
@@ -59,6 +74,17 @@
 #define FSL_XCVR_TX_CS_DATA_3		0x23C
 #define FSL_XCVR_TX_CS_DATA_4		0x240
 #define FSL_XCVR_TX_CS_DATA_5		0x244
+
+#define FSL_XCVR_TX_DPTH_CNTR_CTRL	0x260
+#define FSL_XCVR_TX_DPTH_CNTR_CTRL_SET	0x264
+#define FSL_XCVR_TX_DPTH_CNTR_CTRL_CLR	0x268
+#define FSL_XCVR_TX_DPTH_CNTR_CTRL_TOG	0x26C
+
+#define FSL_XCVR_TX_DPTH_TSCR		0x270
+#define FSL_XCVR_TX_DPTH_BCR		0x274
+#define FSL_XCVR_TX_DPTH_BCTR		0x278
+#define FSL_XCVR_TX_DPTH_BCRR		0x27C
+
 #define FSL_XCVR_DEBUG_REG_0		0x2E0
 #define FSL_XCVR_DEBUG_REG_1		0x2F0
 
@@ -263,4 +289,32 @@
 #define FSL_XCVR_RX_CS_BUFF_1		0xA0 /* Second RX CS buffer */
 #define FSL_XCVR_CAP_DATA_STR		0x300 /* Capabilities data structure */
 
+#define FSL_XCVR_CAPDS_SIZE	256
+
+struct fsl_xcvr_soc_data {
+	const char *fw_name;
+};
+
+struct fsl_xcvr {
+	const struct fsl_xcvr_soc_data *soc_data;
+	struct platform_device *pdev;
+	struct regmap *regmap;
+	struct clk *ipg_clk;
+	struct clk *pll_ipg_clk;
+	struct clk *phy_clk;
+	struct clk *spba_clk;
+	struct reset_control *reset;
+	u8 streams;
+	u32 mode;
+	u32 arc_mode;
+	void __iomem *ram_addr;
+	struct snd_dmaengine_dai_dma_data dma_prms_rx;
+	struct snd_dmaengine_dai_dma_data dma_prms_tx;
+	struct snd_aes_iec958 rx_iec958;
+	struct snd_aes_iec958 tx_iec958;
+	u8 cap_ds[FSL_XCVR_CAPDS_SIZE];
+};
+
+const struct attribute_group *fsl_xcvr_get_attr_grp(void);
+
 #endif /* __FSL_XCVR_H */
diff --git a/sound/soc/fsl/fsl_xcvr_sysfs.c b/sound/soc/fsl/fsl_xcvr_sysfs.c
new file mode 100644
index 000000000..2ff57263e
--- /dev/null
+++ b/sound/soc/fsl/fsl_xcvr_sysfs.c
@@ -0,0 +1,109 @@
+// SPDX-License-Identifier: GPL-2.0+
+// Copyright 2020 NXP
+
+#include <linux/clk.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/kdev_t.h>
+#include <linux/pm_runtime.h>
+
+#include "fsl_xcvr.h"
+
+static ssize_t read(struct device *dev, struct device_attribute *attr, char *buf, unsigned int reg)
+{
+	struct fsl_xcvr *xcvr = dev_get_drvdata(dev);
+	unsigned int val = 0;
+
+	regmap_read(xcvr->regmap, reg, &val);
+
+	return sprintf(buf, "%u\n", val);
+}
+
+#define XRDC_RO_ATTR(_name, _reg) \
+static ssize_t _name##_show(struct device *dev, struct device_attribute *attr, char *buf) \
+{	/* read bitcounter */ \
+	return read(dev, attr, buf, _reg); \
+} \
+static DEVICE_ATTR_RO(_name);
+
+XRDC_RO_ATTR(rx_bitcnt, FSL_XCVR_RX_DPTH_BCR)
+XRDC_RO_ATTR(tx_bitcnt, FSL_XCVR_TX_DPTH_BCR)
+XRDC_RO_ATTR(rx_timestamp, FSL_XCVR_RX_DPTH_TSCR)
+XRDC_RO_ATTR(tx_timestamp, FSL_XCVR_TX_DPTH_TSCR)
+XRDC_RO_ATTR(rx_bitcnt_latched_timestamp, FSL_XCVR_RX_DPTH_BCRR)
+XRDC_RO_ATTR(tx_bitcnt_latched_timestamp, FSL_XCVR_TX_DPTH_BCRR)
+
+/* ============ */
+static ssize_t show(struct device *dev, struct device_attribute *attr, char *buf, u32 reg, u32 bit)
+{
+	struct fsl_xcvr *xcvr = dev_get_drvdata(dev);
+	unsigned int val = 0;
+
+	regmap_read(xcvr->regmap, reg, &val);
+
+	return sprintf(buf, "%u\n", (val & BIT(bit)) ? 1 : 0);
+}
+
+static ssize_t store(struct device *dev, struct device_attribute *attr, const char *buf, size_t n,
+		     u32 reg, u32 bit)
+{
+	struct fsl_xcvr *xcvr = dev_get_drvdata(dev);
+	unsigned int val = 0;
+
+	if (kstrtouint(buf, 0, &val))
+		return -EINVAL;
+
+	regmap_update_bits(xcvr->regmap, reg, BIT(bit), val ? BIT(bit) : 0);
+
+	return n;
+}
+
+#define XRDC_RW_ATTR(_name, _reg, _bit) \
+static ssize_t _name##_show(struct device *dev, struct device_attribute *attr, char *buf) \
+{ \
+	return show(dev, attr, buf, _reg, _bit); \
+} \
+\
+static ssize_t _name##_store(struct device *dev, struct device_attribute *attr, const char *buf, \
+			     size_t n) \
+{ \
+	return store(dev, attr, buf, n, _reg, _bit); \
+} \
+static DEVICE_ATTR_RW(_name);
+
+XRDC_RW_ATTR(rx_bitcnt_reset, FSL_XCVR_RX_DPTH_CNTR_CTRL, 8)
+XRDC_RW_ATTR(tx_bitcnt_reset, FSL_XCVR_TX_DPTH_CNTR_CTRL, 8)
+XRDC_RW_ATTR(rx_timestamp_enable, FSL_XCVR_RX_DPTH_CNTR_CTRL, 0)
+XRDC_RW_ATTR(tx_timestamp_enable, FSL_XCVR_TX_DPTH_CNTR_CTRL, 0)
+XRDC_RW_ATTR(rx_timestamp_increment, FSL_XCVR_RX_DPTH_CNTR_CTRL, 1)
+XRDC_RW_ATTR(tx_timestamp_increment, FSL_XCVR_TX_DPTH_CNTR_CTRL, 1)
+XRDC_RW_ATTR(rx_timestamp_reset, FSL_XCVR_RX_DPTH_CNTR_CTRL, 9)
+XRDC_RW_ATTR(tx_timestamp_reset, FSL_XCVR_TX_DPTH_CNTR_CTRL, 9)
+
+static struct attribute *fsl_xcvr_attrs[] = {
+	&dev_attr_tx_bitcnt.attr,
+	&dev_attr_rx_bitcnt.attr,
+	&dev_attr_tx_timestamp.attr,
+	&dev_attr_rx_timestamp.attr,
+	&dev_attr_tx_bitcnt_latched_timestamp.attr,
+	&dev_attr_rx_bitcnt_latched_timestamp.attr,
+	&dev_attr_tx_timestamp_enable.attr,
+	&dev_attr_rx_timestamp_enable.attr,
+	&dev_attr_tx_timestamp_increment.attr,
+	&dev_attr_rx_timestamp_increment.attr,
+	&dev_attr_tx_bitcnt_reset.attr,
+	&dev_attr_rx_bitcnt_reset.attr,
+	&dev_attr_tx_timestamp_reset.attr,
+	&dev_attr_rx_timestamp_reset.attr,
+	NULL,
+};
+
+static struct attribute_group fsl_xcvr_attr_group = {
+	.name  = "counters",
+	.attrs = fsl_xcvr_attrs,
+};
+
+const struct attribute_group *fsl_xcvr_get_attr_grp()
+{
+	return &fsl_xcvr_attr_group;
+}
diff --git a/sound/soc/fsl/hdmi_pcm.S b/sound/soc/fsl/hdmi_pcm.S
new file mode 100644
index 000000000..d8d95fd8f
--- /dev/null
+++ b/sound/soc/fsl/hdmi_pcm.S
@@ -0,0 +1,246 @@
+/**
+ * Copyright (C) 2010-2014 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+.section .text
+
+.global hdmi_dma_copy_16_neon_lut
+.global hdmi_dma_copy_16_neon_fast
+.global hdmi_dma_copy_24_neon_lut
+.global hdmi_dma_copy_24_neon_fast
+
+
+/**
+ * hdmi_dma_copy_16_neon_lut
+ * Convert pcm sample to iec sample. Pcm sample is 16 bits.
+ * Frame index's between 0 and 47 inclusively. Channel count can be 1, 2, 4, 8.
+ * Frame count should be multipliable by 4, and Sample count by 8.
+ *
+ * C Prototype
+ *   void hdmi_dma_copy_16_neon_lut(unsigned short *src, unsigned int *dst,
+ *			int samples, unsigned char *lookup_table);
+ * Return value
+ *   None
+ * Parameters
+ *   src		Source PCM16 samples
+ *   dst		Dest buffer to store pcm with header
+ *   samples		Contains sample count (=frame_count * channel_count)
+ *   lookup_table	Preconstructed header table. Channels interleaved.
+ */
+
+hdmi_dma_copy_16_neon_lut:
+	mov     r12, #1		/* construct vector(1) */
+	vdup.8 d6, r12
+
+hdmi_dma_copy_16_neon_lut_start:
+
+	/* get 8 samples to q0 */
+	vld1.16 {d0, d1}, [r0]!	/* TODO: aligned */
+
+	/* pld [r1, #(64*4)] */
+
+	/* xor every bit */
+	vcnt.8     q1, q0	/* count of 1s */
+	vpadd.i8 d2, d2, d3	/* only care about the LST in every element */
+	vand       d2, d2, d6	/* clear other bits while keep the least bit */
+	vshl.u8    d2, d2, #3	/* bit p: d2 = d2 << 3 */
+
+	/* get packet header */
+	vld1.8       {d5}, [r3]!
+	veor        d4, d5, d2	/* xor bit c */
+
+	/* store: (d4 << 16 | q0) << 8 */
+	vmovl.u8  q2, d4	/* expand from char to short */
+	vzip.16     q0, q2
+	vshl.u32   q0, q0, #8
+	vshl.u32   q1, q2, #8
+	vst1.32     {d0, d1, d2, d3}, [r1]!
+
+	/* decrease sample count */
+	subs  r2, r2, #8
+	bne   hdmi_dma_copy_16_neon_lut_start
+
+	mov pc, lr
+
+/**
+ * hdmi_dma_copy_16_neon_fast
+ * Convert pcm sample to iec sample. Pcm sample is 16 bits.
+ * Frame index's between 48 and 191 inclusively.
+ * Channel count can be 1, 2, 4 or 8.
+ * Frame count should be multipliable by 4, and Sample count by 8.
+ *
+ * C Prototype
+ * void hdmi_dma_copy_16_neon_fast(unsigned short *src,
+ * 		unsigned int *dst, int samples);
+ * Return value
+ *   None
+ * Parameters
+ *   src		Source PCM16 samples
+ *   dst		Dest buffer to store pcm with header
+ *   samples		Contains sample count (=frame_count * channel_count)
+ */
+
+hdmi_dma_copy_16_neon_fast:
+	mov     r12, #1		/* construct vector(1) */
+	vdup.8 d6, r12
+
+hdmi_dma_copy_16_neon_fast_start:
+	/* get 8 samples to q0 */
+	vld1.16 {d0, d1}, [r0]!	/* TODO: aligned */
+
+	/* pld [r1, #(64*4)] */
+
+	/* xor every bit */
+	vcnt.8     q1, q0	/* count of 1s */
+	vpadd.i8 d2, d2, d3
+	vand       d2, d2, d6	/* clear other bits while keep the LST */
+	/* finally we construct packet header */
+	vshl.u8    d4, d2, #3	/* bit p: d2 = d2 << 3 */
+
+	/* get packet header: always 0 */
+
+	/* store: (d4 << 16 | q0) << 8 */
+	vmovl.u8  q2, d4	/* expand from char to short */
+	vzip.16     q0, q2
+	vshl.u32   q0, q0, #8
+	vshl.u32   q1, q2, #8
+	vst1.32     {d0, d1, d2, d3}, [r1]!
+
+	/* decrease sample count */
+	subs  r2, r2, #8
+	bne   hdmi_dma_copy_16_neon_fast_start
+
+	mov pc, lr
+
+
+
+/**
+ * hdmi_dma_copy_24_neon_lut
+ * Convert pcm sample to iec sample. Pcm sample is 24 bits.
+ * Frame index's between 0 and 47 inclusively. Channel count can be 1, 2, 4, 8.
+ * Frame count should be multipliable by 4, and Sample count by 8.
+ *
+ * C Prototype
+ *   void hdmi_dma_copy_24_neon_lut(unsigned int *src, unsigned int *dst,
+ *			int samples, unsigned char *lookup_table);
+ * Return value
+ *   None
+ * Parameters
+ *   src		Source PCM24 samples
+ *   dst		Dest buffer to store pcm with header
+ *   samples		Contains sample count (=frame_count * channel_count)
+ *   lookup_table	Preconstructed header table. Channels interleaved.
+ */
+
+hdmi_dma_copy_24_neon_lut:
+	vpush   {d8}
+
+	mov     r12, #1		/* construct vector(1) */
+	vdup.8 d8, r12
+
+hdmi_dma_copy_24_neon_lut_start:
+
+	/* get 8 samples to q0 and q1 */
+	vld1.32 {d0, d1, d2, d3}, [r0]! /* TODO: aligned */
+
+	/* pld [r1, #(64*4)] */
+
+	/* xor every bit */
+	vcnt.8     q2, q0	/* count of 1s */
+	vpadd.i8 d4, d4, d5	/* only care about the LSB in every element */
+	vcnt.8     q3, q1
+	vpadd.i8 d6, d6, d7
+	vpadd.i8 d4, d4, d6	/* d4: contains xor result and other dirty bits */
+	vand       d4, d4, d8	/* clear other bits while keep the least bit */
+	vshl.u8    d4, d4, #3	/* bit p: d4 = d4 << 3 */
+
+	/* get packet header */
+	vld1.8       {d5}, [r3]!/* d5: original header */
+	veor        d5, d5, d4	/* fix bit p */
+
+	/* store: (d5 << 24 | q0) */
+	vmovl.u8  q3, d5	/* expand from char to short */
+	vmovl.u16 q2, d6	/* expand from short to int */
+	vmovl.u16 q3, d7
+	vshl.u32    q2, q2, #24
+	vshl.u32    q3, q3, #24
+	vorr          q0, q0, q2
+	vorr          q1, q1, q3
+	vst1.32     {d0, d1, d2, d3}, [r1]!
+
+	/* decrease sample count */
+	subs  r2, r2, #8
+	bne   hdmi_dma_copy_24_neon_lut_start
+
+	vpop {d8}
+	mov pc, lr
+
+/**
+ * hdmi_dma_copy_24_neon_fast
+ * Convert pcm sample to iec sample. Pcm sample is 24 bits.
+ * Frame index's between 48 and 191 inclusively.
+ * Channel count can be 1, 2, 4 or 8.
+ * Frame count should be multipliable by 4, and Sample count by 8.
+ *
+ * C Prototype
+ * void hdmi_dma_copy_24_neon_fast(unsigned int *src,
+ * 		unsigned int *dst, int samples);
+ * Return value
+ *   None
+ * Parameters
+ *   src		Source PCM24 samples
+ *   dst		Dest buffer to store pcm with header
+ *   samples		Contains sample count (=frame_count * channel_count)
+ */
+
+hdmi_dma_copy_24_neon_fast:
+	vpush   {d8}
+
+	mov     r12, #1		/* construct vector(1) */
+	vdup.8 d8, r12
+
+hdmi_dma_copy_24_neon_fast_start:
+	/* get 8 samples to q0 and q1 */
+	vld1.32 {d0, d1, d2, d3}, [r0]! /* TODO: aligned */
+
+	/* pld [r1, #(64*4)] */
+
+	/* xor every bit */
+	vcnt.8     q2, q0	/* count of 1s */
+	vpadd.i8 d4, d4, d5	/* only care about the LSB in every element */
+	vcnt.8     q3, q1
+	vpadd.i8 d6, d6, d7
+	vpadd.i8 d4, d4, d6	/* d4: contains xor result and other dirty bits */
+	vand       d4, d4, d8	/* clear other bits while keep the least bit */
+	vshl.u8    d4, d4, #3	/* bit p: d4 = d4 << 3 */
+
+	/* store: (d4 << 24 | q0)  */
+	vmovl.u8  q3, d4	/* expand from char to short */
+	vmovl.u16 q2, d6	/* expand from short to int */
+	vmovl.u16 q3, d7
+	vshl.u32    q2, q2, #24
+	vshl.u32    q3, q3, #24
+	vorr          q0, q0, q2
+	vorr          q1, q1, q3
+	vst1.32     {d0, d1, d2, d3}, [r1]!
+
+	/* decrease sample count */
+	subs  r2, r2, #8
+	bne   hdmi_dma_copy_24_neon_fast_start
+
+	vpop {d8}
+	mov pc, lr
diff --git a/sound/soc/fsl/imx-audio-rpmsg.c b/sound/soc/fsl/imx-audio-rpmsg.c
index 905c3a071..fdb502f3e 100644
--- a/sound/soc/fsl/imx-audio-rpmsg.c
+++ b/sound/soc/fsl/imx-audio-rpmsg.c
@@ -74,6 +74,10 @@ static int imx_audio_rpmsg_cb(struct rpmsg_device *rpdev, void *data, int len,
 static int imx_audio_rpmsg_probe(struct rpmsg_device *rpdev)
 {
 	struct imx_audio_rpmsg *data;
+	struct platform_device *codec_pdev;
+	struct rpmsg_codec codec;
+	const char *model_string;
+	struct device_node *np;
 	int ret = 0;
 
 	dev_info(&rpdev->dev, "new channel: 0x%x -> 0x%x!\n",
@@ -88,13 +92,46 @@ static int imx_audio_rpmsg_probe(struct rpmsg_device *rpdev)
 	/* Register platform driver for rpmsg routine */
 	data->rpmsg_pdev = platform_device_register_data(&rpdev->dev,
 							 IMX_PCM_DRV_NAME,
-							 PLATFORM_DEVID_NONE,
+							 PLATFORM_DEVID_AUTO,
 							 NULL, 0);
 	if (IS_ERR(data->rpmsg_pdev)) {
 		dev_err(&rpdev->dev, "failed to register rpmsg platform.\n");
 		ret = PTR_ERR(data->rpmsg_pdev);
 	}
 
+	if (!strcmp(rpdev->id.name, "rpmsg-micfil-channel"))
+		return ret;
+	np = of_find_node_by_name(NULL, "rpmsg_audio");
+	of_property_read_string(np, "model", &model_string);
+	if (np && of_device_is_compatible(np, "fsl,imx7ulp-rpmsg-audio")) {
+		codec.audioindex = 0;
+		codec.shared_lrclk = true;
+		codec.capless = false;
+		codec_pdev = platform_device_register_data(&data->rpmsg_pdev->dev,
+							   RPMSG_CODEC_DRV_NAME_WM8960,
+							   PLATFORM_DEVID_NONE,
+							   &codec,
+							   sizeof(struct rpmsg_codec));
+		if (IS_ERR(codec_pdev)) {
+			dev_err(&rpdev->dev, "failed to register rpmsg codec\n");
+			ret = PTR_ERR(codec_pdev);
+			goto fail;
+		}
+	} else if (np && of_device_is_compatible(np, "fsl,imx8mm-rpmsg-audio") &&
+			!strcmp("ak4497-audio", model_string)) {
+		codec.audioindex = 0;
+		codec_pdev = platform_device_register_data(&data->rpmsg_pdev->dev,
+							   RPMSG_CODEC_DRV_NAME_AK4497,
+							   PLATFORM_DEVID_NONE,
+							   &codec,
+							   sizeof(struct rpmsg_codec));
+		if (IS_ERR(codec_pdev)) {
+			dev_err(&rpdev->dev, "failed to register rpmsg codec\n");
+			ret = PTR_ERR(codec_pdev);
+			goto fail;
+		}
+	}
+fail:
 	return ret;
 }
 
@@ -110,6 +147,7 @@ static void imx_audio_rpmsg_remove(struct rpmsg_device *rpdev)
 
 static struct rpmsg_device_id imx_audio_rpmsg_id_table[] = {
 	{ .name	= "rpmsg-audio-channel" },
+	{ .name = "rpmsg-micfil-channel" },
 	{ },
 };
 
diff --git a/sound/soc/fsl/imx-card.c b/sound/soc/fsl/imx-card.c
index 55bc1bb0d..be9c2c911 100644
--- a/sound/soc/fsl/imx-card.c
+++ b/sound/soc/fsl/imx-card.c
@@ -354,7 +354,7 @@ static int imx_aif_hw_params(struct snd_pcm_substream *substream,
 	else
 		mclk_freq = params_rate(params) * slots * slot_width;
 	/* Use the maximum freq from DSD512 (512*44100 = 22579200) */
-	if (format_is_dsd(params))
+	if (format_is_dsd(params) && (params_rate(params) % 44100 == 0))
 		mclk_freq = 22579200;
 
 	ret = snd_soc_dai_set_sysclk(cpu_dai, link_data->cpu_sysclk_id, mclk_freq,
@@ -579,8 +579,9 @@ static int imx_card_parse_of(struct imx_card_data *data)
 
 		ret = snd_soc_of_get_dai_name(cpu, &link->cpus->dai_name);
 		if (ret) {
-			dev_err_probe(card->dev, ret,
-				      "%s: error getting cpu dai name\n", link->name);
+			if (ret != -EPROBE_DEFER)
+				dev_err(card->dev, "%s: error getting cpu dai name: %d\n",
+					link->name, ret);
 			goto err;
 		}
 
@@ -588,8 +589,9 @@ static int imx_card_parse_of(struct imx_card_data *data)
 		if (codec) {
 			ret = snd_soc_of_get_dai_link_codecs(dev, codec, link);
 			if (ret < 0) {
-				dev_err_probe(dev, ret, "%s: codec dai not found\n",
-						link->name);
+				if (ret != -EPROBE_DEFER)
+					dev_err(dev, "%s: codec dai not found: %d\n",
+						link->name, ret);
 				goto err;
 			}
 
@@ -828,8 +830,11 @@ static int imx_card_probe(struct platform_device *pdev)
 	}
 
 	ret = devm_snd_soc_register_card(&pdev->dev, &data->card);
-	if (ret)
-		return dev_err_probe(&pdev->dev, ret, "snd_soc_register_card failed\n");
+	if (ret) {
+		if (ret != -EPROBE_DEFER)
+			dev_err(&pdev->dev, "snd_soc_register_card failed (%d)\n", ret);
+		return ret;
+	}
 
 	return 0;
 }
diff --git a/sound/soc/fsl/imx-es8328.c b/sound/soc/fsl/imx-es8328.c
index a7fb53e0f..1981dcd7e 100644
--- a/sound/soc/fsl/imx-es8328.c
+++ b/sound/soc/fsl/imx-es8328.c
@@ -87,7 +87,6 @@ static int imx_es8328_probe(struct platform_device *pdev)
 	if (int_port > MUX_PORT_MAX || int_port == 0) {
 		dev_err(dev, "mux-int-port: hardware only has %d mux ports\n",
 			MUX_PORT_MAX);
-		ret = -EINVAL;
 		goto fail;
 	}
 
diff --git a/sound/soc/fsl/imx-hdmi-dma.c b/sound/soc/fsl/imx-hdmi-dma.c
new file mode 100644
index 000000000..8ff3fabf3
--- /dev/null
+++ b/sound/soc/fsl/imx-hdmi-dma.c
@@ -0,0 +1,1174 @@
+/*
+ * imx-hdmi-dma.c  --  HDMI DMA driver for ALSA Soc Audio Layer
+ *
+ * Copyright (C) 2011-2016 Freescale Semiconductor, Inc.
+ *
+ * based on imx-pcm-dma-mx2.c
+ * Copyright 2009 Sascha Hauer <s.hauer@pengutronix.de>
+ *
+ * This code is based on code copyrighted by Freescale,
+ * Liam Girdwood, Javier Martin and probably others.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/mfd/mxc-hdmi-core.h>
+#include <linux/platform_data/dma-imx.h>
+
+#include <video/mxc_hdmi.h>
+
+#include "imx-hdmi.h"
+
+#define DRV_NAME "imx_hdmi_dma"
+
+#define HDMI_DMA_BURST_UNSPECIFIED_LEGNTH	0
+#define HDMI_DMA_BURST_INCR4			1
+#define HDMI_DMA_BURST_INCR8			2
+#define HDMI_DMA_BURST_INCR16			3
+
+#define HDMI_BASE_ADDR 0x00120000
+
+struct hdmi_sdma_script {
+	int control_reg_addr;
+	int status_reg_addr;
+	int dma_start_addr;
+	u32 buffer[20];
+};
+
+struct hdmi_dma_priv {
+	struct snd_pcm_substream *substream;
+	struct platform_device *pdev;
+
+	struct snd_dma_buffer hw_buffer;
+	unsigned long buffer_bytes;
+	unsigned long appl_bytes;
+
+	int periods;
+	int period_time;
+	int period_bytes;
+	int dma_period_bytes;
+	int buffer_ratio;
+
+	unsigned long offset;
+
+	snd_pcm_format_t format;
+	int sample_align;
+	int sample_bits;
+	int channels;
+	int rate;
+
+	int frame_idx;
+
+	bool tx_active;
+	spinlock_t irq_lock;
+
+	/* SDMA part */
+	dma_addr_t phy_hdmi_sdma_t;
+	struct hdmi_sdma_script *hdmi_sdma_t;
+	struct dma_chan *dma_channel;
+	struct dma_async_tx_descriptor *desc;
+	struct imx_hdmi_sdma_params sdma_params;
+};
+
+/* bit 0:0:0:b:p(0):c:(u)0:(v)0 */
+/* max 8 channels supported; channels are interleaved */
+static u8 g_packet_head_table[48 * 8];
+
+void hdmi_dma_copy_16_neon_lut(unsigned short *src, unsigned int *dst,
+		int samples, unsigned char *lookup_table);
+void hdmi_dma_copy_16_neon_fast(unsigned short *src, unsigned int *dst,
+		int samples);
+void hdmi_dma_copy_24_neon_lut(unsigned int *src, unsigned int *dst,
+		int samples, unsigned char *lookup_table);
+void hdmi_dma_copy_24_neon_fast(unsigned int *src, unsigned int *dst,
+		int samples);
+static void hdmi_dma_irq_enable(struct hdmi_dma_priv *priv);
+static void hdmi_dma_irq_disable(struct hdmi_dma_priv *priv);
+
+union hdmi_audio_header_t iec_header;
+EXPORT_SYMBOL(iec_header);
+
+/*
+ * Note that the period size for DMA != period size for ALSA because the
+ * driver adds iec frame info to the audio samples (in hdmi_dma_copy).
+ *
+ * Each 4 byte subframe = 1 byte of iec data + 3 byte audio sample.
+ *
+ * A 16 bit audio sample becomes 32 bits including the frame info. Ratio=2
+ * A 24 bit audio sample becomes 32 bits including the frame info. Ratio=3:4
+ * If the 24 bit raw audio is in 32 bit words, the
+ *
+ *  Original  Packed into  subframe  Ratio of size        Format
+ *   sample    how many      size    of DMA buffer
+ *   (bits)      bits                to ALSA buffer
+ *  --------  -----------  --------  --------------  ------------------------
+ *     16         16          32          2          SNDRV_PCM_FORMAT_S16_LE
+ *     24         24          32          1.33       SNDRV_PCM_FORMAT_S24_3LE*
+ *     24         32          32          1          SNDRV_PCM_FORMAT_S24_LE
+ *
+ * *so SNDRV_PCM_FORMAT_S24_3LE is not supported.
+ */
+
+/*
+ * The minimum dma period is one IEC audio frame (192 * 4 * channels).
+ * The maximum dma period for the HDMI DMA is 8K.
+ *
+ *   channels       minimum          maximum
+ *                 dma period       dma period
+ *   --------  ------------------   ----------
+ *       2     192 * 4 * 2 = 1536   * 4 = 6144
+ *       4     192 * 4 * 4 = 3072   * 2 = 6144
+ *       6     192 * 4 * 6 = 4608   * 1 = 4608
+ *       8     192 * 4 * 8 = 6144   * 1 = 6144
+ *
+ * Bottom line:
+ * 1. Must keep the ratio of DMA buffer to ALSA buffer consistent.
+ * 2. frame_idx is saved in the private data, so even if a frame cannot be
+ *    transmitted in a period, it can be continued in the next period.  This
+ *    is necessary for 6 ch.
+ */
+#define HDMI_DMA_PERIOD_BYTES		(12288)
+#define HDMI_DMA_BUF_SIZE		(128 * 1024)
+#define HDMI_PCM_BUF_SIZE		(128 * 1024)
+
+#define hdmi_audio_debug(dev, reg) \
+	dev_dbg(dev, #reg ": 0x%02x\n", hdmi_readb(reg))
+
+#ifdef DEBUG
+static void dumpregs(struct device *dev)
+{
+	hdmi_audio_debug(dev, HDMI_AHB_DMA_CONF0);
+	hdmi_audio_debug(dev, HDMI_AHB_DMA_START);
+	hdmi_audio_debug(dev, HDMI_AHB_DMA_STOP);
+	hdmi_audio_debug(dev, HDMI_AHB_DMA_THRSLD);
+	hdmi_audio_debug(dev, HDMI_AHB_DMA_STRADDR0);
+	hdmi_audio_debug(dev, HDMI_AHB_DMA_STPADDR0);
+	hdmi_audio_debug(dev, HDMI_AHB_DMA_BSTADDR0);
+	hdmi_audio_debug(dev, HDMI_AHB_DMA_MBLENGTH0);
+	hdmi_audio_debug(dev, HDMI_AHB_DMA_MBLENGTH1);
+	hdmi_audio_debug(dev, HDMI_AHB_DMA_STAT);
+	hdmi_audio_debug(dev, HDMI_AHB_DMA_INT);
+	hdmi_audio_debug(dev, HDMI_AHB_DMA_MASK);
+	hdmi_audio_debug(dev, HDMI_AHB_DMA_POL);
+	hdmi_audio_debug(dev, HDMI_AHB_DMA_CONF1);
+	hdmi_audio_debug(dev, HDMI_AHB_DMA_BUFFSTAT);
+	hdmi_audio_debug(dev, HDMI_AHB_DMA_BUFFINT);
+	hdmi_audio_debug(dev, HDMI_AHB_DMA_BUFFMASK);
+	hdmi_audio_debug(dev, HDMI_AHB_DMA_BUFFPOL);
+	hdmi_audio_debug(dev, HDMI_IH_MUTE_AHBDMAAUD_STAT0);
+	hdmi_audio_debug(dev, HDMI_IH_AHBDMAAUD_STAT0);
+	hdmi_audio_debug(dev, HDMI_IH_MUTE);
+}
+
+static void dumppriv(struct device *dev, struct hdmi_dma_priv *priv)
+{
+	dev_dbg(dev, "channels         = %d\n", priv->channels);
+	dev_dbg(dev, "periods          = %d\n", priv->periods);
+	dev_dbg(dev, "period_bytes     = %d\n", priv->period_bytes);
+	dev_dbg(dev, "dma period_bytes = %d\n", priv->dma_period_bytes);
+	dev_dbg(dev, "buffer_ratio     = %d\n", priv->buffer_ratio);
+	dev_dbg(dev, "hw dma buffer    = 0x%08x\n", (int)priv->hw_buffer.addr);
+	dev_dbg(dev, "dma buf size     = %d\n", (int)priv->buffer_bytes);
+	dev_dbg(dev, "sample_rate      = %d\n", (int)priv->rate);
+}
+#else
+static void dumpregs(struct device *dev) {}
+static void dumppriv(struct device *dev, struct hdmi_dma_priv *priv) {}
+#endif
+
+/*
+ * Conditions for DMA to work:
+ * ((final_addr - initial_addr)>>2)+1) < 2k.  So max period is 8k.
+ * (inital_addr & 0x3) == 0
+ * (final_addr  & 0x3) == 0x3
+ *
+ * The DMA Period should be an integer multiple of the IEC 60958 audio
+ * frame size, which is 768 bytes (192 * 4).
+ */
+static void hdmi_dma_set_addr(int start_addr, int dma_period_bytes)
+{
+	int final_addr = start_addr + dma_period_bytes - 1;
+
+	hdmi_write4(start_addr, HDMI_AHB_DMA_STRADDR0);
+	hdmi_write4(final_addr, HDMI_AHB_DMA_STPADDR0);
+}
+
+static void hdmi_dma_irq_set(bool set)
+{
+	u8 val = hdmi_readb(HDMI_AHB_DMA_MASK);
+
+	if (set)
+		val |= HDMI_AHB_DMA_DONE;
+	else
+		val &= (u8)~HDMI_AHB_DMA_DONE;
+
+	hdmi_writeb(val, HDMI_AHB_DMA_MASK);
+}
+
+static void hdmi_mask(int mask)
+{
+	u8 regval = hdmi_readb(HDMI_AHB_DMA_MASK);
+
+	if (mask)
+		regval |= HDMI_AHB_DMA_ERROR | HDMI_AHB_DMA_FIFO_EMPTY;
+	else
+		regval &= (u8)~(HDMI_AHB_DMA_ERROR | HDMI_AHB_DMA_FIFO_EMPTY);
+
+	hdmi_writeb(regval, HDMI_AHB_DMA_MASK);
+}
+
+int odd_ones(unsigned a)
+{
+	a ^= a >> 8;
+	a ^= a >> 4;
+	a ^= a >> 2;
+	a ^= a >> 1;
+
+	return a & 1;
+}
+
+/* Add frame information for one pcm subframe */
+static u32 hdmi_dma_add_frame_info(struct hdmi_dma_priv *priv,
+				   u32 pcm_data, int subframe_idx)
+{
+	union hdmi_audio_dma_data_t subframe;
+
+	subframe.U = 0;
+	iec_header.B.channel = subframe_idx;
+
+	/* fill b (start-of-block) */
+	subframe.B.b = (priv->frame_idx == 0) ? 1 : 0;
+
+	/* fill c (channel status) */
+	if (priv->frame_idx < 42)
+		subframe.B.c = (iec_header.U >> priv->frame_idx) & 0x1;
+	else
+		subframe.B.c = 0;
+
+	subframe.B.p = odd_ones(pcm_data);
+	subframe.B.p ^= subframe.B.c;
+	subframe.B.p ^= subframe.B.u;
+	subframe.B.p ^= subframe.B.v;
+
+	/* fill data */
+	if (priv->sample_bits == 16)
+		subframe.B.data = pcm_data << 8;
+	else
+		subframe.B.data = pcm_data;
+
+	return subframe.U;
+}
+
+static void init_table(int channels)
+{
+	unsigned char *p = g_packet_head_table;
+	int i, ch = 0;
+
+	for (i = 0; i < 48; i++) {
+		int b = 0;
+		if (i == 0)
+			b = 1;
+
+		for (ch = 0; ch < channels; ch++) {
+			int c = 0;
+			if (i < 42) {
+				iec_header.B.channel = ch+1;
+				c = (iec_header.U >> i) & 0x1;
+			}
+			/* preset bit p as c */
+			*p++ = (b << 4) | (c << 2) | (c << 3);
+		}
+	}
+}
+
+/*
+ * FIXME: Disable NEON Optimization in hdmi, or it will cause crash of
+ * pulseaudio in the userspace. There is no issue for the Optimization
+ * implemenation, if only use "VPUSH, VPOP" in the function, the pulseaudio
+ * will crash also. So for my assumption, we can't use the NEON in the
+ * interrupt.(tasklet is implemented by softirq.)
+ * Disable SMP, preempt, change the dma buffer to nocached, add protection of
+ * Dn register and fpscr, all these operation have no effect to the result.
+ */
+#define HDMI_DMA_NO_NEON
+
+#ifdef HDMI_DMA_NO_NEON
+/* Optimization for IEC head */
+static void hdmi_dma_copy_16_c_lut(u16 *src, u32 *dst, int samples,
+				u8 *lookup_table)
+{
+	u32 sample, head, p;
+	int i;
+
+	for (i = 0; i < samples; i++) {
+		/* get source sample */
+		sample = *src++;
+
+		/* xor every bit */
+		p = sample ^ (sample >> 8);
+		p ^= (p >> 4);
+		p ^= (p >> 2);
+		p ^= (p >> 1);
+		p &= 1;	/* only want last bit */
+		p <<= 3; /* bit p */
+
+		/* get packet header */
+		head = *lookup_table++;
+
+		/* fix head */
+		head ^= p;
+
+		/* store */
+		*dst++ = (head << 24) | (sample << 8);
+	}
+}
+
+static void hdmi_dma_copy_16_c_fast(u16 *src, u32 *dst, int samples)
+{
+	u32 sample, p;
+	int i;
+
+	for (i = 0; i < samples; i++) {
+		/* get source sample */
+		sample = *src++;
+
+		/* xor every bit */
+		p = sample ^ (sample >> 8);
+		p ^= (p >> 4);
+		p ^= (p >> 2);
+		p ^= (p >> 1);
+		p &= 1;	/* only want last bit */
+		p <<= 3; /* bit p */
+
+		/* store */
+		*dst++ = (p << 24) | (sample << 8);
+	}
+}
+
+static void hdmi_dma_copy_16(u16 *src, u32 *dst, int framecnt, int channelcnt)
+{
+	/* split input frames into 192-frame each */
+	int count_in_192 = (framecnt + 191) / 192;
+	int i;
+
+	for (i = 0; i < count_in_192; i++) {
+		int count, samples;
+
+		/* handles frame index [0, 48) */
+		count = (framecnt < 48) ? framecnt : 48;
+		samples = count * channelcnt;
+		hdmi_dma_copy_16_c_lut(src, dst, samples, g_packet_head_table);
+		framecnt -= count;
+		if (framecnt == 0)
+			break;
+
+		src  += samples;
+		dst += samples;
+
+		/* handles frame index [48, 192) */
+		count = (framecnt < 192 - 48) ? framecnt : 192 - 48;
+		samples = count * channelcnt;
+		hdmi_dma_copy_16_c_fast(src, dst, samples);
+		framecnt -= count;
+		src  += samples;
+		dst += samples;
+	}
+}
+#else
+/* NEON optimization for IEC head*/
+
+/**
+ * Convert pcm samples to iec samples suitable for HDMI transfer.
+ * PCM sample is 16 bits length.
+ * Frame index always starts from 0.
+ * Channel count can be 1, 2, 4, 6, or 8
+ * Sample count (frame_count * channel_count) is multipliable by 8.
+ */
+static void hdmi_dma_copy_16(u16 *src, u32 *dst, int framecount, int channelcount)
+{
+	/* split input frames into 192-frame each */
+	int i, count_in_192 = (framecount + 191) / 192;
+
+	for (i = 0; i < count_in_192; i++) {
+		int count, samples;
+
+		/* handles frame index [0, 48) */
+		count = (framecount < 48) ? framecount : 48;
+		samples = count * channelcount;
+		hdmi_dma_copy_16_neon_lut(src, dst, samples, g_packet_head_table);
+		framecount -= count;
+		if (framecount == 0)
+			break;
+
+		src += samples;
+		dst += samples;
+
+		/* handles frame index [48, 192) */
+		count = (framecount < 192 - 48) ? framecount : (192 - 48);
+		samples = count * channelcount;
+		hdmi_dma_copy_16_neon_fast(src, dst, samples);
+		framecount -= count;
+		src += samples;
+		dst += samples;
+	}
+}
+#endif
+
+static void hdmi_dma_mmap_copy(struct snd_pcm_substream *substream,
+				int offset, int count)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_component *component =
+				snd_soc_rtdcom_lookup(rtd, DRV_NAME);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct hdmi_dma_priv *priv = runtime->private_data;
+	struct device *dev = component->dev;
+	u32 framecount, *dst;
+	u16 *src16;
+
+	framecount = count / (priv->sample_align * priv->channels);
+
+	/* hw_buffer is the destination for pcm data plus frame info. */
+	dst = (u32 *)(priv->hw_buffer.area + (offset * priv->buffer_ratio));
+
+	switch (priv->format) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		/* dma_buffer is the mmapped buffer we are copying pcm from. */
+		src16 = (u16 *)(runtime->dma_area + offset);
+		hdmi_dma_copy_16(src16, dst, framecount, priv->channels);
+		break;
+	default:
+		dev_err(dev, "unsupported sample format %s\n",
+				snd_pcm_format_name(priv->format));
+		return;
+	}
+}
+
+static void hdmi_dma_data_copy(struct snd_pcm_substream *substream,
+				struct hdmi_dma_priv *priv, char type)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	unsigned long offset, count, appl_bytes, space_to_end;
+
+	if (runtime->access != SNDRV_PCM_ACCESS_MMAP_INTERLEAVED)
+		return;
+
+	appl_bytes =  (runtime->status->hw_ptr % (priv->buffer_bytes/(runtime->frame_bits/8))) * (runtime->frame_bits/8);
+	if (type == 'p')
+		appl_bytes += 2 * priv->period_bytes;
+	offset = appl_bytes % priv->buffer_bytes;
+
+	switch (type) {
+	case 'p':
+		count = priv->period_bytes;
+		space_to_end = priv->period_bytes;
+		break;
+	case 'b':
+		count = priv->buffer_bytes;
+		space_to_end = priv->buffer_bytes - offset;
+
+		break;
+	default:
+		return;
+	}
+
+	if (count <= space_to_end) {
+		hdmi_dma_mmap_copy(substream, offset, count);
+	} else {
+		hdmi_dma_mmap_copy(substream, offset, space_to_end);
+		hdmi_dma_mmap_copy(substream, 0, count - space_to_end);
+	}
+}
+
+static void hdmi_sdma_callback(void *data)
+{
+	struct hdmi_dma_priv *priv = (struct hdmi_dma_priv *)data;
+	struct snd_pcm_substream *substream = priv->substream;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->irq_lock, flags);
+
+	if (runtime && runtime->dma_area && priv->tx_active) {
+		priv->offset += priv->period_bytes;
+		priv->offset %= priv->period_bytes * priv->periods;
+
+		/* Copy data by period_bytes */
+		hdmi_dma_data_copy(substream, priv, 'p');
+
+		snd_pcm_period_elapsed(substream);
+	}
+
+	spin_unlock_irqrestore(&priv->irq_lock, flags);
+
+	return;
+}
+
+static int hdmi_dma_set_thrsld_incrtype(struct device *dev, int channels)
+{
+	u8 mask = HDMI_AHB_DMA_CONF0_BURST_MODE | HDMI_AHB_DMA_CONF0_INCR_TYPE_MASK;
+	u8 val = hdmi_readb(HDMI_AHB_DMA_CONF0) & ~mask;
+	int incr_type, threshold;
+
+	switch (hdmi_readb(HDMI_REVISION_ID)) {
+	case 0x0a:
+		incr_type = HDMI_DMA_BURST_INCR4;
+		if (channels == 2)
+			threshold = 126;
+		else
+			threshold = 124;
+		break;
+	case 0x1a:
+		incr_type = HDMI_DMA_BURST_INCR8;
+		threshold = 128;
+		break;
+	default:
+		dev_err(dev, "unknown hdmi controller!\n");
+		return -ENODEV;
+	}
+
+	hdmi_writeb(threshold, HDMI_AHB_DMA_THRSLD);
+
+	switch (incr_type) {
+	case HDMI_DMA_BURST_UNSPECIFIED_LEGNTH:
+		break;
+	case HDMI_DMA_BURST_INCR4:
+		val |= HDMI_AHB_DMA_CONF0_BURST_MODE;
+		break;
+	case HDMI_DMA_BURST_INCR8:
+		val |= HDMI_AHB_DMA_CONF0_BURST_MODE |
+			 HDMI_AHB_DMA_CONF0_INCR8;
+		break;
+	case HDMI_DMA_BURST_INCR16:
+		val |= HDMI_AHB_DMA_CONF0_BURST_MODE |
+			 HDMI_AHB_DMA_CONF0_INCR16;
+		break;
+	default:
+		dev_err(dev, "invalid increment type: %d!", incr_type);
+		return -EINVAL;
+	}
+
+	hdmi_writeb(val, HDMI_AHB_DMA_CONF0);
+
+	hdmi_audio_debug(dev, HDMI_AHB_DMA_THRSLD);
+
+	return 0;
+}
+
+static int hdmi_dma_configure_dma(struct device *dev, int channels)
+{
+	u8 i, val = 0;
+	int ret;
+
+	if (channels <= 0 || channels > 8 || channels % 2 != 0) {
+		dev_err(dev, "unsupported channel number: %d\n", channels);
+		return -EINVAL;
+	}
+
+	hdmi_audio_writeb(AHB_DMA_CONF0, EN_HLOCK, 0x1);
+
+	ret = hdmi_dma_set_thrsld_incrtype(dev, channels);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < channels; i += 2)
+		val |= 0x3 << i;
+
+	hdmi_writeb(val, HDMI_AHB_DMA_CONF1);
+
+	return 0;
+}
+
+static void hdmi_dma_init_iec_header(void)
+{
+	iec_header.U = 0;
+
+	iec_header.B.consumer = 0;		/* Consumer use */
+	iec_header.B.linear_pcm = 0;		/* linear pcm audio */
+	iec_header.B.copyright = 1;		/* no copyright */
+	iec_header.B.pre_emphasis = 0;		/* 2 channels without pre-emphasis */
+	iec_header.B.mode = 0;			/* Mode 0 */
+
+	iec_header.B.category_code = 0;
+
+	iec_header.B.source = 2;		/* stereo */
+	iec_header.B.channel = 0;
+
+	iec_header.B.sample_freq = 0x02;	/* 48 KHz */
+	iec_header.B.clock_acc = 0;		/* Level II */
+
+	iec_header.B.word_length = 0x02;	/* 16 bits */
+	iec_header.B.org_sample_freq = 0x0D;	/* 48 KHz */
+
+	iec_header.B.cgms_a = 0;		/* Copying is permitted without restriction */
+}
+
+static int hdmi_dma_update_iec_header(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_component *component =
+				snd_soc_rtdcom_lookup(rtd, DRV_NAME);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct hdmi_dma_priv *priv = runtime->private_data;
+	struct device *dev = component->dev;
+
+	iec_header.B.source = priv->channels;
+
+	switch (priv->rate) {
+	case 32000:
+		iec_header.B.sample_freq = 0x03;
+		iec_header.B.org_sample_freq = 0x0C;
+		break;
+	case 44100:
+		iec_header.B.sample_freq = 0x00;
+		iec_header.B.org_sample_freq = 0x0F;
+		break;
+	case 48000:
+		iec_header.B.sample_freq = 0x02;
+		iec_header.B.org_sample_freq = 0x0D;
+		break;
+	case 88200:
+		iec_header.B.sample_freq = 0x08;
+		iec_header.B.org_sample_freq = 0x07;
+		break;
+	case 96000:
+		iec_header.B.sample_freq = 0x0A;
+		iec_header.B.org_sample_freq = 0x05;
+		break;
+	case 176400:
+		iec_header.B.sample_freq = 0x0C;
+		iec_header.B.org_sample_freq = 0x03;
+		break;
+	case 192000:
+		iec_header.B.sample_freq = 0x0E;
+		iec_header.B.org_sample_freq = 0x01;
+		break;
+	default:
+		dev_err(dev, "unsupported sample rate\n");
+		return -EFAULT;
+	}
+
+	switch (priv->format) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		iec_header.B.word_length = 0x02;
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		iec_header.B.word_length = 0x0b;
+		break;
+	default:
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+/*
+ * The HDMI block transmits the audio data without adding any of the audio
+ * frame bits.  So we have to copy the raw dma data from the ALSA buffer
+ * to the DMA buffer, adding the frame information.
+ */
+static int hdmi_dma_copy_user(struct snd_soc_component *component, struct snd_pcm_substream *substream, int channel,
+			unsigned long pos_bytes, void __user *buf,
+			unsigned long count)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct hdmi_dma_priv *priv = runtime->private_data;
+	u32 *hw_buf;
+	int subframe_idx;
+	u32 pcm_data;
+
+	/* Adding frame info to pcm data from userspace and copy to hw_buffer */
+	hw_buf = (u32 *)(priv->hw_buffer.area + (pos_bytes * priv->buffer_ratio));
+
+	while (count > 0) {
+		for (subframe_idx = 1 ; subframe_idx <= priv->channels ; subframe_idx++) {
+			if (copy_from_user(&pcm_data, buf, priv->sample_align))
+				return -EFAULT;
+
+			buf += priv->sample_align;
+			count -= priv->sample_align;
+
+			/* Save the header info to the audio dma buffer */
+			*hw_buf++ = hdmi_dma_add_frame_info(priv, pcm_data, subframe_idx);
+		}
+
+		priv->frame_idx++;
+		if (priv->frame_idx == 192)
+			priv->frame_idx = 0;
+	}
+
+	return 0;
+}
+
+static int hdmi_sdma_initbuf(struct device *dev, struct hdmi_dma_priv *priv)
+{
+	struct hdmi_sdma_script *hdmi_sdma_t = priv->hdmi_sdma_t;
+	u32 *head, *tail, i;
+
+	if (!hdmi_sdma_t) {
+		dev_err(dev, "hdmi private addr invalid!!!\n");
+		return -EINVAL;
+	}
+
+	hdmi_sdma_t->control_reg_addr = HDMI_BASE_ADDR + HDMI_AHB_DMA_START;
+	hdmi_sdma_t->status_reg_addr = HDMI_BASE_ADDR + HDMI_IH_AHBDMAAUD_STAT0;
+	hdmi_sdma_t->dma_start_addr = HDMI_BASE_ADDR + HDMI_AHB_DMA_STRADDR0;
+
+	head = &hdmi_sdma_t->buffer[0];
+	tail = &hdmi_sdma_t->buffer[1];
+
+	for (i = 0; i < priv->sdma_params.buffer_num; i++) {
+		*head = priv->hw_buffer.addr + i * priv->period_bytes * priv->buffer_ratio;
+		*tail = *head + priv->dma_period_bytes - 1;
+		head += 2;
+		tail += 2;
+	}
+
+	return 0;
+}
+
+static int hdmi_sdma_config(struct snd_pcm_substream *substream,
+			struct hdmi_dma_priv *priv)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_component *component =
+				snd_soc_rtdcom_lookup(rtd, DRV_NAME);
+	struct device *dai_dev = &priv->pdev->dev;
+	struct device *dev = component->dev;
+	struct dma_slave_config slave_config = { 0 };
+	int ret;
+
+	priv->dma_channel = dma_request_slave_channel(dai_dev, "tx");
+	if (priv->dma_channel == NULL) {
+		dev_err(dev, "failed to alloc dma channel\n");
+		return -EBUSY;
+	}
+
+	slave_config.direction = DMA_TRANS_NONE;
+	slave_config.src_addr = (dma_addr_t)priv->sdma_params.buffer_num;
+	slave_config.dst_addr = (dma_addr_t)priv->sdma_params.phyaddr;
+
+	ret = dmaengine_slave_config(priv->dma_channel, &slave_config);
+	if (ret) {
+		dev_err(dev, "failed to config slave dma\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int hdmi_dma_hw_free(struct snd_soc_component *component, struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct hdmi_dma_priv *priv = runtime->private_data;
+
+	if (priv->dma_channel) {
+		dma_release_channel(priv->dma_channel);
+		priv->dma_channel = NULL;
+	}
+
+	return 0;
+}
+
+static int hdmi_dma_hw_params(struct snd_soc_component *component, struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct hdmi_dma_priv *priv = runtime->private_data;
+	struct device *dev = component->dev;
+	int ret;
+
+	priv->buffer_bytes = params_buffer_bytes(params);
+	priv->periods = params_periods(params);
+	priv->period_bytes = params_period_bytes(params);
+	priv->channels = params_channels(params);
+	priv->format = params_format(params);
+	priv->rate = params_rate(params);
+
+	priv->offset = 0;
+	priv->period_time = HZ / (priv->rate / params_period_size(params));
+
+	switch (priv->format) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		priv->buffer_ratio = 2;
+		priv->sample_align = 2;
+		priv->sample_bits = 16;
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		/* 24 bit audio in 32 bit word */
+		priv->buffer_ratio = 1;
+		priv->sample_align = 4;
+		priv->sample_bits = 24;
+		break;
+	default:
+		dev_err(dev, "unsupported sample format: %d\n", priv->format);
+		return -EINVAL;
+	}
+
+	priv->dma_period_bytes = priv->period_bytes * priv->buffer_ratio;
+	priv->sdma_params.buffer_num = priv->periods;
+	priv->sdma_params.phyaddr = priv->phy_hdmi_sdma_t;
+
+	ret = hdmi_sdma_initbuf(dev, priv);
+	if (ret)
+		return ret;
+
+	ret = hdmi_sdma_config(substream, priv);
+	if (ret)
+		return ret;
+
+	snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
+
+	ret = hdmi_dma_configure_dma(dev, priv->channels);
+	if (ret)
+		return ret;
+
+	hdmi_dma_set_addr(priv->hw_buffer.addr, priv->dma_period_bytes);
+
+	dumppriv(dev, priv);
+
+	hdmi_dma_update_iec_header(substream);
+
+	/* Init par for mmap optimizate */
+	init_table(priv->channels);
+
+	priv->appl_bytes = 0;
+
+	return 0;
+}
+
+static void hdmi_dma_trigger_init(struct snd_pcm_substream *substream,
+				struct hdmi_dma_priv *priv)
+{
+	unsigned long status;
+
+	priv->offset = 0;
+	priv->frame_idx = 0;
+
+	/* Copy data by buffer_bytes */
+	hdmi_dma_data_copy(substream, priv, 'b');
+
+	hdmi_audio_writeb(AHB_DMA_CONF0, SW_FIFO_RST, 0x1);
+
+	/* Delay after reset */
+	udelay(1);
+
+	status = hdmi_readb(HDMI_IH_AHBDMAAUD_STAT0);
+	hdmi_writeb(status, HDMI_IH_AHBDMAAUD_STAT0);
+}
+
+static int hdmi_dma_prepare_and_submit(struct snd_pcm_substream *substream,
+					struct hdmi_dma_priv *priv)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_component *component =
+				snd_soc_rtdcom_lookup(rtd, DRV_NAME);
+	struct device *dev = component->dev;
+
+	priv->desc = dmaengine_prep_dma_cyclic(priv->dma_channel, 0, 0, 0,
+						DMA_TRANS_NONE, 0);
+	if (!priv->desc) {
+		dev_err(dev, "failed to prepare slave dma\n");
+		return -EINVAL;
+	}
+
+	priv->desc->callback = hdmi_sdma_callback;
+	priv->desc->callback_param = (void *)priv;
+	dmaengine_submit(priv->desc);
+
+	return 0;
+}
+
+static int hdmi_dma_trigger(struct snd_soc_component *component, struct snd_pcm_substream *substream, int cmd)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct hdmi_dma_priv *priv = runtime->private_data;
+	struct device *dev = component->dev;
+	int ret;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (!check_hdmi_state())
+			return 0;
+		hdmi_dma_trigger_init(substream, priv);
+
+		dumpregs(dev);
+
+		priv->tx_active = true;
+		hdmi_audio_writeb(AHB_DMA_START, START, 0x1);
+		hdmi_dma_irq_set(false);
+		hdmi_set_dma_mode(1);
+		ret = hdmi_dma_prepare_and_submit(substream, priv);
+		if (ret)
+			return ret;
+		dma_async_issue_pending(priv->desc->chan);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		dmaengine_terminate_all(priv->dma_channel);
+		hdmi_set_dma_mode(0);
+		hdmi_dma_irq_set(true);
+		hdmi_audio_writeb(AHB_DMA_STOP, STOP, 0x1);
+		priv->tx_active = false;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static snd_pcm_uframes_t hdmi_dma_pointer(struct snd_soc_component *component, struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct hdmi_dma_priv *priv = runtime->private_data;
+
+	return bytes_to_frames(runtime, priv->offset);
+}
+
+static struct snd_pcm_hardware snd_imx_hardware = {
+	.info = SNDRV_PCM_INFO_INTERLEAVED |
+		SNDRV_PCM_INFO_BLOCK_TRANSFER |
+		SNDRV_PCM_INFO_MMAP |
+		SNDRV_PCM_INFO_MMAP_VALID |
+		SNDRV_PCM_INFO_PAUSE |
+		SNDRV_PCM_INFO_RESUME,
+	.formats = MXC_HDMI_FORMATS_PLAYBACK,
+	.rate_min = 32000,
+	.channels_min = 2,
+	.channels_max = 8,
+	.buffer_bytes_max = HDMI_PCM_BUF_SIZE,
+	.period_bytes_min = HDMI_DMA_PERIOD_BYTES / 2,
+	.period_bytes_max = HDMI_DMA_PERIOD_BYTES / 2,
+	.periods_min = 8,
+	.periods_max = 8,
+	.fifo_size = 0,
+};
+
+static void hdmi_dma_irq_enable(struct hdmi_dma_priv *priv)
+{
+	unsigned long flags;
+
+	hdmi_writeb(0xff, HDMI_AHB_DMA_POL);
+	hdmi_writeb(0xff, HDMI_AHB_DMA_BUFFPOL);
+
+	spin_lock_irqsave(&priv->irq_lock, flags);
+
+	hdmi_writeb(0xff, HDMI_IH_AHBDMAAUD_STAT0);
+	hdmi_writeb(0xff, HDMI_IH_MUTE_AHBDMAAUD_STAT0);
+	hdmi_dma_irq_set(false);
+	hdmi_mask(0);
+
+	spin_unlock_irqrestore(&priv->irq_lock, flags);
+}
+
+static void hdmi_dma_irq_disable(struct hdmi_dma_priv *priv)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->irq_lock, flags);
+
+	hdmi_dma_irq_set(true);
+	hdmi_writeb(0x0, HDMI_IH_MUTE_AHBDMAAUD_STAT0);
+	hdmi_writeb(0xff, HDMI_IH_AHBDMAAUD_STAT0);
+	hdmi_mask(1);
+
+	spin_unlock_irqrestore(&priv->irq_lock, flags);
+}
+
+static int hdmi_dma_open(struct snd_soc_component *component, struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct device *dev = component->dev;
+	struct hdmi_dma_priv *priv = dev_get_drvdata(dev);
+	int ret;
+
+	runtime->private_data = priv;
+
+	ret = mxc_hdmi_register_audio(substream);
+	if (ret < 0) {
+		dev_err(dev, "HDMI Video is not ready!\n");
+		return ret;
+	}
+
+	hdmi_audio_writeb(AHB_DMA_CONF0, SW_FIFO_RST, 0x1);
+
+	ret = snd_pcm_hw_constraint_integer(substream->runtime,
+			SNDRV_PCM_HW_PARAM_PERIODS);
+	if (ret < 0)
+		return ret;
+
+	snd_soc_set_runtime_hwparams(substream, &snd_imx_hardware);
+
+	hdmi_dma_irq_enable(priv);
+
+	return 0;
+}
+
+static int hdmi_dma_close(struct snd_soc_component *component, struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct hdmi_dma_priv *priv = runtime->private_data;
+
+	hdmi_dma_irq_disable(priv);
+	mxc_hdmi_unregister_audio(substream);
+
+	return 0;
+}
+
+static int imx_hdmi_dma_pcm_new(struct snd_soc_component *component, struct snd_soc_pcm_runtime *rtd)
+{
+	struct hdmi_dma_priv *priv = dev_get_drvdata(component->dev);
+	struct snd_card *card = rtd->card->snd_card;
+	struct snd_pcm_substream *substream;
+	struct snd_pcm *pcm = rtd->pcm;
+	u64 dma_mask = DMA_BIT_MASK(32);
+	int ret = 0;
+
+	if (!card->dev->dma_mask)
+		card->dev->dma_mask = &dma_mask;
+	if (!card->dev->coherent_dma_mask)
+		card->dev->coherent_dma_mask = DMA_BIT_MASK(32);
+
+	substream = pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream;
+
+	ret = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, pcm->card->dev,
+			HDMI_PCM_BUF_SIZE, &substream->dma_buffer);
+	if (ret) {
+		dev_err(card->dev, "failed to alloc playback dma buffer\n");
+		return ret;
+	}
+
+	priv->substream = substream;
+
+	/* Alloc the hw_buffer */
+	ret = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, pcm->card->dev,
+			HDMI_DMA_BUF_SIZE, &priv->hw_buffer);
+	if (ret) {
+		dev_err(card->dev, "failed to alloc hw dma buffer\n");
+		return ret;
+	}
+
+	return ret;
+}
+
+static void imx_hdmi_dma_pcm_free(struct snd_soc_component *component, struct snd_pcm *pcm)
+{
+	int stream = SNDRV_PCM_STREAM_PLAYBACK;
+	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
+	struct hdmi_dma_priv *priv = dev_get_drvdata(component->dev);
+
+	if (substream) {
+		snd_dma_free_pages(&substream->dma_buffer);
+		substream->dma_buffer.area = NULL;
+		substream->dma_buffer.addr = 0;
+	}
+
+	/* Free the hw_buffer */
+	snd_dma_free_pages(&priv->hw_buffer);
+	priv->hw_buffer.area = NULL;
+	priv->hw_buffer.addr = 0;
+}
+
+static const struct snd_soc_component_driver imx_hdmi_component = {
+	.name		= DRV_NAME,
+	.pcm_construct	= imx_hdmi_dma_pcm_new,
+	.pcm_destruct	= imx_hdmi_dma_pcm_free,
+	.open		= hdmi_dma_open,
+	.close		= hdmi_dma_close,
+	.hw_params	= hdmi_dma_hw_params,
+	.hw_free	= hdmi_dma_hw_free,
+	.trigger	= hdmi_dma_trigger,
+	.pointer	= hdmi_dma_pointer,
+	.copy_user	= hdmi_dma_copy_user,
+};
+
+static int imx_soc_platform_probe(struct platform_device *pdev)
+{
+	struct imx_hdmi *hdmi_drvdata = platform_get_drvdata(pdev);
+	struct hdmi_dma_priv *priv;
+	int ret = 0;
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv) {
+		dev_err(&pdev->dev, "Failed to alloc hdmi_dma\n");
+		return -ENOMEM;
+	}
+
+	ret = dma_coerce_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));
+	if (ret)
+		return ret;
+
+	priv->hdmi_sdma_t = dma_alloc_coherent(&pdev->dev,
+			sizeof(struct hdmi_sdma_script),
+			&priv->phy_hdmi_sdma_t, GFP_KERNEL);
+	if (!priv->hdmi_sdma_t) {
+		dev_err(&pdev->dev, "Failed to alloc hdmi_sdma_t\n");
+		return -ENOMEM;
+	}
+
+	priv->tx_active = false;
+	spin_lock_init(&priv->irq_lock);
+
+	priv->pdev = hdmi_drvdata->pdev;
+
+	hdmi_dma_init_iec_header();
+
+	dev_set_drvdata(&pdev->dev, priv);
+
+	switch (hdmi_readb(HDMI_REVISION_ID)) {
+	case 0x0a:
+		snd_imx_hardware.period_bytes_max = HDMI_DMA_PERIOD_BYTES / 4;
+		snd_imx_hardware.period_bytes_min = HDMI_DMA_PERIOD_BYTES / 4;
+		break;
+	default:
+		break;
+	}
+
+	ret = devm_snd_soc_register_component(&pdev->dev,
+					      &imx_hdmi_component, NULL, 0);
+	if (ret)
+		goto err_plat;
+
+	return 0;
+
+err_plat:
+	dma_free_coherent(&pdev->dev, sizeof(struct hdmi_sdma_script),
+			priv->hdmi_sdma_t, priv->phy_hdmi_sdma_t);
+
+	return ret;
+}
+
+static int imx_soc_platform_remove(struct platform_device *pdev)
+{
+	struct hdmi_dma_priv *priv = dev_get_drvdata(&pdev->dev);
+
+	dma_free_coherent(&pdev->dev, sizeof(struct hdmi_sdma_script),
+			priv->hdmi_sdma_t, priv->phy_hdmi_sdma_t);
+
+	return 0;
+}
+
+static struct platform_driver imx_hdmi_dma_driver = {
+	.driver = {
+		.name = "imx-hdmi-audio",
+		.owner = THIS_MODULE,
+	},
+	.probe = imx_soc_platform_probe,
+	.remove = imx_soc_platform_remove,
+};
+
+module_platform_driver(imx_hdmi_dma_driver);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("i.MX HDMI audio DMA");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/fsl/imx-hdmi.c b/sound/soc/fsl/imx-hdmi.c
index d61e3c841..6a6cbdc5f 100644
--- a/sound/soc/fsl/imx-hdmi.c
+++ b/sound/soc/fsl/imx-hdmi.c
@@ -8,6 +8,8 @@
 #include <sound/hdmi-codec.h>
 #include "fsl_sai.h"
 
+#define SUPPORT_RATE_NUM 10
+
 /**
  * struct cpu_priv - CPU private data
  * @sysclk_id: SYSCLK ids for set_sysclk()
@@ -29,6 +31,33 @@ struct imx_hdmi_data {
 	u32 dai_fmt;
 };
 
+static int imx_sii902x_startup(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	static struct snd_pcm_hw_constraint_list constraint_rates;
+	static u32 support_rates[SUPPORT_RATE_NUM];
+	int ret;
+
+	support_rates[0] = 32000;
+	support_rates[1] = 48000;
+	support_rates[2] = 96000;
+	support_rates[3] = 192000;
+	constraint_rates.list = support_rates;
+	constraint_rates.count = 4;
+
+	ret = snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
+					 &constraint_rates);
+	if (ret)
+		return ret;
+
+	ret = snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_CHANNELS,
+					   1, 2);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
 static int imx_hdmi_hw_params(struct snd_pcm_substream *substream,
 			      struct snd_pcm_hw_params *params)
 {
@@ -63,6 +92,11 @@ static struct snd_soc_ops imx_hdmi_ops = {
 	.hw_params = imx_hdmi_hw_params,
 };
 
+static struct snd_soc_ops imx_sii902x_ops = {
+	.startup = imx_sii902x_startup,
+	.hw_params = imx_hdmi_hw_params,
+};
+
 static const struct snd_soc_dapm_widget imx_hdmi_widgets[] = {
 	SND_SOC_DAPM_LINE("HDMI Jack", NULL),
 };
@@ -126,7 +160,6 @@ static int imx_hdmi_probe(struct platform_device *pdev)
 	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
 	if (!data) {
 		ret = -ENOMEM;
-		put_device(&cpu_pdev->dev);
 		goto fail;
 	}
 
@@ -156,6 +189,7 @@ static int imx_hdmi_probe(struct platform_device *pdev)
 	if (of_device_is_compatible(np, "fsl,imx-audio-sii902x")) {
 		data->dai_fmt = SND_SOC_DAIFMT_LEFT_J;
 		data->cpu_priv.slot_width = 24;
+		data->dai.ops = &imx_sii902x_ops;
 	} else {
 		data->dai_fmt = SND_SOC_DAIFMT_I2S;
 		data->cpu_priv.slot_width = 32;
diff --git a/sound/soc/fsl/imx-hdmi.h b/sound/soc/fsl/imx-hdmi.h
new file mode 100644
index 000000000..d06ce9c34
--- /dev/null
+++ b/sound/soc/fsl/imx-hdmi.h
@@ -0,0 +1,106 @@
+/*
+ * Copyright (C) 2011-2014 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __IMX_HDMI_H
+#define __IMX_HDMI_H
+
+struct imx_hdmi_sdma_params {
+	dma_addr_t phyaddr;
+	u32 buffer_num;
+	int dma;
+};
+
+struct imx_hdmi {
+	struct snd_soc_dai_driver cpu_dai_drv;
+	struct platform_device *codec_dev;
+	struct platform_device *dma_dev;
+	struct platform_device *pdev;
+	struct clk *isfr_clk;
+	struct clk *iahb_clk;
+	struct clk *mipi_core_clk;
+};
+
+#define HDMI_MAX_RATES 7
+#define HDMI_MAX_SAMPLE_SIZE 3
+#define HDMI_MAX_CHANNEL_CONSTRAINTS 4
+
+#define MXC_HDMI_RATES_PLAYBACK \
+	(SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 | \
+	 SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 | \
+	 SNDRV_PCM_RATE_176400 | SNDRV_PCM_RATE_192000)
+
+#define MXC_HDMI_FORMATS_PLAYBACK \
+	(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE)
+
+union hdmi_audio_header_t {
+	uint64_t  U;
+	struct {
+		unsigned consumer:1;
+		unsigned linear_pcm:1;
+		unsigned copyright:1;
+		unsigned pre_emphasis:3;
+		unsigned mode:2;
+
+		unsigned category_code:8;
+
+		unsigned source:4;
+		unsigned channel:4;
+
+		unsigned sample_freq:4;
+		unsigned clock_acc:2;
+		unsigned reserved0:2;
+
+		unsigned word_length:4;
+		unsigned org_sample_freq:4;
+
+		unsigned cgms_a:2;
+		unsigned reserved1:6;
+
+		unsigned reserved2:8;
+
+		unsigned reserved3:8;
+	} B;
+	unsigned char status[8];
+};
+
+union hdmi_audio_dma_data_t {
+	uint32_t  U;
+	struct {
+		unsigned data:24;
+		unsigned v:1;
+		unsigned u:1;
+		unsigned c:1;
+		unsigned p:1;
+		unsigned b:1;
+		unsigned reserved:3;
+	} B;
+};
+
+extern union hdmi_audio_header_t iec_header;
+
+#define hdmi_audio_writeb(reg, bit, val) \
+	do { \
+		hdmi_mask_writeb(val, HDMI_ ## reg, \
+			HDMI_ ## reg ## _ ## bit ## _OFFSET, \
+			HDMI_ ## reg ## _ ## bit ## _MASK); \
+		pr_debug("Set reg: HDMI_" #reg " (0x%x) "\
+			"bit: HDMI_" #reg "_" #bit " (%d) to val: %x\n", \
+			HDMI_ ## reg, HDMI_ ## reg ## _ ## bit ## _OFFSET, val); \
+	} while (0)
+
+#endif /* __IMX_HDMI_H */
diff --git a/sound/soc/fsl/imx-pcm-dma.c b/sound/soc/fsl/imx-pcm-dma.c
index 04a9bc749..7ec48dfb1 100644
--- a/sound/soc/fsl/imx-pcm-dma.c
+++ b/sound/soc/fsl/imx-pcm-dma.c
@@ -44,6 +44,9 @@ int imx_pcm_dma_init(struct platform_device *pdev, size_t size)
 		return -ENOMEM;
 	*config = imx_dmaengine_pcm_config;
 
+	if (size)
+		config->prealloc_buffer_size = size;
+
 	return devm_snd_dmaengine_pcm_register(&pdev->dev,
 		config,
 		SND_DMAENGINE_PCM_FLAG_COMPAT);
diff --git a/sound/soc/fsl/imx-pcm-rpmsg.c b/sound/soc/fsl/imx-pcm-rpmsg.c
index 35049043e..b36c5ff44 100644
--- a/sound/soc/fsl/imx-pcm-rpmsg.c
+++ b/sound/soc/fsl/imx-pcm-rpmsg.c
@@ -178,7 +178,7 @@ static int imx_rpmsg_pcm_hw_params(struct snd_soc_component *component,
 		msg->s_msg.param.channels = RPMSG_CH_STEREO;
 		break;
 	default:
-		ret = -EINVAL;
+		msg->s_msg.param.channels = params_channels(params);
 		break;
 	}
 
@@ -228,7 +228,11 @@ static void imx_rpmsg_timer_callback(struct timer_list *t)
 static int imx_rpmsg_pcm_open(struct snd_soc_component *component,
 			      struct snd_pcm_substream *substream)
 {
+	struct snd_pcm_hardware pcm_hardware = imx_rpmsg_pcm_hardware;
 	struct rpmsg_info *info = dev_get_drvdata(component->dev);
+	struct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);
+	struct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);
+	struct fsl_rpmsg *rpmsg = dev_get_drvdata(cpu_dai->dev);
 	struct rpmsg_msg *msg;
 	int ret = 0;
 	int cmd;
@@ -256,10 +260,11 @@ static int imx_rpmsg_pcm_open(struct snd_soc_component *component,
 
 	info->send_message(msg, info);
 
-	imx_rpmsg_pcm_hardware.period_bytes_max =
-			imx_rpmsg_pcm_hardware.buffer_bytes_max / 2;
+	pcm_hardware.buffer_bytes_max = rpmsg->buffer_size[substream->stream];
+	pcm_hardware.period_bytes_max =
+			pcm_hardware.buffer_bytes_max / 2;
 
-	snd_soc_set_runtime_hwparams(substream, &imx_rpmsg_pcm_hardware);
+	snd_soc_set_runtime_hwparams(substream, &pcm_hardware);
 
 	ret = snd_pcm_hw_constraint_integer(substream->runtime,
 					    SNDRV_PCM_HW_PARAM_PERIODS);
@@ -593,15 +598,29 @@ static int imx_rpmsg_pcm_new(struct snd_soc_component *component,
 	struct snd_pcm *pcm = rtd->pcm;
 	struct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);
 	struct fsl_rpmsg *rpmsg = dev_get_drvdata(cpu_dai->dev);
+	struct snd_pcm_substream *substream;
 	int ret;
 
 	ret = dma_coerce_mask_and_coherent(card->dev, DMA_BIT_MASK(32));
 	if (ret)
 		return ret;
 
-	imx_rpmsg_pcm_hardware.buffer_bytes_max = rpmsg->buffer_size;
-	return snd_pcm_set_fixed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV_WC,
-					    pcm->card->dev, rpmsg->buffer_size);
+	substream = pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream;
+	if (substream) {
+		ret = snd_pcm_set_fixed_buffer(substream, SNDRV_DMA_TYPE_DEV_WC,
+						 pcm->card->dev, rpmsg->buffer_size[SNDRV_PCM_STREAM_PLAYBACK]);
+		if (ret < 0)
+			return ret;
+	}
+	substream = pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream;
+	if (substream) {
+		ret = snd_pcm_set_fixed_buffer(substream, SNDRV_DMA_TYPE_DEV_WC,
+						 pcm->card->dev, rpmsg->buffer_size[SNDRV_PCM_STREAM_CAPTURE]);
+		if (ret < 0)
+			return ret;
+	}
+
+	return ret;
 }
 
 static const struct snd_soc_component_driver imx_rpmsg_soc_component = {
@@ -672,6 +691,7 @@ static void imx_rpmsg_pcm_work(struct work_struct *work)
 static int imx_rpmsg_pcm_probe(struct platform_device *pdev)
 {
 	struct snd_soc_component *component;
+	struct device_node *np;
 	struct rpmsg_info *info;
 	int ret, i;
 
@@ -684,7 +704,7 @@ static int imx_rpmsg_pcm_probe(struct platform_device *pdev)
 	info->rpdev = container_of(pdev->dev.parent, struct rpmsg_device, dev);
 	info->dev = &pdev->dev;
 	/* Setup work queue */
-	info->rpmsg_wq = alloc_ordered_workqueue("rpmsg_audio",
+	info->rpmsg_wq = alloc_ordered_workqueue(info->rpdev->id.name,
 						 WQ_HIGHPRI |
 						 WQ_UNBOUND |
 						 WQ_FREEZABLE);
@@ -723,11 +743,17 @@ static int imx_rpmsg_pcm_probe(struct platform_device *pdev)
 	if (ret)
 		goto fail;
 
-	component = snd_soc_lookup_component(&pdev->dev, IMX_PCM_DRV_NAME);
+	component = snd_soc_lookup_component(&pdev->dev, NULL);
 	if (!component) {
 		ret = -EINVAL;
 		goto fail;
 	}
+	/* platform component name is used by machine driver to link with */
+	component->name = IMX_PCM_DRV_NAME;
+	np = of_find_node_by_name(NULL, "rpmsg_audio");
+	if (np && of_property_read_bool(np, "fsl,platform"))
+		component->name = info->rpdev->id.name;
+
 #ifdef CONFIG_DEBUG_FS
 	component->debugfs_prefix = "rpmsg";
 #endif
diff --git a/sound/soc/fsl/imx-pcm-rpmsg.h b/sound/soc/fsl/imx-pcm-rpmsg.h
index 8286b55f0..cbc12a6d4 100644
--- a/sound/soc/fsl/imx-pcm-rpmsg.h
+++ b/sound/soc/fsl/imx-pcm-rpmsg.h
@@ -507,6 +507,19 @@ struct rpmsg_info {
 	struct stream_timer      stream_timer[2];
 };
 
+struct rpmsg_codec {
+        int audioindex;
+
+        /*property for wm8960*/
+        bool capless;
+        bool shared_lrclk;
+};
+
+#define RPMSG_CODEC_WM8960 1
+#define RPMSG_CODEC_AK4497 2
+
+#define RPMSG_CODEC_DRV_NAME_WM8960 "rpmsg-codec-wm8960"
+#define RPMSG_CODEC_DRV_NAME_AK4497 "rpmsg-codec-ak4497"
 #define IMX_PCM_DRV_NAME "imx_pcm_rpmsg"
 
 #endif /* IMX_PCM_RPMSG_H */
diff --git a/sound/soc/fsl/imx-pcm.h b/sound/soc/fsl/imx-pcm.h
index 5dd406774..cc0ede261 100644
--- a/sound/soc/fsl/imx-pcm.h
+++ b/sound/soc/fsl/imx-pcm.h
@@ -17,7 +17,7 @@
 #define IMX_SSI_DMABUF_SIZE	(64 * 1024)
 
 #define IMX_DEFAULT_DMABUF_SIZE	(64 * 1024)
-#define IMX_SAI_DMABUF_SIZE	(64 * 1024)
+#define IMX_SAI_DMABUF_SIZE	(512 * 1024)
 #define IMX_SPDIF_DMABUF_SIZE	(64 * 1024)
 #define IMX_ESAI_DMABUF_SIZE	(256 * 1024)
 
diff --git a/sound/soc/fsl/imx-pcm512x.c b/sound/soc/fsl/imx-pcm512x.c
new file mode 100644
index 000000000..c6388a37d
--- /dev/null
+++ b/sound/soc/fsl/imx-pcm512x.c
@@ -0,0 +1,576 @@
+/* i.MX pcm512x audio support
+ *
+ * Copyright 2020 NXP
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/gpio/consumer.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/clk.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <sound/pcm.h>
+#include <sound/simple_card.h>
+#include <sound/soc-dapm.h>
+
+#include "fsl_sai.h"
+#include "../codecs/pcm512x.h"
+
+#define DAC_CLK_EXT_44K 22579200UL
+#define DAC_CLK_EXT_48K 24576000UL
+
+struct imx_pcm512x_data {
+	struct asoc_simple_priv *priv;
+	struct gpio_desc *mute_gpio;
+	bool dac_sclk;
+	bool dac_pluspro;
+	bool dac_led_status;
+	bool dac_gain_limit;
+	bool dac_gpio_unmute;
+	bool dac_auto_mute;
+	bool one2one_ratio;
+	bool tdm_mode;
+};
+
+enum ext_osc {
+	DAC_CLK_INT,
+	DAC_CLK_EXT_44EN,
+	DAC_CLK_EXT_48EN,
+};
+
+static const struct imx_pcm512x_fs_map {
+	unsigned int rmin;
+	unsigned int rmax;
+	unsigned int wmin;
+	unsigned int wmax;
+} fs_map[] = {
+	{ .rmin = 8000,   .rmax = 192000, .wmin = 128, .wmax = 3072, },
+	{ .rmin = 384000, .rmax = 384000, .wmin = 64,  .wmax = 128,  },
+};
+
+static const u32 pcm512x_rates[] = {
+	8000, 11025, 16000, 22050, 32000,
+	44100, 48000, 64000, 88200, 96000,
+	176400, 192000, 384000,
+};
+
+static int imx_pcm512x_select_ext_clk(struct snd_soc_component *comp,
+				      int ext_osc)
+{
+	switch(ext_osc) {
+	case DAC_CLK_INT:
+		snd_soc_component_update_bits(comp, PCM512x_GPIO_CONTROL_1, 0x24, 0x00);
+		break;
+	case DAC_CLK_EXT_44EN:
+		snd_soc_component_update_bits(comp, PCM512x_GPIO_CONTROL_1, 0x24, 0x20);
+		break;
+	case DAC_CLK_EXT_48EN:
+		snd_soc_component_update_bits(comp, PCM512x_GPIO_CONTROL_1, 0x24, 0x04);
+		break;
+	}
+
+	return 0;
+}
+
+static bool imx_pcm512x_is_sclk(struct snd_soc_component *comp)
+{
+	unsigned int sclk;
+
+	sclk = snd_soc_component_read(comp, PCM512x_RATE_DET_4);
+
+	return (!(sclk & 0x40));
+}
+
+static bool imx_pcm512x_is_sclk_sleep(struct snd_soc_component *comp)
+{
+	msleep(2);
+	return imx_pcm512x_is_sclk(comp);
+}
+
+static int imx_pcm512x_dai_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_card *card = rtd->card;
+	struct imx_pcm512x_data *data = snd_soc_card_get_drvdata(card);
+	int ret;
+
+	if (data->dac_gain_limit) {
+		ret = snd_soc_limit_volume(card, "Digital Playback Volume", 207);
+		if (ret)
+			dev_warn(card->dev, "failed to set volume limit\n");
+	}
+
+	return 0;
+}
+
+static int imx_pcm512x_set_bias_level(struct snd_soc_card *card,
+	struct snd_soc_dapm_context *dapm, enum snd_soc_bias_level level)
+{
+	struct imx_pcm512x_data *data = snd_soc_card_get_drvdata(card);
+	struct snd_soc_pcm_runtime *rtd;
+	struct snd_soc_dai *codec_dai;
+
+	rtd = snd_soc_get_pcm_runtime(card, card->dai_link);
+	codec_dai = asoc_rtd_to_codec(rtd, 0);
+
+	if (dapm->dev != codec_dai->dev)
+		return 0;
+
+	switch (level) {
+	case SND_SOC_BIAS_PREPARE:
+		if (dapm->bias_level != SND_SOC_BIAS_STANDBY)
+			break;
+		/* unmute amp */
+		gpiod_set_value_cansleep(data->mute_gpio, 1);
+		break;
+	case SND_SOC_BIAS_STANDBY:
+		if (dapm->bias_level != SND_SOC_BIAS_PREPARE)
+			break;
+		/* mute amp */
+		gpiod_set_value_cansleep(data->mute_gpio, 0);
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static unsigned long pcm512x_get_mclk_rate(struct snd_pcm_substream *substream,
+					  struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);
+	struct imx_pcm512x_data *data = snd_soc_card_get_drvdata(rtd->card);
+	unsigned int channels = params_channels(params);
+	unsigned int width = params_width(params);
+	unsigned int rate = params_rate(params);
+	unsigned int ratio = channels * width;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(fs_map); i++) {
+		if (rate >= fs_map[i].rmin && rate <= fs_map[i].rmax) {
+			ratio = max(ratio, fs_map[i].wmin);
+			ratio = min(ratio, fs_map[i].wmax);
+			/* Adjust SAI bclk:mclk ratio */
+			ratio *= data->one2one_ratio ? 1 : 2;
+			return rate * ratio;
+		}
+	}
+
+	/* Let DAI manage clk frequency by default */
+	return 0;
+}
+
+static int imx_pcm512x_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);
+	struct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);
+	struct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);
+	struct snd_soc_component *comp = codec_dai->component;
+	struct snd_soc_card *card = rtd->card;
+	struct imx_pcm512x_data *data = snd_soc_card_get_drvdata(card);
+	unsigned int rate = params_rate(params);
+	unsigned int channels = params_channels(params);
+	unsigned int width = params_width(params);
+	unsigned long mclk_freq;
+	int ret, i;
+
+	/* set MCLK freq */
+	if (data->dac_pluspro && data->dac_sclk) {
+		if (do_div(rate, 8000)) {
+			mclk_freq = DAC_CLK_EXT_44K;
+			imx_pcm512x_select_ext_clk(comp, DAC_CLK_EXT_44EN);
+			ret = snd_soc_dai_set_sysclk(codec_dai,
+				PCM512x_SYSCLK_MCLK1, mclk_freq, SND_SOC_CLOCK_IN);
+		} else {
+			mclk_freq = DAC_CLK_EXT_48K;
+			imx_pcm512x_select_ext_clk(comp, DAC_CLK_EXT_48EN);
+			ret = snd_soc_dai_set_sysclk(codec_dai,
+				PCM512x_SYSCLK_MCLK2, mclk_freq, SND_SOC_CLOCK_IN);
+		}
+		if (ret < 0)
+			dev_err(card->dev, "failed to set cpu dai mclk rate (%lu): %d\n",
+				mclk_freq, ret);
+	} else {
+		mclk_freq = pcm512x_get_mclk_rate(substream, params);
+		ret = snd_soc_dai_set_sysclk(cpu_dai, FSL_SAI_CLK_MAST1,
+					     mclk_freq, SND_SOC_CLOCK_OUT);
+		if (ret < 0)
+			dev_err(card->dev, "failed to set cpu dai mclk1 rate (%lu): %d\n",
+				mclk_freq, ret);
+	}
+
+	for_each_rtd_codec_dais(rtd, i, codec_dai) {
+		ret = snd_soc_dai_set_bclk_ratio(codec_dai, (channels * width));
+		if (ret) {
+			dev_err(card->dev, "failed to set codec dai bclk ratio\n");
+			return ret;
+		}
+	}
+
+	dev_dbg(card->dev, "mclk_freq: %lu, bclk ratio: %u\n",
+		mclk_freq, (channels * width));
+
+	return 0;
+}
+
+static int imx_pcm512x_startup(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_soc_card *card = rtd->card;
+	struct imx_pcm512x_data *data = snd_soc_card_get_drvdata(card);
+	static struct snd_pcm_hw_constraint_list constraint_rates;
+	struct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);
+	struct snd_soc_component *comp = codec_dai->component;
+	bool ext_44sclk, ext_48sclk, ext_nosclk;
+	int ret;
+
+	constraint_rates.list = pcm512x_rates;
+	constraint_rates.count = ARRAY_SIZE(pcm512x_rates);
+
+	ret = snd_pcm_hw_constraint_list(runtime, 0,
+			SNDRV_PCM_HW_PARAM_RATE, &constraint_rates);
+	if (ret)
+		return ret;
+
+	if (data->dac_led_status) {
+		snd_soc_component_update_bits(comp, PCM512x_GPIO_EN, 0x08, 0x08);
+		snd_soc_component_update_bits(comp, PCM512x_GPIO_OUTPUT_4, 0x0f, 0x02);
+		snd_soc_component_update_bits(comp, PCM512x_GPIO_CONTROL_1, 0x08, 0x08);
+	}
+
+	if (data->dac_sclk) {
+		snd_soc_component_update_bits(comp, PCM512x_GPIO_EN, 0x24, 0x24);
+		snd_soc_component_update_bits(comp, PCM512x_GPIO_OUTPUT_3, 0x0f, 0x02);
+		snd_soc_component_update_bits(comp, PCM512x_GPIO_OUTPUT_6, 0x0f, 0x02);
+
+		imx_pcm512x_select_ext_clk(comp, DAC_CLK_EXT_44EN);
+		ext_44sclk = imx_pcm512x_is_sclk_sleep(comp);
+
+		imx_pcm512x_select_ext_clk(comp, DAC_CLK_EXT_48EN);
+		ext_48sclk = imx_pcm512x_is_sclk_sleep(comp);
+
+		imx_pcm512x_select_ext_clk(comp, DAC_CLK_INT);
+		ext_nosclk = imx_pcm512x_is_sclk_sleep(comp);
+
+		data->dac_pluspro = (ext_44sclk && ext_48sclk && !ext_nosclk);
+	}
+
+	return 0;
+}
+
+static void imx_pcm512x_shutdown(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_card *card = rtd->card;
+	struct imx_pcm512x_data *data = snd_soc_card_get_drvdata(card);
+	struct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);
+	struct snd_soc_component *comp = codec_dai->component;
+
+	if (data->dac_led_status)
+		snd_soc_component_update_bits(comp, PCM512x_GPIO_CONTROL_1, 0x08, 0x00);
+
+	if (data->dac_sclk && data->dac_pluspro)
+		imx_pcm512x_select_ext_clk(comp, DAC_CLK_INT);
+}
+
+static struct snd_soc_ops imx_pcm512x_ops = {
+	.hw_params = imx_pcm512x_hw_params,
+	.startup = imx_pcm512x_startup,
+	.shutdown = imx_pcm512x_shutdown,
+};
+
+static int imx_asoc_card_parse_dt(struct snd_soc_card *card,
+				  struct asoc_simple_priv *priv)
+{
+	struct device_node *np, *cpu_np, *codec_np = NULL;
+	struct snd_soc_dai_link_component *dlc;
+	struct asoc_simple_dai *simple_dai;
+	struct device *dev = card->dev;
+	struct snd_soc_dai_link *link;
+	struct of_phandle_args args;
+	int ret, num_links;
+
+	ret = snd_soc_of_parse_card_name(card, "model");
+	if (ret) {
+		dev_err(dev, "failed to find card model name\n");
+		return ret;
+	}
+
+	if (of_property_read_bool(dev->of_node, "audio-routing")) {
+		ret = snd_soc_of_parse_audio_routing(card, "audio-routing");
+		if (ret) {
+			dev_err(dev, "failed to parse audio-routing\n");
+			return ret;
+		}
+	}
+
+	if (of_property_read_bool(dev->of_node, "audio-widgets")) {
+		ret = snd_soc_of_parse_audio_simple_widgets(card,
+							    "audio-widgets");
+		if (ret) {
+			dev_err(dev, "failed to parse audio-widgets\n");
+			return ret;
+		}
+	}
+
+	if (of_property_read_bool(dev->of_node, "aux-devs")) {
+		ret = snd_soc_of_parse_aux_devs(card, "aux-devs");
+		if (ret) {
+			dev_err(dev, "failed to parse aux devs\n");
+			return ret;
+		}
+	}
+
+	num_links = of_get_child_count(dev->of_node);
+
+	card->dai_link = devm_kcalloc(dev, num_links, sizeof(*link), GFP_KERNEL);
+	if (!card->dai_link) {
+		dev_err(dev, "failed to allocate memory for dai_link\n");
+		return -ENOMEM;
+	}
+
+	simple_dai = devm_kcalloc(dev, num_links, sizeof(*simple_dai), GFP_KERNEL);
+	if (!simple_dai) {
+		dev_err(dev, "failed to allocate memory for simple_dai\n");
+		return -ENOMEM;
+	}
+
+	link = card->dai_link;
+	card->num_links = num_links;
+	/* pupulate dai links */
+	for_each_child_of_node(dev->of_node, np) {
+		dlc = devm_kzalloc(dev, 2 * sizeof(*dlc), GFP_KERNEL);
+		if (!dlc) {
+			dev_err(dev, "failed to allocate memory for dlc\n");
+			ret = -ENOMEM;
+			goto err_fail;
+		}
+
+		link->cpus = &dlc[0];
+		link->platforms = &dlc[1];
+		link->num_cpus = 1;
+		link->num_platforms = 1;
+
+		if (of_property_read_bool(np, "link-name")) {
+			ret = of_property_read_string(np, "link-name", &link->name);
+			if (ret) {
+				dev_err(dev, "failed to get dai_link name\n");
+				goto fail;
+			}
+		}
+
+		cpu_np = of_get_child_by_name(np, "cpu");
+		if (!cpu_np) {
+			dev_err(dev, "failed to get cpu phandle missing or invalid");
+			ret = -EINVAL;
+			goto fail;
+		}
+
+		ret = of_parse_phandle_with_args(cpu_np, "sound-dai",
+						 "#sound-dai-cells", 0, &args);
+		if (ret) {
+			dev_err(dev, "failed to get cpu sound-dais\n");
+			goto fail;
+		}
+
+		ret = snd_soc_of_get_dai_name(cpu_np, &link->cpus->dai_name);
+		if (ret) {
+			if (ret != -EPROBE_DEFER)
+				dev_err(dev, "failed to get cpu dai name\n");
+			goto fail;
+		}
+
+		link->cpus->of_node = args.np;
+		link->id = args.args[0];
+		link->platforms->of_node = link->cpus->of_node;
+
+		codec_np = of_get_child_by_name(np, "codec");
+		if (!codec_np) {
+			dev_err(dev, "failed to get codec phandle missing or invalid\n");
+			goto fail;
+		}
+
+		if (codec_np) {
+			ret = snd_soc_of_get_dai_link_codecs(dev, codec_np, link);
+			if (ret) {
+				if (ret != -EPROBE_DEFER)
+					dev_err(dev, "failed to get codec dais\n");
+				goto fail;
+			}
+		} else {
+			dlc = devm_kzalloc(dev, sizeof(*dlc), GFP_KERNEL);
+			if (!dlc) {
+				dev_err(dev, "failed to allocate memory for dlc\n");
+				ret = -ENOMEM;
+				goto err_fail;
+			}
+
+			link->codecs = dlc;
+			link->num_codecs = 1;
+
+			link->codecs->dai_name = "snd-soc-dummy-dai";
+			link->codecs->name = "snd-soc-dummy";
+		}
+
+		ret = asoc_simple_parse_daifmt(dev, np, codec_np, NULL,
+					       &link->dai_fmt);
+		if (ret) {
+			dev_warn(dev, "failed to parse dai format\n");
+			link->dai_fmt = SND_SOC_DAIFMT_NB_NF |
+				SND_SOC_DAIFMT_CBS_CFS |
+				SND_SOC_DAIFMT_I2S;
+		}
+
+		ret = asoc_simple_parse_tdm(np, simple_dai);
+		if (ret) {
+			dev_err(dev, "failed to parse dai tdm\n");
+		}
+
+		link->stream_name = link->name;
+		link->ignore_pmdown_time = 1;
+		simple_dai++;
+		link++;
+
+		of_node_put(cpu_np);
+		of_node_put(codec_np);
+	}
+
+	return 0;
+
+fail:
+	if (cpu_np)
+		of_node_put(cpu_np);
+	if (codec_np)
+		of_node_put(codec_np);
+err_fail:
+	if (np)
+		of_node_put(np);
+
+	return ret;
+}
+
+static int imx_pcm512x_parse_dt(struct imx_pcm512x_data *data)
+{
+	struct snd_soc_card *card = &data->priv->snd_card;
+	struct device *dev = card->dev;
+	struct device_node *np = dev->of_node;
+	int ret;
+
+	/* Multiple dais */
+	ret = imx_asoc_card_parse_dt(card, data->priv);
+	if (ret)
+		return ret;
+
+	data->dac_gain_limit =
+		of_property_read_bool(np, "dac,24db_digital_gain");
+	data->dac_auto_mute =
+		of_property_read_bool(np, "dac,auto_mute_amp");
+	data->dac_gpio_unmute =
+		of_property_read_bool(np, "dac,unmute_amp");
+	data->dac_led_status =
+		of_property_read_bool(np, "dac,led_status");
+	data->dac_sclk =
+		of_property_read_bool(np, "dac,sclk");
+
+	return 0;
+}
+
+static int imx_pcm512x_probe(struct platform_device *pdev)
+{
+	struct asoc_simple_priv *priv;
+	struct imx_pcm512x_data *data;
+	struct snd_soc_card *card;
+	int ret, i;
+
+	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	data->priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!data->priv)
+		return -ENOMEM;
+
+	card = &data->priv->snd_card;
+	dev_set_drvdata(&pdev->dev, &data);
+	snd_soc_card_set_drvdata(card, data);
+
+	card->owner = THIS_MODULE;
+	card->dev = &pdev->dev;
+
+	ret = imx_pcm512x_parse_dt(data);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to parse sound card dts\n");
+		return ret;
+	}
+
+	for (i = 0; i < card->num_links; i++) {
+		card->dai_link->ops = &imx_pcm512x_ops;
+		card->dai_link->init = &imx_pcm512x_dai_init;
+	}
+
+	if (data->dac_auto_mute || data->dac_gpio_unmute) {
+		data->mute_gpio = devm_gpiod_get_optional(&pdev->dev,
+						"mute-amp", GPIOD_OUT_LOW);
+		if (IS_ERR(data->mute_gpio)) {
+			dev_err(&pdev->dev, "failed to get mute amp gpio\n");
+			return PTR_ERR(data->mute_gpio);
+		}
+	}
+
+	if (data->dac_auto_mute && data->dac_gpio_unmute)
+		card->set_bias_level = imx_pcm512x_set_bias_level;
+
+	ret = devm_snd_soc_register_card(&pdev->dev, card);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to register snd card\n");
+		return ret;
+	}
+
+	if (data->dac_gpio_unmute && data->dac_auto_mute)
+		gpiod_set_value_cansleep(data->mute_gpio, 1);
+
+	return 0;
+}
+
+static int imx_pcm512x_remove(struct platform_device *pdev)
+{
+	struct imx_pcm512x_data *data = platform_get_drvdata(pdev);
+
+	if (data->mute_gpio)
+		gpiod_set_value_cansleep(data->mute_gpio, 0);
+
+	return snd_soc_unregister_card(&data->priv->snd_card);
+}
+
+static const struct of_device_id imx_pcm512x_dt_ids[] = {
+	{ .compatible = "fsl,imx-audio-pcm512x", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, imx_pcm512x_dt_ids);
+
+static struct platform_driver imx_pcm512x_driver = {
+	.driver = {
+		.name = "imx-pcm512x",
+		.pm = &snd_soc_pm_ops,
+		.of_match_table = imx_pcm512x_dt_ids,
+	},
+	.probe = imx_pcm512x_probe,
+	.remove = imx_pcm512x_remove,
+};
+module_platform_driver(imx_pcm512x_driver);
+
+MODULE_DESCRIPTION("NXP i.MX pcm512x ASoC machine driver");
+MODULE_AUTHOR("Adrian Alonso <adrian.alonso@nxp.com>");
+MODULE_ALIAS("platform:imx-pcm512x");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/fsl/imx-pdm.c b/sound/soc/fsl/imx-pdm.c
new file mode 100644
index 000000000..32cf58404
--- /dev/null
+++ b/sound/soc/fsl/imx-pdm.c
@@ -0,0 +1,409 @@
+/*
+ * Copyright 2017-2020 NXP.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <sound/soc.h>
+
+#include "fsl_sai.h"
+
+#define IMX_PDM_FORMATS (SNDRV_PCM_FMTBIT_DSD_U8 | \
+			 SNDRV_PCM_FMTBIT_DSD_U16_LE | \
+			 SNDRV_PCM_FMTBIT_DSD_U32_LE)
+
+struct imx_pdm_data {
+	struct snd_soc_dai_link dai;
+	struct snd_soc_card card;
+	unsigned int decimation;
+	unsigned long mclk_11k;
+	unsigned long mclk_8k;
+	bool fixed_mclk;
+	int osr_id;
+};
+
+static const struct imx_pdm_mic_fs_mul {
+	unsigned int min;
+	unsigned int max;
+	unsigned int mul;
+} fs_mul[] = {
+	{ .min =  8000, .max = 11025, .mul =  8 }, /* low power */
+	{ .min = 16000, .max = 64000, .mul = 16 }, /* performance */
+};
+
+/* Ratio based on default Audio PLLs
+ * Audio PLL1 = 393216000 Hz
+ * Audio PLL2 = 361267200 Hz
+ */
+static const struct imx_pdm_mic_mclk_fixed {
+	unsigned long mclk_11k;
+	unsigned long mclk_8k;
+	unsigned int ratio;
+} mclk_fixed[] = {
+	{ .mclk_11k = 11289600, .mclk_8k = 12288000, .ratio = 32 },
+	{ .mclk_11k = 15052800, .mclk_8k = 16384000, .ratio = 24 },
+	{ .mclk_11k = 22579200, .mclk_8k = 24576000, .ratio = 16 },
+	{ .mclk_11k = 45158400, .mclk_8k = 49152000, .ratio =  8 },
+};
+
+static const unsigned int imx_pdm_mic_rates[] = {
+	8000,  11025, 16000, 22050,
+	32000, 44100, 48000, 64000,
+};
+
+static const struct imx_pdm_mic_osr_map {
+	int id;
+	unsigned int osr;
+} osr_map[] = {
+	{ .id = 0, .osr =  48 }, /* 4x12 */
+	{ .id = 1, .osr =  64 }, /* 4x16 */
+	{ .id = 2, .osr =  96 }, /* 4x24 */
+	{ .id = 3, .osr = 128 }, /* 4x32 */
+	{ .id = 4, .osr = 192 }, /* 4x48 */
+};
+
+static int imx_pdm_mic_get_osr_id(int decimation)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(osr_map); i++) {
+		if (osr_map[i].osr == decimation)
+			return osr_map[i].id;
+	}
+
+	return -EINVAL;
+}
+
+static unsigned int imx_pdm_mic_get_osr_rate(int osr_id)
+{
+	int i;
+
+	for (i = 0; ARRAY_SIZE(osr_map); i++) {
+		if (osr_map[i].id == osr_id)
+			return osr_map[i].osr;
+	}
+
+	return -EINVAL;
+}
+
+static const char *const osr_rate_text[] = {
+	"OSR_4x12",
+	"OSR_4x16",
+	"OSR_4x24",
+	"OSR_4x32",
+	"OSR_4x48"
+};
+
+static int osr_rate_get(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+	struct imx_pdm_data *data = snd_soc_card_get_drvdata(card);
+
+	ucontrol->value.enumerated.item[0] = data->osr_id;
+
+	return 0;
+}
+
+static int osr_rate_set(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+	struct imx_pdm_data *data = snd_soc_card_get_drvdata(card);
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+	unsigned int *item = ucontrol->value.enumerated.item;
+	int osr = snd_soc_enum_item_to_val(e, item[0]);
+
+	data->decimation = imx_pdm_mic_get_osr_rate(osr);
+	data->osr_id = osr;
+
+	return 0;
+}
+
+static const struct soc_enum osr_rate_enum =
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(osr_rate_text), osr_rate_text);
+
+const struct snd_kcontrol_new imx_pdm_mic_snd_ctrls[] = {
+	SOC_ENUM_EXT("over sampling ratio", osr_rate_enum,
+		     osr_rate_get, osr_rate_set),
+};
+
+static struct snd_pcm_hw_constraint_list imx_pdm_mic_rate_constrains = {
+	.count = ARRAY_SIZE(imx_pdm_mic_rates),
+	.list = imx_pdm_mic_rates,
+};
+static unsigned int imx_pdm_mic_channels[] = { 1, 2, 4, 6, 8 };
+static struct snd_pcm_hw_constraint_list imx_pdm_mic_channels_constrains = {
+	.count = ARRAY_SIZE(imx_pdm_mic_channels),
+	.list = imx_pdm_mic_channels,
+};
+
+static unsigned long imx_pdm_mic_mclk_freq(unsigned int decimation,
+		unsigned int rate)
+{
+	int i;
+
+	/* Find appropriate mclk freq */
+	for (i = 0; i < ARRAY_SIZE(fs_mul); i++) {
+		if (rate >= fs_mul[i].min && rate <= fs_mul[i].max)
+			return (rate * decimation * fs_mul[i].mul);
+	}
+
+	return 0;
+}
+
+static int imx_pdm_mic_get_mclk_fixed(struct imx_pdm_data *data,
+		unsigned int ratio)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(mclk_fixed); i++) {
+		if (mclk_fixed[i].ratio == ratio) {
+			data->mclk_11k = mclk_fixed[i].mclk_11k;
+			data->mclk_8k = mclk_fixed[i].mclk_8k;
+			return 0;
+		}
+	}
+
+	return -EINVAL;
+}
+
+static int imx_pdm_mic_startup(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_soc_card *card = rtd->card;
+	int ret;
+
+	ret = snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
+			&imx_pdm_mic_rate_constrains);
+	if (ret) {
+		dev_err(card->dev,
+			"fail to set pcm hw rate constrains: %d\n", ret);
+		return ret;
+	}
+
+	ret = snd_pcm_hw_constraint_list(runtime, 0,
+		SNDRV_PCM_HW_PARAM_CHANNELS, &imx_pdm_mic_channels_constrains);
+	if (ret) {
+		dev_err(card->dev,
+			"fail to set pcm hw channels constrains: %d\n", ret);
+		return ret;
+	}
+
+	ret = snd_pcm_hw_constraint_mask64(runtime,
+			SNDRV_PCM_HW_PARAM_FORMAT, IMX_PDM_FORMATS);
+	if (ret) {
+		dev_err(card->dev,
+			"fail to set pcm hw format constrains: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int imx_pdm_mic_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);
+	struct snd_soc_card *card = rtd->card;
+	struct imx_pdm_data *data = snd_soc_card_get_drvdata(card);
+	unsigned int sample_rate = params_rate(params);
+	unsigned long mclk_freq;
+	int ret;
+
+	/* set cpu dai format configuration */
+	ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_PDM |
+			SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+	if (ret) {
+		dev_err(card->dev, "fail to set cpu dai fmt: %d\n", ret);
+		return ret;
+	}
+
+	/* Set bitclk ratio */
+	ret = snd_soc_dai_set_bclk_ratio(cpu_dai, data->decimation);
+	if (ret) {
+		dev_err(card->dev, "fail to set cpu sysclk: %d\n", ret);
+		return ret;
+	}
+
+	if (data->fixed_mclk) {
+		mclk_freq = (do_div(sample_rate, 8000) ?
+			data->mclk_11k : data->mclk_8k);
+	} else {
+		mclk_freq = imx_pdm_mic_mclk_freq(data->decimation,
+			sample_rate);
+	}
+	/* set mclk freq */
+	ret = snd_soc_dai_set_sysclk(cpu_dai, FSL_SAI_CLK_MAST1,
+			mclk_freq, SND_SOC_CLOCK_OUT);
+	if (ret) {
+		dev_err(card->dev, "fail to set cpu mclk1 rate: %lu\n",
+			mclk_freq);
+		return ret;
+	}
+
+	dev_dbg(card->dev, "mclk: %lu, bclk ratio: %u\n",
+			mclk_freq, data->decimation);
+
+	return 0;
+}
+
+static const struct snd_soc_ops imx_pdm_mic_ops = {
+	.startup = imx_pdm_mic_startup,
+	.hw_params = imx_pdm_mic_hw_params,
+};
+
+static int imx_pdm_mic_probe(struct platform_device *pdev)
+{
+	struct device_node *cpu_np = NULL;
+	struct device_node *np = pdev->dev.of_node;
+	struct platform_device *cpu_pdev;
+	struct imx_pdm_data *data;
+	struct snd_soc_dai_link_component *dlc;
+	unsigned long sai_mclk, sai_pll8k;
+	struct fsl_sai *sai;
+	unsigned int ratio;
+	int ret;
+
+	dlc = devm_kzalloc(&pdev->dev, 3 * sizeof(*dlc), GFP_KERNEL);
+	if (!dlc)
+		return -ENOMEM;
+
+	cpu_np = of_parse_phandle(np, "audio-cpu", 0);
+	if (!cpu_np) {
+		dev_err(&pdev->dev, "cpu dai phandle missing or invalid\n");
+		ret = -EINVAL;
+		goto fail;
+	}
+
+	cpu_pdev = of_find_device_by_node(cpu_np);
+	if (!cpu_pdev) {
+		dev_err(&pdev->dev, "fail to find SAI platform device\n");
+		ret = -EINVAL;
+		goto fail;
+	}
+
+	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
+	if (!data) {
+		ret = -ENOMEM;
+		goto fail;
+	}
+
+	ret = of_property_read_u32(np, "decimation", &data->decimation);
+	if (ret < 0) {
+		ret = -EINVAL;
+		goto fail;
+	}
+
+	data->osr_id = imx_pdm_mic_get_osr_id(data->decimation);
+	if (data->osr_id < 0) {
+		ret = -EINVAL;
+		goto fail;
+	}
+
+	if (of_find_property(np, "fixed-mclk", NULL))
+		data->fixed_mclk = true;
+
+	if (data->fixed_mclk) {
+		sai = dev_get_drvdata(&cpu_pdev->dev);
+		/* Get SAI clock settings */
+		sai_mclk = clk_get_rate(sai->mclk_clk[FSL_SAI_CLK_MAST1]);
+		sai_pll8k = clk_get_rate(sai->pll8k_clk);
+		ratio = sai_pll8k / sai_mclk;
+
+		ret = imx_pdm_mic_get_mclk_fixed(data, ratio);
+		if (ret) {
+			dev_err(&pdev->dev, "fail to set fixed mclk: %d\n", ret);
+			return ret;
+		}
+
+		dev_dbg(&pdev->dev, "sai_pll8k: %lu, sai_mclk: %lu, ratio: %u\n",
+			sai_pll8k, sai_mclk, ratio);
+	}
+
+	data->dai.cpus = &dlc[0];
+	data->dai.num_cpus = 1;
+	data->dai.platforms = &dlc[1];
+	data->dai.num_platforms = 1;
+	data->dai.codecs = &dlc[2];
+	data->dai.num_codecs = 1;
+
+	data->dai.name = "pdm hifi";
+	data->dai.stream_name = "pdm hifi";
+	data->dai.codecs->dai_name = "snd-soc-dummy-dai";
+	data->dai.codecs->name = "snd-soc-dummy";
+	data->dai.cpus->dai_name = dev_name(&cpu_pdev->dev);
+	data->dai.platforms->of_node = cpu_np;
+	data->dai.capture_only = 1;
+	data->dai.ops = &imx_pdm_mic_ops;
+
+	data->card.dev = &pdev->dev;
+	data->card.owner = THIS_MODULE;
+
+	ret = snd_soc_of_parse_card_name(&data->card, "model");
+	if (ret) {
+		dev_err(&pdev->dev, "fail to find card model name\n");
+		goto fail;
+	}
+
+	data->card.num_links = 1;
+	data->card.dai_link = &data->dai;
+	data->card.controls = imx_pdm_mic_snd_ctrls;
+	data->card.num_controls = ARRAY_SIZE(imx_pdm_mic_snd_ctrls);
+
+	platform_set_drvdata(pdev, &data->card);
+	snd_soc_card_set_drvdata(&data->card, data);
+
+	ret = devm_snd_soc_register_card(&pdev->dev, &data->card);
+	if (ret) {
+		dev_err(&pdev->dev, "snd soc register card failed: %d\n", ret);
+		goto fail;
+	}
+
+	ret = 0;
+fail:
+	if (cpu_np)
+		of_node_put(cpu_np);
+
+	return ret;
+}
+
+static int imx_pdm_mic_remove(struct platform_device *pdev)
+{
+	struct imx_pdm_data *data = platform_get_drvdata(pdev);
+	/* unregister card */
+	snd_soc_unregister_card(&data->card);
+	return 0;
+}
+
+static const struct of_device_id imx_pdm_mic_dt_ids[] = {
+	{ .compatible = "fsl,imx-pdm-mic", },
+	{ /* sentinel*/ }
+};
+MODULE_DEVICE_TABLE(of, imx_pdm_mic_dt_ids);
+
+static struct platform_driver imx_pdm_mic_driver = {
+	.driver = {
+		.name = "imx-pdm-mic",
+		.pm = &snd_soc_pm_ops,
+		.of_match_table = imx_pdm_mic_dt_ids,
+	},
+	.probe = imx_pdm_mic_probe,
+	.remove = imx_pdm_mic_remove,
+};
+module_platform_driver(imx_pdm_mic_driver);
+
+MODULE_DESCRIPTION("NXP i.MX PDM mic ASoC machine driver");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:imx-pdm-mic");
diff --git a/sound/soc/fsl/imx-rpmsg.c b/sound/soc/fsl/imx-rpmsg.c
index f96fe4ff8..8e7cbba21 100644
--- a/sound/soc/fsl/imx-rpmsg.c
+++ b/sound/soc/fsl/imx-rpmsg.c
@@ -14,11 +14,14 @@
 #include <sound/control.h>
 #include <sound/pcm_params.h>
 #include <sound/soc-dapm.h>
+#include <sound/simple_card_utils.h>
 #include "imx-pcm-rpmsg.h"
 
 struct imx_rpmsg {
 	struct snd_soc_dai_link dai;
 	struct snd_soc_card card;
+	struct asoc_simple_jack hp_jack;
+	unsigned int sysclk;
 };
 
 static const struct snd_soc_dapm_widget imx_rpmsg_dapm_widgets[] = {
@@ -28,6 +31,26 @@ static const struct snd_soc_dapm_widget imx_rpmsg_dapm_widgets[] = {
 	SND_SOC_DAPM_MIC("Main MIC", NULL),
 };
 
+static int imx_rpmsg_late_probe(struct snd_soc_card *card)
+{
+	struct imx_rpmsg *data = snd_soc_card_get_drvdata(card);
+	struct snd_soc_pcm_runtime *rtd = list_first_entry(&card->rtd_list,
+							   struct snd_soc_pcm_runtime, list);
+	struct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);
+	struct device *dev = card->dev;
+	int ret;
+
+	if (data->sysclk) {
+		ret = snd_soc_dai_set_sysclk(codec_dai, 0, data->sysclk, SND_SOC_CLOCK_IN);
+		if (ret && ret != -ENOTSUPP) {
+			dev_err(dev, "failed to set sysclk in %s\n", __func__);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
 static int imx_rpmsg_probe(struct platform_device *pdev)
 {
 	struct snd_soc_dai_link_component *dlc;
@@ -36,6 +59,8 @@ static int imx_rpmsg_probe(struct platform_device *pdev)
 	struct platform_device *rpmsg_pdev = to_platform_device(dev);
 	struct device_node *np = rpmsg_pdev->dev.of_node;
 	struct of_phandle_args args;
+	const char *platform_name;
+	const char *model_string;
 	struct imx_rpmsg *data;
 	int ret = 0;
 
@@ -67,21 +92,40 @@ static int imx_rpmsg_probe(struct platform_device *pdev)
 			    SND_SOC_DAIFMT_CBS_CFS;
 
 	/* Optional codec node */
+	of_property_read_string(np, "model", &model_string);
 	ret = of_parse_phandle_with_fixed_args(np, "audio-codec", 0, 0, &args);
 	if (ret) {
-		data->dai.codecs->dai_name = "snd-soc-dummy-dai";
-		data->dai.codecs->name = "snd-soc-dummy";
+		if (of_device_is_compatible(np, "fsl,imx7ulp-rpmsg-audio")) {
+			data->dai.codecs->dai_name = "rpmsg-wm8960-hifi";
+			data->dai.codecs->name = RPMSG_CODEC_DRV_NAME_WM8960;
+		} else if (of_device_is_compatible(np, "fsl,imx8mm-rpmsg-audio") &&
+				!strcmp("ak4497-audio", model_string)) {
+			data->dai.codecs->dai_name = "rpmsg-ak4497-aif";
+			data->dai.codecs->name = RPMSG_CODEC_DRV_NAME_AK4497;
+		} else {
+			data->dai.codecs->dai_name = "snd-soc-dummy-dai";
+			data->dai.codecs->name = "snd-soc-dummy";
+		}
 	} else {
+		struct clk *clk;
+
 		data->dai.codecs->of_node = args.np;
 		ret = snd_soc_get_dai_name(&args, &data->dai.codecs->dai_name);
 		if (ret) {
 			dev_err(&pdev->dev, "Unable to get codec_dai_name\n");
 			goto fail;
 		}
+
+		clk = devm_get_clk_from_child(&pdev->dev, args.np, NULL);
+		if (!IS_ERR(clk))
+			data->sysclk = clk_get_rate(clk);
 	}
 
 	data->dai.cpus->dai_name = dev_name(&rpmsg_pdev->dev);
 	data->dai.platforms->name = IMX_PCM_DRV_NAME;
+	if (!of_property_read_string(np, "fsl,platform", &platform_name))
+		data->dai.platforms->name = platform_name;
+
 	data->dai.playback_only = true;
 	data->dai.capture_only = true;
 	data->card.num_links = 1;
@@ -103,6 +147,7 @@ static int imx_rpmsg_probe(struct platform_device *pdev)
 	data->card.owner = THIS_MODULE;
 	data->card.dapm_widgets = imx_rpmsg_dapm_widgets;
 	data->card.num_dapm_widgets = ARRAY_SIZE(imx_rpmsg_dapm_widgets);
+	data->card.late_probe = imx_rpmsg_late_probe;
 	/*
 	 * Inoder to use common api to get card name and audio routing.
 	 * Use parent of_node for this device, revert it after finishing using
@@ -129,6 +174,11 @@ static int imx_rpmsg_probe(struct platform_device *pdev)
 		goto fail;
 	}
 
+	data->hp_jack.pin.pin = "Headphone Jack";
+	data->hp_jack.pin.mask = SND_JACK_HEADPHONE;
+	snd_soc_card_jack_new(&data->card, "Headphone Jack", SND_JACK_HEADPHONE,
+			      &data->hp_jack.jack, &data->hp_jack.pin, 1);
+	snd_soc_jack_report(&data->hp_jack.jack, SND_JACK_HEADPHONE, SND_JACK_HEADPHONE);
 fail:
 	pdev->dev.of_node = NULL;
 	return ret;
diff --git a/sound/soc/fsl/imx-sgtl5000.c b/sound/soc/fsl/imx-sgtl5000.c
index c4e3699ad..f45cb4bbb 100644
--- a/sound/soc/fsl/imx-sgtl5000.c
+++ b/sound/soc/fsl/imx-sgtl5000.c
@@ -120,19 +120,19 @@ static int imx_sgtl5000_probe(struct platform_device *pdev)
 	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
 	if (!data) {
 		ret = -ENOMEM;
-		goto put_device;
+		goto fail;
 	}
 
 	comp = devm_kzalloc(&pdev->dev, 3 * sizeof(*comp), GFP_KERNEL);
 	if (!comp) {
 		ret = -ENOMEM;
-		goto put_device;
+		goto fail;
 	}
 
 	data->codec_clk = clk_get(&codec_dev->dev, NULL);
 	if (IS_ERR(data->codec_clk)) {
 		ret = PTR_ERR(data->codec_clk);
-		goto put_device;
+		goto fail;
 	}
 
 	data->clk_frequency = clk_get_rate(data->codec_clk);
@@ -158,10 +158,10 @@ static int imx_sgtl5000_probe(struct platform_device *pdev)
 	data->card.dev = &pdev->dev;
 	ret = snd_soc_of_parse_card_name(&data->card, "model");
 	if (ret)
-		goto put_device;
+		goto fail;
 	ret = snd_soc_of_parse_audio_routing(&data->card, "audio-routing");
 	if (ret)
-		goto put_device;
+		goto fail;
 	data->card.num_links = 1;
 	data->card.owner = THIS_MODULE;
 	data->card.dai_link = &data->dai;
@@ -173,8 +173,10 @@ static int imx_sgtl5000_probe(struct platform_device *pdev)
 
 	ret = devm_snd_soc_register_card(&pdev->dev, &data->card);
 	if (ret) {
-		dev_err_probe(&pdev->dev, ret, "snd_soc_register_card failed\n");
-		goto put_device;
+		if (ret != -EPROBE_DEFER)
+			dev_err(&pdev->dev, "snd_soc_register_card failed (%d)\n",
+				ret);
+		goto fail;
 	}
 
 	of_node_put(ssi_np);
@@ -182,8 +184,6 @@ static int imx_sgtl5000_probe(struct platform_device *pdev)
 
 	return 0;
 
-put_device:
-	put_device(&codec_dev->dev);
 fail:
 	if (data && !IS_ERR(data->codec_clk))
 		clk_put(data->codec_clk);
diff --git a/sound/soc/fsl/imx-spdif.c b/sound/soc/fsl/imx-spdif.c
index 4446fba75..4d5589a5e 100644
--- a/sound/soc/fsl/imx-spdif.c
+++ b/sound/soc/fsl/imx-spdif.c
@@ -5,10 +5,67 @@
 #include <linux/module.h>
 #include <linux/of_platform.h>
 #include <sound/soc.h>
+#include "fsl_spdif.h"
+
+#define SUPPORT_RATE_NUM 10
 
 struct imx_spdif_data {
 	struct snd_soc_dai_link dai;
 	struct snd_soc_card card;
+	u32 support_rates[SUPPORT_RATE_NUM];
+	u32 support_rates_num;
+};
+
+#define CLK_8K_FREQ    24576000
+#define CLK_11K_FREQ   22579200
+
+static int imx_spdif_startup(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_card *card = rtd->card;
+	struct imx_spdif_data *data = snd_soc_card_get_drvdata(card);
+	static struct snd_pcm_hw_constraint_list constraint_rates;
+	int ret;
+
+	if (!data->support_rates_num)
+		return 0;
+
+	constraint_rates.list = data->support_rates;
+	constraint_rates.count = data->support_rates_num;
+
+	ret = snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
+					 &constraint_rates);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int imx_spdif_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);
+	struct device *dev = rtd->card->dev;
+	int ret = 0;
+	u64 rate = params_rate(params);
+	unsigned int freq;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		freq = do_div(rate, 8000) ? CLK_11K_FREQ : CLK_8K_FREQ;
+		ret = snd_soc_dai_set_sysclk(cpu_dai, STC_TXCLK_SPDIF_ROOT,
+			freq, SND_SOC_CLOCK_OUT);
+		if (ret)
+			dev_err(dev, "failed to set cpu sysclk: %d\n", ret);
+	}
+
+	return ret;
+}
+
+static struct snd_soc_ops imx_spdif_ops = {
+	.startup = imx_spdif_startup,
+	.hw_params = imx_spdif_hw_params,
 };
 
 static int imx_spdif_audio_probe(struct platform_device *pdev)
@@ -16,7 +73,7 @@ static int imx_spdif_audio_probe(struct platform_device *pdev)
 	struct device_node *spdif_np, *np = pdev->dev.of_node;
 	struct imx_spdif_data *data;
 	struct snd_soc_dai_link_component *comp;
-	int ret = 0;
+	int ret = 0, i;
 
 	spdif_np = of_parse_phandle(np, "spdif-controller", 0);
 	if (!spdif_np) {
@@ -48,6 +105,7 @@ static int imx_spdif_audio_probe(struct platform_device *pdev)
 	data->dai.platforms->of_node = spdif_np;
 	data->dai.playback_only = true;
 	data->dai.capture_only = true;
+	data->dai.ops = &imx_spdif_ops;
 
 	if (of_property_read_bool(np, "spdif-out"))
 		data->dai.capture_only = false;
@@ -60,6 +118,16 @@ static int imx_spdif_audio_probe(struct platform_device *pdev)
 		goto end;
 	}
 
+	for (i = 0; i < SUPPORT_RATE_NUM; i++) {
+		ret = of_property_read_u32_index(pdev->dev.of_node,
+						 "fsl,constraint-rate",
+						 i, &data->support_rates[i]);
+		if (!ret)
+			data->support_rates_num = i + 1;
+		else
+			break;
+	}
+
 	data->card.dev = &pdev->dev;
 	data->card.dai_link = &data->dai;
 	data->card.num_links = 1;
@@ -69,9 +137,10 @@ static int imx_spdif_audio_probe(struct platform_device *pdev)
 	if (ret)
 		goto end;
 
+	snd_soc_card_set_drvdata(&data->card, data);
 	ret = devm_snd_soc_register_card(&pdev->dev, &data->card);
-	if (ret)
-		dev_err_probe(&pdev->dev, ret, "snd_soc_register_card failed\n");
+	if (ret && ret != -EPROBE_DEFER)
+		dev_err(&pdev->dev, "snd_soc_register_card failed: %d\n", ret);
 
 end:
 	of_node_put(spdif_np);
diff --git a/sound/soc/fsl/imx6qdl-hdmi.c b/sound/soc/fsl/imx6qdl-hdmi.c
new file mode 100644
index 000000000..a18740b99
--- /dev/null
+++ b/sound/soc/fsl/imx6qdl-hdmi.c
@@ -0,0 +1,117 @@
+/*
+ * ASoC HDMI Transmitter driver for IMX development boards
+ *
+ * Copyright (C) 2011-2016 Freescale Semiconductor, Inc.
+ *
+ * based on stmp3780_devb_hdmi.c
+ *
+ * Vladimir Barinov <vbarinov@embeddedalley.com>
+ *
+ * Copyright 2008 SigmaTel, Inc
+ * Copyright 2008 Embedded Alley Solutions, Inc
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program  is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/mfd/mxc-hdmi-core.h>
+#include <sound/soc.h>
+
+#include "imx-hdmi.h"
+
+SND_SOC_DAILINK_DEFS(hifi,
+	DAILINK_COMP_ARRAY(COMP_EMPTY()),
+	DAILINK_COMP_ARRAY(COMP_CODEC("hdmi-audio-codec", "i2s-hifi")),
+	DAILINK_COMP_ARRAY(COMP_PLATFORM("imx-hdmi-audio")));
+
+/* imx digital audio interface glue - connects codec <--> CPU */
+static struct snd_soc_dai_link imx_hdmi_dai_link = {
+	.name = "i.MX HDMI Audio Tx",
+	.stream_name = "i.MX HDMI Audio Tx",
+	SND_SOC_DAILINK_REG(hifi),
+};
+
+static struct snd_soc_card snd_soc_card_imx_hdmi = {
+	.name = "imx-hdmi-soc",
+	.dai_link = &imx_hdmi_dai_link,
+	.num_links = 1,
+	.owner = THIS_MODULE,
+};
+
+static int imx_hdmi_audio_probe(struct platform_device *pdev)
+{
+	struct device_node *hdmi_np, *np = pdev->dev.of_node;
+	struct snd_soc_card *card = &snd_soc_card_imx_hdmi;
+	struct platform_device *hdmi_pdev;
+	int ret = 0;
+
+	if (!hdmi_get_registered()) {
+		dev_err(&pdev->dev, "initialize HDMI-audio failed. load HDMI-video first!\n");
+		return -ENODEV;
+	}
+
+	hdmi_np = of_parse_phandle(np, "hdmi-controller", 0);
+	if (!hdmi_np) {
+		dev_err(&pdev->dev, "failed to find hdmi-audio cpudai\n");
+		ret = -EINVAL;
+		goto end;
+	}
+
+	hdmi_pdev = of_find_device_by_node(hdmi_np);
+	if (!hdmi_pdev) {
+		dev_err(&pdev->dev, "failed to find SSI platform device\n");
+		ret = -EINVAL;
+		goto end;
+	}
+
+	card->dev = &pdev->dev;
+	card->dai_link->cpus->dai_name = dev_name(&hdmi_pdev->dev);
+
+	platform_set_drvdata(pdev, card);
+
+	ret = snd_soc_register_card(card);
+	if (ret)
+		dev_err(&pdev->dev, "failed to register card: %d\n", ret);
+
+end:
+	if (hdmi_np)
+		of_node_put(hdmi_np);
+
+	return ret;
+}
+
+static int imx_hdmi_audio_remove(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
+
+	snd_soc_unregister_card(card);
+
+	return 0;
+}
+
+static const struct of_device_id imx_hdmi_dt_ids[] = {
+	{ .compatible = "fsl,imx6qdl-audio-hdmi", },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, imx_hdmi_dt_ids);
+
+static struct platform_driver imx_hdmi_audio_driver = {
+	.probe = imx_hdmi_audio_probe,
+	.remove = imx_hdmi_audio_remove,
+	.driver = {
+		.of_match_table = imx_hdmi_dt_ids,
+		.name = "imx6qdl-audio-hdmi",
+		.owner = THIS_MODULE,
+		.pm = &snd_soc_pm_ops,
+	},
+};
+
+module_platform_driver(imx_hdmi_audio_driver);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("IMX HDMI TX ASoC driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:imx-audio-hdmi");
-- 
2.25.1

