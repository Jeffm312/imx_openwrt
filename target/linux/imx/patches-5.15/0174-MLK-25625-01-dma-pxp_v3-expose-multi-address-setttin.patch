From 6d312cb89bf05127a9ebbf65dca4ed3cac5d971a Mon Sep 17 00:00:00 2001
From: "Guoniu.zhou" <guoniu.zhou@nxp.com>
Date: Tue, 1 Mar 2022 13:52:08 +0800
Subject: [PATCH 174/274] MLK-25625-01: dma: pxp_v3: expose multi address
 settting for multi-plane format

In current pxp driver, U and V address are caculated by driver when input/output
format is multi-plane format, such as NV12. But for some cases, user space want
to set U and V address by themself, so expose multi address settting for the case

Signed-off-by: Guoniu.zhou <guoniu.zhou@nxp.com>
Tested-by: Jared Hu <jared.hu@nxp.com>
Reviewed-by: Robby Cai <robby.cai@nxp.com>
---
 drivers/dma/pxp/pxp_dma_v3.c | 33 +++++++++++++++++++--------------
 include/uapi/linux/pxp_dma.h |  2 ++
 2 files changed, 21 insertions(+), 14 deletions(-)

diff --git a/drivers/dma/pxp/pxp_dma_v3.c b/drivers/dma/pxp/pxp_dma_v3.c
index a6b553c85..77c77e264 100644
--- a/drivers/dma/pxp/pxp_dma_v3.c
+++ b/drivers/dma/pxp/pxp_dma_v3.c
@@ -276,6 +276,8 @@ struct pxp_pixmap {
 	uint32_t flags;
 	bool valid;
 	dma_addr_t paddr;
+	dma_addr_t paddr_u;
+	dma_addr_t paddr_v;
 	struct pxp_alpha_global g_alpha;
 };
 
@@ -2493,30 +2495,30 @@ static int pxp_ps_config(struct pxp_pixmap *input,
 	case 1:		/* 1 Plane YUV */
 		break;
 	case 2:		/* NV16,NV61,NV12,NV21 */
+		U = (input->paddr_u) ? input->paddr_u :
+				       input->paddr + input->width * input->height;
 		if ((input->format == PXP_PIX_FMT_NV16) ||
-		    (input->format == PXP_PIX_FMT_NV61)) {
-			U = input->paddr + input->width * input->height;
+		    (input->format == PXP_PIX_FMT_NV61))
 			pxp_writel(U + offset, HW_PXP_PS_UBUF);
-		}
-		else {
-			U = input->paddr + input->width * input->height;
+		else
 			pxp_writel(U + (offset >> 1), HW_PXP_PS_UBUF);
-		}
 		break;
 	case 3:		/* YUV422P, YUV420P */
+		U = (input->paddr_u) ? input->paddr_u :
+				       input->paddr + input->width * input->height;
 		if (input->format == PXP_PIX_FMT_YUV422P) {
-			U = input->paddr + input->width * input->height;
 			pxp_writel(U + (offset >> 1), HW_PXP_PS_UBUF);
-			V = U + (input->width * input->height >> 1);
+			V = (input->paddr_v) ? input->paddr_v :
+					       U + (input->width * input->height >> 1);
 			pxp_writel(V + (offset >> 1), HW_PXP_PS_VBUF);
 		} else if (input->format == PXP_PIX_FMT_YUV420P) {
-			U = input->paddr + input->width * input->height;
 			pxp_writel(U + (offset >> 2), HW_PXP_PS_UBUF);
-			V = U + (input->width * input->height >> 2);
+			V = (input->paddr_v) ? input->paddr_v :
+					       U + (input->width * input->height >> 2);
 			pxp_writel(V + (offset >> 2), HW_PXP_PS_VBUF);
 		} else if (input->format == PXP_PIX_FMT_YVU420P) {
-			U = input->paddr + input->width * input->height;
-			V = U + (input->width * input->height >> 2);
+			V = (input->paddr_v) ? input->paddr_v :
+					       U + (input->width * input->height >> 2);
 			pxp_writel(U + (offset >> 2), HW_PXP_PS_VBUF);
 			pxp_writel(V + (offset >> 2), HW_PXP_PS_UBUF);
 		}
@@ -2792,7 +2794,8 @@ static int pxp_out_config(struct pxp_pixmap *output)
 
 	pxp_writel(output->paddr, HW_PXP_OUT_BUF);
 	if (is_yuv(output->format) == 2) {
-		UV = output->paddr + output->width * output->height;
+		UV = (output->paddr_u) ? output->paddr_u :
+					  output->paddr + output->width * output->height;
 		if ((output->format == PXP_PIX_FMT_NV16) ||
 		    (output->format == PXP_PIX_FMT_NV61))
 			pxp_writel(UV + offset, HW_PXP_OUT_BUF2);
@@ -3733,8 +3736,10 @@ static int convert_param_to_pixmap(struct pxp_pixmap *pixmap,
 	pixmap->width  = param->width;
 	pixmap->height = param->height;
 	pixmap->format = param->pixel_fmt;
-	pixmap->paddr  = param->paddr;
 	pixmap->bpp    = get_bpp_from_fmt(pixmap->format);
+	pixmap->paddr  = param->paddr;
+	pixmap->paddr_u  = param->paddr_u;
+	pixmap->paddr_v  = param->paddr_v;
 
 	if (pxp_legacy) {
 		pixmap->pitch = (param->stride) ? (param->stride * pixmap->bpp >> 3) :
diff --git a/include/uapi/linux/pxp_dma.h b/include/uapi/linux/pxp_dma.h
index 2888f44fa..9b5228504 100644
--- a/include/uapi/linux/pxp_dma.h
+++ b/include/uapi/linux/pxp_dma.h
@@ -239,6 +239,8 @@ struct pxp_layer_param {
 	struct rect crop;
 
 	dma_addr_t paddr;
+	dma_addr_t paddr_u;
+	dma_addr_t paddr_v;
 };
 
 struct pxp_collision_info {
-- 
2.25.1

