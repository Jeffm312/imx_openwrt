From ff9deb1e52b6610d27d6fa0dd5ea1e380d5ef705 Mon Sep 17 00:00:00 2001
From: shuyang <shuyang.guan@nxp.com>
Date: Wed, 12 Oct 2022 11:47:41 +0800
Subject: [PATCH 259/274] imx93: Add FSL_EDMA_V3

Signed-off-by: shuyang <shuyang.guan@nxp.com>
---
 drivers/dma/Kconfig       | 12 +++++++
 drivers/dma/Makefile      |  1 +
 drivers/dma/fsl-edma-v3.c | 74 ++++++++++++++++-----------------------
 3 files changed, 43 insertions(+), 44 deletions(-)

diff --git a/drivers/dma/Kconfig b/drivers/dma/Kconfig
index 0ac27de0e..5998be101 100644
--- a/drivers/dma/Kconfig
+++ b/drivers/dma/Kconfig
@@ -223,6 +223,18 @@ config FSL_QDMA
 	 This module can be found on NXP Layerscape SoCs.
 	  The qdma driver only work on  SoCs with a DPAA hardware block.
 
+config FSL_EDMA_V3
+    tristate "Freescale eDMA v3 engine support"
+    depends on OF
+    select DMA_ENGINE
+    select DMA_VIRTUAL_CHANNELS
+    help
+      Support the Freescale eDMA v3 engine with programmable channel.
+      This driver is based on FSL_EDMA but big changes come such as
+      different interrupt for different channel, different register
+      scope for different channel.
+      This module can be found on Freescale i.MX8QM.
+
 config FSL_RAID
 	tristate "Freescale RAID engine Support"
 	depends on FSL_SOC && !ASYNC_TX_ENABLE_CHANNEL_SWITCH
diff --git a/drivers/dma/Makefile b/drivers/dma/Makefile
index 3957c0fc7..3224fb192 100644
--- a/drivers/dma/Makefile
+++ b/drivers/dma/Makefile
@@ -32,6 +32,7 @@ obj-$(CONFIG_DW_EDMA) += dw-edma/
 obj-$(CONFIG_EP93XX_DMA) += ep93xx_dma.o
 obj-$(CONFIG_FSL_DMA) += fsldma.o
 obj-$(CONFIG_FSL_EDMA) += fsl-edma.o fsl-edma-common.o
+obj-$(CONFIG_FSL_EDMA_V3) += fsl-edma-v3.o
 obj-$(CONFIG_MCF_EDMA) += mcf-edma.o fsl-edma-common.o
 obj-$(CONFIG_FSL_QDMA) += fsl-qdma.o
 obj-$(CONFIG_FSL_RAID) += fsl_raid.o
diff --git a/drivers/dma/fsl-edma-v3.c b/drivers/dma/fsl-edma-v3.c
index 8c8dddbd5..d0acec5c9 100644
--- a/drivers/dma/fsl-edma-v3.c
+++ b/drivers/dma/fsl-edma-v3.c
@@ -82,6 +82,7 @@
 
 #define EDMA_TCD_SOFF_SOFF(x)		(x)
 #define EDMA_TCD_NBYTES_NBYTES(x)	(x)
+#define EDMA_TCD_NBYTES_MLOFF_NBYTES(x)	((x) & GENMASK(9, 0))
 #define EDMA_TCD_NBYTES_MLOFF(x)	(x << 10)
 #define EDMA_TCD_NBYTES_DMLOE		(1 << 30)
 #define EDMA_TCD_NBYTES_SMLOE		(1 << 31)
@@ -98,8 +99,8 @@
 #define EDMA_TCD_CSR_D_REQ		BIT(3)
 #define EDMA_TCD_CSR_E_SG		BIT(4)
 #define EDMA_TCD_CSR_E_LINK		BIT(5)
-#define EDMA_TCD_CSR_EEOP		BIT(6)
-#define EDMA_TCD_CSR_ESDA		BIT(7)
+#define EDMA_TCD_CSR_ACTIVE		BIT(6)
+#define EDMA_TCD_CSR_DONE		BIT(7)
 
 #define FSL_EDMA_BUSWIDTHS	(BIT(DMA_SLAVE_BUSWIDTH_1_BYTE) | \
 				BIT(DMA_SLAVE_BUSWIDTH_2_BYTES) | \
@@ -130,11 +131,6 @@ struct fsl_edma3_hw_tcd {
 	__le32	dlast_sga;
 	__le16	csr;
 	__le16	biter;
-	/*
-	 * Store Dest Address if EDMA_TCD_CSR_ESDA enabled which's used as
-	 * 'eeop + cyclic'.
-	 */
-	__le32  sda;
 };
 
 struct fsl_edma3_sw_tcd {
@@ -188,7 +184,6 @@ struct fsl_edma3_desc {
 	struct fsl_edma3_chan		*echan;
 	bool				iscyclic;
 	unsigned int			n_tcds;
-	u32				curidx;
 	struct fsl_edma3_sw_tcd		tcd[];
 };
 
@@ -430,12 +425,19 @@ static size_t fsl_edma3_desc_residue(struct fsl_edma3_chan *fsl_chan,
 	enum dma_transfer_direction dir = fsl_chan->fsc.dir;
 	dma_addr_t cur_addr, dma_addr;
 	size_t len, size;
+	u32 nbytes = 0;
 	int i;
 
 	/* calculate the total size in this desc */
-	for (len = i = 0; i < fsl_chan->edesc->n_tcds; i++)
-		len += le32_to_cpu(edesc->tcd[i].vtcd->nbytes)
-			* le16_to_cpu(edesc->tcd[i].vtcd->biter);
+	for (len = i = 0; i < fsl_chan->edesc->n_tcds; i++) {
+		if ((edesc->tcd[i].vtcd->nbytes & EDMA_TCD_NBYTES_DMLOE) ||
+		    (edesc->tcd[i].vtcd->nbytes & EDMA_TCD_NBYTES_SMLOE))
+			nbytes = EDMA_TCD_NBYTES_MLOFF_NBYTES(edesc->tcd[i].vtcd->nbytes);
+		else
+			nbytes = le32_to_cpu(edesc->tcd[i].vtcd->nbytes);
+
+		len += nbytes * le16_to_cpu(edesc->tcd[i].vtcd->biter);
+	}
 
 	if (!in_progress)
 		return len;
@@ -445,33 +447,24 @@ static size_t fsl_edma3_desc_residue(struct fsl_edma3_chan *fsl_chan,
 	else
 		cur_addr = readl(addr + EDMA_TCD_DADDR);
 
-	/* skip the tcds before curidx in cyclic case */
-	if (edesc->iscyclic)
-		len -= edesc->curidx * le32_to_cpu(edesc->tcd[0].vtcd->nbytes)
-			* le16_to_cpu(edesc->tcd[0].vtcd->biter);
-
 	/* figure out the finished and calculate the residue */
-	for (i = edesc->curidx; i < fsl_chan->edesc->n_tcds; i++) {
-		if (dir == DMA_DEV_TO_MEM)
-			cur_addr = le32_to_cpu(edesc->tcd[i].vtcd->sda);
+	for (i = 0; i < fsl_chan->edesc->n_tcds; i++) {
+		if ((edesc->tcd[i].vtcd->nbytes & EDMA_TCD_NBYTES_DMLOE) ||
+		    (edesc->tcd[i].vtcd->nbytes & EDMA_TCD_NBYTES_SMLOE))
+			nbytes = EDMA_TCD_NBYTES_MLOFF_NBYTES(edesc->tcd[i].vtcd->nbytes);
+		else
+			nbytes = le32_to_cpu(edesc->tcd[i].vtcd->nbytes);
+
+		size = nbytes * le16_to_cpu(edesc->tcd[i].vtcd->biter);
 
-		size = le32_to_cpu(edesc->tcd[i].vtcd->nbytes)
-			* le16_to_cpu(edesc->tcd[i].vtcd->biter);
 		if (dir == DMA_MEM_TO_DEV)
 			dma_addr = le32_to_cpu(edesc->tcd[i].vtcd->saddr);
 		else
 			dma_addr = le32_to_cpu(edesc->tcd[i].vtcd->daddr);
 
 		len -= size;
-		if (cur_addr > dma_addr && cur_addr <= dma_addr + size) {
+		if (cur_addr >= dma_addr && cur_addr < dma_addr + size) {
 			len += dma_addr + size - cur_addr;
-			/*
-			 * mark curidx as the start point in the next time
-			 * fsl_edma3_desc_residue(called by fsl_edma3_tx_status
-			 * commonly per cyclic interrupt/callback)
-			 */
-			if (edesc->iscyclic)
-				edesc->curidx = (i + 1) % edesc->n_tcds;
 			break;
 		}
 	}
@@ -547,13 +540,11 @@ static void fsl_edma3_set_tcd_regs(struct fsl_edma3_chan *fsl_chan,
 
 static inline
 void fsl_edma3_fill_tcd(struct fsl_edma3_chan *fsl_chan,
-			struct fsl_edma3_sw_tcd *sw_tcd, u32 src, u32 dst,
+			struct fsl_edma3_hw_tcd *tcd, u32 src, u32 dst,
 			u16 attr, u16 soff, u32 nbytes, u32 slast, u16 citer,
 			u16 biter, u16 doff, u32 dlast_sga, bool major_int,
 			bool disable_req, bool enable_sg)
 {
-	struct fsl_edma3_hw_tcd *tcd = sw_tcd->vtcd;
-	u32 slast_sda = sw_tcd->ptcd + offsetof(struct fsl_edma3_hw_tcd, sda);
 	u16 csr = 0;
 
 	/*
@@ -583,11 +574,7 @@ void fsl_edma3_fill_tcd(struct fsl_edma3_chan *fsl_chan,
 	}
 
 	tcd->nbytes = cpu_to_le32(EDMA_TCD_NBYTES_NBYTES(nbytes));
-
-	if (fsl_chan->is_rxchan)
-		tcd->slast = cpu_to_le32(EDMA_TCD_SLAST_SLAST(slast_sda));
-	else
-		tcd->slast = cpu_to_le32(EDMA_TCD_SLAST_SLAST(slast));
+	tcd->slast = cpu_to_le32(EDMA_TCD_SLAST_SLAST(slast));
 
 	tcd->citer = cpu_to_le16(EDMA_TCD_CITER_CITER(citer));
 	tcd->doff = cpu_to_le16(EDMA_TCD_DOFF_DOFF(doff));
@@ -605,7 +592,7 @@ void fsl_edma3_fill_tcd(struct fsl_edma3_chan *fsl_chan,
 		csr |= EDMA_TCD_CSR_E_SG;
 
 	if (fsl_chan->is_rxchan)
-		csr |= EDMA_TCD_CSR_EEOP | EDMA_TCD_CSR_ESDA;
+		csr |= EDMA_TCD_CSR_ACTIVE;
 
 	if (fsl_chan->is_sw)
 		csr |= EDMA_TCD_CSR_START;
@@ -717,14 +704,12 @@ static struct dma_async_tx_descriptor *fsl_edma3_prep_dma_cyclic(
 			major_int = false;
 		}
 
-		fsl_edma3_fill_tcd(fsl_chan, &fsl_desc->tcd[i], src_addr,
+		fsl_edma3_fill_tcd(fsl_chan, fsl_desc->tcd[i].vtcd, src_addr,
 				dst_addr, fsl_chan->fsc.attr, soff, nbytes, 0,
 				iter, iter, doff, last_sg, major_int, false, true);
 		dma_buf_next += period_len;
 	}
 
-	fsl_desc->curidx = 0;
-
 	return vchan_tx_prep(&fsl_chan->vchan, &fsl_desc->vdesc, flags);
 }
 
@@ -794,13 +779,13 @@ static struct dma_async_tx_descriptor *fsl_edma3_prep_slave_sg(
 		iter = sg_dma_len(sg) / nbytes;
 		if (i < sg_len - 1) {
 			last_sg = fsl_desc->tcd[(i + 1)].ptcd;
-			fsl_edma3_fill_tcd(fsl_chan, &fsl_desc->tcd[i],
+			fsl_edma3_fill_tcd(fsl_chan, fsl_desc->tcd[i].vtcd,
 					src_addr, dst_addr, fsl_chan->fsc.attr,
 					soff, nbytes, 0, iter, iter, doff,
 					last_sg, false, false, true);
 		} else {
 			last_sg = 0;
-			fsl_edma3_fill_tcd(fsl_chan, &fsl_desc->tcd[i],
+			fsl_edma3_fill_tcd(fsl_chan, fsl_desc->tcd[i].vtcd,
 					src_addr, dst_addr, fsl_chan->fsc.attr,
 					soff, nbytes, 0, iter, iter, doff,
 					last_sg, true, true, false);
@@ -840,7 +825,7 @@ static struct dma_async_tx_descriptor *fsl_edma3_prep_memcpy(
 	fsl_chan->is_sw = true;
 
 	/* To match with copy_align and max_seg_size so 1 tcd is enough */
-	fsl_edma3_fill_tcd(fsl_chan, &fsl_desc->tcd[0], dma_src, dma_dst,
+	fsl_edma3_fill_tcd(fsl_chan, fsl_desc->tcd[0].vtcd, dma_src, dma_dst,
 			EDMA_TCD_ATTR_SSIZE_64BYTE | EDMA_TCD_ATTR_DSIZE_64BYTE,
 			64, len, 0, 1, 1, 64, 0, true, true, false);
 
@@ -1250,6 +1235,7 @@ static int fsl_edma3_probe(struct platform_device *pdev)
 	fsl_edma3->dma_dev.device_terminate_all = fsl_edma3_terminate_all;
 	fsl_edma3->dma_dev.device_issue_pending = fsl_edma3_issue_pending;
 	fsl_edma3->dma_dev.device_synchronize = fsl_edma3_synchronize;
+	fsl_edma3->dma_dev.residue_granularity = DMA_RESIDUE_GRANULARITY_SEGMENT;
 
 	fsl_edma3->dma_dev.src_addr_widths = FSL_EDMA_BUSWIDTHS;
 	fsl_edma3->dma_dev.dst_addr_widths = FSL_EDMA_BUSWIDTHS;
-- 
2.25.1

